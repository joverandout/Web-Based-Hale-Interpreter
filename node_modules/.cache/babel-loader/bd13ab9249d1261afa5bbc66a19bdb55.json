{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { ILanguageService } from '../services/language.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\n\nfunction createTextBufferBuilder() {\n  return new PieceTreeTextBufferBuilder();\n}\n\nexport function createTextBufferFactory(text) {\n  const builder = createTextBufferBuilder();\n  builder.acceptChunk(text);\n  return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n  const factory = typeof value === 'string' ? createTextBufferFactory(value) : value;\n  return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\n\nclass TextModelSnapshot {\n  constructor(source) {\n    this._source = source;\n    this._eos = false;\n  }\n\n  read() {\n    if (this._eos) {\n      return null;\n    }\n\n    const result = [];\n    let resultCnt = 0;\n    let resultLength = 0;\n\n    do {\n      const tmp = this._source.read();\n\n      if (tmp === null) {\n        // end-of-stream\n        this._eos = true;\n\n        if (resultCnt === 0) {\n          return null;\n        } else {\n          return result.join('');\n        }\n      }\n\n      if (tmp.length > 0) {\n        result[resultCnt++] = tmp;\n        resultLength += tmp.length;\n      }\n\n      if (resultLength >= 64 * 1024) {\n        return result.join('');\n      }\n    } while (true);\n  }\n\n}\n\nconst invalidFunc = () => {\n  throw new Error(`Invalid change accessor`);\n};\n\nlet TextModel = class TextModel extends Disposable {\n  constructor(source, languageId, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n    super();\n    this._undoRedoService = _undoRedoService;\n    this._languageService = _languageService;\n    this._languageConfigurationService = _languageConfigurationService; //#region Events\n\n    this._onWillDispose = this._register(new Emitter());\n    this.onWillDispose = this._onWillDispose.event;\n    this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n    this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n    this._onDidChangeLanguage = this._register(new Emitter());\n    this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n    this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n    this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n    this._onDidChangeTokens = this._register(new Emitter());\n    this.onDidChangeTokens = this._onDidChangeTokens.event;\n    this._onDidChangeOptions = this._register(new Emitter());\n    this.onDidChangeOptions = this._onDidChangeOptions.event;\n    this._onDidChangeAttached = this._register(new Emitter());\n    this.onDidChangeAttached = this._onDidChangeAttached.event;\n    this._onDidChangeContentOrInjectedText = this._register(new Emitter());\n    this.onDidChangeContentOrInjectedText = this._onDidChangeContentOrInjectedText.event;\n    this._eventEmitter = this._register(new DidChangeContentEmitter());\n    this._backgroundTokenizationState = 0\n    /* Uninitialized */\n    ;\n    this._onBackgroundTokenizationStateChanged = this._register(new Emitter());\n    this.onBackgroundTokenizationStateChanged = this._onBackgroundTokenizationStateChanged.event;\n\n    this._register(this._eventEmitter.fastEvent(e => {\n      this._onDidChangeContentOrInjectedText.fire(e.rawContentChangedEvent);\n    })); // Generate a new unique model id\n\n\n    MODEL_ID++;\n    this.id = '$model' + MODEL_ID;\n    this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n\n    if (typeof associatedResource === 'undefined' || associatedResource === null) {\n      this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n    } else {\n      this._associatedResource = associatedResource;\n    }\n\n    this._attachedEditorCount = 0;\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(source, creationOptions.defaultEOL);\n    this._buffer = textBuffer;\n    this._bufferDisposable = disposable;\n    this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n\n    const bufferLineCount = this._buffer.getLineCount();\n\n    const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0\n    /* TextDefined */\n    ); // !!! Make a decision in the ctor and permanently respect this decision !!!\n    // If a model is too large at construction time, it will never get tokenized,\n    // under no circumstances.\n\n\n    if (creationOptions.largeFileOptimizations) {\n      this._isTooLargeForTokenization = bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD;\n    } else {\n      this._isTooLargeForTokenization = false;\n    }\n\n    this._isTooLargeForSyncing = bufferTextLength > TextModel.MODEL_SYNC_LIMIT;\n    this._versionId = 1;\n    this._alternativeVersionId = 1;\n    this._initialUndoRedoSnapshot = null;\n    this._isDisposed = false;\n    this._isDisposing = false;\n    this._languageId = languageId;\n    this._languageRegistryListener = this._languageConfigurationService.onDidChange(e => {\n      if (e.affects(this._languageId)) {\n        this._onDidChangeLanguageConfiguration.fire({});\n      }\n    });\n    this._instanceId = strings.singleLetterHash(MODEL_ID);\n    this._lastDecorationId = 0;\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    this._commandManager = new EditStack(this, this._undoRedoService);\n    this._isUndoing = false;\n    this._isRedoing = false;\n    this._trimAutoWhitespaceLines = null;\n    this._tokens = new ContiguousTokensStore(this._languageService.languageIdCodec);\n    this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n    this._tokenization = new TextModelTokenization(this, this._languageService.languageIdCodec);\n    this._bracketPairColorizer = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n    this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n    this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n\n    this._register(this._decorationProvider.onDidChange(() => {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._onDidChangeDecorations.fire();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }));\n  }\n\n  static resolveOptions(textBuffer, options) {\n    if (options.detectIndentation) {\n      const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n      return new model.TextModelResolvedOptions({\n        tabSize: guessedIndentation.tabSize,\n        indentSize: guessedIndentation.tabSize,\n        insertSpaces: guessedIndentation.insertSpaces,\n        trimAutoWhitespace: options.trimAutoWhitespace,\n        defaultEOL: options.defaultEOL,\n        bracketPairColorizationOptions: options.bracketPairColorizationOptions\n      });\n    }\n\n    return new model.TextModelResolvedOptions({\n      tabSize: options.tabSize,\n      indentSize: options.indentSize,\n      insertSpaces: options.insertSpaces,\n      trimAutoWhitespace: options.trimAutoWhitespace,\n      defaultEOL: options.defaultEOL,\n      bracketPairColorizationOptions: options.bracketPairColorizationOptions\n    });\n  }\n\n  onDidChangeContentFast(listener) {\n    return this._eventEmitter.fastEvent(e => listener(e.contentChangedEvent));\n  }\n\n  onDidChangeContent(listener) {\n    return this._eventEmitter.slowEvent(e => listener(e.contentChangedEvent));\n  }\n\n  get bracketPairs() {\n    return this._bracketPairColorizer;\n  }\n\n  get guides() {\n    return this._guidesTextModelPart;\n  }\n\n  get backgroundTokenizationState() {\n    return this._backgroundTokenizationState;\n  }\n\n  handleTokenizationProgress(completed) {\n    if (this._backgroundTokenizationState === 2\n    /* Completed */\n    ) {\n      // We already did a full tokenization and don't go back to progressing.\n      return;\n    }\n\n    const newState = completed ? 2\n    /* Completed */\n    : 1\n    /* InProgress */\n    ;\n\n    if (this._backgroundTokenizationState !== newState) {\n      this._backgroundTokenizationState = newState;\n\n      this._onBackgroundTokenizationStateChanged.fire();\n    }\n  }\n\n  dispose() {\n    this._isDisposing = true;\n\n    this._onWillDispose.fire();\n\n    this._languageRegistryListener.dispose();\n\n    this._tokenization.dispose();\n\n    this._isDisposed = true;\n    super.dispose();\n\n    this._bufferDisposable.dispose();\n\n    this._isDisposing = false; // Manually release reference to previous text buffer to avoid large leaks\n    // in case someone leaks a TextModel reference\n\n    const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n    emptyDisposedTextBuffer.dispose();\n    this._buffer = emptyDisposedTextBuffer;\n  }\n\n  _assertNotDisposed() {\n    if (this._isDisposed) {\n      throw new Error('Model is disposed!');\n    }\n  }\n\n  _emitContentChangedEvent(rawChange, change) {\n    this._bracketPairColorizer.handleContentChanged(change);\n\n    if (this._isDisposing) {\n      // Do not confuse listeners by emitting any event after disposing\n      return;\n    }\n\n    this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n  }\n\n  setValue(value) {\n    this._assertNotDisposed();\n\n    if (value === null) {\n      // There's nothing to do\n      return;\n    }\n\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(value, this._options.defaultEOL);\n\n    this._setValueFromTextBuffer(textBuffer, disposable);\n  }\n\n  _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n    return {\n      changes: [{\n        range: range,\n        rangeOffset: rangeOffset,\n        rangeLength: rangeLength,\n        text: text\n      }],\n      eol: this._buffer.getEOL(),\n      versionId: this.getVersionId(),\n      isUndoing: isUndoing,\n      isRedoing: isRedoing,\n      isFlush: isFlush\n    };\n  }\n\n  _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n    this._assertNotDisposed();\n\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._buffer = textBuffer;\n\n    this._bufferDisposable.dispose();\n\n    this._bufferDisposable = textBufferDisposable;\n\n    this._increaseVersionId(); // Flush all tokens\n\n\n    this._tokens.flush();\n\n    this._semanticTokens.flush(); // Destroy all my decorations\n\n\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees(); // Destroy my edit history and settings\n\n    this._commandManager.clear();\n\n    this._trimAutoWhitespaceLines = null;\n\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawFlush()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n  }\n\n  setEOL(eol) {\n    this._assertNotDisposed();\n\n    const newEOL = eol === 1\n    /* CRLF */\n    ? '\\r\\n' : '\\n';\n\n    if (this._buffer.getEOL() === newEOL) {\n      // Nothing to do\n      return;\n    }\n\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n\n    this._onBeforeEOLChange();\n\n    this._buffer.setEOL(newEOL);\n\n    this._increaseVersionId();\n\n    this._onAfterEOLChange();\n\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawEOLChanged()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n  }\n\n  _onBeforeEOLChange() {\n    // Ensure all decorations get their `range` set.\n    this._decorationsTree.ensureAllNodesHaveRanges(this);\n  }\n\n  _onAfterEOLChange() {\n    // Transform back `range` to offsets\n    const versionId = this.getVersionId();\n\n    const allDecorations = this._decorationsTree.collectNodesPostOrder();\n\n    for (let i = 0, len = allDecorations.length; i < len; i++) {\n      const node = allDecorations[i];\n      const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n\n      const delta = node.cachedAbsoluteStart - node.start;\n\n      const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n      const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n      node.cachedAbsoluteStart = startOffset;\n      node.cachedAbsoluteEnd = endOffset;\n      node.cachedVersionId = versionId;\n      node.start = startOffset - delta;\n      node.end = endOffset - delta;\n      recomputeMaxEnd(node);\n    }\n  }\n\n  onBeforeAttached() {\n    this._attachedEditorCount++;\n\n    if (this._attachedEditorCount === 1) {\n      this._onDidChangeAttached.fire(undefined);\n    }\n  }\n\n  onBeforeDetached() {\n    this._attachedEditorCount--;\n\n    if (this._attachedEditorCount === 0) {\n      this._onDidChangeAttached.fire(undefined);\n    }\n  }\n\n  isAttachedToEditor() {\n    return this._attachedEditorCount > 0;\n  }\n\n  getAttachedEditorCount() {\n    return this._attachedEditorCount;\n  }\n\n  isTooLargeForSyncing() {\n    return this._isTooLargeForSyncing;\n  }\n\n  isTooLargeForTokenization() {\n    return this._isTooLargeForTokenization;\n  }\n\n  isDisposed() {\n    return this._isDisposed;\n  }\n\n  isDominatedByLongLines() {\n    this._assertNotDisposed();\n\n    if (this.isTooLargeForTokenization()) {\n      // Cannot word wrap huge files anyways, so it doesn't really matter\n      return false;\n    }\n\n    let smallLineCharCount = 0;\n    let longLineCharCount = 0;\n\n    const lineCount = this._buffer.getLineCount();\n\n    for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n      const lineLength = this._buffer.getLineLength(lineNumber);\n\n      if (lineLength >= LONG_LINE_BOUNDARY) {\n        longLineCharCount += lineLength;\n      } else {\n        smallLineCharCount += lineLength;\n      }\n    }\n\n    return longLineCharCount > smallLineCharCount;\n  }\n\n  get uri() {\n    return this._associatedResource;\n  } //#region Options\n\n\n  getOptions() {\n    this._assertNotDisposed();\n\n    return this._options;\n  }\n\n  getFormattingOptions() {\n    return {\n      tabSize: this._options.indentSize,\n      insertSpaces: this._options.insertSpaces\n    };\n  }\n\n  updateOptions(_newOpts) {\n    this._assertNotDisposed();\n\n    const tabSize = typeof _newOpts.tabSize !== 'undefined' ? _newOpts.tabSize : this._options.tabSize;\n    const indentSize = typeof _newOpts.indentSize !== 'undefined' ? _newOpts.indentSize : this._options.indentSize;\n    const insertSpaces = typeof _newOpts.insertSpaces !== 'undefined' ? _newOpts.insertSpaces : this._options.insertSpaces;\n    const trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== 'undefined' ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n    const bracketPairColorizationOptions = typeof _newOpts.bracketColorizationOptions !== 'undefined' ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n    const newOpts = new model.TextModelResolvedOptions({\n      tabSize: tabSize,\n      indentSize: indentSize,\n      insertSpaces: insertSpaces,\n      defaultEOL: this._options.defaultEOL,\n      trimAutoWhitespace: trimAutoWhitespace,\n      bracketPairColorizationOptions\n    });\n\n    if (this._options.equals(newOpts)) {\n      return;\n    }\n\n    const e = this._options.createChangeEvent(newOpts);\n\n    this._options = newOpts;\n\n    this._onDidChangeOptions.fire(e);\n  }\n\n  detectIndentation(defaultInsertSpaces, defaultTabSize) {\n    this._assertNotDisposed();\n\n    const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n    this.updateOptions({\n      insertSpaces: guessedIndentation.insertSpaces,\n      tabSize: guessedIndentation.tabSize,\n      indentSize: guessedIndentation.tabSize // TODO@Alex: guess indentSize independent of tabSize\n\n    });\n  }\n\n  static _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      if (str.charAt(i) === '\\t') {\n        spacesCnt += indentSize;\n      } else {\n        spacesCnt++;\n      }\n    }\n\n    let result = '';\n\n    if (!insertSpaces) {\n      const tabsCnt = Math.floor(spacesCnt / indentSize);\n      spacesCnt = spacesCnt % indentSize;\n\n      for (let i = 0; i < tabsCnt; i++) {\n        result += '\\t';\n      }\n    }\n\n    for (let i = 0; i < spacesCnt; i++) {\n      result += ' ';\n    }\n\n    return result;\n  }\n\n  static normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n\n    if (firstNonWhitespaceIndex === -1) {\n      firstNonWhitespaceIndex = str.length;\n    }\n\n    return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n  }\n\n  normalizeIndentation(str) {\n    this._assertNotDisposed();\n\n    return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n  } //#endregion\n  //#region Reading\n\n\n  getVersionId() {\n    this._assertNotDisposed();\n\n    return this._versionId;\n  }\n\n  mightContainRTL() {\n    return this._buffer.mightContainRTL();\n  }\n\n  mightContainUnusualLineTerminators() {\n    return this._buffer.mightContainUnusualLineTerminators();\n  }\n\n  removeUnusualLineTerminators(selections = null) {\n    const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    );\n\n    this._buffer.resetMightContainUnusualLineTerminators();\n\n    this.pushEditOperations(selections, matches.map(m => ({\n      range: m.range,\n      text: null\n    })), () => null);\n  }\n\n  mightContainNonBasicASCII() {\n    return this._buffer.mightContainNonBasicASCII();\n  }\n\n  getAlternativeVersionId() {\n    this._assertNotDisposed();\n\n    return this._alternativeVersionId;\n  }\n\n  getInitialUndoRedoSnapshot() {\n    this._assertNotDisposed();\n\n    return this._initialUndoRedoSnapshot;\n  }\n\n  getOffsetAt(rawPosition) {\n    this._assertNotDisposed();\n\n    const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0\n    /* Relaxed */\n    );\n\n    return this._buffer.getOffsetAt(position.lineNumber, position.column);\n  }\n\n  getPositionAt(rawOffset) {\n    this._assertNotDisposed();\n\n    const offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));\n    return this._buffer.getPositionAt(offset);\n  }\n\n  _increaseVersionId() {\n    this._versionId = this._versionId + 1;\n    this._alternativeVersionId = this._versionId;\n  }\n\n  _overwriteVersionId(versionId) {\n    this._versionId = versionId;\n  }\n\n  _overwriteAlternativeVersionId(newAlternativeVersionId) {\n    this._alternativeVersionId = newAlternativeVersionId;\n  }\n\n  _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n    this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n  }\n\n  getValue(eol, preserveBOM = false) {\n    this._assertNotDisposed();\n\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueInRange(fullModelRange, eol);\n\n    if (preserveBOM) {\n      return this._buffer.getBOM() + fullModelValue;\n    }\n\n    return fullModelValue;\n  }\n\n  createSnapshot(preserveBOM = false) {\n    return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n  }\n\n  getValueLength(eol, preserveBOM = false) {\n    this._assertNotDisposed();\n\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n\n    if (preserveBOM) {\n      return this._buffer.getBOM().length + fullModelValue;\n    }\n\n    return fullModelValue;\n  }\n\n  getValueInRange(rawRange, eol = 0\n  /* TextDefined */\n  ) {\n    this._assertNotDisposed();\n\n    return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n  }\n\n  getValueLengthInRange(rawRange, eol = 0\n  /* TextDefined */\n  ) {\n    this._assertNotDisposed();\n\n    return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n  }\n\n  getCharacterCountInRange(rawRange, eol = 0\n  /* TextDefined */\n  ) {\n    this._assertNotDisposed();\n\n    return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n  }\n\n  getLineCount() {\n    this._assertNotDisposed();\n\n    return this._buffer.getLineCount();\n  }\n\n  getLineContent(lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineContent(lineNumber);\n  }\n\n  getLineLength(lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineLength(lineNumber);\n  }\n\n  getLinesContent() {\n    this._assertNotDisposed();\n\n    return this._buffer.getLinesContent();\n  }\n\n  getEOL() {\n    this._assertNotDisposed();\n\n    return this._buffer.getEOL();\n  }\n\n  getEndOfLineSequence() {\n    this._assertNotDisposed();\n\n    return this._buffer.getEOL() === '\\n' ? 0\n    /* LF */\n    : 1\n    /* CRLF */\n    ;\n  }\n\n  getLineMinColumn(lineNumber) {\n    this._assertNotDisposed();\n\n    return 1;\n  }\n\n  getLineMaxColumn(lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineLength(lineNumber) + 1;\n  }\n\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n  }\n\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n  }\n  /**\n   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n   * Will try to not allocate if possible.\n   */\n\n\n  _validateRangeRelaxedNoAllocations(range) {\n    const linesCount = this._buffer.getLineCount();\n\n    const initialStartLineNumber = range.startLineNumber;\n    const initialStartColumn = range.startColumn;\n    let startLineNumber = Math.floor(typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber) ? initialStartLineNumber : 1);\n    let startColumn = Math.floor(typeof initialStartColumn === 'number' && !isNaN(initialStartColumn) ? initialStartColumn : 1);\n\n    if (startLineNumber < 1) {\n      startLineNumber = 1;\n      startColumn = 1;\n    } else if (startLineNumber > linesCount) {\n      startLineNumber = linesCount;\n      startColumn = this.getLineMaxColumn(startLineNumber);\n    } else {\n      if (startColumn <= 1) {\n        startColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(startLineNumber);\n\n        if (startColumn >= maxColumn) {\n          startColumn = maxColumn;\n        }\n      }\n    }\n\n    const initialEndLineNumber = range.endLineNumber;\n    const initialEndColumn = range.endColumn;\n    let endLineNumber = Math.floor(typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber) ? initialEndLineNumber : 1);\n    let endColumn = Math.floor(typeof initialEndColumn === 'number' && !isNaN(initialEndColumn) ? initialEndColumn : 1);\n\n    if (endLineNumber < 1) {\n      endLineNumber = 1;\n      endColumn = 1;\n    } else if (endLineNumber > linesCount) {\n      endLineNumber = linesCount;\n      endColumn = this.getLineMaxColumn(endLineNumber);\n    } else {\n      if (endColumn <= 1) {\n        endColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(endLineNumber);\n\n        if (endColumn >= maxColumn) {\n          endColumn = maxColumn;\n        }\n      }\n    }\n\n    if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range instanceof Range && !(range instanceof Selection)) {\n      return range;\n    }\n\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n\n  _isValidPosition(lineNumber, column, validationType) {\n    if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n      return false;\n    }\n\n    if (isNaN(lineNumber) || isNaN(column)) {\n      return false;\n    }\n\n    if (lineNumber < 1 || column < 1) {\n      return false;\n    }\n\n    if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n      return false;\n    }\n\n    const lineCount = this._buffer.getLineCount();\n\n    if (lineNumber > lineCount) {\n      return false;\n    }\n\n    if (column === 1) {\n      return true;\n    }\n\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n\n    if (column > maxColumn) {\n      return false;\n    }\n\n    if (validationType === 1\n    /* SurrogatePairs */\n    ) {\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _validatePosition(_lineNumber, _column, validationType) {\n    const lineNumber = Math.floor(typeof _lineNumber === 'number' && !isNaN(_lineNumber) ? _lineNumber : 1);\n    const column = Math.floor(typeof _column === 'number' && !isNaN(_column) ? _column : 1);\n\n    const lineCount = this._buffer.getLineCount();\n\n    if (lineNumber < 1) {\n      return new Position(1, 1);\n    }\n\n    if (lineNumber > lineCount) {\n      return new Position(lineCount, this.getLineMaxColumn(lineCount));\n    }\n\n    if (column <= 1) {\n      return new Position(lineNumber, 1);\n    }\n\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n\n    if (column >= maxColumn) {\n      return new Position(lineNumber, maxColumn);\n    }\n\n    if (validationType === 1\n    /* SurrogatePairs */\n    ) {\n      // If the position would end up in the middle of a high-low surrogate pair,\n      // we move it to before the pair\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return new Position(lineNumber, column - 1);\n      }\n    }\n\n    return new Position(lineNumber, column);\n  }\n\n  validatePosition(position) {\n    const validationType = 1\n    /* SurrogatePairs */\n    ;\n\n    this._assertNotDisposed(); // Avoid object allocation and cover most likely case\n\n\n    if (position instanceof Position) {\n      if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n        return position;\n      }\n    }\n\n    return this._validatePosition(position.lineNumber, position.column, validationType);\n  }\n\n  _isValidRange(range, validationType) {\n    const startLineNumber = range.startLineNumber;\n    const startColumn = range.startColumn;\n    const endLineNumber = range.endLineNumber;\n    const endColumn = range.endColumn;\n\n    if (!this._isValidPosition(startLineNumber, startColumn, 0\n    /* Relaxed */\n    )) {\n      return false;\n    }\n\n    if (!this._isValidPosition(endLineNumber, endColumn, 0\n    /* Relaxed */\n    )) {\n      return false;\n    }\n\n    if (validationType === 1\n    /* SurrogatePairs */\n    ) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  validateRange(_range) {\n    const validationType = 1\n    /* SurrogatePairs */\n    ;\n\n    this._assertNotDisposed(); // Avoid object allocation and cover most likely case\n\n\n    if (_range instanceof Range && !(_range instanceof Selection)) {\n      if (this._isValidRange(_range, validationType)) {\n        return _range;\n      }\n    }\n\n    const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0\n    /* Relaxed */\n    );\n\n    const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0\n    /* Relaxed */\n    );\n\n    const startLineNumber = start.lineNumber;\n    const startColumn = start.column;\n    const endLineNumber = end.lineNumber;\n    const endColumn = end.column;\n\n    if (validationType === 1\n    /* SurrogatePairs */\n    ) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      }\n\n      if (startLineNumber === endLineNumber && startColumn === endColumn) {\n        // do not expand a collapsed range, simply move it to a valid location\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n      }\n\n      if (startInsideSurrogatePair && endInsideSurrogatePair) {\n        // expand range at both ends\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n      }\n\n      if (startInsideSurrogatePair) {\n        // only expand range at the start\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n      } // only expand range at the end\n\n\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n    }\n\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n\n  modifyPosition(rawPosition, offset) {\n    this._assertNotDisposed();\n\n    const candidate = this.getOffsetAt(rawPosition) + offset;\n    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n  }\n\n  getFullModelRange() {\n    this._assertNotDisposed();\n\n    const lineCount = this.getLineCount();\n    return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n  }\n\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n\n  findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n    this._assertNotDisposed();\n\n    let searchRanges = null;\n\n    if (rawSearchScope !== null) {\n      if (!Array.isArray(rawSearchScope)) {\n        rawSearchScope = [rawSearchScope];\n      }\n\n      if (rawSearchScope.every(searchScope => Range.isIRange(searchScope))) {\n        searchRanges = rawSearchScope.map(searchScope => this.validateRange(searchScope));\n      }\n    }\n\n    if (searchRanges === null) {\n      searchRanges = [this.getFullModelRange()];\n    }\n\n    searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n    const uniqueSearchRanges = [];\n    uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n      if (Range.areIntersecting(prev, curr)) {\n        return prev.plusRange(curr);\n      }\n\n      uniqueSearchRanges.push(prev);\n      return curr;\n    }));\n    let matchMapper;\n\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      // not regex, not multi line\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n\n      if (!searchData) {\n        return [];\n      }\n\n      matchMapper = searchRange => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    } else {\n      matchMapper = searchRange => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n    }\n\n    return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n  }\n\n  findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n\n    const searchStart = this.validatePosition(rawSearchStart);\n\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n\n      if (!searchData) {\n        return null;\n      }\n\n      const lineCount = this.getLineCount();\n      let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n      let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\n      if (ret.length > 0) {\n        return ret[0];\n      }\n\n      searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n      ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n\n      if (ret.length > 0) {\n        return ret[0];\n      }\n\n      return null;\n    }\n\n    return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n\n  findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n\n    const searchStart = this.validatePosition(rawSearchStart);\n    return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  } //#endregion\n  //#region Editing\n\n\n  pushStackElement() {\n    this._commandManager.pushStackElement();\n  }\n\n  popStackElement() {\n    this._commandManager.popStackElement();\n  }\n\n  pushEOL(eol) {\n    const currentEOL = this.getEOL() === '\\n' ? 0\n    /* LF */\n    : 1\n    /* CRLF */\n    ;\n\n    if (currentEOL === eol) {\n      return;\n    }\n\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      if (this._initialUndoRedoSnapshot === null) {\n        this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n      }\n\n      this._commandManager.pushEOL(eol);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  _validateEditOperation(rawOperation) {\n    if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n      return rawOperation;\n    }\n\n    return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n  }\n\n  _validateEditOperations(rawOperations) {\n    const result = [];\n\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      result[i] = this._validateEditOperation(rawOperations[i]);\n    }\n\n    return result;\n  }\n\n  pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n      // Go through each saved line number and insert a trim whitespace edit\n      // if it is safe to do so (no conflicts with other edits).\n      const incomingEdits = editOperations.map(op => {\n        return {\n          range: this.validateRange(op.range),\n          text: op.text\n        };\n      }); // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n      // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n\n      let editsAreNearCursors = true;\n\n      if (beforeCursorState) {\n        for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n          const sel = beforeCursorState[i];\n          let foundEditNearSel = false;\n\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            const editRange = incomingEdits[j].range;\n            const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n            const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n\n            if (!selIsAbove && !selIsBelow) {\n              foundEditNearSel = true;\n              break;\n            }\n          }\n\n          if (!foundEditNearSel) {\n            editsAreNearCursors = false;\n            break;\n          }\n        }\n      }\n\n      if (editsAreNearCursors) {\n        for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n          const trimLineNumber = this._trimAutoWhitespaceLines[i];\n          const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n          let allowTrimLine = true;\n\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            const editRange = incomingEdits[j].range;\n            const editText = incomingEdits[j].text;\n\n            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n              // `trimLine` is completely outside this edit\n              continue;\n            } // At this point:\n            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n\n\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n              // This edit inserts a new line (and maybe other text) after `trimLine`\n              continue;\n            }\n\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n              // This edit inserts a new line (and maybe other text) before `trimLine`\n              continue;\n            } // Looks like we can't trim this line as it would interfere with an incoming edit\n\n\n            allowTrimLine = false;\n            break;\n          }\n\n          if (allowTrimLine) {\n            const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n            editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n          }\n        }\n      }\n\n      this._trimAutoWhitespaceLines = null;\n    }\n\n    if (this._initialUndoRedoSnapshot === null) {\n      this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n    }\n\n    return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n  }\n\n  _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.newPosition);\n      const rangeEnd = this.getPositionAt(change.newEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.oldText\n      };\n    });\n\n    this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n  }\n\n  _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.oldPosition);\n      const rangeEnd = this.getPositionAt(change.oldEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.newText\n      };\n    });\n\n    this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n  }\n\n  _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      this._isUndoing = isUndoing;\n      this._isRedoing = isRedoing;\n      this.applyEdits(edits, false);\n      this.setEOL(eol);\n\n      this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n    } finally {\n      this._isUndoing = false;\n      this._isRedoing = false;\n\n      this._eventEmitter.endDeferredEmit(resultingSelection);\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  applyEdits(rawOperations, computeUndoEdits = false) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      const operations = this._validateEditOperations(rawOperations);\n\n      return this._doApplyEdits(operations, computeUndoEdits);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  _doApplyEdits(rawOperations, computeUndoEdits) {\n    const oldLineCount = this._buffer.getLineCount();\n\n    const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n\n    const newLineCount = this._buffer.getLineCount();\n\n    const contentChanges = result.changes;\n    this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n\n    if (contentChanges.length !== 0) {\n      // We do a first pass to update tokens and decorations\n      // because we want to read decorations in the second pass\n      // where we will emit content change events\n      // and we want to read the final decorations\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n\n        this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\n\n        this._semanticTokens.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0\n        /* Null */\n        );\n\n        this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n      }\n\n      const rawContentChanges = [];\n\n      this._increaseVersionId();\n\n      let lineCount = oldLineCount;\n\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        const [eolCount] = countEOL(change.text);\n\n        this._onDidChangeDecorations.fire();\n\n        const startLineNumber = change.range.startLineNumber;\n        const endLineNumber = change.range.endLineNumber;\n        const deletingLinesCnt = endLineNumber - startLineNumber;\n        const insertingLinesCnt = eolCount;\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        const changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;\n        const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n        const firstEditLineNumber = currentEditStartLineNumber;\n        const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n\n        const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n\n        const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n        const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n\n        for (let j = editingLinesCnt; j >= 0; j--) {\n          const editLineNumber = startLineNumber + j;\n          const currentEditLineNumber = currentEditStartLineNumber + j;\n          injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n          const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n          rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n        }\n\n        if (editingLinesCnt < deletingLinesCnt) {\n          // Must delete some lines\n          const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n          rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n        }\n\n        if (editingLinesCnt < insertingLinesCnt) {\n          const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange); // Must insert some lines\n\n          const spliceLineNumber = startLineNumber + editingLinesCnt;\n          const cnt = insertingLinesCnt - editingLinesCnt;\n          const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n          const injectedTexts = [];\n          const newLines = [];\n\n          for (let i = 0; i < cnt; i++) {\n            const lineNumber = fromLineNumber + i;\n            newLines[i] = this.getLineContent(lineNumber);\n            injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n            injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n          }\n\n          rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n        }\n\n        lineCount += changeLineCountDelta;\n      }\n\n      this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n        changes: contentChanges,\n        eol: this._buffer.getEOL(),\n        versionId: this.getVersionId(),\n        isUndoing: this._isUndoing,\n        isRedoing: this._isRedoing,\n        isFlush: false\n      });\n    }\n\n    return result.reverseEdits === null ? undefined : result.reverseEdits;\n  }\n\n  undo() {\n    return this._undoRedoService.undo(this.uri);\n  }\n\n  canUndo() {\n    return this._undoRedoService.canUndo(this.uri);\n  }\n\n  redo() {\n    return this._undoRedoService.redo(this.uri);\n  }\n\n  canRedo() {\n    return this._undoRedoService.canRedo(this.uri);\n  } //#endregion\n  //#region Decorations\n\n\n  handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n    // This is called before the decoration changed event is fired.\n    if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n      return;\n    }\n\n    const affectedLines = [...affectedInjectedTextLines];\n    const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n\n    this._onDidChangeContentOrInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n  }\n\n  changeDecorations(callback, ownerId = 0) {\n    this._assertNotDisposed();\n\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      return this._changeDecorations(ownerId, callback);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  _changeDecorations(ownerId, callback) {\n    const changeAccessor = {\n      addDecoration: (range, options) => {\n        return this._deltaDecorationsImpl(ownerId, [], [{\n          range: range,\n          options: options\n        }])[0];\n      },\n      changeDecoration: (id, newRange) => {\n        this._changeDecorationImpl(id, newRange);\n      },\n      changeDecorationOptions: (id, options) => {\n        this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n      },\n      removeDecoration: id => {\n        this._deltaDecorationsImpl(ownerId, [id], []);\n      },\n      deltaDecorations: (oldDecorations, newDecorations) => {\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n          // nothing to do\n          return [];\n        }\n\n        return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n      }\n    };\n    let result = null;\n\n    try {\n      result = callback(changeAccessor);\n    } catch (e) {\n      onUnexpectedError(e);\n    } // Invalidate change accessor\n\n\n    changeAccessor.addDecoration = invalidFunc;\n    changeAccessor.changeDecoration = invalidFunc;\n    changeAccessor.changeDecorationOptions = invalidFunc;\n    changeAccessor.removeDecoration = invalidFunc;\n    changeAccessor.deltaDecorations = invalidFunc;\n    return result;\n  }\n\n  deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n    this._assertNotDisposed();\n\n    if (!oldDecorations) {\n      oldDecorations = [];\n    }\n\n    if (oldDecorations.length === 0 && newDecorations.length === 0) {\n      // nothing to do\n      return [];\n    }\n\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n\n  _getTrackedRange(id) {\n    return this.getDecorationRange(id);\n  }\n\n  _setTrackedRange(id, newRange, newStickiness) {\n    const node = id ? this._decorations[id] : null;\n\n    if (!node) {\n      if (!newRange) {\n        // node doesn't exist, the request is to delete => nothing to do\n        return null;\n      } // node doesn't exist, the request is to set => add the tracked range\n\n\n      return this._deltaDecorationsImpl(0, [], [{\n        range: newRange,\n        options: TRACKED_RANGE_OPTIONS[newStickiness]\n      }])[0];\n    }\n\n    if (!newRange) {\n      // node exists, the request is to delete => delete node\n      this._decorationsTree.delete(node);\n\n      delete this._decorations[node.id];\n      return null;\n    } // node exists, the request is to set => change the tracked range and its options\n\n\n    const range = this._validateRangeRelaxedNoAllocations(newRange);\n\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n    this._decorationsTree.delete(node);\n\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n\n    this._decorationsTree.insert(node);\n\n    return node.id;\n  }\n\n  removeAllDecorationsWithOwnerId(ownerId) {\n    if (this._isDisposed) {\n      return;\n    }\n\n    const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n\n    for (let i = 0, len = nodes.length; i < len; i++) {\n      const node = nodes[i];\n\n      this._decorationsTree.delete(node);\n\n      delete this._decorations[node.id];\n    }\n  }\n\n  getDecorationOptions(decorationId) {\n    const node = this._decorations[decorationId];\n\n    if (!node) {\n      return null;\n    }\n\n    return node.options;\n  }\n\n  getDecorationRange(decorationId) {\n    const node = this._decorations[decorationId];\n\n    if (!node) {\n      return null;\n    }\n\n    return this._decorationsTree.getNodeRange(this, node);\n  }\n\n  getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      return [];\n    }\n\n    return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n  }\n\n  getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\n    const lineCount = this.getLineCount();\n    const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n    const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n\n    const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation);\n\n    decorations.push(...this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n    return decorations;\n  }\n\n  getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\n    const validatedRange = this.validateRange(range);\n\n    const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n\n    decorations.push(...this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation));\n    return decorations;\n  }\n\n  getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n    return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true);\n  }\n\n  getInjectedTextDecorations(ownerId = 0) {\n    return this._decorationsTree.getAllInjectedText(this, ownerId);\n  }\n\n  _getInjectedTextInLine(lineNumber) {\n    const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n\n    const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n\n    const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n\n    return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n  }\n\n  getAllDecorations(ownerId = 0, filterOutValidation = false) {\n    let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false);\n\n    result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n    return result;\n  }\n\n  _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n    const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n\n    const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n\n    return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation);\n  }\n\n  getRangeAt(start, end) {\n    return this._buffer.getRangeAt(start, end - start);\n  }\n\n  _changeDecorationImpl(decorationId, _range) {\n    const node = this._decorations[decorationId];\n\n    if (!node) {\n      return;\n    }\n\n    if (node.options.after) {\n      const oldRange = this.getDecorationRange(decorationId);\n\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n    }\n\n    if (node.options.before) {\n      const oldRange = this.getDecorationRange(decorationId);\n\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n    }\n\n    const range = this._validateRangeRelaxedNoAllocations(_range);\n\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n    this._decorationsTree.delete(node);\n\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n\n    this._decorationsTree.insert(node);\n\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\n    if (node.options.after) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n    }\n\n    if (node.options.before) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n    }\n  }\n\n  _changeDecorationOptionsImpl(decorationId, options) {\n    const node = this._decorations[decorationId];\n\n    if (!node) {\n      return;\n    }\n\n    const nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n    const nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\n    this._onDidChangeDecorations.checkAffectedAndFire(options);\n\n    if (node.options.after || options.after) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n    }\n\n    if (node.options.before || options.before) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n    }\n\n    if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n      // Delete + Insert due to an overview ruler status change\n      this._decorationsTree.delete(node);\n\n      node.setOptions(options);\n\n      this._decorationsTree.insert(node);\n    } else {\n      node.setOptions(options);\n    }\n  }\n\n  _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n    const versionId = this.getVersionId();\n    const oldDecorationsLen = oldDecorationsIds.length;\n    let oldDecorationIndex = 0;\n    const newDecorationsLen = newDecorations.length;\n    let newDecorationIndex = 0;\n    const result = new Array(newDecorationsLen);\n\n    while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n      let node = null;\n\n      if (oldDecorationIndex < oldDecorationsLen) {\n        // (1) get ourselves an old node\n        do {\n          node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n        } while (!node && oldDecorationIndex < oldDecorationsLen); // (2) remove the node from the tree (if it exists)\n\n\n        if (node) {\n          if (node.options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n          }\n\n          if (node.options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n          }\n\n          this._decorationsTree.delete(node);\n\n          this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        }\n      }\n\n      if (newDecorationIndex < newDecorationsLen) {\n        // (3) create a new node if necessary\n        if (!node) {\n          const internalDecorationId = ++this._lastDecorationId;\n          const decorationId = `${this._instanceId};${internalDecorationId}`;\n          node = new IntervalNode(decorationId, 0, 0);\n          this._decorations[decorationId] = node;\n        } // (4) initialize node\n\n\n        const newDecoration = newDecorations[newDecorationIndex];\n\n        const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n\n        const options = _normalizeOptions(newDecoration.options);\n\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n        node.ownerId = ownerId;\n        node.reset(versionId, startOffset, endOffset, range);\n        node.setOptions(options);\n\n        if (node.options.after) {\n          this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n\n        if (node.options.before) {\n          this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n\n        this._decorationsTree.insert(node);\n\n        result[newDecorationIndex] = node.id;\n        newDecorationIndex++;\n      } else {\n        if (node) {\n          delete this._decorations[node.id];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  setTokens(tokens, backgroundTokenizationCompleted = false) {\n    if (tokens.length !== 0) {\n      const ranges = [];\n\n      for (let i = 0, len = tokens.length; i < len; i++) {\n        const element = tokens[i];\n        let minChangedLineNumber = 0;\n        let maxChangedLineNumber = 0;\n        let hasChange = false;\n\n        for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n          if (hasChange) {\n            this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n\n            maxChangedLineNumber = lineNumber;\n          } else {\n            const lineHasChange = this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n\n            if (lineHasChange) {\n              hasChange = true;\n              minChangedLineNumber = lineNumber;\n              maxChangedLineNumber = lineNumber;\n            }\n          }\n        }\n\n        if (hasChange) {\n          ranges.push({\n            fromLineNumber: minChangedLineNumber,\n            toLineNumber: maxChangedLineNumber\n          });\n        }\n      }\n\n      if (ranges.length > 0) {\n        this._emitModelTokensChangedEvent({\n          tokenizationSupportChanged: false,\n          semanticTokensApplied: false,\n          ranges: ranges\n        });\n      }\n    }\n\n    this.handleTokenizationProgress(backgroundTokenizationCompleted);\n  }\n\n  setSemanticTokens(tokens, isComplete) {\n    this._semanticTokens.set(tokens, isComplete);\n\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: false,\n      semanticTokensApplied: tokens !== null,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this.getLineCount()\n      }]\n    });\n  }\n\n  hasCompleteSemanticTokens() {\n    return this._semanticTokens.isComplete();\n  }\n\n  hasSomeSemanticTokens() {\n    return !this._semanticTokens.isEmpty();\n  }\n\n  setPartialSemanticTokens(range, tokens) {\n    if (this.hasCompleteSemanticTokens()) {\n      return;\n    }\n\n    const changedRange = this.validateRange(this._semanticTokens.setPartial(range, tokens));\n\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: false,\n      semanticTokensApplied: true,\n      ranges: [{\n        fromLineNumber: changedRange.startLineNumber,\n        toLineNumber: changedRange.endLineNumber\n      }]\n    });\n  }\n\n  tokenizeViewport(startLineNumber, endLineNumber) {\n    startLineNumber = Math.max(1, startLineNumber);\n    endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\n\n    this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n  }\n\n  clearTokens() {\n    this._tokens.flush();\n\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: true,\n      semanticTokensApplied: false,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this._buffer.getLineCount()\n      }]\n    });\n  }\n\n  _emitModelTokensChangedEvent(e) {\n    if (!this._isDisposing) {\n      this._onDidChangeTokens.fire(e);\n    }\n  }\n\n  resetTokenization() {\n    this._tokenization.reset();\n  }\n\n  forceTokenization(lineNumber) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    this._tokenization.forceTokenization(lineNumber);\n  }\n\n  isCheapToTokenize(lineNumber) {\n    return this._tokenization.isCheapToTokenize(lineNumber);\n  }\n\n  tokenizeIfCheap(lineNumber) {\n    if (this.isCheapToTokenize(lineNumber)) {\n      this.forceTokenization(lineNumber);\n    }\n  }\n\n  getLineTokens(lineNumber) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._getLineTokens(lineNumber);\n  }\n\n  _getLineTokens(lineNumber) {\n    const lineText = this.getLineContent(lineNumber);\n\n    const syntacticTokens = this._tokens.getTokens(this._languageId, lineNumber - 1, lineText);\n\n    return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n  }\n\n  getLanguageId() {\n    return this._languageId;\n  }\n\n  setMode(languageId) {\n    if (this._languageId === languageId) {\n      // There's nothing to do\n      return;\n    }\n\n    const e = {\n      oldLanguage: this._languageId,\n      newLanguage: languageId\n    };\n    this._languageId = languageId;\n\n    this._onDidChangeLanguage.fire(e);\n\n    this._onDidChangeLanguageConfiguration.fire({});\n  }\n\n  getLanguageIdAtPosition(lineNumber, column) {\n    const position = this.validatePosition(new Position(lineNumber, column));\n    const lineTokens = this.getLineTokens(position.lineNumber);\n    return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n  }\n\n  getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n    const position = this.validatePosition(new Position(lineNumber, column));\n    return this._tokenization.getTokenTypeIfInsertingCharacter(position, character);\n  }\n\n  tokenizeLineWithEdit(position, length, newText) {\n    const validatedPosition = this.validatePosition(position);\n    return this._tokenization.tokenizeLineWithEdit(validatedPosition, length, newText);\n  }\n\n  getLanguageConfiguration(languageId) {\n    return this._languageConfigurationService.getLanguageConfiguration(languageId);\n  } // Having tokens allows implementing additional helper methods\n\n\n  getWordAtPosition(_position) {\n    this._assertNotDisposed();\n\n    const position = this.validatePosition(_position);\n    const lineContent = this.getLineContent(position.lineNumber);\n\n    const lineTokens = this._getLineTokens(position.lineNumber);\n\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1); // (1). First try checking right biased word\n\n    const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\n\n    const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset); // Make sure the result touches the original passed in position\n\n    if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n      return rightBiasedWord;\n    } // (2). Else, if we were at a language boundary, check the left biased word\n\n\n    if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n      // edge case, where `position` sits between two tokens belonging to two different languages\n      const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n\n      const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset); // Make sure the result touches the original passed in position\n\n      if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n        return leftBiasedWord;\n      }\n    }\n\n    return null;\n  }\n\n  static _findLanguageBoundaries(lineTokens, tokenIndex) {\n    const languageId = lineTokens.getLanguageId(tokenIndex); // go left until a different language is hit\n\n    let startOffset = 0;\n\n    for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n      startOffset = lineTokens.getStartOffset(i);\n    } // go right until a different language is hit\n\n\n    let endOffset = lineTokens.getLineContent().length;\n\n    for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n      endOffset = lineTokens.getEndOffset(i);\n    }\n\n    return [startOffset, endOffset];\n  }\n\n  getWordUntilPosition(position) {\n    const wordAtPosition = this.getWordAtPosition(position);\n\n    if (!wordAtPosition) {\n      return {\n        word: '',\n        startColumn: position.column,\n        endColumn: position.column\n      };\n    }\n\n    return {\n      word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n      startColumn: wordAtPosition.startColumn,\n      endColumn: position.column\n    };\n  } //#endregion\n\n\n  normalizePosition(position, affinity) {\n    return position;\n  }\n  /**\n   * Gets the column at which indentation stops at a given line.\n   * @internal\n  */\n\n\n  getLineIndentColumn(lineNumber) {\n    // Columns start with 1.\n    return indentOfLine(this.getLineContent(lineNumber)) + 1;\n  }\n\n};\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\n\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\n\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\n\nTextModel.DEFAULT_CREATION_OPTIONS = {\n  isForSimpleWidget: false,\n  tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n  indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n  insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n  detectIndentation: false,\n  defaultEOL: 1\n  /* LF */\n  ,\n  trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n  largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n  bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions\n};\nTextModel = __decorate([__param(4, IUndoRedoService), __param(5, ILanguageService), __param(6, ILanguageConfigurationService)], TextModel);\nexport { TextModel };\n\nfunction indentOfLine(line) {\n  let indent = 0;\n\n  for (const c of line) {\n    if (c === ' ' || c === '\\t') {\n      indent++;\n    } else {\n      break;\n    }\n  }\n\n  return indent;\n} //#region Decorations\n\n\nfunction isNodeInOverviewRuler(node) {\n  return node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n}\n\nfunction isNodeInjectedText(node) {\n  return !!node.options.after || !!node.options.before;\n}\n\nclass DecorationsTrees {\n  constructor() {\n    this._decorationsTree0 = new IntervalTree();\n    this._decorationsTree1 = new IntervalTree();\n    this._injectedTextDecorationsTree = new IntervalTree();\n  }\n\n  ensureAllNodesHaveRanges(host) {\n    this.getAll(host, 0, false, false);\n  }\n\n  _ensureNodesHaveRanges(host, nodes) {\n    for (const node of nodes) {\n      if (node.range === null) {\n        node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n      }\n    }\n\n    return nodes;\n  }\n\n  getAllInInterval(host, start, end, filterOwnerId, filterOutValidation) {\n    const versionId = host.getVersionId();\n\n    const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId);\n\n    return this._ensureNodesHaveRanges(host, result);\n  }\n\n  _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\n    const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\n    const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\n    return r0.concat(r1).concat(r2);\n  }\n\n  getInjectedTextInInterval(host, start, end, filterOwnerId) {\n    const versionId = host.getVersionId();\n\n    const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId);\n\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n\n  getAllInjectedText(host, filterOwnerId) {\n    const versionId = host.getVersionId();\n\n    const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId);\n\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n\n  getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly) {\n    const versionId = host.getVersionId();\n\n    const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId);\n\n    return this._ensureNodesHaveRanges(host, result);\n  }\n\n  _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n    if (overviewRulerOnly) {\n      return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n    } else {\n      const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\n      const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\n      const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\n      return r0.concat(r1).concat(r2);\n    }\n  }\n\n  collectNodesFromOwner(ownerId) {\n    const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n\n    const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n\n    const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n\n    return r0.concat(r1).concat(r2);\n  }\n\n  collectNodesPostOrder() {\n    const r0 = this._decorationsTree0.collectNodesPostOrder();\n\n    const r1 = this._decorationsTree1.collectNodesPostOrder();\n\n    const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n\n    return r0.concat(r1).concat(r2);\n  }\n\n  insert(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.insert(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.insert(node);\n    } else {\n      this._decorationsTree0.insert(node);\n    }\n  }\n\n  delete(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.delete(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.delete(node);\n    } else {\n      this._decorationsTree0.delete(node);\n    }\n  }\n\n  getNodeRange(host, node) {\n    const versionId = host.getVersionId();\n\n    if (node.cachedVersionId !== versionId) {\n      this._resolveNode(node, versionId);\n    }\n\n    if (node.range === null) {\n      node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n    }\n\n    return node.range;\n  }\n\n  _resolveNode(node, cachedVersionId) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.resolveNode(node, cachedVersionId);\n    } else {\n      this._decorationsTree0.resolveNode(node, cachedVersionId);\n    }\n  }\n\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\n    this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\n    this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n  }\n\n}\n\nfunction cleanClassName(className) {\n  return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\n\nclass DecorationOptions {\n  constructor(options) {\n    this.color = options.color || '';\n    this.darkColor = options.darkColor || '';\n  }\n\n}\n\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this._resolvedColor = null;\n    this.position = typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center;\n  }\n\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n\n    return this._resolvedColor;\n  }\n\n  invalidateCachedColor() {\n    this._resolvedColor = null;\n  }\n\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return color;\n    }\n\n    const c = color ? theme.getColor(color.id) : null;\n\n    if (!c) {\n      return '';\n    }\n\n    return c.toString();\n  }\n\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this.position = options.position;\n  }\n\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n\n    return this._resolvedColor;\n  }\n\n  invalidateCachedColor() {\n    this._resolvedColor = undefined;\n  }\n\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return Color.fromHex(color);\n    }\n\n    return theme.getColor(color.id);\n  }\n\n}\nexport class ModelDecorationInjectedTextOptions {\n  constructor(options) {\n    this.content = options.content || '';\n    this.inlineClassName = options.inlineClassName || null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.attachedData = options.attachedData || null;\n    this.cursorStops = options.cursorStops || null;\n  }\n\n  static from(options) {\n    if (options instanceof ModelDecorationInjectedTextOptions) {\n      return options;\n    }\n\n    return new ModelDecorationInjectedTextOptions(options);\n  }\n\n}\nexport class ModelDecorationOptions {\n  constructor(options) {\n    var _a, _b;\n\n    this.description = options.description;\n    this.stickiness = options.stickiness || 0\n    /* AlwaysGrowsWhenTypingAtEdges */\n    ;\n    this.zIndex = options.zIndex || 0;\n    this.className = options.className ? cleanClassName(options.className) : null;\n    this.hoverMessage = options.hoverMessage || null;\n    this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n    this.isWholeLine = options.isWholeLine || false;\n    this.showIfCollapsed = options.showIfCollapsed || false;\n    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n    this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n    this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n    this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n    this.hideInCommentTokens = (_a = options.hideInCommentTokens) !== null && _a !== void 0 ? _a : false;\n    this.hideInStringTokens = (_b = options.hideInStringTokens) !== null && _b !== void 0 ? _b : false;\n  }\n\n  static register(options) {\n    return new ModelDecorationOptions(options);\n  }\n\n  static createDynamic(options) {\n    return new ModelDecorationOptions(options);\n  }\n\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({\n  description: 'empty'\n});\n/**\n * The order carefully matches the values of the enum.\n */\n\nconst TRACKED_RANGE_OPTIONS = [ModelDecorationOptions.register({\n  description: 'tracked-range-always-grows-when-typing-at-edges',\n  stickiness: 0\n  /* AlwaysGrowsWhenTypingAtEdges */\n\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-never-grows-when-typing-at-edges',\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-before',\n  stickiness: 2\n  /* GrowsOnlyWhenTypingBefore */\n\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-after',\n  stickiness: 3\n  /* GrowsOnlyWhenTypingAfter */\n\n})];\n\nfunction _normalizeOptions(options) {\n  if (options instanceof ModelDecorationOptions) {\n    return options;\n  }\n\n  return ModelDecorationOptions.createDynamic(options);\n}\n\nexport class DidChangeDecorationsEmitter extends Disposable {\n  constructor(handleBeforeFire) {\n    super();\n    this.handleBeforeFire = handleBeforeFire;\n    this._actual = this._register(new Emitter());\n    this.event = this._actual.event;\n    this._affectedInjectedTextLines = null;\n    this._deferredCnt = 0;\n    this._shouldFire = false;\n    this._affectsMinimap = false;\n    this._affectsOverviewRuler = false;\n  }\n\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n\n  endDeferredEmit() {\n    var _a;\n\n    this._deferredCnt--;\n\n    if (this._deferredCnt === 0) {\n      if (this._shouldFire) {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n          affectsMinimap: this._affectsMinimap,\n          affectsOverviewRuler: this._affectsOverviewRuler\n        };\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n\n        this._actual.fire(event);\n      }\n\n      (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n      this._affectedInjectedTextLines = null;\n    }\n  }\n\n  recordLineAffectedByInjectedText(lineNumber) {\n    if (!this._affectedInjectedTextLines) {\n      this._affectedInjectedTextLines = new Set();\n    }\n\n    this._affectedInjectedTextLines.add(lineNumber);\n  }\n\n  checkAffectedAndFire(options) {\n    if (!this._affectsMinimap) {\n      this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n    }\n\n    if (!this._affectsOverviewRuler) {\n      this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n    }\n\n    this._shouldFire = true;\n  }\n\n  fire() {\n    this._affectsMinimap = true;\n    this._affectsOverviewRuler = true;\n    this._shouldFire = true;\n  }\n\n} //#endregion\n\nexport class DidChangeContentEmitter extends Disposable {\n  constructor() {\n    super();\n    /**\n     * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n     */\n\n    this._fastEmitter = this._register(new Emitter());\n    this.fastEvent = this._fastEmitter.event;\n    this._slowEmitter = this._register(new Emitter());\n    this.slowEvent = this._slowEmitter.event;\n    this._deferredCnt = 0;\n    this._deferredEvent = null;\n  }\n\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n\n  endDeferredEmit(resultingSelection = null) {\n    this._deferredCnt--;\n\n    if (this._deferredCnt === 0) {\n      if (this._deferredEvent !== null) {\n        this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n        const e = this._deferredEvent;\n        this._deferredEvent = null;\n\n        this._fastEmitter.fire(e);\n\n        this._slowEmitter.fire(e);\n      }\n    }\n  }\n\n  fire(e) {\n    if (this._deferredCnt > 0) {\n      if (this._deferredEvent) {\n        this._deferredEvent = this._deferredEvent.merge(e);\n      } else {\n        this._deferredEvent = e;\n      }\n\n      return;\n    }\n\n    this._fastEmitter.fire(e);\n\n    this._slowEmitter.fire(e);\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","ArrayQueue","Color","onUnexpectedError","Emitter","Disposable","strings","URI","Position","Range","Selection","model","BracketPairsTextModelPart","ColorizedBracketPairsDecorationProvider","EditStack","GuidesTextModelPart","guessIndentation","IntervalNode","IntervalTree","recomputeMaxEnd","PieceTreeTextBuffer","PieceTreeTextBufferBuilder","InternalModelContentChangeEvent","LineInjectedText","ModelInjectedTextChangedEvent","ModelRawContentChangedEvent","ModelRawEOLChanged","ModelRawFlush","ModelRawLineChanged","ModelRawLinesDeleted","ModelRawLinesInserted","SearchParams","TextModelSearch","TextModelTokenization","countEOL","ContiguousTokensStore","SparseTokensStore","getWordAtText","ILanguageConfigurationService","ILanguageService","IUndoRedoService","EDITOR_MODEL_DEFAULTS","createTextBufferBuilder","createTextBufferFactory","text","builder","acceptChunk","finish","createTextBuffer","value","defaultEOL","factory","create","MODEL_ID","LIMIT_FIND_COUNT","LONG_LINE_BOUNDARY","TextModelSnapshot","constructor","source","_source","_eos","read","result","resultCnt","resultLength","tmp","join","invalidFunc","Error","TextModel","languageId","creationOptions","associatedResource","_undoRedoService","_languageService","_languageConfigurationService","_onWillDispose","_register","onWillDispose","event","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeLanguage","onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","_onDidChangeContentOrInjectedText","onDidChangeContentOrInjectedText","_eventEmitter","DidChangeContentEmitter","_backgroundTokenizationState","_onBackgroundTokenizationStateChanged","onBackgroundTokenizationStateChanged","fastEvent","e","fire","rawContentChangedEvent","id","isForSimpleWidget","_associatedResource","parse","_attachedEditorCount","textBuffer","disposable","_buffer","_bufferDisposable","_options","resolveOptions","bufferLineCount","getLineCount","bufferTextLength","getValueLengthInRange","getLineLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForSyncing","MODEL_SYNC_LIMIT","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_isDisposed","_isDisposing","_languageId","_languageRegistryListener","onDidChange","affects","_instanceId","singleLetterHash","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","_tokens","languageIdCodec","_semanticTokens","_tokenization","_bracketPairColorizer","_guidesTextModelPart","_decorationProvider","beginDeferredEmit","endDeferredEmit","options","detectIndentation","guessedIndentation","tabSize","insertSpaces","TextModelResolvedOptions","indentSize","trimAutoWhitespace","bracketPairColorizationOptions","onDidChangeContentFast","listener","contentChangedEvent","onDidChangeContent","slowEvent","bracketPairs","guides","backgroundTokenizationState","handleTokenizationProgress","completed","newState","dispose","emptyDisposedTextBuffer","_assertNotDisposed","_emitContentChangedEvent","rawChange","change","handleContentChanged","setValue","_setValueFromTextBuffer","_createContentChanged2","range","rangeOffset","rangeLength","isUndoing","isRedoing","isFlush","changes","eol","getEOL","versionId","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","endLineNumber","endColumn","getLineMaxColumn","_increaseVersionId","flush","clear","getValue","setEOL","newEOL","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","collectNodesPostOrder","len","node","delta","cachedAbsoluteStart","start","startOffset","getOffsetAt","startLineNumber","startColumn","endOffset","cachedAbsoluteEnd","cachedVersionId","end","onBeforeAttached","undefined","onBeforeDetached","isAttachedToEditor","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForTokenization","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineCount","lineNumber","lineLength","uri","getOptions","getFormattingOptions","updateOptions","_newOpts","bracketColorizationOptions","newOpts","equals","createChangeEvent","defaultInsertSpaces","defaultTabSize","_normalizeIndentationFromWhitespace","str","spacesCnt","charAt","tabsCnt","Math","floor","normalizeIndentation","firstNonWhitespaceIndex","substring","mightContainRTL","mightContainUnusualLineTerminators","removeUnusualLineTerminators","selections","matches","findMatches","UNUSUAL_LINE_TERMINATORS","resetMightContainUnusualLineTerminators","pushEditOperations","map","m","mightContainNonBasicASCII","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","position","_validatePosition","column","getPositionAt","rawOffset","offset","min","getLength","max","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","preserveBOM","fullModelRange","fullModelValue","getValueInRange","getBOM","createSnapshot","getValueLength","rawRange","validateRange","getCharacterCountInRange","getLineContent","getLinesContent","getEndOfLineSequence","getLineMinColumn","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","_validateRangeRelaxedNoAllocations","linesCount","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","getLineCharCode","isHighSurrogate","_lineNumber","_column","validatePosition","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","modifyPosition","candidate","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","searchString","rawSearchScope","isRegex","matchCase","wordSeparators","searchRanges","Array","isArray","every","searchScope","isIRange","sort","d1","d2","uniqueSearchRanges","push","reduce","prev","curr","areIntersecting","plusRange","matchMapper","indexOf","searchParams","parseSearchRequest","arr","concat","findNextMatch","rawSearchStart","searchStart","ret","findPreviousMatch","pushStackElement","popStackElement","pushEOL","currentEOL","_validateEditOperation","rawOperation","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","_validateEditOperations","rawOperations","beforeCursorState","editOperations","cursorStateComputer","_pushEditOperations","incomingEdits","op","editsAreNearCursors","sel","foundEditNearSel","j","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","isEmpty","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","rangeEnd","newEnd","oldText","_applyUndoRedoEdits","_applyRedo","oldPosition","oldEnd","newText","applyEdits","computeUndoEdits","operations","_doApplyEdits","oldLineCount","newLineCount","contentChanges","trimAutoWhitespaceLineNumbers","eolCount","firstLineLength","lastLineLength","acceptEdit","charCodeAt","acceptReplace","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","fromDecorations","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","cnt","fromLineNumber","injectedTexts","newLines","takeWhile","reverseEdits","undo","canUndo","redo","canRedo","size","affectedLines","lineChangeEvents","_getInjectedTextInLine","changeDecorations","callback","ownerId","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","delete","reset","setOptions","insert","removeAllDecorationsWithOwnerId","nodes","collectNodesFromOwner","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","decorations","_getDecorationsInRange","getDecorationsInRange","validatedRange","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","filter","t","getAllDecorations","filterRange","filterOwnerId","getAllInInterval","getRangeAt","after","oldRange","recordLineAffectedByInjectedText","before","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","color","nodeIsInOverviewRuler","nodeRange","oldDecorationsIds","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","setTokens","tokens","backgroundTokenizationCompleted","ranges","element","minChangedLineNumber","maxChangedLineNumber","hasChange","getLineTokens","lineHasChange","toLineNumber","_emitModelTokensChangedEvent","tokenizationSupportChanged","semanticTokensApplied","setSemanticTokens","isComplete","set","hasCompleteSemanticTokens","hasSomeSemanticTokens","setPartialSemanticTokens","changedRange","setPartial","tokenizeViewport","clearTokens","resetTokenization","forceTokenization","isCheapToTokenize","tokenizeIfCheap","_getLineTokens","lineText","syntacticTokens","getTokens","addSparseTokens","getLanguageId","setMode","oldLanguage","newLanguage","getLanguageIdAtPosition","lineTokens","findTokenIndexAtOffset","getTokenTypeIfInsertingCharacter","character","tokenizeLineWithEdit","validatedPosition","getLanguageConfiguration","getWordAtPosition","_position","lineContent","tokenIndex","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getWordDefinition","lbStartOffset","lbEndOffset","leftBiasedWord","getStartOffset","tokenCount","getCount","getEndOffset","getWordUntilPosition","wordAtPosition","word","substr","normalizePosition","affinity","getLineIndentColumn","indentOfLine","DEFAULT_CREATION_OPTIONS","line","indent","isNodeInOverviewRuler","isNodeInjectedText","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","intervalSearch","r1","r2","showIfCollapsed","search","overviewRulerOnly","_search","_resolveNode","resolveNode","textLength","cleanClassName","className","replace","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","OverviewRulerLane","Center","getColor","theme","type","_resolveColor","invalidateCachedColor","toString","ModelDecorationMinimapOptions","fromHex","ModelDecorationInjectedTextOptions","content","inlineClassName","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","from","ModelDecorationOptions","_a","_b","description","stickiness","zIndex","hoverMessage","glyphMarginHoverMessage","isWholeLine","collapseOnReplaceEdit","minimap","glyphMarginClassName","linesDecorationsClassName","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","register","createDynamic","EMPTY","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFire","_affectsMinimap","_affectsOverviewRuler","affectsMinimap","affectsOverviewRuler","Set","add","_fastEmitter","_slowEmitter","_deferredEvent","merge"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { ILanguageService } from '../services/language.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nfunction createTextBufferBuilder() {\n    return new PieceTreeTextBufferBuilder();\n}\nexport function createTextBufferFactory(text) {\n    const builder = createTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    const factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    constructor(source, languageId, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeContentOrInjectedText = this._register(new Emitter());\n        this.onDidChangeContentOrInjectedText = this._onDidChangeContentOrInjectedText.event;\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._backgroundTokenizationState = 0 /* Uninitialized */;\n        this._onBackgroundTokenizationStateChanged = this._register(new Emitter());\n        this.onBackgroundTokenizationStateChanged = this._onBackgroundTokenizationStateChanged.event;\n        this._register(this._eventEmitter.fastEvent((e) => {\n            this._onDidChangeContentOrInjectedText.fire(e.rawContentChangedEvent);\n        }));\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this._isDisposing = false;\n        this._languageId = languageId;\n        this._languageRegistryListener = this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        });\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._tokens = new ContiguousTokensStore(this._languageService.languageIdCodec);\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._tokenization = new TextModelTokenization(this, this._languageService.languageIdCodec);\n        this._bracketPairColorizer = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n    }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: guessedIndentation.tabSize,\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions({\n            tabSize: options.tabSize,\n            indentSize: options.indentSize,\n            insertSpaces: options.insertSpaces,\n            trimAutoWhitespace: options.trimAutoWhitespace,\n            defaultEOL: options.defaultEOL,\n            bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n        });\n    }\n    onDidChangeContentFast(listener) {\n        return this._eventEmitter.fastEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    get bracketPairs() { return this._bracketPairColorizer; }\n    get guides() { return this._guidesTextModelPart; }\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    handleTokenizationProgress(completed) {\n        if (this._backgroundTokenizationState === 2 /* Completed */) {\n            // We already did a full tokenization and don't go back to progressing.\n            return;\n        }\n        const newState = completed ? 2 /* Completed */ : 1 /* InProgress */;\n        if (this._backgroundTokenizationState !== newState) {\n            this._backgroundTokenizationState = newState;\n            this._onBackgroundTokenizationStateChanged.fire();\n        }\n    }\n    dispose() {\n        this._isDisposing = true;\n        this._onWillDispose.fire();\n        this._languageRegistryListener.dispose();\n        this._tokenization.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this._isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        this._bracketPairColorizer.handleContentChanged(change);\n        if (this._isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null) {\n            // There's nothing to do\n            return;\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Flush all tokens\n        this._tokens.flush();\n        this._semanticTokens.flush();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    onBeforeDetached() {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    static _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n        let spacesCnt = 0;\n        for (let i = 0; i < str.length; i++) {\n            if (str.charAt(i) === '\\t') {\n                spacesCnt += indentSize;\n            }\n            else {\n                spacesCnt++;\n            }\n        }\n        let result = '';\n        if (!insertSpaces) {\n            const tabsCnt = Math.floor(spacesCnt / indentSize);\n            spacesCnt = spacesCnt % indentSize;\n            for (let i = 0; i < tabsCnt; i++) {\n                result += '\\t';\n            }\n        }\n        for (let i = 0; i < spacesCnt; i++) {\n            result += ' ';\n        }\n        return result;\n    }\n    static normalizeIndentation(str, indentSize, insertSpaces) {\n        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n        if (firstNonWhitespaceIndex === -1) {\n            firstNonWhitespaceIndex = str.length;\n        }\n        return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* LF */\n            : 1 /* CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* LF */ : 1 /* CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update tokens and decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n                this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\n                this._semanticTokens.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0 /* Null */);\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = [...affectedInjectedTextLines];\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeContentOrInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation);\n        decorations.push(...this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n        decorations.push(...this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n            // Delete + Insert due to an overview ruler status change\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        const result = new Array(newDecorationsLen);\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n            let node = null;\n            if (oldDecorationIndex < oldDecorationsLen) {\n                // (1) get ourselves an old node\n                do {\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\n                // (2) remove the node from the tree (if it exists)\n                if (node) {\n                    if (node.options.after) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                    }\n                    this._decorationsTree.delete(node);\n                    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                }\n            }\n            if (newDecorationIndex < newDecorationsLen) {\n                // (3) create a new node if necessary\n                if (!node) {\n                    const internalDecorationId = (++this._lastDecorationId);\n                    const decorationId = `${this._instanceId};${internalDecorationId}`;\n                    node = new IntervalNode(decorationId, 0, 0);\n                    this._decorations[decorationId] = node;\n                }\n                // (4) initialize node\n                const newDecoration = newDecorations[newDecorationIndex];\n                const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                const options = _normalizeOptions(newDecoration.options);\n                const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                node.ownerId = ownerId;\n                node.reset(versionId, startOffset, endOffset, range);\n                node.setOptions(options);\n                if (node.options.after) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                }\n                if (node.options.before) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                }\n                this._onDidChangeDecorations.checkAffectedAndFire(options);\n                this._decorationsTree.insert(node);\n                result[newDecorationIndex] = node.id;\n                newDecorationIndex++;\n            }\n            else {\n                if (node) {\n                    delete this._decorations[node.id];\n                }\n            }\n        }\n        return result;\n    }\n    setTokens(tokens, backgroundTokenizationCompleted = false) {\n        if (tokens.length !== 0) {\n            const ranges = [];\n            for (let i = 0, len = tokens.length; i < len; i++) {\n                const element = tokens[i];\n                let minChangedLineNumber = 0;\n                let maxChangedLineNumber = 0;\n                let hasChange = false;\n                for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                    if (hasChange) {\n                        this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                        maxChangedLineNumber = lineNumber;\n                    }\n                    else {\n                        const lineHasChange = this._tokens.setTokens(this._languageId, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                        if (lineHasChange) {\n                            hasChange = true;\n                            minChangedLineNumber = lineNumber;\n                            maxChangedLineNumber = lineNumber;\n                        }\n                    }\n                }\n                if (hasChange) {\n                    ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber });\n                }\n            }\n            if (ranges.length > 0) {\n                this._emitModelTokensChangedEvent({\n                    tokenizationSupportChanged: false,\n                    semanticTokensApplied: false,\n                    ranges: ranges\n                });\n            }\n        }\n        this.handleTokenizationProgress(backgroundTokenizationCompleted);\n    }\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: true,\n            ranges: [{ fromLineNumber: changedRange.startLineNumber, toLineNumber: changedRange.endLineNumber }]\n        });\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        startLineNumber = Math.max(1, startLineNumber);\n        endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\n        this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n    }\n    clearTokens() {\n        this._tokens.flush();\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: true,\n            semanticTokensApplied: false,\n            ranges: [{\n                    fromLineNumber: 1,\n                    toLineNumber: this._buffer.getLineCount()\n                }]\n        });\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._isDisposing) {\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    resetTokenization() {\n        this._tokenization.reset();\n    }\n    forceTokenization(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        this._tokenization.forceTokenization(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        return this._tokenization.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n    getLineTokens(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._getLineTokens(lineNumber);\n    }\n    _getLineTokens(lineNumber) {\n        const lineText = this.getLineContent(lineNumber);\n        const syntacticTokens = this._tokens.getTokens(this._languageId, lineNumber - 1, lineText);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    getLanguageId() {\n        return this._languageId;\n    }\n    setMode(languageId) {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId\n        };\n        this._languageId = languageId;\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        const position = this.validatePosition(new Position(lineNumber, column));\n        return this._tokenization.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        const validatedPosition = this.validatePosition(position);\n        return this._tokenization.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    // Having tokens allows implementing additional helper methods\n    getWordAtPosition(_position) {\n        this._assertNotDisposed();\n        const position = this.validatePosition(_position);\n        const lineContent = this.getLineContent(position.lineNumber);\n        const lineTokens = this._getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return {\n                word: '',\n                startColumn: position.column,\n                endColumn: position.column\n            };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column\n        };\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n};\nTextModel = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService)\n], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n}\nexport class ModelDecorationOptions {\n    constructor(options) {\n        var _a, _b;\n        this.description = options.description;\n        this.stickiness = options.stickiness || 0 /* AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = (_a = options.hideInCommentTokens) !== null && _a !== void 0 ? _a : false;\n        this.hideInStringTokens = (_b = options.hideInStringTokens) !== null && _b !== void 0 ? _b : false;\n    }\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nexport class DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        var _a;\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFire) {\n                this.handleBeforeFire(this._affectedInjectedTextLines);\n                const event = {\n                    affectsMinimap: this._affectsMinimap,\n                    affectsOverviewRuler: this._affectsOverviewRuler\n                };\n                this._shouldFire = false;\n                this._affectsMinimap = false;\n                this._affectsOverviewRuler = false;\n                this._actual.fire(event);\n            }\n            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        if (!this._affectsMinimap) {\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n        }\n        if (!this._affectsOverviewRuler) {\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n        }\n        this._shouldFire = true;\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._shouldFire = true;\n    }\n}\n//#endregion\nexport class DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}