{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { quickSelect } from '../../../../base/common/arrays.js';\nimport { anyScore, fuzzyScore, FuzzyScore, fuzzyScoreGracefulAggressive } from '../../../../base/common/filters.js';\nimport { compareIgnoreCase } from '../../../../base/common/strings.js';\nexport class LineContext {\n  constructor(leadingLineContent, characterCountDelta) {\n    this.leadingLineContent = leadingLineContent;\n    this.characterCountDelta = characterCountDelta;\n  }\n\n}\n/**\n * Sorted, filtered completion view model\n * */\n\nexport class CompletionModel {\n  constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, clipboardText) {\n    this.clipboardText = clipboardText;\n    this._snippetCompareFn = CompletionModel._compareCompletionItems;\n    this._items = items;\n    this._column = column;\n    this._wordDistance = wordDistance;\n    this._options = options;\n    this._refilterKind = 1\n    /* All */\n    ;\n    this._lineContext = lineContext;\n\n    if (snippetSuggestions === 'top') {\n      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n    } else if (snippetSuggestions === 'bottom') {\n      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n    }\n  }\n\n  get lineContext() {\n    return this._lineContext;\n  }\n\n  set lineContext(value) {\n    if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {\n      this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2\n      /* Incr */\n      : 1\n      /* All */\n      ;\n      this._lineContext = value;\n    }\n  }\n\n  get items() {\n    this._ensureCachedState();\n\n    return this._filteredItems;\n  }\n\n  get allProvider() {\n    this._ensureCachedState();\n\n    return this._providerInfo.keys();\n  }\n\n  get incomplete() {\n    this._ensureCachedState();\n\n    const result = new Set();\n\n    for (let [provider, incomplete] of this._providerInfo) {\n      if (incomplete) {\n        result.add(provider);\n      }\n    }\n\n    return result;\n  }\n\n  adopt(except) {\n    let res = [];\n\n    for (let i = 0; i < this._items.length;) {\n      if (!except.has(this._items[i].provider)) {\n        res.push(this._items[i]); // unordered removed\n\n        this._items[i] = this._items[this._items.length - 1];\n\n        this._items.pop();\n      } else {\n        // continue with next item\n        i++;\n      }\n    }\n\n    this._refilterKind = 1\n    /* All */\n    ;\n    return res;\n  }\n\n  get stats() {\n    this._ensureCachedState();\n\n    return this._stats;\n  }\n\n  _ensureCachedState() {\n    if (this._refilterKind !== 0\n    /* Nothing */\n    ) {\n      this._createCachedState();\n    }\n  }\n\n  _createCachedState() {\n    this._providerInfo = new Map();\n    const labelLengths = [];\n    const {\n      leadingLineContent,\n      characterCountDelta\n    } = this._lineContext;\n    let word = '';\n    let wordLow = ''; // incrementally filter less\n\n    const source = this._refilterKind === 1\n    /* All */\n    ? this._items : this._filteredItems;\n    const target = []; // picks a score function based on the number of\n    // items that we have to score/filter and based on the\n    // user-configuration\n\n    const scoreFn = !this._options.filterGraceful || source.length > 2000 ? fuzzyScore : fuzzyScoreGracefulAggressive;\n\n    for (let i = 0; i < source.length; i++) {\n      const item = source[i];\n\n      if (item.isInvalid) {\n        continue; // SKIP invalid items\n      } // collect all support, know if their result is incomplete\n\n\n      this._providerInfo.set(item.provider, Boolean(item.container.incomplete)); // 'word' is that remainder of the current line that we\n      // filter and score against. In theory each suggestion uses a\n      // different word, but in practice not - that's why we cache\n\n\n      const overwriteBefore = item.position.column - item.editStart.column;\n      const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n\n      if (word.length !== wordLen) {\n        word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n        wordLow = word.toLowerCase();\n      } // remember the word against which this item was\n      // scored\n\n\n      item.word = word;\n\n      if (wordLen === 0) {\n        // when there is nothing to score against, don't\n        // event try to do. Use a const rank and rely on\n        // the fallback-sort using the initial sort order.\n        // use a score of `-100` because that is out of the\n        // bound of values `fuzzyScore` will return\n        item.score = FuzzyScore.Default;\n      } else {\n        // skip word characters that are whitespace until\n        // we have hit the replace range (overwriteBefore)\n        let wordPos = 0;\n\n        while (wordPos < overwriteBefore) {\n          const ch = word.charCodeAt(wordPos);\n\n          if (ch === 32\n          /* Space */\n          || ch === 9\n          /* Tab */\n          ) {\n            wordPos += 1;\n          } else {\n            break;\n          }\n        }\n\n        if (wordPos >= wordLen) {\n          // the wordPos at which scoring starts is the whole word\n          // and therefore the same rules as not having a word apply\n          item.score = FuzzyScore.Default;\n        } else if (typeof item.completion.filterText === 'string') {\n          // when there is a `filterText` it must match the `word`.\n          // if it matches we check with the label to compute highlights\n          // and if that doesn't yield a result we have no highlights,\n          // despite having the match\n          let match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);\n\n          if (!match) {\n            continue; // NO match\n          }\n\n          if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {\n            // filterText and label are actually the same -> use good highlights\n            item.score = match;\n          } else {\n            // re-run the scorer on the label in the hope of a result BUT use the rank\n            // of the filterText-match\n            item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);\n            item.score[0] = match[0]; // use score from filterText\n          }\n        } else {\n          // by default match `word` against the `label`\n          let match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, false);\n\n          if (!match) {\n            continue; // NO match\n          }\n\n          item.score = match;\n        }\n      }\n\n      item.idx = i;\n      item.distance = this._wordDistance.distance(item.position, item.completion);\n      target.push(item); // update stats\n\n      labelLengths.push(item.textLabel.length);\n    }\n\n    this._filteredItems = target.sort(this._snippetCompareFn);\n    this._refilterKind = 0\n    /* Nothing */\n    ;\n    this._stats = {\n      pLabelLen: labelLengths.length ? quickSelect(labelLengths.length - .85, labelLengths, (a, b) => a - b) : 0\n    };\n  }\n\n  static _compareCompletionItems(a, b) {\n    if (a.score[0] > b.score[0]) {\n      return -1;\n    } else if (a.score[0] < b.score[0]) {\n      return 1;\n    } else if (a.distance < b.distance) {\n      return -1;\n    } else if (a.distance > b.distance) {\n      return 1;\n    } else if (a.idx < b.idx) {\n      return -1;\n    } else if (a.idx > b.idx) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  static _compareCompletionItemsSnippetsDown(a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n      if (a.completion.kind === 27\n      /* Snippet */\n      ) {\n        return 1;\n      } else if (b.completion.kind === 27\n      /* Snippet */\n      ) {\n        return -1;\n      }\n    }\n\n    return CompletionModel._compareCompletionItems(a, b);\n  }\n\n  static _compareCompletionItemsSnippetsUp(a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n      if (a.completion.kind === 27\n      /* Snippet */\n      ) {\n        return -1;\n      } else if (b.completion.kind === 27\n      /* Snippet */\n      ) {\n        return 1;\n      }\n    }\n\n    return CompletionModel._compareCompletionItems(a, b);\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/completionModel.js"],"names":["quickSelect","anyScore","fuzzyScore","FuzzyScore","fuzzyScoreGracefulAggressive","compareIgnoreCase","LineContext","constructor","leadingLineContent","characterCountDelta","CompletionModel","items","column","lineContext","wordDistance","options","snippetSuggestions","clipboardText","_snippetCompareFn","_compareCompletionItems","_items","_column","_wordDistance","_options","_refilterKind","_lineContext","_compareCompletionItemsSnippetsUp","_compareCompletionItemsSnippetsDown","value","_filteredItems","_ensureCachedState","allProvider","_providerInfo","keys","incomplete","result","Set","provider","add","adopt","except","res","i","length","has","push","pop","stats","_stats","_createCachedState","Map","labelLengths","word","wordLow","source","target","scoreFn","filterGraceful","item","isInvalid","set","Boolean","container","overwriteBefore","position","editStart","wordLen","slice","toLowerCase","score","Default","wordPos","ch","charCodeAt","completion","filterText","match","filterTextLow","textLabel","labelLow","idx","distance","sort","pLabelLen","a","b","kind"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { quickSelect } from '../../../../base/common/arrays.js';\nimport { anyScore, fuzzyScore, FuzzyScore, fuzzyScoreGracefulAggressive } from '../../../../base/common/filters.js';\nimport { compareIgnoreCase } from '../../../../base/common/strings.js';\nexport class LineContext {\n    constructor(leadingLineContent, characterCountDelta) {\n        this.leadingLineContent = leadingLineContent;\n        this.characterCountDelta = characterCountDelta;\n    }\n}\n/**\n * Sorted, filtered completion view model\n * */\nexport class CompletionModel {\n    constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, clipboardText) {\n        this.clipboardText = clipboardText;\n        this._snippetCompareFn = CompletionModel._compareCompletionItems;\n        this._items = items;\n        this._column = column;\n        this._wordDistance = wordDistance;\n        this._options = options;\n        this._refilterKind = 1 /* All */;\n        this._lineContext = lineContext;\n        if (snippetSuggestions === 'top') {\n            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n        }\n        else if (snippetSuggestions === 'bottom') {\n            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n        }\n    }\n    get lineContext() {\n        return this._lineContext;\n    }\n    set lineContext(value) {\n        if (this._lineContext.leadingLineContent !== value.leadingLineContent\n            || this._lineContext.characterCountDelta !== value.characterCountDelta) {\n            this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 /* Incr */ : 1 /* All */;\n            this._lineContext = value;\n        }\n    }\n    get items() {\n        this._ensureCachedState();\n        return this._filteredItems;\n    }\n    get allProvider() {\n        this._ensureCachedState();\n        return this._providerInfo.keys();\n    }\n    get incomplete() {\n        this._ensureCachedState();\n        const result = new Set();\n        for (let [provider, incomplete] of this._providerInfo) {\n            if (incomplete) {\n                result.add(provider);\n            }\n        }\n        return result;\n    }\n    adopt(except) {\n        let res = [];\n        for (let i = 0; i < this._items.length;) {\n            if (!except.has(this._items[i].provider)) {\n                res.push(this._items[i]);\n                // unordered removed\n                this._items[i] = this._items[this._items.length - 1];\n                this._items.pop();\n            }\n            else {\n                // continue with next item\n                i++;\n            }\n        }\n        this._refilterKind = 1 /* All */;\n        return res;\n    }\n    get stats() {\n        this._ensureCachedState();\n        return this._stats;\n    }\n    _ensureCachedState() {\n        if (this._refilterKind !== 0 /* Nothing */) {\n            this._createCachedState();\n        }\n    }\n    _createCachedState() {\n        this._providerInfo = new Map();\n        const labelLengths = [];\n        const { leadingLineContent, characterCountDelta } = this._lineContext;\n        let word = '';\n        let wordLow = '';\n        // incrementally filter less\n        const source = this._refilterKind === 1 /* All */ ? this._items : this._filteredItems;\n        const target = [];\n        // picks a score function based on the number of\n        // items that we have to score/filter and based on the\n        // user-configuration\n        const scoreFn = (!this._options.filterGraceful || source.length > 2000) ? fuzzyScore : fuzzyScoreGracefulAggressive;\n        for (let i = 0; i < source.length; i++) {\n            const item = source[i];\n            if (item.isInvalid) {\n                continue; // SKIP invalid items\n            }\n            // collect all support, know if their result is incomplete\n            this._providerInfo.set(item.provider, Boolean(item.container.incomplete));\n            // 'word' is that remainder of the current line that we\n            // filter and score against. In theory each suggestion uses a\n            // different word, but in practice not - that's why we cache\n            const overwriteBefore = item.position.column - item.editStart.column;\n            const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n            if (word.length !== wordLen) {\n                word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n                wordLow = word.toLowerCase();\n            }\n            // remember the word against which this item was\n            // scored\n            item.word = word;\n            if (wordLen === 0) {\n                // when there is nothing to score against, don't\n                // event try to do. Use a const rank and rely on\n                // the fallback-sort using the initial sort order.\n                // use a score of `-100` because that is out of the\n                // bound of values `fuzzyScore` will return\n                item.score = FuzzyScore.Default;\n            }\n            else {\n                // skip word characters that are whitespace until\n                // we have hit the replace range (overwriteBefore)\n                let wordPos = 0;\n                while (wordPos < overwriteBefore) {\n                    const ch = word.charCodeAt(wordPos);\n                    if (ch === 32 /* Space */ || ch === 9 /* Tab */) {\n                        wordPos += 1;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (wordPos >= wordLen) {\n                    // the wordPos at which scoring starts is the whole word\n                    // and therefore the same rules as not having a word apply\n                    item.score = FuzzyScore.Default;\n                }\n                else if (typeof item.completion.filterText === 'string') {\n                    // when there is a `filterText` it must match the `word`.\n                    // if it matches we check with the label to compute highlights\n                    // and if that doesn't yield a result we have no highlights,\n                    // despite having the match\n                    let match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);\n                    if (!match) {\n                        continue; // NO match\n                    }\n                    if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {\n                        // filterText and label are actually the same -> use good highlights\n                        item.score = match;\n                    }\n                    else {\n                        // re-run the scorer on the label in the hope of a result BUT use the rank\n                        // of the filterText-match\n                        item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);\n                        item.score[0] = match[0]; // use score from filterText\n                    }\n                }\n                else {\n                    // by default match `word` against the `label`\n                    let match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, false);\n                    if (!match) {\n                        continue; // NO match\n                    }\n                    item.score = match;\n                }\n            }\n            item.idx = i;\n            item.distance = this._wordDistance.distance(item.position, item.completion);\n            target.push(item);\n            // update stats\n            labelLengths.push(item.textLabel.length);\n        }\n        this._filteredItems = target.sort(this._snippetCompareFn);\n        this._refilterKind = 0 /* Nothing */;\n        this._stats = {\n            pLabelLen: labelLengths.length ?\n                quickSelect(labelLengths.length - .85, labelLengths, (a, b) => a - b)\n                : 0\n        };\n    }\n    static _compareCompletionItems(a, b) {\n        if (a.score[0] > b.score[0]) {\n            return -1;\n        }\n        else if (a.score[0] < b.score[0]) {\n            return 1;\n        }\n        else if (a.distance < b.distance) {\n            return -1;\n        }\n        else if (a.distance > b.distance) {\n            return 1;\n        }\n        else if (a.idx < b.idx) {\n            return -1;\n        }\n        else if (a.idx > b.idx) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    static _compareCompletionItemsSnippetsDown(a, b) {\n        if (a.completion.kind !== b.completion.kind) {\n            if (a.completion.kind === 27 /* Snippet */) {\n                return 1;\n            }\n            else if (b.completion.kind === 27 /* Snippet */) {\n                return -1;\n            }\n        }\n        return CompletionModel._compareCompletionItems(a, b);\n    }\n    static _compareCompletionItemsSnippetsUp(a, b) {\n        if (a.completion.kind !== b.completion.kind) {\n            if (a.completion.kind === 27 /* Snippet */) {\n                return -1;\n            }\n            else if (b.completion.kind === 27 /* Snippet */) {\n                return 1;\n            }\n        }\n        return CompletionModel._compareCompletionItems(a, b);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}