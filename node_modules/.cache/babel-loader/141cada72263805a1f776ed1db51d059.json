{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThanEqual, lengthOfString, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nexport class BracketPairsTree extends Disposable {\n  constructor(textModel, getLanguageConfiguration) {\n    super();\n    this.textModel = textModel;\n    this.getLanguageConfiguration = getLanguageConfiguration;\n    this.didChangeEmitter = new Emitter();\n    this.denseKeyProvider = new DenseKeyProvider();\n    this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n    this.onDidChange = this.didChangeEmitter.event;\n\n    this._register(textModel.onBackgroundTokenizationStateChanged(() => {\n      if (textModel.backgroundTokenizationState === 2\n      /* Completed */\n      ) {\n        const wasUndefined = this.initialAstWithoutTokens === undefined; // Clear the initial tree as we can use the tree with token information now.\n\n        this.initialAstWithoutTokens = undefined;\n\n        if (!wasUndefined) {\n          this.didChangeEmitter.fire();\n        }\n      }\n    }));\n\n    this._register(textModel.onDidChangeTokens(({\n      ranges\n    }) => {\n      const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n      this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n\n      if (!this.initialAstWithoutTokens) {\n        this.didChangeEmitter.fire();\n      }\n    }));\n\n    if (textModel.backgroundTokenizationState === 0\n    /* Uninitialized */\n    ) {\n      // There are no token information yet\n      const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n      const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n      this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n      this.astWithTokens = this.initialAstWithoutTokens;\n    } else if (textModel.backgroundTokenizationState === 2\n    /* Completed */\n    ) {\n      // Skip the initial ast, as there is no flickering.\n      // Directly create the tree with token information.\n      this.initialAstWithoutTokens = undefined;\n      this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n    } else if (textModel.backgroundTokenizationState === 1\n    /* InProgress */\n    ) {\n      this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n      this.astWithTokens = this.initialAstWithoutTokens;\n    }\n  }\n\n  didLanguageChange(languageId) {\n    return this.brackets.didLanguageChange(languageId);\n  }\n\n  handleContentChanged(change) {\n    const edits = change.changes.map(c => {\n      const range = Range.lift(c.range);\n      return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n    }).reverse();\n    this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n\n    if (this.initialAstWithoutTokens) {\n      this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(edits, this.initialAstWithoutTokens, false);\n    }\n  }\n  /**\n   * @pure (only if isPure = true)\n  */\n\n\n  parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n    // Is much faster if `isPure = false`.\n    const isPure = false;\n    const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n    const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n    const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n    return result;\n  }\n\n  getBracketsInRange(range) {\n    const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n    const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n    const result = new Array();\n    const node = this.initialAstWithoutTokens || this.astWithTokens;\n    collectBrackets(node, lengthZero, node.length, startOffset, endOffset, result);\n    return result;\n  }\n\n  getBracketPairsInRange(range, includeMinIndentation) {\n    const result = new Array();\n    const startLength = positionToLength(range.getStartPosition());\n    const endLength = positionToLength(range.getEndPosition());\n    const node = this.initialAstWithoutTokens || this.astWithTokens;\n    const context = new CollectBracketPairsContext(result, includeMinIndentation, this.textModel);\n    collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context);\n    return result;\n  }\n\n}\n\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level = 0) {\n  if (node.kind === 1\n  /* Bracket */\n  ) {\n    const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n    result.push(new BracketInfo(range, level - 1, false));\n  } else if (node.kind === 3\n  /* UnexpectedClosingBracket */\n  ) {\n    const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n    result.push(new BracketInfo(range, level - 1, true));\n  } else if (node.kind === 4\n  /* List */\n  ) {\n    for (const child of node.children) {\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n      }\n\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n  } else if (node.kind === 2\n  /* Pair */\n  ) {\n    // Don't use node.children here to improve performance\n    level++;\n    {\n      const child = node.openingBracket;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n      }\n\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n\n    if (node.child) {\n      const child = node.child;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n      }\n\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n\n    if (node.closingBracket) {\n      const child = node.closingBracket;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n      }\n\n      nodeOffsetStart = nodeOffsetEnd;\n    }\n  }\n}\n\nclass CollectBracketPairsContext {\n  constructor(result, includeMinIndentation, textModel) {\n    this.result = result;\n    this.includeMinIndentation = includeMinIndentation;\n    this.textModel = textModel;\n  }\n\n}\n\nfunction collectBracketPairs(node, nodeOffset, nodeOffsetEnd, startOffset, endOffset, context, level = 0) {\n  var _a;\n\n  if (node.kind === 2\n  /* Pair */\n  ) {\n    const openingBracketEnd = lengthAdd(nodeOffset, node.openingBracket.length);\n    let minIndentation = -1;\n\n    if (context.includeMinIndentation) {\n      minIndentation = node.computeMinIndentation(nodeOffset, context.textModel);\n    }\n\n    context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffset, nodeOffsetEnd), lengthsToRange(nodeOffset, openingBracketEnd), node.closingBracket ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd) : undefined, level, minIndentation));\n    level++;\n  }\n\n  let curOffset = nodeOffset;\n\n  for (const child of node.children) {\n    const childOffset = curOffset;\n    curOffset = lengthAdd(curOffset, child.length);\n\n    if (lengthLessThanEqual(childOffset, endOffset) && lengthLessThanEqual(startOffset, curOffset)) {\n      collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level);\n    }\n  }\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js"],"names":["Emitter","Disposable","Range","BracketInfo","BracketPairWithMinIndentationInfo","TextEditInfo","LanguageAgnosticBracketTokens","lengthAdd","lengthGreaterThanEqual","lengthLessThanEqual","lengthOfString","lengthsToRange","lengthZero","positionToLength","toLength","parseDocument","DenseKeyProvider","FastTokenizer","TextBufferTokenizer","BracketPairsTree","constructor","textModel","getLanguageConfiguration","didChangeEmitter","denseKeyProvider","brackets","onDidChange","event","_register","onBackgroundTokenizationStateChanged","backgroundTokenizationState","wasUndefined","initialAstWithoutTokens","undefined","fire","onDidChangeTokens","ranges","edits","map","r","fromLineNumber","toLineNumber","astWithTokens","parseDocumentFromTextBuffer","getSingleLanguageBracketTokens","getLanguageId","tokenizer","getValue","didLanguageChange","languageId","handleContentChanged","change","changes","c","range","lift","getStartPosition","getEndPosition","text","reverse","previousAst","immutable","isPure","previousAstClone","deepClone","result","getBracketsInRange","startOffset","startLineNumber","startColumn","endOffset","endLineNumber","endColumn","Array","node","collectBrackets","length","getBracketPairsInRange","includeMinIndentation","startLength","endLength","context","CollectBracketPairsContext","collectBracketPairs","nodeOffsetStart","nodeOffsetEnd","level","kind","push","child","children","openingBracket","closingBracket","nodeOffset","_a","openingBracketEnd","minIndentation","computeMinIndentation","curOffset","childOffset"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThanEqual, lengthOfString, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nexport class BracketPairsTree extends Disposable {\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this._register(textModel.onBackgroundTokenizationStateChanged(() => {\n            if (textModel.backgroundTokenizationState === 2 /* Completed */) {\n                const wasUndefined = this.initialAstWithoutTokens === undefined;\n                // Clear the initial tree as we can use the tree with token information now.\n                this.initialAstWithoutTokens = undefined;\n                if (!wasUndefined) {\n                    this.didChangeEmitter.fire();\n                }\n            }\n        }));\n        this._register(textModel.onDidChangeTokens(({ ranges }) => {\n            const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n            this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n            if (!this.initialAstWithoutTokens) {\n                this.didChangeEmitter.fire();\n            }\n        }));\n        if (textModel.backgroundTokenizationState === 0 /* Uninitialized */) {\n            // There are no token information yet\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.backgroundTokenizationState === 2 /* Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else if (textModel.backgroundTokenizationState === 1 /* InProgress */) {\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    handleContentChanged(change) {\n        const edits = change.changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n        if (this.initialAstWithoutTokens) {\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(edits, this.initialAstWithoutTokens, false);\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range) {\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        const result = new Array();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        collectBrackets(node, lengthZero, node.length, startOffset, endOffset, result);\n        return result;\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        const result = new Array();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        const context = new CollectBracketPairsContext(result, includeMinIndentation, this.textModel);\n        collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context);\n        return result;\n    }\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level = 0) {\n    if (node.kind === 1 /* Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level - 1, false));\n    }\n    else if (node.kind === 3 /* UnexpectedClosingBracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level - 1, true));\n    }\n    else if (node.kind === 4 /* List */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n    }\n    else if (node.kind === 2 /* Pair */) {\n        // Don't use node.children here to improve performance\n        level++;\n        {\n            const child = node.openingBracket;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        if (node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        if (node.closingBracket) {\n            const child = node.closingBracket;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(result, includeMinIndentation, textModel) {\n        this.result = result;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffset, nodeOffsetEnd, startOffset, endOffset, context, level = 0) {\n    var _a;\n    if (node.kind === 2 /* Pair */) {\n        const openingBracketEnd = lengthAdd(nodeOffset, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffset, context.textModel);\n        }\n        context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffset, nodeOffsetEnd), lengthsToRange(nodeOffset, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)\n            : undefined, level, minIndentation));\n        level++;\n    }\n    let curOffset = nodeOffset;\n    for (const child of node.children) {\n        const childOffset = curOffset;\n        curOffset = lengthAdd(curOffset, child.length);\n        if (lengthLessThanEqual(childOffset, endOffset) && lengthLessThanEqual(startOffset, curOffset)) {\n            collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}