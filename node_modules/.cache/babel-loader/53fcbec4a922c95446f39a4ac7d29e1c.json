{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\n\nexport class NodeReader {\n  constructor(node) {\n    this.lastOffset = lengthZero;\n    this.nextNodes = [node];\n    this.offsets = [lengthZero];\n    this.idxs = [];\n  }\n  /**\n   * Returns the longest node at `offset` that satisfies the predicate.\n   * @param offset must be greater than or equal to the last offset this method has been called with!\n  */\n\n\n  readLongestNodeAt(offset, predicate) {\n    if (lengthLessThan(offset, this.lastOffset)) {\n      throw new Error('Invalid offset');\n    }\n\n    this.lastOffset = offset; // Find the longest node of all those that are closest to the current offset.\n\n    while (true) {\n      const curNode = lastOrUndefined(this.nextNodes);\n\n      if (!curNode) {\n        return undefined;\n      }\n\n      const curNodeOffset = lastOrUndefined(this.offsets);\n\n      if (lengthLessThan(offset, curNodeOffset)) {\n        // The next best node is not here yet.\n        // The reader must advance before a cached node is hit.\n        return undefined;\n      }\n\n      if (lengthLessThan(curNodeOffset, offset)) {\n        // The reader is ahead of the current node.\n        if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n          // The reader is after the end of the current node.\n          this.nextNodeAfterCurrent();\n        } else {\n          // The reader is somewhere in the current node.\n          const nextChildIdx = getNextChildIdx(curNode);\n\n          if (nextChildIdx !== -1) {\n            // Go to the first child and repeat.\n            this.nextNodes.push(curNode.getChild(nextChildIdx));\n            this.offsets.push(curNodeOffset);\n            this.idxs.push(nextChildIdx);\n          } else {\n            // We don't have children\n            this.nextNodeAfterCurrent();\n          }\n        }\n      } else {\n        // readerOffsetBeforeChange === curNodeOffset\n        if (predicate(curNode)) {\n          this.nextNodeAfterCurrent();\n          return curNode;\n        } else {\n          const nextChildIdx = getNextChildIdx(curNode); // look for shorter node\n\n          if (nextChildIdx === -1) {\n            // There is no shorter node.\n            this.nextNodeAfterCurrent();\n            return undefined;\n          } else {\n            // Descend into first child & repeat.\n            this.nextNodes.push(curNode.getChild(nextChildIdx));\n            this.offsets.push(curNodeOffset);\n            this.idxs.push(nextChildIdx);\n          }\n        }\n      }\n    }\n  } // Navigates to the longest node that continues after the current node.\n\n\n  nextNodeAfterCurrent() {\n    while (true) {\n      const currentOffset = lastOrUndefined(this.offsets);\n      const currentNode = lastOrUndefined(this.nextNodes);\n      this.nextNodes.pop();\n      this.offsets.pop();\n\n      if (this.idxs.length === 0) {\n        // We just popped the root node, there is no next node.\n        break;\n      } // Parent is not undefined, because idxs is not empty\n\n\n      const parent = lastOrUndefined(this.nextNodes);\n      const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n\n      if (nextChildIdx !== -1) {\n        this.nextNodes.push(parent.getChild(nextChildIdx));\n        this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n        this.idxs[this.idxs.length - 1] = nextChildIdx;\n        break;\n      } else {\n        this.idxs.pop();\n      } // We fully consumed the parent.\n      // Current node is now parent, so call nextNodeAfterCurrent again\n\n    }\n  }\n\n}\n\nfunction getNextChildIdx(node, curIdx = -1) {\n  while (true) {\n    curIdx++;\n\n    if (curIdx >= node.childrenLength) {\n      return -1;\n    }\n\n    if (node.getChild(curIdx)) {\n      return curIdx;\n    }\n  }\n}\n\nfunction lastOrUndefined(arr) {\n  return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js"],"names":["lengthAdd","lengthZero","lengthLessThan","NodeReader","constructor","node","lastOffset","nextNodes","offsets","idxs","readLongestNodeAt","offset","predicate","Error","curNode","lastOrUndefined","undefined","curNodeOffset","length","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","push","getChild","currentOffset","currentNode","pop","parent","curIdx","childrenLength","arr"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n"]},"metadata":{},"sourceType":"module"}