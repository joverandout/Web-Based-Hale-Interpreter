{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\n\nlet _utf16LE_TextDecoder;\n\nfunction getUTF16LE_TextDecoder() {\n  if (!_utf16LE_TextDecoder) {\n    _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n  }\n\n  return _utf16LE_TextDecoder;\n}\n\nlet _utf16BE_TextDecoder;\n\nfunction getUTF16BE_TextDecoder() {\n  if (!_utf16BE_TextDecoder) {\n    _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n  }\n\n  return _utf16BE_TextDecoder;\n}\n\nlet _platformTextDecoder;\n\nexport function getPlatformTextDecoder() {\n  if (!_platformTextDecoder) {\n    _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n  }\n\n  return _platformTextDecoder;\n}\nexport const hasTextDecoder = typeof TextDecoder !== 'undefined';\nexport let createStringBuilder;\nexport let decodeUTF16LE;\n\nif (hasTextDecoder) {\n  createStringBuilder = capacity => new StringBuilder(capacity);\n\n  decodeUTF16LE = standardDecodeUTF16LE;\n} else {\n  createStringBuilder = capacity => new CompatStringBuilder();\n\n  decodeUTF16LE = compatDecodeUTF16LE;\n}\n\nfunction standardDecodeUTF16LE(source, offset, len) {\n  const view = new Uint16Array(source.buffer, offset, len);\n\n  if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n    // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n    // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n    // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n    // So we use the manual decoder\n    return compatDecodeUTF16LE(source, offset, len);\n  }\n\n  return getUTF16LE_TextDecoder().decode(view);\n}\n\nfunction compatDecodeUTF16LE(source, offset, len) {\n  const result = [];\n  let resultLen = 0;\n\n  for (let i = 0; i < len; i++) {\n    const charCode = buffer.readUInt16LE(source, offset);\n    offset += 2;\n    result[resultLen++] = String.fromCharCode(charCode);\n  }\n\n  return result.join('');\n}\n\nclass StringBuilder {\n  constructor(capacity) {\n    this._capacity = capacity | 0;\n    this._buffer = new Uint16Array(this._capacity);\n    this._completedStrings = null;\n    this._bufferLength = 0;\n  }\n\n  reset() {\n    this._completedStrings = null;\n    this._bufferLength = 0;\n  }\n\n  build() {\n    if (this._completedStrings !== null) {\n      this._flushBuffer();\n\n      return this._completedStrings.join('');\n    }\n\n    return this._buildBuffer();\n  }\n\n  _buildBuffer() {\n    if (this._bufferLength === 0) {\n      return '';\n    }\n\n    const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n    return getPlatformTextDecoder().decode(view);\n  }\n\n  _flushBuffer() {\n    const bufferString = this._buildBuffer();\n\n    this._bufferLength = 0;\n\n    if (this._completedStrings === null) {\n      this._completedStrings = [bufferString];\n    } else {\n      this._completedStrings[this._completedStrings.length] = bufferString;\n    }\n  }\n\n  write1(charCode) {\n    const remainingSpace = this._capacity - this._bufferLength;\n\n    if (remainingSpace <= 1) {\n      if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n        this._flushBuffer();\n      }\n    }\n\n    this._buffer[this._bufferLength++] = charCode;\n  }\n\n  appendASCII(charCode) {\n    if (this._bufferLength === this._capacity) {\n      // buffer is full\n      this._flushBuffer();\n    }\n\n    this._buffer[this._bufferLength++] = charCode;\n  }\n\n  appendASCIIString(str) {\n    const strLen = str.length;\n\n    if (this._bufferLength + strLen >= this._capacity) {\n      // This string does not fit in the remaining buffer space\n      this._flushBuffer();\n\n      this._completedStrings[this._completedStrings.length] = str;\n      return;\n    }\n\n    for (let i = 0; i < strLen; i++) {\n      this._buffer[this._bufferLength++] = str.charCodeAt(i);\n    }\n  }\n\n}\n\nclass CompatStringBuilder {\n  constructor() {\n    this._pieces = [];\n    this._piecesLen = 0;\n  }\n\n  reset() {\n    this._pieces = [];\n    this._piecesLen = 0;\n  }\n\n  build() {\n    return this._pieces.join('');\n  }\n\n  write1(charCode) {\n    this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n  }\n\n  appendASCII(charCode) {\n    this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n  }\n\n  appendASCIIString(str) {\n    this._pieces[this._piecesLen++] = str;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js"],"names":["strings","platform","buffer","_utf16LE_TextDecoder","getUTF16LE_TextDecoder","TextDecoder","_utf16BE_TextDecoder","getUTF16BE_TextDecoder","_platformTextDecoder","getPlatformTextDecoder","isLittleEndian","hasTextDecoder","createStringBuilder","decodeUTF16LE","capacity","StringBuilder","standardDecodeUTF16LE","CompatStringBuilder","compatDecodeUTF16LE","source","offset","len","view","Uint16Array","decode","result","resultLen","i","charCode","readUInt16LE","String","fromCharCode","join","constructor","_capacity","_buffer","_completedStrings","_bufferLength","reset","build","_flushBuffer","_buildBuffer","bufferString","length","write1","remainingSpace","isHighSurrogate","appendASCII","appendASCIIString","str","strLen","charCodeAt","_pieces","_piecesLen"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport const hasTextDecoder = (typeof TextDecoder !== 'undefined');\nexport let createStringBuilder;\nexport let decodeUTF16LE;\nif (hasTextDecoder) {\n    createStringBuilder = (capacity) => new StringBuilder(capacity);\n    decodeUTF16LE = standardDecodeUTF16LE;\n}\nelse {\n    createStringBuilder = (capacity) => new CompatStringBuilder();\n    decodeUTF16LE = compatDecodeUTF16LE;\n}\nfunction standardDecodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nclass StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    write1(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCII(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCIIString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\nclass CompatStringBuilder {\n    constructor() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    reset() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    build() {\n        return this._pieces.join('');\n    }\n    write1(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCII(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCIIString(str) {\n        this._pieces[this._piecesLen++] = str;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}