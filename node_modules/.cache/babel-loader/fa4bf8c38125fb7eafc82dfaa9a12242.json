{"ast":null,"code":"import { onUnexpectedError } from './errors.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\nexport var Event;\n\n(function (Event) {\n  Event.None = () => Disposable.None;\n  /**\n   * Given an event, returns another event which only fires once.\n   */\n\n\n  function once(event) {\n    return (listener, thisArgs = null, disposables) => {\n      // we need this, in case the event fires during the listener call\n      let didFire = false;\n      let result;\n      result = event(e => {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n\n      if (didFire) {\n        result.dispose();\n      }\n\n      return result;\n    };\n  }\n\n  Event.once = once;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function map(event, map) {\n    return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n  }\n\n  Event.map = map;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function forEach(event, each) {\n    return snapshot((listener, thisArgs = null, disposables) => event(i => {\n      each(i);\n      listener.call(thisArgs, i);\n    }, null, disposables));\n  }\n\n  Event.forEach = forEach;\n\n  function filter(event, filter) {\n    return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n  }\n\n  Event.filter = filter;\n  /**\n   * Given an event, returns the same event but typed as `Event<void>`.\n   */\n\n  function signal(event) {\n    return event;\n  }\n\n  Event.signal = signal;\n\n  function any(...events) {\n    return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n  }\n\n  Event.any = any;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function reduce(event, merge, initial) {\n    let output = initial;\n    return map(event, e => {\n      output = merge(output, e);\n      return output;\n    });\n  }\n\n  Event.reduce = reduce;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function snapshot(event) {\n    let listener;\n    const emitter = new Emitter({\n      onFirstListenerAdd() {\n        listener = event(emitter.fire, emitter);\n      },\n\n      onLastListenerRemove() {\n        listener.dispose();\n      }\n\n    });\n    return emitter.event;\n  }\n\n  function debouncedListener(event, listener, merge, delay = 100, leading = false) {\n    let output = undefined;\n    let handle = undefined;\n    let numDebouncedCalls = 0;\n    return event(cur => {\n      numDebouncedCalls++;\n      output = merge(output, cur);\n\n      if (leading && !handle) {\n        listener(output);\n        output = undefined;\n      }\n\n      clearTimeout(handle);\n      handle = setTimeout(() => {\n        const _output = output;\n        output = undefined;\n        handle = undefined;\n\n        if (!leading || numDebouncedCalls > 1) {\n          listener(_output);\n        }\n\n        numDebouncedCalls = 0;\n      }, delay);\n    });\n  }\n\n  Event.debouncedListener = debouncedListener;\n  /**\n   * @deprecated this leaks memory, {@link debouncedListener} or {@link DebounceEmitter} instead\n   */\n\n  function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {\n    let subscription;\n    let output = undefined;\n    let handle = undefined;\n    let numDebouncedCalls = 0;\n    const emitter = new Emitter({\n      leakWarningThreshold,\n\n      onFirstListenerAdd() {\n        subscription = event(cur => {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n\n          clearTimeout(handle);\n          handle = setTimeout(() => {\n            const _output = output;\n            output = undefined;\n            handle = undefined;\n\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n\n            numDebouncedCalls = 0;\n          }, delay);\n        });\n      },\n\n      onLastListenerRemove() {\n        subscription.dispose();\n      }\n\n    });\n    return emitter.event;\n  }\n\n  Event.debounce = debounce;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function latch(event, equals = (a, b) => a === b) {\n    let firstCall = true;\n    let cache;\n    return filter(event, value => {\n      const shouldEmit = firstCall || !equals(value, cache);\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    });\n  }\n\n  Event.latch = latch;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function split(event, isT) {\n    return [Event.filter(event, isT), Event.filter(event, e => !isT(e))];\n  }\n\n  Event.split = split;\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n  function buffer(event, flushAfterTimeout = false, _buffer = []) {\n    let buffer = _buffer.slice();\n\n    let listener = event(e => {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n\n    const flush = () => {\n      if (buffer) {\n        buffer.forEach(e => emitter.fire(e));\n      }\n\n      buffer = null;\n    };\n\n    const emitter = new Emitter({\n      onFirstListenerAdd() {\n        if (!listener) {\n          listener = event(e => emitter.fire(e));\n        }\n      },\n\n      onFirstListenerDidAdd() {\n        if (buffer) {\n          if (flushAfterTimeout) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n\n      onLastListenerRemove() {\n        if (listener) {\n          listener.dispose();\n        }\n\n        listener = null;\n      }\n\n    });\n    return emitter.event;\n  }\n\n  Event.buffer = buffer;\n\n  class ChainableEvent {\n    constructor(event) {\n      this.event = event;\n    }\n\n    map(fn) {\n      return new ChainableEvent(map(this.event, fn));\n    }\n\n    forEach(fn) {\n      return new ChainableEvent(forEach(this.event, fn));\n    }\n\n    filter(fn) {\n      return new ChainableEvent(filter(this.event, fn));\n    }\n\n    reduce(merge, initial) {\n      return new ChainableEvent(reduce(this.event, merge, initial));\n    }\n\n    latch() {\n      return new ChainableEvent(latch(this.event));\n    }\n\n    debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\n      return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n    }\n\n    on(listener, thisArgs, disposables) {\n      return this.event(listener, thisArgs, disposables);\n    }\n\n    once(listener, thisArgs, disposables) {\n      return once(this.event)(listener, thisArgs, disposables);\n    }\n\n  }\n  /**\n   * @deprecated DO NOT use, this leaks memory\n   */\n\n\n  function chain(event) {\n    return new ChainableEvent(event);\n  }\n\n  Event.chain = chain;\n\n  function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n    const fn = (...args) => result.fire(map(...args));\n\n    const onFirstListenerAdd = () => emitter.on(eventName, fn);\n\n    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\n    const result = new Emitter({\n      onFirstListenerAdd,\n      onLastListenerRemove\n    });\n    return result.event;\n  }\n\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n\n  function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n    const fn = (...args) => result.fire(map(...args));\n\n    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\n    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\n    const result = new Emitter({\n      onFirstListenerAdd,\n      onLastListenerRemove\n    });\n    return result.event;\n  }\n\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n\n  function toPromise(event) {\n    return new Promise(resolve => once(event)(resolve));\n  }\n\n  Event.toPromise = toPromise;\n\n  function runAndSubscribe(event, handler) {\n    handler(undefined);\n    return event(e => handler(e));\n  }\n\n  Event.runAndSubscribe = runAndSubscribe;\n\n  function runAndSubscribeWithStore(event, handler) {\n    let store = null;\n\n    function run(e) {\n      store === null || store === void 0 ? void 0 : store.dispose();\n      store = new DisposableStore();\n      handler(e, store);\n    }\n\n    run(undefined);\n    const disposable = event(e => run(e));\n    return toDisposable(() => {\n      disposable.dispose();\n      store === null || store === void 0 ? void 0 : store.dispose();\n    });\n  }\n\n  Event.runAndSubscribeWithStore = runAndSubscribeWithStore;\n})(Event || (Event = {}));\n\nclass EventProfiling {\n  constructor(name) {\n    this._listenerCount = 0;\n    this._invocationCount = 0;\n    this._elapsedOverall = 0;\n    this._name = `${name}_${EventProfiling._idPool++}`;\n  }\n\n  start(listenerCount) {\n    this._stopWatch = new StopWatch(true);\n    this._listenerCount = listenerCount;\n  }\n\n  stop() {\n    if (this._stopWatch) {\n      const elapsed = this._stopWatch.elapsed();\n\n      this._elapsedOverall += elapsed;\n      this._invocationCount += 1;\n      console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n      this._stopWatch = undefined;\n    }\n  }\n\n}\n\nEventProfiling._idPool = 0;\n\nlet _globalLeakWarningThreshold = -1;\n\nclass LeakageMonitor {\n  constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\n    this.customThreshold = customThreshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n\n  dispose() {\n    if (this._stacks) {\n      this._stacks.clear();\n    }\n  }\n\n  check(listenerCount) {\n    let threshold = _globalLeakWarningThreshold;\n\n    if (typeof this.customThreshold === 'number') {\n      threshold = this.customThreshold;\n    }\n\n    if (threshold <= 0 || listenerCount < threshold) {\n      return undefined;\n    }\n\n    if (!this._stacks) {\n      this._stacks = new Map();\n    }\n\n    const stack = new Error().stack.split('\\n').slice(3).join('\\n');\n    const count = this._stacks.get(stack) || 0;\n\n    this._stacks.set(stack, count + 1);\n\n    this._warnCountdown -= 1;\n\n    if (this._warnCountdown <= 0) {\n      // only warn on first exceed and then every time the limit\n      // is exceeded by 50% again\n      this._warnCountdown = threshold * 0.5; // find most frequent listener and print warning\n\n      let topStack;\n      let topCount = 0;\n\n      for (const [stack, count] of this._stacks) {\n        if (!topStack || topCount < count) {\n          topStack = stack;\n          topCount = count;\n        }\n      }\n\n      console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n      console.warn(topStack);\n    }\n\n    return () => {\n      const count = this._stacks.get(stack) || 0;\n\n      this._stacks.set(stack, count - 1);\n    };\n  }\n\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\n\n\nexport class Emitter {\n  constructor(options) {\n    var _a;\n\n    this._disposed = false;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n    this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n  }\n  /**\n   * For the public to allow to subscribe\n   * to events from this Emitter\n   */\n\n\n  get event() {\n    if (!this._event) {\n      this._event = (listener, thisArgs, disposables) => {\n        var _a;\n\n        if (!this._listeners) {\n          this._listeners = new LinkedList();\n        }\n\n        const firstListener = this._listeners.isEmpty();\n\n        if (firstListener && this._options && this._options.onFirstListenerAdd) {\n          this._options.onFirstListenerAdd(this);\n        }\n\n        const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n        if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n          this._options.onFirstListenerDidAdd(this);\n        }\n\n        if (this._options && this._options.onListenerDidAdd) {\n          this._options.onListenerDidAdd(this, listener, thisArgs);\n        } // check and record this emitter for potential leakage\n\n\n        const removeMonitor = (_a = this._leakageMon) === null || _a === void 0 ? void 0 : _a.check(this._listeners.size);\n        const result = toDisposable(() => {\n          if (removeMonitor) {\n            removeMonitor();\n          }\n\n          if (!this._disposed) {\n            remove();\n\n            if (this._options && this._options.onLastListenerRemove) {\n              const hasListeners = this._listeners && !this._listeners.isEmpty();\n\n              if (!hasListeners) {\n                this._options.onLastListenerRemove(this);\n              }\n            }\n          }\n        });\n\n        if (disposables instanceof DisposableStore) {\n          disposables.add(result);\n        } else if (Array.isArray(disposables)) {\n          disposables.push(result);\n        }\n\n        return result;\n      };\n    }\n\n    return this._event;\n  }\n  /**\n   * To be kept private to fire an event to\n   * subscribers\n   */\n\n\n  fire(event) {\n    var _a, _b;\n\n    if (this._listeners) {\n      // put all [listener,event]-pairs into delivery queue\n      // then emit all event. an inner/nested event might be\n      // the driver of this\n      if (!this._deliveryQueue) {\n        this._deliveryQueue = new LinkedList();\n      }\n\n      for (let listener of this._listeners) {\n        this._deliveryQueue.push([listener, event]);\n      } // start/stop performance insight collection\n\n\n      (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n\n      while (this._deliveryQueue.size > 0) {\n        const [listener, event] = this._deliveryQueue.shift();\n\n        try {\n          if (typeof listener === 'function') {\n            listener.call(undefined, event);\n          } else {\n            listener[0].call(listener[1], event);\n          }\n        } catch (e) {\n          onUnexpectedError(e);\n        }\n      }\n\n      (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n    }\n  }\n\n  dispose() {\n    var _a, _b, _c, _d, _e;\n\n    if (!this._disposed) {\n      this._disposed = true;\n      (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.clear();\n      (_b = this._deliveryQueue) === null || _b === void 0 ? void 0 : _b.clear();\n      (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onLastListenerRemove) === null || _d === void 0 ? void 0 : _d.call(_c);\n      (_e = this._leakageMon) === null || _e === void 0 ? void 0 : _e.dispose();\n    }\n  }\n\n}\nexport class PauseableEmitter extends Emitter {\n  constructor(options) {\n    super(options);\n    this._isPaused = 0;\n    this._eventQueue = new LinkedList();\n    this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n  }\n\n  pause() {\n    this._isPaused++;\n  }\n\n  resume() {\n    if (this._isPaused !== 0 && --this._isPaused === 0) {\n      if (this._mergeFn) {\n        // use the merge function to create a single composite\n        // event. make a copy in case firing pauses this emitter\n        const events = Array.from(this._eventQueue);\n\n        this._eventQueue.clear();\n\n        super.fire(this._mergeFn(events));\n      } else {\n        // no merging, fire each event individually and test\n        // that this emitter isn't paused halfway through\n        while (!this._isPaused && this._eventQueue.size !== 0) {\n          super.fire(this._eventQueue.shift());\n        }\n      }\n    }\n  }\n\n  fire(event) {\n    if (this._listeners) {\n      if (this._isPaused !== 0) {\n        this._eventQueue.push(event);\n      } else {\n        super.fire(event);\n      }\n    }\n  }\n\n}\nexport class DebounceEmitter extends PauseableEmitter {\n  constructor(options) {\n    var _a;\n\n    super(options);\n    this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n  }\n\n  fire(event) {\n    if (!this._handle) {\n      this.pause();\n      this._handle = setTimeout(() => {\n        this._handle = undefined;\n        this.resume();\n      }, this._delay);\n    }\n\n    super.fire(event);\n  }\n\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\n\nexport class EventBufferer {\n  constructor() {\n    this.buffers = [];\n  }\n\n  wrapEvent(event) {\n    return (listener, thisArgs, disposables) => {\n      return event(i => {\n        const buffer = this.buffers[this.buffers.length - 1];\n\n        if (buffer) {\n          buffer.push(() => listener.call(thisArgs, i));\n        } else {\n          listener.call(thisArgs, i);\n        }\n      }, undefined, disposables);\n    };\n  }\n\n  bufferEvents(fn) {\n    const buffer = [];\n    this.buffers.push(buffer);\n    const r = fn();\n    this.buffers.pop();\n    buffer.forEach(flush => flush());\n    return r;\n  }\n\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\n\nexport class Relay {\n  constructor() {\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onFirstListenerDidAdd: () => {\n        this.listening = true;\n        this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n      },\n      onLastListenerRemove: () => {\n        this.listening = false;\n        this.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n\n  set input(event) {\n    this.inputEvent = event;\n\n    if (this.listening) {\n      this.inputEventListener.dispose();\n      this.inputEventListener = event(this.emitter.fire, this.emitter);\n    }\n  }\n\n  dispose() {\n    this.inputEventListener.dispose();\n    this.emitter.dispose();\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/event.js"],"names":["onUnexpectedError","combinedDisposable","Disposable","DisposableStore","toDisposable","LinkedList","StopWatch","Event","None","once","event","listener","thisArgs","disposables","didFire","result","e","dispose","call","map","snapshot","i","forEach","each","filter","signal","any","events","reduce","merge","initial","output","emitter","Emitter","onFirstListenerAdd","fire","onLastListenerRemove","debouncedListener","delay","leading","undefined","handle","numDebouncedCalls","cur","clearTimeout","setTimeout","_output","debounce","leakWarningThreshold","subscription","latch","equals","a","b","firstCall","cache","value","shouldEmit","split","isT","buffer","flushAfterTimeout","_buffer","slice","push","flush","onFirstListenerDidAdd","ChainableEvent","constructor","fn","on","chain","fromNodeEventEmitter","eventName","id","args","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","toPromise","Promise","resolve","runAndSubscribe","handler","runAndSubscribeWithStore","store","run","disposable","EventProfiling","name","_listenerCount","_invocationCount","_elapsedOverall","_name","_idPool","start","listenerCount","_stopWatch","stop","elapsed","console","info","toFixed","_globalLeakWarningThreshold","LeakageMonitor","customThreshold","Math","random","toString","_warnCountdown","_stacks","clear","check","threshold","Map","stack","Error","join","count","get","set","topStack","topCount","warn","options","_a","_disposed","_options","_leakageMon","_perfMon","_profName","_event","_listeners","firstListener","isEmpty","remove","onListenerDidAdd","removeMonitor","size","hasListeners","add","Array","isArray","_b","_deliveryQueue","shift","_c","_d","_e","PauseableEmitter","_isPaused","_eventQueue","_mergeFn","pause","resume","from","DebounceEmitter","_delay","_handle","EventBufferer","buffers","wrapEvent","length","bufferEvents","r","pop","Relay","listening","inputEvent","inputEventListener","input"],"mappings":"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","sourcesContent":["import { onUnexpectedError } from './errors.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    /**\n     * Given an event, returns another event which only fires once.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function map(event, map) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables));\n    }\n    Event.map = map;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function forEach(event, each) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\n    }\n    Event.forEach = forEach;\n    function filter(event, filter) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    }\n    Event.any = any;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function reduce(event, merge, initial) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        });\n    }\n    Event.reduce = reduce;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function snapshot(event) {\n        let listener;\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                listener = event(emitter.fire, emitter);\n            },\n            onLastListenerRemove() {\n                listener.dispose();\n            }\n        });\n        return emitter.event;\n    }\n    function debouncedListener(event, listener, merge, delay = 100, leading = false) {\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        return event(cur => {\n            numDebouncedCalls++;\n            output = merge(output, cur);\n            if (leading && !handle) {\n                listener(output);\n                output = undefined;\n            }\n            clearTimeout(handle);\n            handle = setTimeout(() => {\n                const _output = output;\n                output = undefined;\n                handle = undefined;\n                if (!leading || numDebouncedCalls > 1) {\n                    listener(_output);\n                }\n                numDebouncedCalls = 0;\n            }, delay);\n        });\n    }\n    Event.debouncedListener = debouncedListener;\n    /**\n     * @deprecated this leaks memory, {@link debouncedListener} or {@link DebounceEmitter} instead\n     */\n    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        const emitter = new Emitter({\n            leakWarningThreshold,\n            onFirstListenerAdd() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    clearTimeout(handle);\n                    handle = setTimeout(() => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    }, delay);\n                });\n            },\n            onLastListenerRemove() {\n                subscription.dispose();\n            }\n        });\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function latch(event, equals = (a, b) => a === b) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        });\n    }\n    Event.latch = latch;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function split(event, isT) {\n        return [\n            Event.filter(event, isT),\n            Event.filter(event, e => !isT(e)),\n        ];\n    }\n    Event.split = split;\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = []) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        const flush = () => {\n            if (buffer) {\n                buffer.forEach(e => emitter.fire(e));\n            }\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                }\n            },\n            onFirstListenerDidAdd() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onLastListenerRemove() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    class ChainableEvent {\n        constructor(event) {\n            this.event = event;\n        }\n        map(fn) {\n            return new ChainableEvent(map(this.event, fn));\n        }\n        forEach(fn) {\n            return new ChainableEvent(forEach(this.event, fn));\n        }\n        filter(fn) {\n            return new ChainableEvent(filter(this.event, fn));\n        }\n        reduce(merge, initial) {\n            return new ChainableEvent(reduce(this.event, merge, initial));\n        }\n        latch() {\n            return new ChainableEvent(latch(this.event));\n        }\n        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n        }\n        on(listener, thisArgs, disposables) {\n            return this.event(listener, thisArgs, disposables);\n        }\n        once(listener, thisArgs, disposables) {\n            return once(this.event)(listener, thisArgs, disposables);\n        }\n    }\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function chain(event) {\n        return new ChainableEvent(event);\n    }\n    Event.chain = chain;\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    function runAndSubscribe(event, handler) {\n        handler(undefined);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    function runAndSubscribeWithStore(event, handler) {\n        let store = null;\n        function run(e) {\n            store === null || store === void 0 ? void 0 : store.dispose();\n            store = new DisposableStore();\n            handler(e, store);\n        }\n        run(undefined);\n        const disposable = event(e => run(e));\n        return toDisposable(() => {\n            disposable.dispose();\n            store === null || store === void 0 ? void 0 : store.dispose();\n        });\n    }\n    Event.runAndSubscribeWithStore = runAndSubscribeWithStore;\n})(Event || (Event = {}));\nclass EventProfiling {\n    constructor(name) {\n        this._listenerCount = 0;\n        this._invocationCount = 0;\n        this._elapsedOverall = 0;\n        this._name = `${name}_${EventProfiling._idPool++}`;\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch(true);\n        this._listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this._elapsedOverall += elapsed;\n            this._invocationCount += 1;\n            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.customThreshold = customThreshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        if (this._stacks) {\n            this._stacks.clear();\n        }\n    }\n    check(listenerCount) {\n        let threshold = _globalLeakWarningThreshold;\n        if (typeof this.customThreshold === 'number') {\n            threshold = this.customThreshold;\n        }\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const stack = new Error().stack.split('\\n').slice(3).join('\\n');\n        const count = (this._stacks.get(stack) || 0);\n        this._stacks.set(stack, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack) || 0);\n            this._stacks.set(stack, count - 1);\n        };\n    }\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        var _a;\n        this._disposed = false;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n        this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                var _a;\n                if (!this._listeners) {\n                    this._listeners = new LinkedList();\n                }\n                const firstListener = this._listeners.isEmpty();\n                if (firstListener && this._options && this._options.onFirstListenerAdd) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n                if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n                    this._options.onFirstListenerDidAdd(this);\n                }\n                if (this._options && this._options.onListenerDidAdd) {\n                    this._options.onListenerDidAdd(this, listener, thisArgs);\n                }\n                // check and record this emitter for potential leakage\n                const removeMonitor = (_a = this._leakageMon) === null || _a === void 0 ? void 0 : _a.check(this._listeners.size);\n                const result = toDisposable(() => {\n                    if (removeMonitor) {\n                        removeMonitor();\n                    }\n                    if (!this._disposed) {\n                        remove();\n                        if (this._options && this._options.onLastListenerRemove) {\n                            const hasListeners = (this._listeners && !this._listeners.isEmpty());\n                            if (!hasListeners) {\n                                this._options.onLastListenerRemove(this);\n                            }\n                        }\n                    }\n                });\n                if (disposables instanceof DisposableStore) {\n                    disposables.add(result);\n                }\n                else if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b;\n        if (this._listeners) {\n            // put all [listener,event]-pairs into delivery queue\n            // then emit all event. an inner/nested event might be\n            // the driver of this\n            if (!this._deliveryQueue) {\n                this._deliveryQueue = new LinkedList();\n            }\n            for (let listener of this._listeners) {\n                this._deliveryQueue.push([listener, event]);\n            }\n            // start/stop performance insight collection\n            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n            while (this._deliveryQueue.size > 0) {\n                const [listener, event] = this._deliveryQueue.shift();\n                try {\n                    if (typeof listener === 'function') {\n                        listener.call(undefined, event);\n                    }\n                    else {\n                        listener[0].call(listener[1], event);\n                    }\n                }\n                catch (e) {\n                    onUnexpectedError(e);\n                }\n            }\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n        }\n    }\n    dispose() {\n        var _a, _b, _c, _d, _e;\n        if (!this._disposed) {\n            this._disposed = true;\n            (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.clear();\n            (_b = this._deliveryQueue) === null || _b === void 0 ? void 0 : _b.clear();\n            (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onLastListenerRemove) === null || _d === void 0 ? void 0 : _d.call(_c);\n            (_e = this._leakageMon) === null || _e === void 0 ? void 0 : _e.dispose();\n        }\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                const events = Array.from(this._eventQueue);\n                this._eventQueue.clear();\n                super.fire(this._mergeFn(events));\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._listeners) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onFirstListenerDidAdd: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onLastListenerRemove: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}