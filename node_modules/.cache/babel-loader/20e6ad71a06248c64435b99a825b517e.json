{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IndentAction } from '../../../common/languages/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as indentUtils from '../../indentation/browser/indentUtils.js';\nexport class MoveLinesCommand {\n  constructor(selection, isMovingDown, autoIndent) {\n    this._selection = selection;\n    this._isMovingDown = isMovingDown;\n    this._autoIndent = autoIndent;\n    this._selectionId = null;\n    this._moveEndLineSelectionShrink = false;\n  }\n\n  getEditOperations(model, builder) {\n    let modelLineCount = model.getLineCount();\n\n    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n      this._selectionId = builder.trackSelection(this._selection);\n      return;\n    }\n\n    if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n      this._selectionId = builder.trackSelection(this._selection);\n      return;\n    }\n\n    this._moveEndPositionDown = false;\n    let s = this._selection;\n\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n\n    const {\n      tabSize,\n      indentSize,\n      insertSpaces\n    } = model.getOptions();\n    let indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n    let virtualModel = {\n      getLineTokens: lineNumber => {\n        return model.getLineTokens(lineNumber);\n      },\n      getLanguageId: () => {\n        return model.getLanguageId();\n      },\n      getLanguageIdAtPosition: (lineNumber, column) => {\n        return model.getLanguageIdAtPosition(lineNumber, column);\n      },\n      getLineContent: null\n    };\n\n    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n      // Current line is empty\n      let lineNumber = s.startLineNumber;\n      let otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;\n\n      if (model.getLineMaxColumn(otherLineNumber) === 1) {\n        // Other line number is empty too, so no editing is needed\n        // Add a no-op to force running by the model\n        builder.addEditOperation(new Range(1, 1, 1, 1), null);\n      } else {\n        // Type content from other line number on line number\n        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber)); // Remove content from other line number\n\n        builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n      } // Track selection at the other line number\n\n\n      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n    } else {\n      let movingLineNumber;\n      let movingLineText;\n\n      if (this._isMovingDown) {\n        movingLineNumber = s.endLineNumber + 1;\n        movingLineText = model.getLineContent(movingLineNumber); // Delete line that needs to be moved\n\n        builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n        let insertingText = movingLineText;\n\n        if (this.shouldAutoIndent(model, s)) {\n          let movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1); // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n\n          if (movingLineMatchResult !== null) {\n            let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n            let newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n            let newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n            insertingText = newIndentation + this.trimLeft(movingLineText);\n          } else {\n            // no enter rule matches, let's check indentatin rules then.\n            virtualModel.getLineContent = lineNumber => {\n              if (lineNumber === s.startLineNumber) {\n                return model.getLineContent(movingLineNumber);\n              } else {\n                return model.getLineContent(lineNumber);\n              }\n            };\n\n            let indentOfMovingLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter);\n\n            if (indentOfMovingLine !== null) {\n              let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n              let newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n              let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n\n              if (newSpaceCnt !== oldSpaceCnt) {\n                let newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                insertingText = newIndentation + this.trimLeft(movingLineText);\n              }\n            }\n          } // add edit operations for moving line first to make sure it's executed after we make indentation change\n          // to s.startLineNumber\n\n\n          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n          let ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText); // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n\n          if (ret !== null) {\n            if (ret !== 0) {\n              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n            }\n          } else {\n            // it doesn't match onEnter rules, let's check indentation rules then.\n            virtualModel.getLineContent = lineNumber => {\n              if (lineNumber === s.startLineNumber) {\n                return insertingText;\n              } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                return model.getLineContent(lineNumber - 1);\n              } else {\n                return model.getLineContent(lineNumber);\n              }\n            };\n\n            let newIndentatOfMovingBlock = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter);\n\n            if (newIndentatOfMovingBlock !== null) {\n              const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n              const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n              const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n\n              if (newSpaceCnt !== oldSpaceCnt) {\n                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n              }\n            }\n          }\n        } else {\n          // Insert line that needs to be moved before\n          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n        }\n      } else {\n        movingLineNumber = s.startLineNumber - 1;\n        movingLineText = model.getLineContent(movingLineNumber); // Delete line that needs to be moved\n\n        builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null); // Insert line that needs to be moved after\n\n        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n\n        if (this.shouldAutoIndent(model, s)) {\n          virtualModel.getLineContent = lineNumber => {\n            if (lineNumber === movingLineNumber) {\n              return model.getLineContent(s.startLineNumber);\n            } else {\n              return model.getLineContent(lineNumber);\n            }\n          };\n\n          let ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2); // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n\n          if (ret !== null) {\n            if (ret !== 0) {\n              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n            }\n          } else {\n            // it doesn't match any onEnter rule, let's check indentation rules then.\n            let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter);\n\n            if (indentOfFirstLine !== null) {\n              // adjust the indentation of the moving block\n              let oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n              let newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n              let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n\n              if (newSpaceCnt !== oldSpaceCnt) {\n                let spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this._selectionId = builder.trackSelection(s);\n  }\n\n  buildIndentConverter(tabSize, indentSize, insertSpaces) {\n    return {\n      shiftIndent: indentation => {\n        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      },\n      unshiftIndent: indentation => {\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      }\n    };\n  }\n\n  parseEnterResult(model, indentConverter, tabSize, line, enter) {\n    if (enter) {\n      let enterPrefix = enter.indentation;\n\n      if (enter.indentAction === IndentAction.None) {\n        enterPrefix = enter.indentation + enter.appendText;\n      } else if (enter.indentAction === IndentAction.Indent) {\n        enterPrefix = enter.indentation + enter.appendText;\n      } else if (enter.indentAction === IndentAction.IndentOutdent) {\n        enterPrefix = enter.indentation;\n      } else if (enter.indentAction === IndentAction.Outdent) {\n        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n      }\n\n      let movingLineText = model.getLineContent(line);\n\n      if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {\n        let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n        let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n        let indentMetadataOfMovelingLine = LanguageConfigurationRegistry.getIndentMetadata(model, line);\n\n        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2\n        /* DECREASE_MASK */\n        ) {\n          newIndentation = indentConverter.unshiftIndent(newIndentation);\n        }\n\n        let newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n        let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n        return newSpaceCnt - oldSpaceCnt;\n      }\n    }\n\n    return null;\n  }\n  /**\n   *\n   * @param model\n   * @param indentConverter\n   * @param tabSize\n   * @param line the line moving down\n   * @param futureAboveLineNumber the line which will be at the `line` position\n   * @param futureAboveLineText\n   */\n\n\n  matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n    if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n      // break\n      let maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n      let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn));\n      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    } else {\n      // go upwards, starting from `line - 1`\n      let validPrecedingLine = line - 1;\n\n      while (validPrecedingLine >= 1) {\n        let lineContent = model.getLineContent(validPrecedingLine);\n        let nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n\n        validPrecedingLine--;\n      }\n\n      if (validPrecedingLine < 1 || line > model.getLineCount()) {\n        return null;\n      }\n\n      let maxColumn = model.getLineMaxColumn(validPrecedingLine);\n      let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));\n      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n  }\n\n  matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n    let validPrecedingLine = oneLineAbove;\n\n    while (validPrecedingLine >= 1) {\n      // ship empty lines as empty lines just inherit indentation\n      let lineContent;\n\n      if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n        lineContent = previousLineText;\n      } else {\n        lineContent = model.getLineContent(validPrecedingLine);\n      }\n\n      let nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n\n      if (nonWhitespaceIdx >= 0) {\n        break;\n      }\n\n      validPrecedingLine--;\n    }\n\n    if (validPrecedingLine < 1 || line > model.getLineCount()) {\n      return null;\n    }\n\n    let maxColumn = model.getLineMaxColumn(validPrecedingLine);\n    let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));\n    return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n  }\n\n  trimLeft(str) {\n    return str.replace(/^\\s+/, '');\n  }\n\n  shouldAutoIndent(model, selection) {\n    if (this._autoIndent < 4\n    /* Full */\n    ) {\n      return false;\n    } // if it's not easy to tokenize, we stop auto indent.\n\n\n    if (!model.isCheapToTokenize(selection.startLineNumber)) {\n      return false;\n    }\n\n    let languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n    let languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n\n    if (languageAtSelectionStart !== languageAtSelectionEnd) {\n      return false;\n    }\n\n    if (LanguageConfigurationRegistry.getIndentRulesSupport(languageAtSelectionStart) === null) {\n      return false;\n    }\n\n    return true;\n  }\n\n  getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n      let lineContent = model.getLineContent(i);\n      let originalIndent = strings.getLeadingWhitespace(lineContent);\n      let originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n      let newSpacesCnt = originalSpacesCnt + offset;\n      let newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n\n      if (newIndent !== originalIndent) {\n        builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n\n        if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n          // as users select part of the original indent white spaces\n          // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n          this._moveEndLineSelectionShrink = true;\n        }\n      }\n    }\n  }\n\n  computeCursorState(model, helper) {\n    let result = helper.getTrackedSelection(this._selectionId);\n\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n\n    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n      result = result.setEndPosition(result.endLineNumber, 2);\n    }\n\n    return result;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/moveLinesCommand.js"],"names":["strings","ShiftCommand","Range","Selection","IndentAction","LanguageConfigurationRegistry","indentUtils","MoveLinesCommand","constructor","selection","isMovingDown","autoIndent","_selection","_isMovingDown","_autoIndent","_selectionId","_moveEndLineSelectionShrink","getEditOperations","model","builder","modelLineCount","getLineCount","endLineNumber","trackSelection","startLineNumber","_moveEndPositionDown","s","endColumn","setEndPosition","getLineMaxColumn","tabSize","indentSize","insertSpaces","getOptions","indentConverter","buildIndentConverter","virtualModel","getLineTokens","lineNumber","getLanguageId","getLanguageIdAtPosition","column","getLineContent","otherLineNumber","addEditOperation","movingLineNumber","movingLineText","insertingText","shouldAutoIndent","movingLineMatchResult","matchEnterRule","oldIndentation","getLeadingWhitespace","newSpaceCnt","getSpaceCnt","newIndentation","generateIndent","trimLeft","indentOfMovingLine","getGoodIndentForLine","oldSpaceCnt","ret","matchEnterRuleMovingDown","getIndentEditsOfMovingBlock","newIndentatOfMovingBlock","spaceCntOffset","indentOfFirstLine","oldIndent","shiftIndent","indentation","length","unshiftIndent","parseEnterResult","line","enter","enterPrefix","indentAction","None","appendText","Indent","IndentOutdent","Outdent","indexOf","indentMetadataOfMovelingLine","getIndentMetadata","futureAboveLineNumber","futureAboveLineText","lastNonWhitespaceIndex","maxColumn","getEnterAction","validPrecedingLine","lineContent","nonWhitespaceIdx","oneLineAbove","previousLineText","undefined","str","replace","isCheapToTokenize","languageAtSelectionStart","languageAtSelectionEnd","getIndentRulesSupport","offset","i","originalIndent","originalSpacesCnt","newSpacesCnt","newIndent","computeCursorState","helper","result","getTrackedSelection"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IndentAction } from '../../../common/languages/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as indentUtils from '../../indentation/browser/indentUtils.js';\nexport class MoveLinesCommand {\n    constructor(selection, isMovingDown, autoIndent) {\n        this._selection = selection;\n        this._isMovingDown = isMovingDown;\n        this._autoIndent = autoIndent;\n        this._selectionId = null;\n        this._moveEndLineSelectionShrink = false;\n    }\n    getEditOperations(model, builder) {\n        let modelLineCount = model.getLineCount();\n        if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        this._moveEndPositionDown = false;\n        let s = this._selection;\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const { tabSize, indentSize, insertSpaces } = model.getOptions();\n        let indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n        let virtualModel = {\n            getLineTokens: (lineNumber) => {\n                return model.getLineTokens(lineNumber);\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n            getLineContent: null,\n        };\n        if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n            // Current line is empty\n            let lineNumber = s.startLineNumber;\n            let otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);\n            if (model.getLineMaxColumn(otherLineNumber) === 1) {\n                // Other line number is empty too, so no editing is needed\n                // Add a no-op to force running by the model\n                builder.addEditOperation(new Range(1, 1, 1, 1), null);\n            }\n            else {\n                // Type content from other line number on line number\n                builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n                // Remove content from other line number\n                builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n            }\n            // Track selection at the other line number\n            s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n        }\n        else {\n            let movingLineNumber;\n            let movingLineText;\n            if (this._isMovingDown) {\n                movingLineNumber = s.endLineNumber + 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n                let insertingText = movingLineText;\n                if (this.shouldAutoIndent(model, s)) {\n                    let movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n                    // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n                    if (movingLineMatchResult !== null) {\n                        let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                        let newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                        let newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                        insertingText = newIndentation + this.trimLeft(movingLineText);\n                    }\n                    else {\n                        // no enter rule matches, let's check indentatin rules then.\n                        virtualModel.getLineContent = (lineNumber) => {\n                            if (lineNumber === s.startLineNumber) {\n                                return model.getLineContent(movingLineNumber);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        };\n                        let indentOfMovingLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter);\n                        if (indentOfMovingLine !== null) {\n                            let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                            let newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n                            let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                let newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                                insertingText = newIndentation + this.trimLeft(movingLineText);\n                            }\n                        }\n                    }\n                    // add edit operations for moving line first to make sure it's executed after we make indentation change\n                    // to s.startLineNumber\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                    let ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\n                    // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match onEnter rules, let's check indentation rules then.\n                        virtualModel.getLineContent = (lineNumber) => {\n                            if (lineNumber === s.startLineNumber) {\n                                return insertingText;\n                            }\n                            else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                                return model.getLineContent(lineNumber - 1);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        };\n                        let newIndentatOfMovingBlock = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter);\n                        if (newIndentatOfMovingBlock !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Insert line that needs to be moved before\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                }\n            }\n            else {\n                movingLineNumber = s.startLineNumber - 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n                // Insert line that needs to be moved after\n                builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n                if (this.shouldAutoIndent(model, s)) {\n                    virtualModel.getLineContent = (lineNumber) => {\n                        if (lineNumber === movingLineNumber) {\n                            return model.getLineContent(s.startLineNumber);\n                        }\n                        else {\n                            return model.getLineContent(lineNumber);\n                        }\n                    };\n                    let ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n                    // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match any onEnter rule, let's check indentation rules then.\n                        let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter);\n                        if (indentOfFirstLine !== null) {\n                            // adjust the indentation of the moving block\n                            let oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            let newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n                            let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                let spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    buildIndentConverter(tabSize, indentSize, insertSpaces) {\n        return {\n            shiftIndent: (indentation) => {\n                return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            },\n            unshiftIndent: (indentation) => {\n                return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            }\n        };\n    }\n    parseEnterResult(model, indentConverter, tabSize, line, enter) {\n        if (enter) {\n            let enterPrefix = enter.indentation;\n            if (enter.indentAction === IndentAction.None) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.Indent) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.IndentOutdent) {\n                enterPrefix = enter.indentation;\n            }\n            else if (enter.indentAction === IndentAction.Outdent) {\n                enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n            }\n            let movingLineText = model.getLineContent(line);\n            if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {\n                let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n                let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n                let indentMetadataOfMovelingLine = LanguageConfigurationRegistry.getIndentMetadata(model, line);\n                if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* DECREASE_MASK */) {\n                    newIndentation = indentConverter.unshiftIndent(newIndentation);\n                }\n                let newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n                let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                return newSpaceCnt - oldSpaceCnt;\n            }\n        }\n        return null;\n    }\n    /**\n     *\n     * @param model\n     * @param indentConverter\n     * @param tabSize\n     * @param line the line moving down\n     * @param futureAboveLineNumber the line which will be at the `line` position\n     * @param futureAboveLineText\n     */\n    matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n        if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n            // break\n            let maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n            let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn));\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n        else {\n            // go upwards, starting from `line - 1`\n            let validPrecedingLine = line - 1;\n            while (validPrecedingLine >= 1) {\n                let lineContent = model.getLineContent(validPrecedingLine);\n                let nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n                validPrecedingLine--;\n            }\n            if (validPrecedingLine < 1 || line > model.getLineCount()) {\n                return null;\n            }\n            let maxColumn = model.getLineMaxColumn(validPrecedingLine);\n            let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n    }\n    matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n        let validPrecedingLine = oneLineAbove;\n        while (validPrecedingLine >= 1) {\n            // ship empty lines as empty lines just inherit indentation\n            let lineContent;\n            if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n                lineContent = previousLineText;\n            }\n            else {\n                lineContent = model.getLineContent(validPrecedingLine);\n            }\n            let nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n            if (nonWhitespaceIdx >= 0) {\n                break;\n            }\n            validPrecedingLine--;\n        }\n        if (validPrecedingLine < 1 || line > model.getLineCount()) {\n            return null;\n        }\n        let maxColumn = model.getLineMaxColumn(validPrecedingLine);\n        let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));\n        return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n    trimLeft(str) {\n        return str.replace(/^\\s+/, '');\n    }\n    shouldAutoIndent(model, selection) {\n        if (this._autoIndent < 4 /* Full */) {\n            return false;\n        }\n        // if it's not easy to tokenize, we stop auto indent.\n        if (!model.isCheapToTokenize(selection.startLineNumber)) {\n            return false;\n        }\n        let languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n        let languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n        if (languageAtSelectionStart !== languageAtSelectionEnd) {\n            return false;\n        }\n        if (LanguageConfigurationRegistry.getIndentRulesSupport(languageAtSelectionStart) === null) {\n            return false;\n        }\n        return true;\n    }\n    getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n            let lineContent = model.getLineContent(i);\n            let originalIndent = strings.getLeadingWhitespace(lineContent);\n            let originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n            let newSpacesCnt = originalSpacesCnt + offset;\n            let newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n            if (newIndent !== originalIndent) {\n                builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n                if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n                    // as users select part of the original indent white spaces\n                    // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n                    this._moveEndLineSelectionShrink = true;\n                }\n            }\n        }\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n            result = result.setEndPosition(result.endLineNumber, 2);\n        }\n        return result;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}