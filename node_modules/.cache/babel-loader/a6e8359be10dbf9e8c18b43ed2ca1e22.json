{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { LanguageConfigurationRegistry } from '../languages/languageConfigurationRegistry.js';\nconst repeatCache = Object.create(null);\nexport function cachedStringRepeat(str, count) {\n  if (count <= 0) {\n    return '';\n  }\n\n  if (!repeatCache[str]) {\n    repeatCache[str] = ['', str];\n  }\n\n  const cache = repeatCache[str];\n\n  for (let i = cache.length; i <= count; i++) {\n    cache[i] = cache[i - 1] + str;\n  }\n\n  return cache[count];\n}\nexport class ShiftCommand {\n  constructor(range, opts) {\n    this._opts = opts;\n    this._selection = range;\n    this._selectionId = null;\n    this._useLastEditRangeForCursorEndPosition = false;\n    this._selectionStartColumnStaysPut = false;\n  }\n\n  static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n    // Determine the visible column where the content starts\n    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n    if (insertSpaces) {\n      const indent = cachedStringRepeat(' ', indentSize);\n      const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n      const indentCount = desiredTabStop / indentSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    } else {\n      const indent = '\\t';\n      const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n      const indentCount = desiredTabStop / tabSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    }\n  }\n\n  static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n    // Determine the visible column where the content starts\n    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n    if (insertSpaces) {\n      const indent = cachedStringRepeat(' ', indentSize);\n      const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n      const indentCount = desiredTabStop / indentSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    } else {\n      const indent = '\\t';\n      const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n      const indentCount = desiredTabStop / tabSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    }\n  }\n\n  _addEditOperation(builder, range, text) {\n    if (this._useLastEditRangeForCursorEndPosition) {\n      builder.addTrackedEditOperation(range, text);\n    } else {\n      builder.addEditOperation(range, text);\n    }\n  }\n\n  getEditOperations(model, builder) {\n    const startLine = this._selection.startLineNumber;\n    let endLine = this._selection.endLineNumber;\n\n    if (this._selection.endColumn === 1 && startLine !== endLine) {\n      endLine = endLine - 1;\n    }\n\n    const {\n      tabSize,\n      indentSize,\n      insertSpaces\n    } = this._opts;\n    const shouldIndentEmptyLines = startLine === endLine;\n\n    if (this._opts.useTabStops) {\n      // if indenting or outdenting on a whitespace only line\n      if (this._selection.isEmpty()) {\n        if (/^\\s*$/.test(model.getLineContent(startLine))) {\n          this._useLastEditRangeForCursorEndPosition = true;\n        }\n      } // keep track of previous line's \"miss-alignment\"\n\n\n      let previousLineExtraSpaces = 0,\n          extraSpaces = 0;\n\n      for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n        extraSpaces = 0;\n        const lineText = model.getLineContent(lineNumber);\n        let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n          // empty line or line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n          // do not indent empty lines => nothing to do\n          continue;\n        }\n\n        if (indentationEndIndex === -1) {\n          // the entire line is whitespace\n          indentationEndIndex = lineText.length;\n        }\n\n        if (lineNumber > 1) {\n          const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n\n          if (contentStartVisibleColumn % indentSize !== 0) {\n            // The current line is \"miss-aligned\", so let's see if this is expected...\n            // This can only happen when it has trailing commas in the indent\n            if (model.isCheapToTokenize(lineNumber - 1)) {\n              const enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));\n\n              if (enterAction) {\n                extraSpaces = previousLineExtraSpaces;\n\n                if (enterAction.appendText) {\n                  for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                    if (enterAction.appendText.charCodeAt(j) === 32\n                    /* Space */\n                    ) {\n                      extraSpaces++;\n                    } else {\n                      break;\n                    }\n                  }\n                }\n\n                if (enterAction.removeText) {\n                  extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                } // Act as if `prefixSpaces` is not part of the indentation\n\n\n                for (let j = 0; j < extraSpaces; j++) {\n                  if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32\n                  /* Space */\n                  ) {\n                    break;\n                  }\n\n                  indentationEndIndex--;\n                }\n              }\n            }\n          }\n        }\n\n        if (this._opts.isUnshift && indentationEndIndex === 0) {\n          // line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        let desiredIndent;\n\n        if (this._opts.isUnshift) {\n          desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n        } else {\n          desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n        }\n\n        this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n\n        if (lineNumber === startLine && !this._selection.isEmpty()) {\n          // Force the startColumn to stay put because we're inserting after it\n          this._selectionStartColumnStaysPut = this._selection.startColumn <= indentationEndIndex + 1;\n        }\n      }\n    } else {\n      // if indenting or outdenting on a whitespace only line\n      if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n        this._useLastEditRangeForCursorEndPosition = true;\n      }\n\n      const oneIndent = insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t';\n\n      for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n        const lineText = model.getLineContent(lineNumber);\n        let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n          // empty line or line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n          // do not indent empty lines => nothing to do\n          continue;\n        }\n\n        if (indentationEndIndex === -1) {\n          // the entire line is whitespace\n          indentationEndIndex = lineText.length;\n        }\n\n        if (this._opts.isUnshift && indentationEndIndex === 0) {\n          // line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        if (this._opts.isUnshift) {\n          indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n\n          for (let i = 0; i < indentationEndIndex; i++) {\n            const chr = lineText.charCodeAt(i);\n\n            if (chr === 9\n            /* Tab */\n            ) {\n              indentationEndIndex = i + 1;\n              break;\n            }\n          }\n\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n        } else {\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n\n          if (lineNumber === startLine && !this._selection.isEmpty()) {\n            // Force the startColumn to stay put because we're inserting after it\n            this._selectionStartColumnStaysPut = this._selection.startColumn === 1;\n          }\n        }\n      }\n    }\n\n    this._selectionId = builder.trackSelection(this._selection);\n  }\n\n  computeCursorState(model, helper) {\n    if (this._useLastEditRangeForCursorEndPosition) {\n      const lastOp = helper.getInverseEditOperations()[0];\n      return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n    }\n\n    const result = helper.getTrackedSelection(this._selectionId);\n\n    if (this._selectionStartColumnStaysPut) {\n      // The selection start should not move\n      const initialStartColumn = this._selection.startColumn;\n      const resultStartColumn = result.startColumn;\n\n      if (resultStartColumn <= initialStartColumn) {\n        return result;\n      }\n\n      if (result.getDirection() === 0\n      /* LTR */\n      ) {\n        return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n      }\n\n      return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n    }\n\n    return result;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js"],"names":["strings","CursorColumns","Range","Selection","LanguageConfigurationRegistry","repeatCache","Object","create","cachedStringRepeat","str","count","cache","i","length","ShiftCommand","constructor","range","opts","_opts","_selection","_selectionId","_useLastEditRangeForCursorEndPosition","_selectionStartColumnStaysPut","unshiftIndent","line","column","tabSize","indentSize","insertSpaces","contentStartVisibleColumn","visibleColumnFromColumn","indent","desiredTabStop","prevIndentTabStop","indentCount","prevRenderTabStop","shiftIndent","nextIndentTabStop","nextRenderTabStop","_addEditOperation","builder","text","addTrackedEditOperation","addEditOperation","getEditOperations","model","startLine","startLineNumber","endLine","endLineNumber","endColumn","shouldIndentEmptyLines","useTabStops","isEmpty","test","getLineContent","previousLineExtraSpaces","extraSpaces","lineNumber","lineText","indentationEndIndex","firstNonWhitespaceIndex","isUnshift","isCheapToTokenize","enterAction","getEnterAction","autoIndent","getLineMaxColumn","appendText","j","lenJ","charCodeAt","removeText","Math","max","desiredIndent","startColumn","getLineLength","oneIndent","min","chr","trackSelection","computeCursorState","helper","lastOp","getInverseEditOperations","result","getTrackedSelection","initialStartColumn","resultStartColumn","getDirection"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { LanguageConfigurationRegistry } from '../languages/languageConfigurationRegistry.js';\nconst repeatCache = Object.create(null);\nexport function cachedStringRepeat(str, count) {\n    if (count <= 0) {\n        return '';\n    }\n    if (!repeatCache[str]) {\n        repeatCache[str] = ['', str];\n    }\n    const cache = repeatCache[str];\n    for (let i = cache.length; i <= count; i++) {\n        cache[i] = cache[i - 1] + str;\n    }\n    return cache[count];\n}\nexport class ShiftCommand {\n    constructor(range, opts) {\n        this._opts = opts;\n        this._selection = range;\n        this._selectionId = null;\n        this._useLastEditRangeForCursorEndPosition = false;\n        this._selectionStartColumnStaysPut = false;\n    }\n    static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    _addEditOperation(builder, range, text) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            builder.addTrackedEditOperation(range, text);\n        }\n        else {\n            builder.addEditOperation(range, text);\n        }\n    }\n    getEditOperations(model, builder) {\n        const startLine = this._selection.startLineNumber;\n        let endLine = this._selection.endLineNumber;\n        if (this._selection.endColumn === 1 && startLine !== endLine) {\n            endLine = endLine - 1;\n        }\n        const { tabSize, indentSize, insertSpaces } = this._opts;\n        const shouldIndentEmptyLines = (startLine === endLine);\n        if (this._opts.useTabStops) {\n            // if indenting or outdenting on a whitespace only line\n            if (this._selection.isEmpty()) {\n                if (/^\\s*$/.test(model.getLineContent(startLine))) {\n                    this._useLastEditRangeForCursorEndPosition = true;\n                }\n            }\n            // keep track of previous line's \"miss-alignment\"\n            let previousLineExtraSpaces = 0, extraSpaces = 0;\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n                extraSpaces = 0;\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (lineNumber > 1) {\n                    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n                    if (contentStartVisibleColumn % indentSize !== 0) {\n                        // The current line is \"miss-aligned\", so let's see if this is expected...\n                        // This can only happen when it has trailing commas in the indent\n                        if (model.isCheapToTokenize(lineNumber - 1)) {\n                            const enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));\n                            if (enterAction) {\n                                extraSpaces = previousLineExtraSpaces;\n                                if (enterAction.appendText) {\n                                    for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                                        if (enterAction.appendText.charCodeAt(j) === 32 /* Space */) {\n                                            extraSpaces++;\n                                        }\n                                        else {\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (enterAction.removeText) {\n                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                                }\n                                // Act as if `prefixSpaces` is not part of the indentation\n                                for (let j = 0; j < extraSpaces; j++) {\n                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* Space */) {\n                                        break;\n                                    }\n                                    indentationEndIndex--;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                let desiredIndent;\n                if (this._opts.isUnshift) {\n                    desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                else {\n                    desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n                if (lineNumber === startLine && !this._selection.isEmpty()) {\n                    // Force the startColumn to stay put because we're inserting after it\n                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\n                }\n            }\n        }\n        else {\n            // if indenting or outdenting on a whitespace only line\n            if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n                this._useLastEditRangeForCursorEndPosition = true;\n            }\n            const oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (this._opts.isUnshift) {\n                    indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n                    for (let i = 0; i < indentationEndIndex; i++) {\n                        const chr = lineText.charCodeAt(i);\n                        if (chr === 9 /* Tab */) {\n                            indentationEndIndex = i + 1;\n                            break;\n                        }\n                    }\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n                }\n                else {\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n                    if (lineNumber === startLine && !this._selection.isEmpty()) {\n                        // Force the startColumn to stay put because we're inserting after it\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    }\n    computeCursorState(model, helper) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            const lastOp = helper.getInverseEditOperations()[0];\n            return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n        }\n        const result = helper.getTrackedSelection(this._selectionId);\n        if (this._selectionStartColumnStaysPut) {\n            // The selection start should not move\n            const initialStartColumn = this._selection.startColumn;\n            const resultStartColumn = result.startColumn;\n            if (resultStartColumn <= initialStartColumn) {\n                return result;\n            }\n            if (result.getDirection() === 0 /* LTR */) {\n                return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n            }\n            return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n        }\n        return result;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}