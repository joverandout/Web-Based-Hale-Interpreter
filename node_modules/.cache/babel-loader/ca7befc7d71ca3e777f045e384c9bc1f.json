{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\n/**\n * Represents a non-negative length in terms of line and column count.\n * Prefer using {@link Length} for performance reasons.\n*/\n\nexport class LengthObj {\n  constructor(lineCount, columnCount) {\n    this.lineCount = lineCount;\n    this.columnCount = columnCount;\n  }\n\n  toString() {\n    return `${this.lineCount},${this.columnCount}`;\n  }\n\n}\nLengthObj.zero = new LengthObj(0, 0);\n/**\n * The end must be greater than or equal to the start.\n*/\n\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n  return startLineCount !== endLineCount ? toLength(endLineCount - startLineCount, endColumnCount) : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n  return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n *\n * Set boolean to `true` when debugging, so that debugging is easier.\n */\n\nconst factor =\n/* is debug: */\nfalse ? 100000 : Math.pow(2, 26);\nexport function toLength(lineCount, columnCount) {\n  // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n  //       line count (26 bits)    column count (26 bits)\n  // If there is no overflow (all values/sums below 2^26 = 67108864),\n  // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n  return lineCount * factor + columnCount;\n}\nexport function lengthToObj(length) {\n  const l = length;\n  const lineCount = Math.floor(l / factor);\n  const columnCount = l - lineCount * factor;\n  return new LengthObj(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n  return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\n\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n  return length;\n}\nexport function lengthAdd(l1, l2) {\n  return l2 < factor ? l1 + l2 // l2 is the amount of columns (zero line count). Keep the column count from l1.\n  : l1 - l1 % factor + l2; // l1 - (l1 % factor) equals toLength(l1.lineCount, 0)\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\n\nexport function lengthDiffNonNegative(length1, length2) {\n  const l1 = length1;\n  const l2 = length2;\n  const diff = l2 - l1;\n\n  if (diff <= 0) {\n    // line-count of length1 is higher than line-count of length2\n    // or they are equal and column-count of length1 is higher than column-count of length2\n    return lengthZero;\n  }\n\n  const lineCount1 = Math.floor(l1 / factor);\n  const lineCount2 = Math.floor(l2 / factor);\n  const colCount2 = l2 - lineCount2 * factor;\n\n  if (lineCount1 === lineCount2) {\n    const colCount1 = l1 - lineCount1 * factor;\n    return toLength(0, colCount2 - colCount1);\n  } else {\n    return toLength(lineCount2 - lineCount1, colCount2);\n  }\n}\nexport function lengthLessThan(length1, length2) {\n  // First, compare line counts, then column counts.\n  return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n  return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n  return length1 >= length2;\n}\nexport function positionToLength(position) {\n  return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n  const l = lengthStart;\n  const lineCount = Math.floor(l / factor);\n  const colCount = l - lineCount * factor;\n  const l2 = lengthEnd;\n  const lineCount2 = Math.floor(l2 / factor);\n  const colCount2 = l2 - lineCount2 * factor;\n  return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n  const lines = splitLines(str);\n  return toLength(lines.length - 1, lines[lines.length - 1].length);\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js"],"names":["splitLines","Range","LengthObj","constructor","lineCount","columnCount","toString","zero","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","toLength","lengthZero","lengthIsZero","length","factor","Math","pow","lengthToObj","l","floor","lengthGetLineCount","lengthGetColumnCountIfZeroLineCount","lengthAdd","l1","l2","lengthDiffNonNegative","length1","length2","diff","lineCount1","lineCount2","colCount2","colCount1","lengthLessThan","lengthLessThanEqual","lengthGreaterThanEqual","positionToLength","position","lineNumber","column","lengthsToRange","lengthStart","lengthEnd","colCount","lengthOfString","str","lines"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\n/**\n * Represents a non-negative length in terms of line and column count.\n * Prefer using {@link Length} for performance reasons.\n*/\nexport class LengthObj {\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\nLengthObj.zero = new LengthObj(0, 0);\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n *\n * Set boolean to `true` when debugging, so that debugging is easier.\n */\nconst factor = /* is debug: */ false ? 100000 : Math.pow(2, 26);\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new LengthObj(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    return ((l2 < factor)\n        ? (l1 + l2) // l2 is the amount of columns (zero line count). Keep the column count from l1.\n        : (l1 - (l1 % factor) + l2)); // l1 - (l1 % factor) equals toLength(l1.lineCount, 0)\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n"]},"metadata":{},"sourceType":"module"}