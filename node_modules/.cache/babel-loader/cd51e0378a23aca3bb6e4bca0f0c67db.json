{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { DocumentSemanticTokensProviderRegistry, DocumentRangeSemanticTokensProviderRegistry } from '../languages.js';\nimport { IModelService } from './model.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from './semanticTokensDto.js';\nimport { Range } from '../core/range.js';\nexport function isSemanticTokens(v) {\n  return v && !!v.data;\n}\nexport function isSemanticTokensEdits(v) {\n  return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n  constructor(provider, tokens, error) {\n    this.provider = provider;\n    this.tokens = tokens;\n    this.error = error;\n  }\n\n}\nexport function hasDocumentSemanticTokensProvider(model) {\n  return DocumentSemanticTokensProviderRegistry.has(model);\n}\n\nfunction getDocumentSemanticTokensProviders(model) {\n  const groups = DocumentSemanticTokensProviderRegistry.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\n\nexport function getDocumentSemanticTokens(model, lastProvider, lastResultId, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getDocumentSemanticTokensProviders(model); // Get tokens from all providers at the same time.\n\n    const results = yield Promise.all(providers.map(provider => __awaiter(this, void 0, void 0, function* () {\n      let result;\n      let error = null;\n\n      try {\n        result = yield provider.provideDocumentSemanticTokens(model, provider === lastProvider ? lastResultId : null, token);\n      } catch (err) {\n        error = err;\n        result = null;\n      }\n\n      if (!result || !isSemanticTokens(result) && !isSemanticTokensEdits(result)) {\n        result = null;\n      }\n\n      return new DocumentSemanticTokensResult(provider, result, error);\n    }))); // Try to return the first result with actual tokens or\n    // the first result which threw an error (!!)\n\n    for (const result of results) {\n      if (result.error) {\n        throw result.error;\n      }\n\n      if (result.tokens) {\n        return result;\n      }\n    } // Return the first result, even if it doesn't have tokens\n\n\n    if (results.length > 0) {\n      return results[0];\n    }\n\n    return null;\n  });\n}\n\nfunction _getDocumentSemanticTokensProviderHighestGroup(model) {\n  const result = DocumentSemanticTokensProviderRegistry.orderedGroups(model);\n  return result.length > 0 ? result[0] : null;\n}\n\nclass DocumentRangeSemanticTokensResult {\n  constructor(provider, tokens) {\n    this.provider = provider;\n    this.tokens = tokens;\n  }\n\n}\n\nexport function hasDocumentRangeSemanticTokensProvider(model) {\n  return DocumentRangeSemanticTokensProviderRegistry.has(model);\n}\n\nfunction getDocumentRangeSemanticTokensProviders(model) {\n  const groups = DocumentRangeSemanticTokensProviderRegistry.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\n\nexport function getDocumentRangeSemanticTokens(model, range, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getDocumentRangeSemanticTokensProviders(model); // Get tokens from all providers at the same time.\n\n    const results = yield Promise.all(providers.map(provider => __awaiter(this, void 0, void 0, function* () {\n      let result;\n\n      try {\n        result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);\n      } catch (err) {\n        onUnexpectedExternalError(err);\n        result = null;\n      }\n\n      if (!result || !isSemanticTokens(result)) {\n        result = null;\n      }\n\n      return new DocumentRangeSemanticTokensResult(provider, result);\n    }))); // Try to return the first result with actual tokens\n\n    for (const result of results) {\n      if (result.tokens) {\n        return result;\n      }\n    } // Return the first result, even if it doesn't have tokens\n\n\n    if (results.length > 0) {\n      return results[0];\n    }\n\n    return null;\n  });\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n  const [uri] = args;\n  assertType(uri instanceof URI);\n  const model = accessor.get(IModelService).getModel(uri);\n\n  if (!model) {\n    return undefined;\n  }\n\n  const providers = _getDocumentSemanticTokensProviderHighestGroup(model);\n\n  if (!providers) {\n    // there is no provider => fall back to a document range semantic tokens provider\n    return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n  }\n\n  return providers[0].getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n  const [uri] = args;\n  assertType(uri instanceof URI);\n  const model = accessor.get(IModelService).getModel(uri);\n\n  if (!model) {\n    return undefined;\n  }\n\n  if (!hasDocumentSemanticTokensProvider(model)) {\n    // there is no provider => fall back to a document range semantic tokens provider\n    return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n  }\n\n  const r = yield getDocumentSemanticTokens(model, null, null, CancellationToken.None);\n\n  if (!r) {\n    return undefined;\n  }\n\n  const {\n    provider,\n    tokens\n  } = r;\n\n  if (!tokens || !isSemanticTokens(tokens)) {\n    return undefined;\n  }\n\n  const buff = encodeSemanticTokensDto({\n    id: 0,\n    type: 'full',\n    data: tokens.data\n  });\n\n  if (tokens.resultId) {\n    provider.releaseDocumentSemanticTokens(tokens.resultId);\n  }\n\n  return buff;\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n  const [uri, range] = args;\n  assertType(uri instanceof URI);\n  const model = accessor.get(IModelService).getModel(uri);\n\n  if (!model) {\n    return undefined;\n  }\n\n  const providers = getDocumentRangeSemanticTokensProviders(model);\n\n  if (providers.length === 0) {\n    // no providers\n    return undefined;\n  }\n\n  if (providers.length === 1) {\n    // straight forward case, just a single provider\n    return providers[0].getLegend();\n  }\n\n  if (!range || !Range.isIRange(range)) {\n    // if no range is provided, we cannot support multiple providers\n    // as we cannot fall back to the one which would give results\n    // => return the first legend for backwards compatibility and print a warning\n    console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n    return providers[0].getLegend();\n  }\n\n  const result = yield getDocumentRangeSemanticTokens(model, Range.lift(range), CancellationToken.None);\n\n  if (!result) {\n    return undefined;\n  }\n\n  return result.provider.getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n  const [uri, range] = args;\n  assertType(uri instanceof URI);\n  assertType(Range.isIRange(range));\n  const model = accessor.get(IModelService).getModel(uri);\n\n  if (!model) {\n    return undefined;\n  }\n\n  const result = yield getDocumentRangeSemanticTokens(model, Range.lift(range), CancellationToken.None);\n\n  if (!result || !result.tokens) {\n    // there is no provider or it didn't return tokens\n    return undefined;\n  }\n\n  return encodeSemanticTokensDto({\n    id: 0,\n    type: 'full',\n    data: result.tokens.data\n  });\n}));","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/services/getSemanticTokens.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","CancellationToken","onUnexpectedExternalError","URI","DocumentSemanticTokensProviderRegistry","DocumentRangeSemanticTokensProviderRegistry","IModelService","CommandsRegistry","ICommandService","assertType","encodeSemanticTokensDto","Range","isSemanticTokens","v","data","isSemanticTokensEdits","Array","isArray","edits","DocumentSemanticTokensResult","constructor","provider","tokens","error","hasDocumentSemanticTokensProvider","model","has","getDocumentSemanticTokensProviders","groups","orderedGroups","length","getDocumentSemanticTokens","lastProvider","lastResultId","token","providers","results","all","map","provideDocumentSemanticTokens","err","_getDocumentSemanticTokensProviderHighestGroup","DocumentRangeSemanticTokensResult","hasDocumentRangeSemanticTokensProvider","getDocumentRangeSemanticTokensProviders","getDocumentRangeSemanticTokens","range","provideDocumentRangeSemanticTokens","registerCommand","accessor","args","uri","get","getModel","undefined","executeCommand","getLegend","getFullModelRange","r","None","buff","id","type","resultId","releaseDocumentSemanticTokens","isIRange","console","warn","lift"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { DocumentSemanticTokensProviderRegistry, DocumentRangeSemanticTokensProviderRegistry } from '../languages.js';\nimport { IModelService } from './model.js';\nimport { CommandsRegistry, ICommandService } from '../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from './semanticTokensDto.js';\nimport { Range } from '../core/range.js';\nexport function isSemanticTokens(v) {\n    return v && !!(v.data);\n}\nexport function isSemanticTokensEdits(v) {\n    return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n    constructor(provider, tokens, error) {\n        this.provider = provider;\n        this.tokens = tokens;\n        this.error = error;\n    }\n}\nexport function hasDocumentSemanticTokensProvider(model) {\n    return DocumentSemanticTokensProviderRegistry.has(model);\n}\nfunction getDocumentSemanticTokensProviders(model) {\n    const groups = DocumentSemanticTokensProviderRegistry.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport function getDocumentSemanticTokens(model, lastProvider, lastResultId, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getDocumentSemanticTokensProviders(model);\n        // Get tokens from all providers at the same time.\n        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {\n            let result;\n            let error = null;\n            try {\n                result = yield provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);\n            }\n            catch (err) {\n                error = err;\n                result = null;\n            }\n            if (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {\n                result = null;\n            }\n            return new DocumentSemanticTokensResult(provider, result, error);\n        })));\n        // Try to return the first result with actual tokens or\n        // the first result which threw an error (!!)\n        for (const result of results) {\n            if (result.error) {\n                throw result.error;\n            }\n            if (result.tokens) {\n                return result;\n            }\n        }\n        // Return the first result, even if it doesn't have tokens\n        if (results.length > 0) {\n            return results[0];\n        }\n        return null;\n    });\n}\nfunction _getDocumentSemanticTokensProviderHighestGroup(model) {\n    const result = DocumentSemanticTokensProviderRegistry.orderedGroups(model);\n    return (result.length > 0 ? result[0] : null);\n}\nclass DocumentRangeSemanticTokensResult {\n    constructor(provider, tokens) {\n        this.provider = provider;\n        this.tokens = tokens;\n    }\n}\nexport function hasDocumentRangeSemanticTokensProvider(model) {\n    return DocumentRangeSemanticTokensProviderRegistry.has(model);\n}\nfunction getDocumentRangeSemanticTokensProviders(model) {\n    const groups = DocumentRangeSemanticTokensProviderRegistry.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport function getDocumentRangeSemanticTokens(model, range, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getDocumentRangeSemanticTokensProviders(model);\n        // Get tokens from all providers at the same time.\n        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {\n            let result;\n            try {\n                result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);\n            }\n            catch (err) {\n                onUnexpectedExternalError(err);\n                result = null;\n            }\n            if (!result || !isSemanticTokens(result)) {\n                result = null;\n            }\n            return new DocumentRangeSemanticTokensResult(provider, result);\n        })));\n        // Try to return the first result with actual tokens\n        for (const result of results) {\n            if (result.tokens) {\n                return result;\n            }\n        }\n        // Return the first result, even if it doesn't have tokens\n        if (results.length > 0) {\n            return results[0];\n        }\n        return null;\n    });\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const providers = _getDocumentSemanticTokensProviderHighestGroup(model);\n    if (!providers) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n    }\n    return providers[0].getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    if (!hasDocumentSemanticTokensProvider(model)) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n    }\n    const r = yield getDocumentSemanticTokens(model, null, null, CancellationToken.None);\n    if (!r) {\n        return undefined;\n    }\n    const { provider, tokens } = r;\n    if (!tokens || !isSemanticTokens(tokens)) {\n        return undefined;\n    }\n    const buff = encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: tokens.data\n    });\n    if (tokens.resultId) {\n        provider.releaseDocumentSemanticTokens(tokens.resultId);\n    }\n    return buff;\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const providers = getDocumentRangeSemanticTokensProviders(model);\n    if (providers.length === 0) {\n        // no providers\n        return undefined;\n    }\n    if (providers.length === 1) {\n        // straight forward case, just a single provider\n        return providers[0].getLegend();\n    }\n    if (!range || !Range.isIRange(range)) {\n        // if no range is provided, we cannot support multiple providers\n        // as we cannot fall back to the one which would give results\n        // => return the first legend for backwards compatibility and print a warning\n        console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n        return providers[0].getLegend();\n    }\n    const result = yield getDocumentRangeSemanticTokens(model, Range.lift(range), CancellationToken.None);\n    if (!result) {\n        return undefined;\n    }\n    return result.provider.getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const result = yield getDocumentRangeSemanticTokens(model, Range.lift(range), CancellationToken.None);\n    if (!result || !result.tokens) {\n        // there is no provider or it didn't return tokens\n        return undefined;\n    }\n    return encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: result.tokens.data\n    });\n}));\n"]},"metadata":{},"sourceType":"module"}