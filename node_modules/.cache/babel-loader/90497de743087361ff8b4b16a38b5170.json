{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from './modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n  constructor(breakBeforeChars, breakAfterChars) {\n    this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n  }\n\n  static create(options) {\n    return new MonospaceLineBreaksComputerFactory(options.get(120\n    /* wordWrapBreakBeforeCharacters */\n    ), options.get(119\n    /* wordWrapBreakAfterCharacters */\n    ));\n  }\n\n  createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n    const requests = [];\n    const injectedTexts = [];\n    const previousBreakingData = [];\n    return {\n      addRequest: (lineText, injectedText, previousLineBreakData) => {\n        requests.push(lineText);\n        injectedTexts.push(injectedText);\n        previousBreakingData.push(previousLineBreakData);\n      },\n      finalize: () => {\n        const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n        const result = [];\n\n        for (let i = 0, len = requests.length; i < len; i++) {\n          const injectedText = injectedTexts[i];\n          const previousLineBreakData = previousBreakingData[i];\n\n          if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n            result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n          } else {\n            result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n          }\n        }\n\n        arrPool1.length = 0;\n        arrPool2.length = 0;\n        return result;\n      }\n    };\n  }\n\n}\n\nclass WrappingCharacterClassifier extends CharacterClassifier {\n  constructor(BREAK_BEFORE, BREAK_AFTER) {\n    super(0\n    /* NONE */\n    );\n\n    for (let i = 0; i < BREAK_BEFORE.length; i++) {\n      this.set(BREAK_BEFORE.charCodeAt(i), 1\n      /* BREAK_BEFORE */\n      );\n    }\n\n    for (let i = 0; i < BREAK_AFTER.length; i++) {\n      this.set(BREAK_AFTER.charCodeAt(i), 2\n      /* BREAK_AFTER */\n      );\n    }\n  }\n\n  get(charCode) {\n    if (charCode >= 0 && charCode < 256) {\n      return this._asciiMap[charCode];\n    } else {\n      // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n      // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n      // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n      // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n      if (charCode >= 0x3040 && charCode <= 0x30FF || charCode >= 0x3400 && charCode <= 0x4DBF || charCode >= 0x4E00 && charCode <= 0x9FFF) {\n        return 3\n        /* BREAK_IDEOGRAPHIC */\n        ;\n      }\n\n      return this._map.get(charCode) || this._defaultValue;\n    }\n  }\n\n}\n\nlet arrPool1 = [];\nlet arrPool2 = [];\n\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  if (firstLineBreakColumn === -1) {\n    return null;\n  }\n\n  const len = lineText.length;\n\n  if (len <= 1) {\n    return null;\n  }\n\n  const prevBreakingOffsets = previousBreakingData.breakOffsets;\n  const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n  const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n  const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n  const breakingOffsets = arrPool1;\n  const breakingOffsetsVisibleColumn = arrPool2;\n  let breakingOffsetsCount = 0;\n  let lastBreakingOffset = 0;\n  let lastBreakingOffsetVisibleColumn = 0;\n  let breakingColumn = firstLineBreakColumn;\n  const prevLen = prevBreakingOffsets.length;\n  let prevIndex = 0;\n\n  if (prevIndex >= 0) {\n    let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n\n    while (prevIndex + 1 < prevLen) {\n      const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n\n      if (distance >= bestDistance) {\n        break;\n      }\n\n      bestDistance = distance;\n      prevIndex++;\n    }\n  }\n\n  while (prevIndex < prevLen) {\n    // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n    let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n    let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n\n    if (lastBreakingOffset > prevBreakOffset) {\n      prevBreakOffset = lastBreakingOffset;\n      prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n    }\n\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let forcedBreakOffset = 0;\n    let forcedBreakOffsetVisibleColumn = 0; // initially, we search as much as possible to the right (if it fits)\n\n    if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n      let visibleColumn = prevBreakOffsetVisibleColumn;\n      let prevCharCode = prevBreakOffset === 0 ? 0\n      /* Null */\n      : lineText.charCodeAt(prevBreakOffset - 1);\n      let prevCharCodeClass = prevBreakOffset === 0 ? 0\n      /* NONE */\n      : classifier.get(prevCharCode);\n      let entireLineFits = true;\n\n      for (let i = prevBreakOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n\n        if (strings.isHighSurrogate(charCode)) {\n          // A surrogate pair must always be considered as a single unit, so it is never to be broken\n          i++;\n          charCodeClass = 0\n          /* NONE */\n          ;\n          charWidth = 2;\n        } else {\n          charCodeClass = classifier.get(charCode);\n          charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n\n        if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n          breakOffset = charStartOffset;\n          breakOffsetVisibleColumn = visibleColumn;\n        }\n\n        visibleColumn += charWidth; // check if adding character at `i` will go over the breaking column\n\n        if (visibleColumn > breakingColumn) {\n          // We need to break at least before character at `i`:\n          if (charStartOffset > lastBreakingOffset) {\n            forcedBreakOffset = charStartOffset;\n            forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n          } else {\n            // we need to advance at least by one character\n            forcedBreakOffset = i + 1;\n            forcedBreakOffsetVisibleColumn = visibleColumn;\n          }\n\n          if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n            // Cannot break at `breakOffset` => reset it if it was set\n            breakOffset = 0;\n          }\n\n          entireLineFits = false;\n          break;\n        }\n\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n      }\n\n      if (entireLineFits) {\n        // there is no more need to break => stop the outer loop!\n        if (breakingOffsetsCount > 0) {\n          // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n          breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n          breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n          breakingOffsetsCount++;\n        }\n\n        break;\n      }\n    }\n\n    if (breakOffset === 0) {\n      // must search left\n      let visibleColumn = prevBreakOffsetVisibleColumn;\n      let charCode = lineText.charCodeAt(prevBreakOffset);\n      let charCodeClass = classifier.get(charCode);\n      let hitATabCharacter = false;\n\n      for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n        const charStartOffset = i + 1;\n        const prevCharCode = lineText.charCodeAt(i);\n\n        if (prevCharCode === 9\n        /* Tab */\n        ) {\n          // cannot determine the width of a tab when going backwards, so we must go forwards\n          hitATabCharacter = true;\n          break;\n        }\n\n        let prevCharCodeClass;\n        let prevCharWidth;\n\n        if (strings.isLowSurrogate(prevCharCode)) {\n          // A surrogate pair must always be considered as a single unit, so it is never to be broken\n          i--;\n          prevCharCodeClass = 0\n          /* NONE */\n          ;\n          prevCharWidth = 2;\n        } else {\n          prevCharCodeClass = classifier.get(prevCharCode);\n          prevCharWidth = strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1;\n        }\n\n        if (visibleColumn <= breakingColumn) {\n          if (forcedBreakOffset === 0) {\n            forcedBreakOffset = charStartOffset;\n            forcedBreakOffsetVisibleColumn = visibleColumn;\n          }\n\n          if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n            // went too far!\n            break;\n          }\n\n          if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n            break;\n          }\n        }\n\n        visibleColumn -= prevCharWidth;\n        charCode = prevCharCode;\n        charCodeClass = prevCharCodeClass;\n      }\n\n      if (breakOffset !== 0) {\n        const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n\n        if (remainingWidthOfNextLine <= tabSize) {\n          const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n          let charWidth;\n\n          if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            charWidth = 2;\n          } else {\n            charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n          }\n\n          if (remainingWidthOfNextLine - charWidth < 0) {\n            // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n            breakOffset = 0;\n          }\n        }\n      }\n\n      if (hitATabCharacter) {\n        // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n        prevIndex--;\n        continue;\n      }\n    }\n\n    if (breakOffset === 0) {\n      // Could not find a good breaking point\n      breakOffset = forcedBreakOffset;\n      breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n    }\n\n    if (breakOffset <= lastBreakingOffset) {\n      // Make sure that we are advancing (at least one character)\n      const charCode = lineText.charCodeAt(lastBreakingOffset);\n\n      if (strings.isHighSurrogate(charCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        breakOffset = lastBreakingOffset + 2;\n        breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n      } else {\n        breakOffset = lastBreakingOffset + 1;\n        breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n      }\n    }\n\n    lastBreakingOffset = breakOffset;\n    breakingOffsets[breakingOffsetsCount] = breakOffset;\n    lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n    breakingOffsetsCount++;\n    breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n\n    while (prevIndex < 0 || prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn) {\n      prevIndex++;\n    }\n\n    let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n\n    while (prevIndex + 1 < prevLen) {\n      const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n\n      if (distance >= bestDistance) {\n        break;\n      }\n\n      bestDistance = distance;\n      prevIndex++;\n    }\n  }\n\n  if (breakingOffsetsCount === 0) {\n    return null;\n  } // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n\n\n  breakingOffsets.length = breakingOffsetsCount;\n  breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n  arrPool1 = previousBreakingData.breakOffsets;\n  arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n  previousBreakingData.breakOffsets = breakingOffsets;\n  previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n  previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n  return previousBreakingData;\n}\n\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n  let injectionOptions;\n  let injectionOffsets;\n\n  if (injectedTexts && injectedTexts.length > 0) {\n    injectionOptions = injectedTexts.map(t => t.options);\n    injectionOffsets = injectedTexts.map(text => text.column - 1);\n  } else {\n    injectionOptions = null;\n    injectionOffsets = null;\n  }\n\n  if (firstLineBreakColumn === -1) {\n    if (!injectionOptions) {\n      return null;\n    } // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n    // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n\n\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n  }\n\n  const len = lineText.length;\n\n  if (len <= 1) {\n    if (!injectionOptions) {\n      return null;\n    } // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n    // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n\n\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n  }\n\n  const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n  const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n  const breakingOffsets = [];\n  const breakingOffsetsVisibleColumn = [];\n  let breakingOffsetsCount = 0;\n  let breakOffset = 0;\n  let breakOffsetVisibleColumn = 0;\n  let breakingColumn = firstLineBreakColumn;\n  let prevCharCode = lineText.charCodeAt(0);\n  let prevCharCodeClass = classifier.get(prevCharCode);\n  let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n  let startOffset = 1;\n\n  if (strings.isHighSurrogate(prevCharCode)) {\n    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n    visibleColumn += 1;\n    prevCharCode = lineText.charCodeAt(1);\n    prevCharCodeClass = classifier.get(prevCharCode);\n    startOffset++;\n  }\n\n  for (let i = startOffset; i < len; i++) {\n    const charStartOffset = i;\n    const charCode = lineText.charCodeAt(i);\n    let charCodeClass;\n    let charWidth;\n\n    if (strings.isHighSurrogate(charCode)) {\n      // A surrogate pair must always be considered as a single unit, so it is never to be broken\n      i++;\n      charCodeClass = 0\n      /* NONE */\n      ;\n      charWidth = 2;\n    } else {\n      charCodeClass = classifier.get(charCode);\n      charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n    }\n\n    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n      breakOffset = charStartOffset;\n      breakOffsetVisibleColumn = visibleColumn;\n    }\n\n    visibleColumn += charWidth; // check if adding character at `i` will go over the breaking column\n\n    if (visibleColumn > breakingColumn) {\n      // We need to break at least before character at `i`:\n      if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n        // Cannot break at `breakOffset`, must break at `i`\n        breakOffset = charStartOffset;\n        breakOffsetVisibleColumn = visibleColumn - charWidth;\n      }\n\n      breakingOffsets[breakingOffsetsCount] = breakOffset;\n      breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n      breakingOffsetsCount++;\n      breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n      breakOffset = 0;\n    }\n\n    prevCharCode = charCode;\n    prevCharCodeClass = charCodeClass;\n  }\n\n  if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n    return null;\n  } // Add last segment\n\n\n  breakingOffsets[breakingOffsetsCount] = len;\n  breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n  return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\n\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n  if (charCode === 9\n  /* Tab */\n  ) {\n    return tabSize - visibleColumn % tabSize;\n  }\n\n  if (strings.isFullWidthCharacter(charCode)) {\n    return columnsForFullWidthChar;\n  }\n\n  if (charCode < 32) {\n    // when using `editor.renderControlCharacters`, the substitutions are often wide\n    return columnsForFullWidthChar;\n  }\n\n  return 1;\n}\n\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n  return tabSize - visibleColumn % tabSize;\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\n\n\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\n  return charCode !== 32\n  /* Space */\n  && (prevCharCodeClass === 2\n  /* BREAK_AFTER */\n  || prevCharCodeClass === 3\n  /* BREAK_IDEOGRAPHIC */\n  && charCodeClass !== 2\n  /* BREAK_AFTER */\n  || charCodeClass === 1\n  /* BREAK_BEFORE */\n  || charCodeClass === 3\n  /* BREAK_IDEOGRAPHIC */\n  && prevCharCodeClass !== 1\n  /* BREAK_BEFORE */\n  );\n}\n\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  let wrappedTextIndentLength = 0;\n\n  if (wrappingIndent !== 0\n  /* None */\n  ) {\n    const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n\n    if (firstNonWhitespaceIndex !== -1) {\n      // Track existing indent\n      for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n        const charWidth = lineText.charCodeAt(i) === 9\n        /* Tab */\n        ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1;\n        wrappedTextIndentLength += charWidth;\n      } // Increase indent of continuation lines, if desired\n\n\n      const numberOfAdditionalTabs = wrappingIndent === 3\n      /* DeepIndent */\n      ? 2 : wrappingIndent === 2\n      /* Indent */\n      ? 1 : 0;\n\n      for (let i = 0; i < numberOfAdditionalTabs; i++) {\n        const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n        wrappedTextIndentLength += charWidth;\n      } // Force sticking to beginning of line if no character would fit except for the indentation\n\n\n      if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n        wrappedTextIndentLength = 0;\n      }\n    }\n  }\n\n  return wrappedTextIndentLength;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js"],"names":["strings","CharacterClassifier","LineInjectedText","ModelLineProjectionData","MonospaceLineBreaksComputerFactory","constructor","breakBeforeChars","breakAfterChars","classifier","WrappingCharacterClassifier","create","options","get","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","requests","injectedTexts","previousBreakingData","addRequest","lineText","injectedText","previousLineBreakData","push","finalize","columnsForFullWidthChar","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","result","i","len","length","injectionOptions","createLineBreaksFromPreviousLineBreaks","createLineBreaks","arrPool1","arrPool2","BREAK_BEFORE","BREAK_AFTER","set","charCodeAt","charCode","_asciiMap","_map","_defaultValue","firstLineBreakColumn","prevBreakingOffsets","breakOffsets","prevBreakingOffsetsVisibleColumn","breakOffsetsVisibleColumn","wrappedTextIndentLength","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","lastBreakingOffset","lastBreakingOffsetVisibleColumn","breakingColumn","prevLen","prevIndex","bestDistance","Math","abs","distance","prevBreakOffset","prevBreakOffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","visibleColumn","prevCharCode","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","charWidth","isHighSurrogate","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","isLowSurrogate","isFullWidthCharacter","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","_lineText","applyInjectedText","injectionOffsets","map","t","text","column","startOffset","tabCharacterWidth","firstNonWhitespaceIndex","numberOfAdditionalTabs"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from './modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(120 /* wordWrapBreakBeforeCharacters */), options.get(119 /* wordWrapBreakAfterCharacters */));\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n        const requests = [];\n        const injectedTexts = [];\n        const previousBreakingData = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n                const result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const injectedText = injectedTexts[i];\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = arrPool1;\n    const breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n    let injectionOptions;\n    let injectionOffsets;\n    if (injectedTexts && injectedTexts.length > 0) {\n        injectionOptions = injectedTexts.map(t => t.options);\n        injectionOffsets = injectedTexts.map(text => text.column - 1);\n    }\n    else {\n        injectionOptions = null;\n        injectionOffsets = null;\n    }\n    if (firstLineBreakColumn === -1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = [];\n    const breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\n    return (charCode !== 32 /* Space */\n        && ((prevCharCodeClass === 2 /* BREAK_AFTER */)\n            || (prevCharCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* BREAK_AFTER */)\n            || (charCodeClass === 1 /* BREAK_BEFORE */)\n            || (charCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* DeepIndent */ ? 2 : wrappingIndent === 2 /* Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n"]},"metadata":{},"sourceType":"module"}