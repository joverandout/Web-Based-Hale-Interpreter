{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { ComposedTreeDelegate } from './abstractTree.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { CompressibleObjectTree, ObjectTree } from './objectTree.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { createCancelablePromise, Promises, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { isCancellationError, onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { DisposableStore, dispose } from '../../../common/lifecycle.js';\n\nfunction createAsyncDataTreeNode(props) {\n  return Object.assign(Object.assign({}, props), {\n    children: [],\n    refreshPromise: undefined,\n    stale: true,\n    slow: false,\n    collapsedByDefault: undefined\n  });\n}\n\nfunction isAncestor(ancestor, descendant) {\n  if (!descendant.parent) {\n    return false;\n  } else if (descendant.parent === ancestor) {\n    return true;\n  } else {\n    return isAncestor(ancestor, descendant.parent);\n  }\n}\n\nfunction intersects(node, other) {\n  return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\n\nclass AsyncDataTreeNodeWrapper {\n  constructor(node) {\n    this.node = node;\n  }\n\n  get element() {\n    return this.node.element.element;\n  }\n\n  get children() {\n    return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node));\n  }\n\n  get depth() {\n    return this.node.depth;\n  }\n\n  get visibleChildrenCount() {\n    return this.node.visibleChildrenCount;\n  }\n\n  get visibleChildIndex() {\n    return this.node.visibleChildIndex;\n  }\n\n  get collapsible() {\n    return this.node.collapsible;\n  }\n\n  get collapsed() {\n    return this.node.collapsed;\n  }\n\n  get visible() {\n    return this.node.visible;\n  }\n\n  get filterData() {\n    return this.node.filterData;\n  }\n\n}\n\nclass AsyncDataTreeRenderer {\n  constructor(renderer, nodeMapper, onDidChangeTwistieState) {\n    this.renderer = renderer;\n    this.nodeMapper = nodeMapper;\n    this.onDidChangeTwistieState = onDidChangeTwistieState;\n    this.renderedNodes = new Map();\n    this.templateId = renderer.templateId;\n  }\n\n  renderTemplate(container) {\n    const templateData = this.renderer.renderTemplate(container);\n    return {\n      templateData\n    };\n  }\n\n  renderElement(node, index, templateData, height) {\n    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n  }\n\n  renderTwistie(element, twistieElement) {\n    if (element.slow) {\n      twistieElement.classList.add(...Codicon.treeItemLoading.classNamesArray);\n      return true;\n    } else {\n      twistieElement.classList.remove(...Codicon.treeItemLoading.classNamesArray);\n      return false;\n    }\n  }\n\n  disposeElement(node, index, templateData, height) {\n    if (this.renderer.disposeElement) {\n      this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n  }\n\n  disposeTemplate(templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  }\n\n  dispose() {\n    this.renderedNodes.clear();\n  }\n\n}\n\nfunction asTreeEvent(e) {\n  return {\n    browserEvent: e.browserEvent,\n    elements: e.elements.map(e => e.element)\n  };\n}\n\nfunction asTreeMouseEvent(e) {\n  return {\n    browserEvent: e.browserEvent,\n    element: e.element && e.element.element,\n    target: e.target\n  };\n}\n\nclass AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {\n  constructor(data) {\n    super(data.elements.map(node => node.element));\n    this.data = data;\n  }\n\n}\n\nfunction asAsyncDataTreeDragAndDropData(data) {\n  if (data instanceof ElementsDragAndDropData) {\n    return new AsyncDataTreeElementsDragAndDropData(data);\n  }\n\n  return data;\n}\n\nclass AsyncDataTreeNodeListDragAndDrop {\n  constructor(dnd) {\n    this.dnd = dnd;\n  }\n\n  getDragURI(node) {\n    return this.dnd.getDragURI(node.element);\n  }\n\n  getDragLabel(nodes, originalEvent) {\n    if (this.dnd.getDragLabel) {\n      return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n    }\n\n    return undefined;\n  }\n\n  onDragStart(data, originalEvent) {\n    if (this.dnd.onDragStart) {\n      this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\n    }\n  }\n\n  onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {\n    return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n  }\n\n  drop(data, targetNode, targetIndex, originalEvent) {\n    this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n  }\n\n  onDragEnd(originalEvent) {\n    if (this.dnd.onDragEnd) {\n      this.dnd.onDragEnd(originalEvent);\n    }\n  }\n\n}\n\nfunction asObjectTreeOptions(options) {\n  return options && Object.assign(Object.assign({}, options), {\n    collapseByDefault: true,\n    identityProvider: options.identityProvider && {\n      getId(el) {\n        return options.identityProvider.getId(el.element);\n      }\n\n    },\n    dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n    multipleSelectionController: options.multipleSelectionController && {\n      isSelectionSingleChangeEvent(e) {\n        return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), {\n          element: e.element\n        }));\n      },\n\n      isSelectionRangeChangeEvent(e) {\n        return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), {\n          element: e.element\n        }));\n      }\n\n    },\n    accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), {\n      getPosInSet: undefined,\n      getSetSize: undefined,\n      getRole: options.accessibilityProvider.getRole ? el => {\n        return options.accessibilityProvider.getRole(el.element);\n      } : () => 'treeitem',\n      isChecked: options.accessibilityProvider.isChecked ? e => {\n        var _a;\n\n        return !!((_a = options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.isChecked(e.element));\n      } : undefined,\n\n      getAriaLabel(e) {\n        return options.accessibilityProvider.getAriaLabel(e.element);\n      },\n\n      getWidgetAriaLabel() {\n        return options.accessibilityProvider.getWidgetAriaLabel();\n      },\n\n      getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',\n      getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n        return options.accessibilityProvider.getAriaLevel(node.element);\n      }),\n      getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n        return options.accessibilityProvider.getActiveDescendantId(node.element);\n      })\n    }),\n    filter: options.filter && {\n      filter(e, parentVisibility) {\n        return options.filter.filter(e.element, parentVisibility);\n      }\n\n    },\n    keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), {\n      getKeyboardNavigationLabel(e) {\n        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n      }\n\n    }),\n    sorter: undefined,\n    expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : e => options.expandOnlyOnTwistieClick(e.element),\n    additionalScrollHeight: options.additionalScrollHeight\n  });\n}\n\nfunction dfs(node, fn) {\n  fn(node);\n  node.children.forEach(child => dfs(child, fn));\n}\n\nexport class AsyncDataTree {\n  constructor(user, container, delegate, renderers, dataSource, options = {}) {\n    this.user = user;\n    this.dataSource = dataSource;\n    this.nodes = new Map();\n    this.subTreeRefreshPromises = new Map();\n    this.refreshPromises = new Map();\n    this._onDidRender = new Emitter();\n    this._onDidChangeNodeSlowState = new Emitter();\n    this.nodeMapper = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n    this.disposables = new DisposableStore();\n    this.identityProvider = options.identityProvider;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.sorter = options.sorter;\n    this.collapseByDefault = options.collapseByDefault;\n    this.tree = this.createTree(user, container, delegate, renderers, options);\n    this.root = createAsyncDataTreeNode({\n      element: undefined,\n      parent: null,\n      hasChildren: true\n    });\n\n    if (this.identityProvider) {\n      this.root = Object.assign(Object.assign({}, this.root), {\n        id: null\n      });\n    }\n\n    this.nodes.set(null, this.root);\n    this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n  }\n\n  get onDidChangeFocus() {\n    return Event.map(this.tree.onDidChangeFocus, asTreeEvent);\n  }\n\n  get onDidChangeSelection() {\n    return Event.map(this.tree.onDidChangeSelection, asTreeEvent);\n  }\n\n  get onMouseDblClick() {\n    return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent);\n  }\n\n  get onPointer() {\n    return Event.map(this.tree.onPointer, asTreeMouseEvent);\n  }\n\n  get onDidFocus() {\n    return this.tree.onDidFocus;\n  }\n\n  get onDidChangeModel() {\n    return this.tree.onDidChangeModel;\n  }\n\n  get onDidChangeCollapseState() {\n    return this.tree.onDidChangeCollapseState;\n  }\n\n  get onDidDispose() {\n    return this.tree.onDidDispose;\n  }\n\n  createTree(user, container, delegate, renderers, options) {\n    const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n    const objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n    const objectTreeOptions = asObjectTreeOptions(options) || {};\n    return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n  }\n\n  updateOptions(options = {}) {\n    this.tree.updateOptions(options);\n  } // Widget\n\n\n  getHTMLElement() {\n    return this.tree.getHTMLElement();\n  }\n\n  get scrollTop() {\n    return this.tree.scrollTop;\n  }\n\n  set scrollTop(scrollTop) {\n    this.tree.scrollTop = scrollTop;\n  }\n\n  domFocus() {\n    this.tree.domFocus();\n  }\n\n  layout(height, width) {\n    this.tree.layout(height, width);\n  }\n\n  style(styles) {\n    this.tree.style(styles);\n  } // Model\n\n\n  getInput() {\n    return this.root.element;\n  }\n\n  setInput(input, viewState) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.refreshPromises.forEach(promise => promise.cancel());\n      this.refreshPromises.clear();\n      this.root.element = input;\n      const viewStateContext = viewState && {\n        viewState,\n        focus: [],\n        selection: []\n      };\n      yield this._updateChildren(input, true, false, viewStateContext);\n\n      if (viewStateContext) {\n        this.tree.setFocus(viewStateContext.focus);\n        this.tree.setSelection(viewStateContext.selection);\n      }\n\n      if (viewState && typeof viewState.scrollTop === 'number') {\n        this.scrollTop = viewState.scrollTop;\n      }\n    });\n  }\n\n  _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.root.element === 'undefined') {\n        throw new TreeError(this.user, 'Tree input not set');\n      }\n\n      if (this.root.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n\n      const node = this.getDataNode(element);\n      yield this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n\n      if (rerender) {\n        try {\n          this.tree.rerender(node);\n        } catch (_a) {// missing nodes are fine, this could've resulted from\n          // parallel refresh calls, removing `node` altogether\n        }\n      }\n    });\n  } // View\n\n\n  rerender(element) {\n    if (element === undefined || element === this.root.element) {\n      this.tree.rerender();\n      return;\n    }\n\n    const node = this.getDataNode(element);\n    this.tree.rerender(node);\n  } // Tree\n\n\n  getNode(element = this.root.element) {\n    const dataNode = this.getDataNode(element);\n    const node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n    return this.nodeMapper.map(node);\n  }\n\n  collapse(element, recursive = false) {\n    const node = this.getDataNode(element);\n    return this.tree.collapse(node === this.root ? null : node, recursive);\n  }\n\n  expand(element, recursive = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.root.element === 'undefined') {\n        throw new TreeError(this.user, 'Tree input not set');\n      }\n\n      if (this.root.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n\n      const node = this.getDataNode(element);\n\n      if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n        return false;\n      }\n\n      if (node.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n\n      if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n        return false;\n      }\n\n      const result = this.tree.expand(node === this.root ? null : node, recursive);\n\n      if (node.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n\n      return result;\n    });\n  }\n\n  setSelection(elements, browserEvent) {\n    const nodes = elements.map(e => this.getDataNode(e));\n    this.tree.setSelection(nodes, browserEvent);\n  }\n\n  getSelection() {\n    const nodes = this.tree.getSelection();\n    return nodes.map(n => n.element);\n  }\n\n  setFocus(elements, browserEvent) {\n    const nodes = elements.map(e => this.getDataNode(e));\n    this.tree.setFocus(nodes, browserEvent);\n  }\n\n  getFocus() {\n    const nodes = this.tree.getFocus();\n    return nodes.map(n => n.element);\n  }\n\n  reveal(element, relativeTop) {\n    this.tree.reveal(this.getDataNode(element), relativeTop);\n  } // Tree navigation\n\n\n  getParentElement(element) {\n    const node = this.tree.getParentElement(this.getDataNode(element));\n    return node && node.element;\n  }\n\n  getFirstElementChild(element = this.root.element) {\n    const dataNode = this.getDataNode(element);\n    const node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n    return node && node.element;\n  } // Implementation\n\n\n  getDataNode(element) {\n    const node = this.nodes.get(element === this.root.element ? null : element);\n\n    if (!node) {\n      throw new TreeError(this.user, `Data tree node not found: ${element}`);\n    }\n\n    return node;\n  }\n\n  refreshAndRenderNode(node, recursive, viewStateContext, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.refreshNode(node, recursive, viewStateContext);\n      this.render(node, viewStateContext, options);\n    });\n  }\n\n  refreshNode(node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let result;\n      this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n        if (!result && intersects(refreshNode, node)) {\n          result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n        }\n      });\n\n      if (result) {\n        return result;\n      }\n\n      return this.doRefreshSubTree(node, recursive, viewStateContext);\n    });\n  }\n\n  doRefreshSubTree(node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let done;\n      node.refreshPromise = new Promise(c => done = c);\n      this.subTreeRefreshPromises.set(node, node.refreshPromise);\n      node.refreshPromise.finally(() => {\n        node.refreshPromise = undefined;\n        this.subTreeRefreshPromises.delete(node);\n      });\n\n      try {\n        const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);\n        node.stale = false;\n        yield Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n      } finally {\n        done();\n      }\n    });\n  }\n\n  doRefreshNode(node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      node.hasChildren = !!this.dataSource.hasChildren(node.element);\n      let childrenPromise;\n\n      if (!node.hasChildren) {\n        childrenPromise = Promise.resolve(Iterable.empty());\n      } else {\n        const slowTimeout = timeout(800);\n        slowTimeout.then(() => {\n          node.slow = true;\n\n          this._onDidChangeNodeSlowState.fire(node);\n        }, _ => null);\n        childrenPromise = this.doGetChildren(node).finally(() => slowTimeout.cancel());\n      }\n\n      try {\n        const children = yield childrenPromise;\n        return this.setChildren(node, children, recursive, viewStateContext);\n      } catch (err) {\n        if (node !== this.root && this.tree.hasElement(node)) {\n          this.tree.collapse(node);\n        }\n\n        if (isCancellationError(err)) {\n          return [];\n        }\n\n        throw err;\n      } finally {\n        if (node.slow) {\n          node.slow = false;\n\n          this._onDidChangeNodeSlowState.fire(node);\n        }\n      }\n    });\n  }\n\n  doGetChildren(node) {\n    let result = this.refreshPromises.get(node);\n\n    if (result) {\n      return result;\n    }\n\n    result = createCancelablePromise(() => __awaiter(this, void 0, void 0, function* () {\n      const children = yield this.dataSource.getChildren(node.element);\n      return this.processChildren(children);\n    }));\n    this.refreshPromises.set(node, result);\n    return result.finally(() => {\n      this.refreshPromises.delete(node);\n    });\n  }\n\n  _onDidChangeCollapseState({\n    node,\n    deep\n  }) {\n    if (node.element === null) {\n      return;\n    }\n\n    if (!node.collapsed && node.element.stale) {\n      if (deep) {\n        this.collapse(node.element.element);\n      } else {\n        this.refreshAndRenderNode(node.element, false).catch(onUnexpectedError);\n      }\n    }\n  }\n\n  setChildren(node, childrenElementsIterable, recursive, viewStateContext) {\n    const childrenElements = [...childrenElementsIterable]; // perf: if the node was and still is a leaf, avoid all this hassle\n\n    if (node.children.length === 0 && childrenElements.length === 0) {\n      return [];\n    }\n\n    const nodesToForget = new Map();\n    const childrenTreeNodesById = new Map();\n\n    for (const child of node.children) {\n      nodesToForget.set(child.element, child);\n\n      if (this.identityProvider) {\n        const collapsed = this.tree.isCollapsed(child);\n        childrenTreeNodesById.set(child.id, {\n          node: child,\n          collapsed\n        });\n      }\n    }\n\n    const childrenToRefresh = [];\n    const children = childrenElements.map(element => {\n      const hasChildren = !!this.dataSource.hasChildren(element);\n\n      if (!this.identityProvider) {\n        const asyncDataTreeNode = createAsyncDataTreeNode({\n          element,\n          parent: node,\n          hasChildren\n        });\n\n        if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n          asyncDataTreeNode.collapsedByDefault = false;\n          childrenToRefresh.push(asyncDataTreeNode);\n        }\n\n        return asyncDataTreeNode;\n      }\n\n      const id = this.identityProvider.getId(element).toString();\n      const result = childrenTreeNodesById.get(id);\n\n      if (result) {\n        const asyncDataTreeNode = result.node;\n        nodesToForget.delete(asyncDataTreeNode.element);\n        this.nodes.delete(asyncDataTreeNode.element);\n        this.nodes.set(element, asyncDataTreeNode);\n        asyncDataTreeNode.element = element;\n        asyncDataTreeNode.hasChildren = hasChildren;\n\n        if (recursive) {\n          if (result.collapsed) {\n            asyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element)));\n            asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n            asyncDataTreeNode.stale = true;\n          } else {\n            childrenToRefresh.push(asyncDataTreeNode);\n          }\n        } else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n          asyncDataTreeNode.collapsedByDefault = false;\n          childrenToRefresh.push(asyncDataTreeNode);\n        }\n\n        return asyncDataTreeNode;\n      }\n\n      const childAsyncDataTreeNode = createAsyncDataTreeNode({\n        element,\n        parent: node,\n        id,\n        hasChildren\n      });\n\n      if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n        viewStateContext.focus.push(childAsyncDataTreeNode);\n      }\n\n      if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n        viewStateContext.selection.push(childAsyncDataTreeNode);\n      }\n\n      if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n        childrenToRefresh.push(childAsyncDataTreeNode);\n      } else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n        childAsyncDataTreeNode.collapsedByDefault = false;\n        childrenToRefresh.push(childAsyncDataTreeNode);\n      }\n\n      return childAsyncDataTreeNode;\n    });\n\n    for (const node of nodesToForget.values()) {\n      dfs(node, node => this.nodes.delete(node.element));\n    }\n\n    for (const child of children) {\n      this.nodes.set(child.element, child);\n    }\n\n    node.children.splice(0, node.children.length, ...children); // TODO@joao this doesn't take filter into account\n\n    if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n      children[0].collapsedByDefault = false;\n      childrenToRefresh.push(children[0]);\n    }\n\n    return childrenToRefresh;\n  }\n\n  render(node, viewStateContext, options) {\n    const children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n    const objectTreeOptions = options && Object.assign(Object.assign({}, options), {\n      diffIdentityProvider: options.diffIdentityProvider && {\n        getId(node) {\n          return options.diffIdentityProvider.getId(node.element);\n        }\n\n      }\n    });\n    this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n\n    if (node !== this.root) {\n      this.tree.setCollapsible(node, node.hasChildren);\n    }\n\n    this._onDidRender.fire();\n  }\n\n  asTreeElement(node, viewStateContext) {\n    if (node.stale) {\n      return {\n        element: node,\n        collapsible: node.hasChildren,\n        collapsed: true\n      };\n    }\n\n    let collapsed;\n\n    if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n      collapsed = false;\n    } else {\n      collapsed = node.collapsedByDefault;\n    }\n\n    node.collapsedByDefault = undefined;\n    return {\n      element: node,\n      children: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n      collapsible: node.hasChildren,\n      collapsed\n    };\n  }\n\n  processChildren(children) {\n    if (this.sorter) {\n      children = [...children].sort(this.sorter.compare.bind(this.sorter));\n    }\n\n    return children;\n  }\n\n  dispose() {\n    this.disposables.dispose();\n  }\n\n}\n\nclass CompressibleAsyncDataTreeNodeWrapper {\n  constructor(node) {\n    this.node = node;\n  }\n\n  get element() {\n    return {\n      elements: this.node.element.elements.map(e => e.element),\n      incompressible: this.node.element.incompressible\n    };\n  }\n\n  get children() {\n    return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n  }\n\n  get depth() {\n    return this.node.depth;\n  }\n\n  get visibleChildrenCount() {\n    return this.node.visibleChildrenCount;\n  }\n\n  get visibleChildIndex() {\n    return this.node.visibleChildIndex;\n  }\n\n  get collapsible() {\n    return this.node.collapsible;\n  }\n\n  get collapsed() {\n    return this.node.collapsed;\n  }\n\n  get visible() {\n    return this.node.visible;\n  }\n\n  get filterData() {\n    return this.node.filterData;\n  }\n\n}\n\nclass CompressibleAsyncDataTreeRenderer {\n  constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {\n    this.renderer = renderer;\n    this.nodeMapper = nodeMapper;\n    this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;\n    this.onDidChangeTwistieState = onDidChangeTwistieState;\n    this.renderedNodes = new Map();\n    this.disposables = [];\n    this.templateId = renderer.templateId;\n  }\n\n  renderTemplate(container) {\n    const templateData = this.renderer.renderTemplate(container);\n    return {\n      templateData\n    };\n  }\n\n  renderElement(node, index, templateData, height) {\n    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n  }\n\n  renderCompressedElements(node, index, templateData, height) {\n    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n  }\n\n  renderTwistie(element, twistieElement) {\n    if (element.slow) {\n      twistieElement.classList.add(...Codicon.treeItemLoading.classNamesArray);\n      return true;\n    } else {\n      twistieElement.classList.remove(...Codicon.treeItemLoading.classNamesArray);\n      return false;\n    }\n  }\n\n  disposeElement(node, index, templateData, height) {\n    if (this.renderer.disposeElement) {\n      this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n  }\n\n  disposeCompressedElements(node, index, templateData, height) {\n    if (this.renderer.disposeCompressedElements) {\n      this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n    }\n  }\n\n  disposeTemplate(templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  }\n\n  dispose() {\n    this.renderedNodes.clear();\n    this.disposables = dispose(this.disposables);\n  }\n\n}\n\nfunction asCompressibleObjectTreeOptions(options) {\n  const objectTreeOptions = options && asObjectTreeOptions(options);\n  return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), {\n    keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), {\n      getCompressedNodeKeyboardNavigationLabel(els) {\n        return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));\n      }\n\n    })\n  });\n}\n\nexport class CompressibleAsyncDataTree extends AsyncDataTree {\n  constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {\n    super(user, container, virtualDelegate, renderers, dataSource, options);\n    this.compressionDelegate = compressionDelegate;\n    this.compressibleNodeMapper = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n    this.filter = options.filter;\n  }\n\n  createTree(user, container, delegate, renderers, options) {\n    const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n    const objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n    const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};\n    return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n  }\n\n  asTreeElement(node, viewStateContext) {\n    return Object.assign({\n      incompressible: this.compressionDelegate.isIncompressible(node.element)\n    }, super.asTreeElement(node, viewStateContext));\n  }\n\n  updateOptions(options = {}) {\n    this.tree.updateOptions(options);\n  }\n\n  render(node, viewStateContext) {\n    if (!this.identityProvider) {\n      return super.render(node, viewStateContext);\n    } // Preserve traits across compressions. Hacky but does the trick.\n    // This is hard to fix properly since it requires rewriting the traits\n    // across trees and lists. Let's just keep it this way for now.\n\n\n    const getId = element => this.identityProvider.getId(element).toString();\n\n    const getUncompressedIds = nodes => {\n      const result = new Set();\n\n      for (const node of nodes) {\n        const compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n\n        if (!compressedNode.element) {\n          continue;\n        }\n\n        for (const node of compressedNode.element.elements) {\n          result.add(getId(node.element));\n        }\n      }\n\n      return result;\n    };\n\n    const oldSelection = getUncompressedIds(this.tree.getSelection());\n    const oldFocus = getUncompressedIds(this.tree.getFocus());\n    super.render(node, viewStateContext);\n    const selection = this.getSelection();\n    let didChangeSelection = false;\n    const focus = this.getFocus();\n    let didChangeFocus = false;\n\n    const visit = node => {\n      const compressedNode = node.element;\n\n      if (compressedNode) {\n        for (let i = 0; i < compressedNode.elements.length; i++) {\n          const id = getId(compressedNode.elements[i].element);\n          const element = compressedNode.elements[compressedNode.elements.length - 1].element; // github.com/microsoft/vscode/issues/85938\n\n          if (oldSelection.has(id) && selection.indexOf(element) === -1) {\n            selection.push(element);\n            didChangeSelection = true;\n          }\n\n          if (oldFocus.has(id) && focus.indexOf(element) === -1) {\n            focus.push(element);\n            didChangeFocus = true;\n          }\n        }\n      }\n\n      node.children.forEach(visit);\n    };\n\n    visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n\n    if (didChangeSelection) {\n      this.setSelection(selection);\n    }\n\n    if (didChangeFocus) {\n      this.setFocus(focus);\n    }\n  } // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n  // and we have to filter everything beforehand\n  // Related to #85193 and #85835\n\n\n  processChildren(children) {\n    if (this.filter) {\n      children = Iterable.filter(children, e => {\n        const result = this.filter.filter(e, 1\n        /* Visible */\n        );\n        const visibility = getVisibility(result);\n\n        if (visibility === 2\n        /* Recurse */\n        ) {\n          throw new Error('Recursive tree visibility not supported in async data compressed trees');\n        }\n\n        return visibility === 1\n        /* Visible */\n        ;\n      });\n    }\n\n    return super.processChildren(children);\n  }\n\n}\n\nfunction getVisibility(filterResult) {\n  if (typeof filterResult === 'boolean') {\n    return filterResult ? 1\n    /* Visible */\n    : 0\n    /* Hidden */\n    ;\n  } else if (isFilterResult(filterResult)) {\n    return getVisibleState(filterResult.visibility);\n  } else {\n    return getVisibleState(filterResult);\n  }\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/asyncDataTree.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","ElementsDragAndDropData","ComposedTreeDelegate","getVisibleState","isFilterResult","CompressibleObjectTree","ObjectTree","TreeError","WeakMapper","createCancelablePromise","Promises","timeout","Codicon","isCancellationError","onUnexpectedError","Emitter","Event","Iterable","DisposableStore","dispose","createAsyncDataTreeNode","props","Object","assign","children","refreshPromise","undefined","stale","slow","collapsedByDefault","isAncestor","ancestor","descendant","parent","intersects","node","other","AsyncDataTreeNodeWrapper","constructor","element","map","depth","visibleChildrenCount","visibleChildIndex","collapsible","collapsed","visible","filterData","AsyncDataTreeRenderer","renderer","nodeMapper","onDidChangeTwistieState","renderedNodes","Map","templateId","renderTemplate","container","templateData","renderElement","index","height","renderTwistie","twistieElement","classList","add","treeItemLoading","classNamesArray","remove","disposeElement","disposeTemplate","clear","asTreeEvent","browserEvent","elements","asTreeMouseEvent","target","AsyncDataTreeElementsDragAndDropData","data","asAsyncDataTreeDragAndDropData","AsyncDataTreeNodeListDragAndDrop","dnd","getDragURI","getDragLabel","nodes","originalEvent","onDragStart","onDragOver","targetNode","targetIndex","raw","drop","onDragEnd","asObjectTreeOptions","options","collapseByDefault","identityProvider","getId","el","multipleSelectionController","isSelectionSingleChangeEvent","isSelectionRangeChangeEvent","accessibilityProvider","getPosInSet","getSetSize","getRole","isChecked","_a","getAriaLabel","getWidgetAriaLabel","getWidgetRole","getAriaLevel","getActiveDescendantId","filter","parentVisibility","keyboardNavigationLabelProvider","getKeyboardNavigationLabel","sorter","expandOnlyOnTwistieClick","additionalScrollHeight","dfs","fn","forEach","child","AsyncDataTree","user","delegate","renderers","dataSource","subTreeRefreshPromises","refreshPromises","_onDidRender","_onDidChangeNodeSlowState","disposables","autoExpandSingleChildren","tree","createTree","root","hasChildren","id","set","onDidChangeCollapseState","_onDidChangeCollapseState","onDidChangeFocus","onDidChangeSelection","onMouseDblClick","onPointer","onDidFocus","onDidChangeModel","onDidDispose","objectTreeDelegate","objectTreeRenderers","r","event","objectTreeOptions","updateOptions","getHTMLElement","scrollTop","domFocus","layout","width","style","styles","getInput","setInput","input","viewState","promise","cancel","viewStateContext","focus","selection","_updateChildren","setFocus","setSelection","recursive","rerender","toPromise","getDataNode","refreshAndRenderNode","getNode","dataNode","collapse","expand","hasElement","isCollapsible","isCollapsed","getSelection","n","getFocus","reveal","relativeTop","getParentElement","getFirstElementChild","get","refreshNode","render","doRefreshSubTree","c","finally","delete","childrenToRefresh","doRefreshNode","settled","childrenPromise","empty","slowTimeout","fire","_","doGetChildren","setChildren","err","getChildren","processChildren","deep","catch","childrenElementsIterable","childrenElements","length","nodesToForget","childrenTreeNodesById","asyncDataTreeNode","push","toString","splice","childAsyncDataTreeNode","indexOf","expanded","values","asTreeElement","diffIdentityProvider","setCollapsible","sort","compare","bind","CompressibleAsyncDataTreeNodeWrapper","incompressible","CompressibleAsyncDataTreeRenderer","compressibleNodeMapperProvider","renderCompressedElements","disposeCompressedElements","asCompressibleObjectTreeOptions","getCompressedNodeKeyboardNavigationLabel","els","CompressibleAsyncDataTree","virtualDelegate","compressionDelegate","compressibleNodeMapper","isIncompressible","getUncompressedIds","Set","compressedNode","getCompressedTreeNode","oldSelection","oldFocus","didChangeSelection","didChangeFocus","visit","i","has","visibility","getVisibility","Error","filterResult"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { ComposedTreeDelegate } from './abstractTree.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { CompressibleObjectTree, ObjectTree } from './objectTree.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { createCancelablePromise, Promises, timeout } from '../../../common/async.js';\nimport { Codicon } from '../../../common/codicons.js';\nimport { isCancellationError, onUnexpectedError } from '../../../common/errors.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { DisposableStore, dispose } from '../../../common/lifecycle.js';\nfunction createAsyncDataTreeNode(props) {\n    return Object.assign(Object.assign({}, props), { children: [], refreshPromise: undefined, stale: true, slow: false, collapsedByDefault: undefined });\n}\nfunction isAncestor(ancestor, descendant) {\n    if (!descendant.parent) {\n        return false;\n    }\n    else if (descendant.parent === ancestor) {\n        return true;\n    }\n    else {\n        return isAncestor(ancestor, descendant.parent);\n    }\n}\nfunction intersects(node, other) {\n    return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\nclass AsyncDataTreeNodeWrapper {\n    constructor(node) {\n        this.node = node;\n    }\n    get element() { return this.node.element.element; }\n    get children() { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nclass AsyncDataTreeRenderer {\n    constructor(renderer, nodeMapper, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.nodeMapper = nodeMapper;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.templateId = renderer.templateId;\n    }\n    renderTemplate(container) {\n        const templateData = this.renderer.renderTemplate(container);\n        return { templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    renderTwistie(element, twistieElement) {\n        if (element.slow) {\n            twistieElement.classList.add(...Codicon.treeItemLoading.classNamesArray);\n            return true;\n        }\n        else {\n            twistieElement.classList.remove(...Codicon.treeItemLoading.classNamesArray);\n            return false;\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    dispose() {\n        this.renderedNodes.clear();\n    }\n}\nfunction asTreeEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        elements: e.elements.map(e => e.element)\n    };\n}\nfunction asTreeMouseEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        element: e.element && e.element.element,\n        target: e.target\n    };\n}\nclass AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {\n    constructor(data) {\n        super(data.elements.map(node => node.element));\n        this.data = data;\n    }\n}\nfunction asAsyncDataTreeDragAndDropData(data) {\n    if (data instanceof ElementsDragAndDropData) {\n        return new AsyncDataTreeElementsDragAndDropData(data);\n    }\n    return data;\n}\nclass AsyncDataTreeNodeListDragAndDrop {\n    constructor(dnd) {\n        this.dnd = dnd;\n    }\n    getDragURI(node) {\n        return this.dnd.getDragURI(node.element);\n    }\n    getDragLabel(nodes, originalEvent) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n        }\n        return undefined;\n    }\n    onDragStart(data, originalEvent) {\n        if (this.dnd.onDragStart) {\n            this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\n        }\n    }\n    onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {\n        return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    drop(data, targetNode, targetIndex, originalEvent) {\n        this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    }\n    onDragEnd(originalEvent) {\n        if (this.dnd.onDragEnd) {\n            this.dnd.onDragEnd(originalEvent);\n        }\n    }\n}\nfunction asObjectTreeOptions(options) {\n    return options && Object.assign(Object.assign({}, options), { collapseByDefault: true, identityProvider: options.identityProvider && {\n            getId(el) {\n                return options.identityProvider.getId(el.element);\n            }\n        }, dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd), multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            },\n            isSelectionRangeChangeEvent(e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\n            }\n        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getPosInSet: undefined, getSetSize: undefined, getRole: options.accessibilityProvider.getRole ? (el) => {\n                return options.accessibilityProvider.getRole(el.element);\n            } : () => 'treeitem', isChecked: options.accessibilityProvider.isChecked ? (e) => {\n                var _a;\n                return !!((_a = options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.isChecked(e.element));\n            } : undefined, getAriaLabel(e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            },\n            getWidgetAriaLabel() {\n                return options.accessibilityProvider.getWidgetAriaLabel();\n            }, getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n                return options.accessibilityProvider.getAriaLevel(node.element);\n            }), getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\n            }) }), filter: options.filter && {\n            filter(e, parentVisibility) {\n                return options.filter.filter(e.element, parentVisibility);\n            }\n        }, keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n            } }), sorter: undefined, expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (e => options.expandOnlyOnTwistieClick(e.element))), additionalScrollHeight: options.additionalScrollHeight });\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(child => dfs(child, fn));\n}\nexport class AsyncDataTree {\n    constructor(user, container, delegate, renderers, dataSource, options = {}) {\n        this.user = user;\n        this.dataSource = dataSource;\n        this.nodes = new Map();\n        this.subTreeRefreshPromises = new Map();\n        this.refreshPromises = new Map();\n        this._onDidRender = new Emitter();\n        this._onDidChangeNodeSlowState = new Emitter();\n        this.nodeMapper = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n        this.disposables = new DisposableStore();\n        this.identityProvider = options.identityProvider;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.sorter = options.sorter;\n        this.collapseByDefault = options.collapseByDefault;\n        this.tree = this.createTree(user, container, delegate, renderers, options);\n        this.root = createAsyncDataTreeNode({\n            element: undefined,\n            parent: null,\n            hasChildren: true\n        });\n        if (this.identityProvider) {\n            this.root = Object.assign(Object.assign({}, this.root), { id: null });\n        }\n        this.nodes.set(null, this.root);\n        this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n    }\n    get onDidChangeFocus() { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n    get onDidChangeSelection() { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n    get onMouseDblClick() { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n    get onPointer() { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\n    get onDidFocus() { return this.tree.onDidFocus; }\n    get onDidChangeModel() { return this.tree.onDidChangeModel; }\n    get onDidChangeCollapseState() { return this.tree.onDidChangeCollapseState; }\n    get onDidDispose() { return this.tree.onDidDispose; }\n    createTree(user, container, delegate, renderers, options) {\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n        const objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n        const objectTreeOptions = asObjectTreeOptions(options) || {};\n        return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    }\n    updateOptions(options = {}) {\n        this.tree.updateOptions(options);\n    }\n    // Widget\n    getHTMLElement() {\n        return this.tree.getHTMLElement();\n    }\n    get scrollTop() {\n        return this.tree.scrollTop;\n    }\n    set scrollTop(scrollTop) {\n        this.tree.scrollTop = scrollTop;\n    }\n    domFocus() {\n        this.tree.domFocus();\n    }\n    layout(height, width) {\n        this.tree.layout(height, width);\n    }\n    style(styles) {\n        this.tree.style(styles);\n    }\n    // Model\n    getInput() {\n        return this.root.element;\n    }\n    setInput(input, viewState) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.refreshPromises.forEach(promise => promise.cancel());\n            this.refreshPromises.clear();\n            this.root.element = input;\n            const viewStateContext = viewState && { viewState, focus: [], selection: [] };\n            yield this._updateChildren(input, true, false, viewStateContext);\n            if (viewStateContext) {\n                this.tree.setFocus(viewStateContext.focus);\n                this.tree.setSelection(viewStateContext.selection);\n            }\n            if (viewState && typeof viewState.scrollTop === 'number') {\n                this.scrollTop = viewState.scrollTop;\n            }\n        });\n    }\n    _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.root.element === 'undefined') {\n                throw new TreeError(this.user, 'Tree input not set');\n            }\n            if (this.root.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            const node = this.getDataNode(element);\n            yield this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n            if (rerender) {\n                try {\n                    this.tree.rerender(node);\n                }\n                catch (_a) {\n                    // missing nodes are fine, this could've resulted from\n                    // parallel refresh calls, removing `node` altogether\n                }\n            }\n        });\n    }\n    // View\n    rerender(element) {\n        if (element === undefined || element === this.root.element) {\n            this.tree.rerender();\n            return;\n        }\n        const node = this.getDataNode(element);\n        this.tree.rerender(node);\n    }\n    // Tree\n    getNode(element = this.root.element) {\n        const dataNode = this.getDataNode(element);\n        const node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n        return this.nodeMapper.map(node);\n    }\n    collapse(element, recursive = false) {\n        const node = this.getDataNode(element);\n        return this.tree.collapse(node === this.root ? null : node, recursive);\n    }\n    expand(element, recursive = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.root.element === 'undefined') {\n                throw new TreeError(this.user, 'Tree input not set');\n            }\n            if (this.root.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            const node = this.getDataNode(element);\n            if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n                return false;\n            }\n            if (node.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n                return false;\n            }\n            const result = this.tree.expand(node === this.root ? null : node, recursive);\n            if (node.refreshPromise) {\n                yield this.root.refreshPromise;\n                yield Event.toPromise(this._onDidRender.event);\n            }\n            return result;\n        });\n    }\n    setSelection(elements, browserEvent) {\n        const nodes = elements.map(e => this.getDataNode(e));\n        this.tree.setSelection(nodes, browserEvent);\n    }\n    getSelection() {\n        const nodes = this.tree.getSelection();\n        return nodes.map(n => n.element);\n    }\n    setFocus(elements, browserEvent) {\n        const nodes = elements.map(e => this.getDataNode(e));\n        this.tree.setFocus(nodes, browserEvent);\n    }\n    getFocus() {\n        const nodes = this.tree.getFocus();\n        return nodes.map(n => n.element);\n    }\n    reveal(element, relativeTop) {\n        this.tree.reveal(this.getDataNode(element), relativeTop);\n    }\n    // Tree navigation\n    getParentElement(element) {\n        const node = this.tree.getParentElement(this.getDataNode(element));\n        return (node && node.element);\n    }\n    getFirstElementChild(element = this.root.element) {\n        const dataNode = this.getDataNode(element);\n        const node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n        return (node && node.element);\n    }\n    // Implementation\n    getDataNode(element) {\n        const node = this.nodes.get((element === this.root.element ? null : element));\n        if (!node) {\n            throw new TreeError(this.user, `Data tree node not found: ${element}`);\n        }\n        return node;\n    }\n    refreshAndRenderNode(node, recursive, viewStateContext, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.refreshNode(node, recursive, viewStateContext);\n            this.render(node, viewStateContext, options);\n        });\n    }\n    refreshNode(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result;\n            this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n                if (!result && intersects(refreshNode, node)) {\n                    result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n                }\n            });\n            if (result) {\n                return result;\n            }\n            return this.doRefreshSubTree(node, recursive, viewStateContext);\n        });\n    }\n    doRefreshSubTree(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let done;\n            node.refreshPromise = new Promise(c => done = c);\n            this.subTreeRefreshPromises.set(node, node.refreshPromise);\n            node.refreshPromise.finally(() => {\n                node.refreshPromise = undefined;\n                this.subTreeRefreshPromises.delete(node);\n            });\n            try {\n                const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);\n                node.stale = false;\n                yield Promises.settled(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n            }\n            finally {\n                done();\n            }\n        });\n    }\n    doRefreshNode(node, recursive, viewStateContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            node.hasChildren = !!this.dataSource.hasChildren(node.element);\n            let childrenPromise;\n            if (!node.hasChildren) {\n                childrenPromise = Promise.resolve(Iterable.empty());\n            }\n            else {\n                const slowTimeout = timeout(800);\n                slowTimeout.then(() => {\n                    node.slow = true;\n                    this._onDidChangeNodeSlowState.fire(node);\n                }, _ => null);\n                childrenPromise = this.doGetChildren(node)\n                    .finally(() => slowTimeout.cancel());\n            }\n            try {\n                const children = yield childrenPromise;\n                return this.setChildren(node, children, recursive, viewStateContext);\n            }\n            catch (err) {\n                if (node !== this.root && this.tree.hasElement(node)) {\n                    this.tree.collapse(node);\n                }\n                if (isCancellationError(err)) {\n                    return [];\n                }\n                throw err;\n            }\n            finally {\n                if (node.slow) {\n                    node.slow = false;\n                    this._onDidChangeNodeSlowState.fire(node);\n                }\n            }\n        });\n    }\n    doGetChildren(node) {\n        let result = this.refreshPromises.get(node);\n        if (result) {\n            return result;\n        }\n        result = createCancelablePromise(() => __awaiter(this, void 0, void 0, function* () {\n            const children = yield this.dataSource.getChildren(node.element);\n            return this.processChildren(children);\n        }));\n        this.refreshPromises.set(node, result);\n        return result.finally(() => { this.refreshPromises.delete(node); });\n    }\n    _onDidChangeCollapseState({ node, deep }) {\n        if (node.element === null) {\n            return;\n        }\n        if (!node.collapsed && node.element.stale) {\n            if (deep) {\n                this.collapse(node.element.element);\n            }\n            else {\n                this.refreshAndRenderNode(node.element, false)\n                    .catch(onUnexpectedError);\n            }\n        }\n    }\n    setChildren(node, childrenElementsIterable, recursive, viewStateContext) {\n        const childrenElements = [...childrenElementsIterable];\n        // perf: if the node was and still is a leaf, avoid all this hassle\n        if (node.children.length === 0 && childrenElements.length === 0) {\n            return [];\n        }\n        const nodesToForget = new Map();\n        const childrenTreeNodesById = new Map();\n        for (const child of node.children) {\n            nodesToForget.set(child.element, child);\n            if (this.identityProvider) {\n                const collapsed = this.tree.isCollapsed(child);\n                childrenTreeNodesById.set(child.id, { node: child, collapsed });\n            }\n        }\n        const childrenToRefresh = [];\n        const children = childrenElements.map(element => {\n            const hasChildren = !!this.dataSource.hasChildren(element);\n            if (!this.identityProvider) {\n                const asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren });\n                if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                    asyncDataTreeNode.collapsedByDefault = false;\n                    childrenToRefresh.push(asyncDataTreeNode);\n                }\n                return asyncDataTreeNode;\n            }\n            const id = this.identityProvider.getId(element).toString();\n            const result = childrenTreeNodesById.get(id);\n            if (result) {\n                const asyncDataTreeNode = result.node;\n                nodesToForget.delete(asyncDataTreeNode.element);\n                this.nodes.delete(asyncDataTreeNode.element);\n                this.nodes.set(element, asyncDataTreeNode);\n                asyncDataTreeNode.element = element;\n                asyncDataTreeNode.hasChildren = hasChildren;\n                if (recursive) {\n                    if (result.collapsed) {\n                        asyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element)));\n                        asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n                        asyncDataTreeNode.stale = true;\n                    }\n                    else {\n                        childrenToRefresh.push(asyncDataTreeNode);\n                    }\n                }\n                else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                    asyncDataTreeNode.collapsedByDefault = false;\n                    childrenToRefresh.push(asyncDataTreeNode);\n                }\n                return asyncDataTreeNode;\n            }\n            const childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren });\n            if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n                viewStateContext.focus.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n                viewStateContext.selection.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n                childAsyncDataTreeNode.collapsedByDefault = false;\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            return childAsyncDataTreeNode;\n        });\n        for (const node of nodesToForget.values()) {\n            dfs(node, node => this.nodes.delete(node.element));\n        }\n        for (const child of children) {\n            this.nodes.set(child.element, child);\n        }\n        node.children.splice(0, node.children.length, ...children);\n        // TODO@joao this doesn't take filter into account\n        if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n            children[0].collapsedByDefault = false;\n            childrenToRefresh.push(children[0]);\n        }\n        return childrenToRefresh;\n    }\n    render(node, viewStateContext, options) {\n        const children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n        const objectTreeOptions = options && Object.assign(Object.assign({}, options), { diffIdentityProvider: options.diffIdentityProvider && {\n                getId(node) {\n                    return options.diffIdentityProvider.getId(node.element);\n                }\n            } });\n        this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n        if (node !== this.root) {\n            this.tree.setCollapsible(node, node.hasChildren);\n        }\n        this._onDidRender.fire();\n    }\n    asTreeElement(node, viewStateContext) {\n        if (node.stale) {\n            return {\n                element: node,\n                collapsible: node.hasChildren,\n                collapsed: true\n            };\n        }\n        let collapsed;\n        if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n            collapsed = false;\n        }\n        else {\n            collapsed = node.collapsedByDefault;\n        }\n        node.collapsedByDefault = undefined;\n        return {\n            element: node,\n            children: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n            collapsible: node.hasChildren,\n            collapsed\n        };\n    }\n    processChildren(children) {\n        if (this.sorter) {\n            children = [...children].sort(this.sorter.compare.bind(this.sorter));\n        }\n        return children;\n    }\n    dispose() {\n        this.disposables.dispose();\n    }\n}\nclass CompressibleAsyncDataTreeNodeWrapper {\n    constructor(node) {\n        this.node = node;\n    }\n    get element() {\n        return {\n            elements: this.node.element.elements.map(e => e.element),\n            incompressible: this.node.element.incompressible\n        };\n    }\n    get children() { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\n    get depth() { return this.node.depth; }\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\n    get collapsible() { return this.node.collapsible; }\n    get collapsed() { return this.node.collapsed; }\n    get visible() { return this.node.visible; }\n    get filterData() { return this.node.filterData; }\n}\nclass CompressibleAsyncDataTreeRenderer {\n    constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.nodeMapper = nodeMapper;\n        this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.disposables = [];\n        this.templateId = renderer.templateId;\n    }\n    renderTemplate(container) {\n        const templateData = this.renderer.renderTemplate(container);\n        return { templateData };\n    }\n    renderElement(node, index, templateData, height) {\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n    renderCompressedElements(node, index, templateData, height) {\n        this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n    }\n    renderTwistie(element, twistieElement) {\n        if (element.slow) {\n            twistieElement.classList.add(...Codicon.treeItemLoading.classNamesArray);\n            return true;\n        }\n        else {\n            twistieElement.classList.remove(...Codicon.treeItemLoading.classNamesArray);\n            return false;\n        }\n    }\n    disposeElement(node, index, templateData, height) {\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeCompressedElements(node, index, templateData, height) {\n        if (this.renderer.disposeCompressedElements) {\n            this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n        }\n    }\n    disposeTemplate(templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    }\n    dispose() {\n        this.renderedNodes.clear();\n        this.disposables = dispose(this.disposables);\n    }\n}\nfunction asCompressibleObjectTreeOptions(options) {\n    const objectTreeOptions = options && asObjectTreeOptions(options);\n    return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), { keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(els) {\n                return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));\n            } }) });\n}\nexport class CompressibleAsyncDataTree extends AsyncDataTree {\n    constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {\n        super(user, container, virtualDelegate, renderers, dataSource, options);\n        this.compressionDelegate = compressionDelegate;\n        this.compressibleNodeMapper = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n        this.filter = options.filter;\n    }\n    createTree(user, container, delegate, renderers, options) {\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n        const objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n        const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};\n        return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    }\n    asTreeElement(node, viewStateContext) {\n        return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(node.element) }, super.asTreeElement(node, viewStateContext));\n    }\n    updateOptions(options = {}) {\n        this.tree.updateOptions(options);\n    }\n    render(node, viewStateContext) {\n        if (!this.identityProvider) {\n            return super.render(node, viewStateContext);\n        }\n        // Preserve traits across compressions. Hacky but does the trick.\n        // This is hard to fix properly since it requires rewriting the traits\n        // across trees and lists. Let's just keep it this way for now.\n        const getId = (element) => this.identityProvider.getId(element).toString();\n        const getUncompressedIds = (nodes) => {\n            const result = new Set();\n            for (const node of nodes) {\n                const compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n                if (!compressedNode.element) {\n                    continue;\n                }\n                for (const node of compressedNode.element.elements) {\n                    result.add(getId(node.element));\n                }\n            }\n            return result;\n        };\n        const oldSelection = getUncompressedIds(this.tree.getSelection());\n        const oldFocus = getUncompressedIds(this.tree.getFocus());\n        super.render(node, viewStateContext);\n        const selection = this.getSelection();\n        let didChangeSelection = false;\n        const focus = this.getFocus();\n        let didChangeFocus = false;\n        const visit = (node) => {\n            const compressedNode = node.element;\n            if (compressedNode) {\n                for (let i = 0; i < compressedNode.elements.length; i++) {\n                    const id = getId(compressedNode.elements[i].element);\n                    const element = compressedNode.elements[compressedNode.elements.length - 1].element;\n                    // github.com/microsoft/vscode/issues/85938\n                    if (oldSelection.has(id) && selection.indexOf(element) === -1) {\n                        selection.push(element);\n                        didChangeSelection = true;\n                    }\n                    if (oldFocus.has(id) && focus.indexOf(element) === -1) {\n                        focus.push(element);\n                        didChangeFocus = true;\n                    }\n                }\n            }\n            node.children.forEach(visit);\n        };\n        visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n        if (didChangeSelection) {\n            this.setSelection(selection);\n        }\n        if (didChangeFocus) {\n            this.setFocus(focus);\n        }\n    }\n    // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n    // and we have to filter everything beforehand\n    // Related to #85193 and #85835\n    processChildren(children) {\n        if (this.filter) {\n            children = Iterable.filter(children, e => {\n                const result = this.filter.filter(e, 1 /* Visible */);\n                const visibility = getVisibility(result);\n                if (visibility === 2 /* Recurse */) {\n                    throw new Error('Recursive tree visibility not supported in async data compressed trees');\n                }\n                return visibility === 1 /* Visible */;\n            });\n        }\n        return super.processChildren(children);\n    }\n}\nfunction getVisibility(filterResult) {\n    if (typeof filterResult === 'boolean') {\n        return filterResult ? 1 /* Visible */ : 0 /* Hidden */;\n    }\n    else if (isFilterResult(filterResult)) {\n        return getVisibleState(filterResult.visibility);\n    }\n    else {\n        return getVisibleState(filterResult);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}