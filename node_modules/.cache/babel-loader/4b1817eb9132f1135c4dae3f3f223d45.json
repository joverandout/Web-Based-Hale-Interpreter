{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport Severity from '../../../base/common/severity.js';\nimport * as nls from '../../../nls.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\nconst DEBUG = false;\n\nfunction getResourceLabel(resource) {\n  return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\n}\n\nlet stackElementCounter = 0;\n\nclass ResourceStackElement {\n  constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\n    this.id = ++stackElementCounter;\n    this.type = 0\n    /* Resource */\n    ;\n    this.actual = actual;\n    this.label = actual.label;\n    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n    this.resourceLabel = resourceLabel;\n    this.strResource = strResource;\n    this.resourceLabels = [this.resourceLabel];\n    this.strResources = [this.strResource];\n    this.groupId = groupId;\n    this.groupOrder = groupOrder;\n    this.sourceId = sourceId;\n    this.sourceOrder = sourceOrder;\n    this.isValid = true;\n  }\n\n  setValid(isValid) {\n    this.isValid = isValid;\n  }\n\n  toString() {\n    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? '  VALID' : 'INVALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n  }\n\n}\n\nclass ResourceReasonPair {\n  constructor(resourceLabel, reason) {\n    this.resourceLabel = resourceLabel;\n    this.reason = reason;\n  }\n\n}\n\nclass RemovedResources {\n  constructor() {\n    this.elements = new Map();\n  }\n\n  createMessage() {\n    const externalRemoval = [];\n    const noParallelUniverses = [];\n\n    for (const [, element] of this.elements) {\n      const dest = element.reason === 0\n      /* ExternalRemoval */\n      ? externalRemoval : noParallelUniverses;\n      dest.push(element.resourceLabel);\n    }\n\n    let messages = [];\n\n    if (externalRemoval.length > 0) {\n      messages.push(nls.localize({\n        key: 'externalRemoval',\n        comment: ['{0} is a list of filenames']\n      }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\n    }\n\n    if (noParallelUniverses.length > 0) {\n      messages.push(nls.localize({\n        key: 'noParallelUniverses',\n        comment: ['{0} is a list of filenames']\n      }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\n    }\n\n    return messages.join('\\n');\n  }\n\n  get size() {\n    return this.elements.size;\n  }\n\n  has(strResource) {\n    return this.elements.has(strResource);\n  }\n\n  set(strResource, value) {\n    this.elements.set(strResource, value);\n  }\n\n  delete(strResource) {\n    return this.elements.delete(strResource);\n  }\n\n}\n\nclass WorkspaceStackElement {\n  constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\n    this.id = ++stackElementCounter;\n    this.type = 1\n    /* Workspace */\n    ;\n    this.actual = actual;\n    this.label = actual.label;\n    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n    this.resourceLabels = resourceLabels;\n    this.strResources = strResources;\n    this.groupId = groupId;\n    this.groupOrder = groupOrder;\n    this.sourceId = sourceId;\n    this.sourceOrder = sourceOrder;\n    this.removedResources = null;\n    this.invalidatedResources = null;\n  }\n\n  canSplit() {\n    return typeof this.actual.split === 'function';\n  }\n\n  removeResource(resourceLabel, strResource, reason) {\n    if (!this.removedResources) {\n      this.removedResources = new RemovedResources();\n    }\n\n    if (!this.removedResources.has(strResource)) {\n      this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\n    }\n  }\n\n  setValid(resourceLabel, strResource, isValid) {\n    if (isValid) {\n      if (this.invalidatedResources) {\n        this.invalidatedResources.delete(strResource);\n\n        if (this.invalidatedResources.size === 0) {\n          this.invalidatedResources = null;\n        }\n      }\n    } else {\n      if (!this.invalidatedResources) {\n        this.invalidatedResources = new RemovedResources();\n      }\n\n      if (!this.invalidatedResources.has(strResource)) {\n        this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0\n        /* ExternalRemoval */\n        ));\n      }\n    }\n  }\n\n  toString() {\n    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? 'INVALID' : '  VALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n  }\n\n}\n\nclass ResourceEditStack {\n  constructor(resourceLabel, strResource) {\n    this.resourceLabel = resourceLabel;\n    this.strResource = strResource;\n    this._past = [];\n    this._future = [];\n    this.locked = false;\n    this.versionId = 1;\n  }\n\n  dispose() {\n    for (const element of this._past) {\n      if (element.type === 1\n      /* Workspace */\n      ) {\n        element.removeResource(this.resourceLabel, this.strResource, 0\n        /* ExternalRemoval */\n        );\n      }\n    }\n\n    for (const element of this._future) {\n      if (element.type === 1\n      /* Workspace */\n      ) {\n        element.removeResource(this.resourceLabel, this.strResource, 0\n        /* ExternalRemoval */\n        );\n      }\n    }\n\n    this.versionId++;\n  }\n\n  toString() {\n    let result = [];\n    result.push(`* ${this.strResource}:`);\n\n    for (let i = 0; i < this._past.length; i++) {\n      result.push(`   * [UNDO] ${this._past[i]}`);\n    }\n\n    for (let i = this._future.length - 1; i >= 0; i--) {\n      result.push(`   * [REDO] ${this._future[i]}`);\n    }\n\n    return result.join('\\n');\n  }\n\n  flushAllElements() {\n    this._past = [];\n    this._future = [];\n    this.versionId++;\n  }\n\n  _setElementValidFlag(element, isValid) {\n    if (element.type === 1\n    /* Workspace */\n    ) {\n      element.setValid(this.resourceLabel, this.strResource, isValid);\n    } else {\n      element.setValid(isValid);\n    }\n  }\n\n  setElementsValidFlag(isValid, filter) {\n    for (const element of this._past) {\n      if (filter(element.actual)) {\n        this._setElementValidFlag(element, isValid);\n      }\n    }\n\n    for (const element of this._future) {\n      if (filter(element.actual)) {\n        this._setElementValidFlag(element, isValid);\n      }\n    }\n  }\n\n  pushElement(element) {\n    // remove the future\n    for (const futureElement of this._future) {\n      if (futureElement.type === 1\n      /* Workspace */\n      ) {\n        futureElement.removeResource(this.resourceLabel, this.strResource, 1\n        /* NoParallelUniverses */\n        );\n      }\n    }\n\n    this._future = [];\n\n    this._past.push(element);\n\n    this.versionId++;\n  }\n\n  createSnapshot(resource) {\n    const elements = [];\n\n    for (let i = 0, len = this._past.length; i < len; i++) {\n      elements.push(this._past[i].id);\n    }\n\n    for (let i = this._future.length - 1; i >= 0; i--) {\n      elements.push(this._future[i].id);\n    }\n\n    return new ResourceEditStackSnapshot(resource, elements);\n  }\n\n  restoreSnapshot(snapshot) {\n    const snapshotLength = snapshot.elements.length;\n    let isOK = true;\n    let snapshotIndex = 0;\n    let removePastAfter = -1;\n\n    for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\n      const element = this._past[i];\n\n      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n        isOK = false;\n        removePastAfter = 0;\n      }\n\n      if (!isOK && element.type === 1\n      /* Workspace */\n      ) {\n        element.removeResource(this.resourceLabel, this.strResource, 0\n        /* ExternalRemoval */\n        );\n      }\n    }\n\n    let removeFutureBefore = -1;\n\n    for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\n      const element = this._future[i];\n\n      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n        isOK = false;\n        removeFutureBefore = i;\n      }\n\n      if (!isOK && element.type === 1\n      /* Workspace */\n      ) {\n        element.removeResource(this.resourceLabel, this.strResource, 0\n        /* ExternalRemoval */\n        );\n      }\n    }\n\n    if (removePastAfter !== -1) {\n      this._past = this._past.slice(0, removePastAfter);\n    }\n\n    if (removeFutureBefore !== -1) {\n      this._future = this._future.slice(removeFutureBefore + 1);\n    }\n\n    this.versionId++;\n  }\n\n  getElements() {\n    const past = [];\n    const future = [];\n\n    for (const element of this._past) {\n      past.push(element.actual);\n    }\n\n    for (const element of this._future) {\n      future.push(element.actual);\n    }\n\n    return {\n      past,\n      future\n    };\n  }\n\n  getClosestPastElement() {\n    if (this._past.length === 0) {\n      return null;\n    }\n\n    return this._past[this._past.length - 1];\n  }\n\n  getSecondClosestPastElement() {\n    if (this._past.length < 2) {\n      return null;\n    }\n\n    return this._past[this._past.length - 2];\n  }\n\n  getClosestFutureElement() {\n    if (this._future.length === 0) {\n      return null;\n    }\n\n    return this._future[this._future.length - 1];\n  }\n\n  hasPastElements() {\n    return this._past.length > 0;\n  }\n\n  hasFutureElements() {\n    return this._future.length > 0;\n  }\n\n  splitPastWorkspaceElement(toRemove, individualMap) {\n    for (let j = this._past.length - 1; j >= 0; j--) {\n      if (this._past[j] === toRemove) {\n        if (individualMap.has(this.strResource)) {\n          // gets replaced\n          this._past[j] = individualMap.get(this.strResource);\n        } else {\n          // gets deleted\n          this._past.splice(j, 1);\n        }\n\n        break;\n      }\n    }\n\n    this.versionId++;\n  }\n\n  splitFutureWorkspaceElement(toRemove, individualMap) {\n    for (let j = this._future.length - 1; j >= 0; j--) {\n      if (this._future[j] === toRemove) {\n        if (individualMap.has(this.strResource)) {\n          // gets replaced\n          this._future[j] = individualMap.get(this.strResource);\n        } else {\n          // gets deleted\n          this._future.splice(j, 1);\n        }\n\n        break;\n      }\n    }\n\n    this.versionId++;\n  }\n\n  moveBackward(element) {\n    this._past.pop();\n\n    this._future.push(element);\n\n    this.versionId++;\n  }\n\n  moveForward(element) {\n    this._future.pop();\n\n    this._past.push(element);\n\n    this.versionId++;\n  }\n\n}\n\nclass EditStackSnapshot {\n  constructor(editStacks) {\n    this.editStacks = editStacks;\n    this._versionIds = [];\n\n    for (let i = 0, len = this.editStacks.length; i < len; i++) {\n      this._versionIds[i] = this.editStacks[i].versionId;\n    }\n  }\n\n  isValid() {\n    for (let i = 0, len = this.editStacks.length; i < len; i++) {\n      if (this._versionIds[i] !== this.editStacks[i].versionId) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nconst missingEditStack = new ResourceEditStack('', '');\nmissingEditStack.locked = true;\nlet UndoRedoService = class UndoRedoService {\n  constructor(_dialogService, _notificationService) {\n    this._dialogService = _dialogService;\n    this._notificationService = _notificationService;\n    this._editStacks = new Map();\n    this._uriComparisonKeyComputers = [];\n  }\n\n  getUriComparisonKey(resource) {\n    for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\n      if (uriComparisonKeyComputer[0] === resource.scheme) {\n        return uriComparisonKeyComputer[1].getComparisonKey(resource);\n      }\n    }\n\n    return resource.toString();\n  }\n\n  _print(label) {\n    console.log(`------------------------------------`);\n    console.log(`AFTER ${label}: `);\n    let str = [];\n\n    for (const element of this._editStacks) {\n      str.push(element[1].toString());\n    }\n\n    console.log(str.join('\\n'));\n  }\n\n  pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {\n    if (element.type === 0\n    /* Resource */\n    ) {\n      const resourceLabel = getResourceLabel(element.resource);\n      const strResource = this.getUriComparisonKey(element.resource);\n\n      this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\n    } else {\n      const seen = new Set();\n      const resourceLabels = [];\n      const strResources = [];\n\n      for (const resource of element.resources) {\n        const resourceLabel = getResourceLabel(resource);\n        const strResource = this.getUriComparisonKey(resource);\n\n        if (seen.has(strResource)) {\n          continue;\n        }\n\n        seen.add(strResource);\n        resourceLabels.push(resourceLabel);\n        strResources.push(strResource);\n      }\n\n      if (resourceLabels.length === 1) {\n        this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\n      } else {\n        this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\n      }\n    }\n\n    if (DEBUG) {\n      this._print('pushElement');\n    }\n  }\n\n  _pushElement(element) {\n    for (let i = 0, len = element.strResources.length; i < len; i++) {\n      const resourceLabel = element.resourceLabels[i];\n      const strResource = element.strResources[i];\n      let editStack;\n\n      if (this._editStacks.has(strResource)) {\n        editStack = this._editStacks.get(strResource);\n      } else {\n        editStack = new ResourceEditStack(resourceLabel, strResource);\n\n        this._editStacks.set(strResource, editStack);\n      }\n\n      editStack.pushElement(element);\n    }\n  }\n\n  getLastElement(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n\n      if (editStack.hasFutureElements()) {\n        return null;\n      }\n\n      const closestPastElement = editStack.getClosestPastElement();\n      return closestPastElement ? closestPastElement.actual : null;\n    }\n\n    return null;\n  }\n\n  _splitPastWorkspaceElement(toRemove, ignoreResources) {\n    const individualArr = toRemove.actual.split();\n    const individualMap = new Map();\n\n    for (const _element of individualArr) {\n      const resourceLabel = getResourceLabel(_element.resource);\n      const strResource = this.getUriComparisonKey(_element.resource);\n      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n      individualMap.set(element.strResource, element);\n    }\n\n    for (const strResource of toRemove.strResources) {\n      if (ignoreResources && ignoreResources.has(strResource)) {\n        continue;\n      }\n\n      const editStack = this._editStacks.get(strResource);\n\n      editStack.splitPastWorkspaceElement(toRemove, individualMap);\n    }\n  }\n\n  _splitFutureWorkspaceElement(toRemove, ignoreResources) {\n    const individualArr = toRemove.actual.split();\n    const individualMap = new Map();\n\n    for (const _element of individualArr) {\n      const resourceLabel = getResourceLabel(_element.resource);\n      const strResource = this.getUriComparisonKey(_element.resource);\n      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n      individualMap.set(element.strResource, element);\n    }\n\n    for (const strResource of toRemove.strResources) {\n      if (ignoreResources && ignoreResources.has(strResource)) {\n        continue;\n      }\n\n      const editStack = this._editStacks.get(strResource);\n\n      editStack.splitFutureWorkspaceElement(toRemove, individualMap);\n    }\n  }\n\n  removeElements(resource) {\n    const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\n\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n\n      editStack.dispose();\n\n      this._editStacks.delete(strResource);\n    }\n\n    if (DEBUG) {\n      this._print('removeElements');\n    }\n  }\n\n  setElementsValidFlag(resource, isValid, filter) {\n    const strResource = this.getUriComparisonKey(resource);\n\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n\n      editStack.setElementsValidFlag(isValid, filter);\n    }\n\n    if (DEBUG) {\n      this._print('setElementsValidFlag');\n    }\n  }\n\n  createSnapshot(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n\n      return editStack.createSnapshot(resource);\n    }\n\n    return new ResourceEditStackSnapshot(resource, []);\n  }\n\n  restoreSnapshot(snapshot) {\n    const strResource = this.getUriComparisonKey(snapshot.resource);\n\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n\n      editStack.restoreSnapshot(snapshot);\n\n      if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\n        // the edit stack is now empty, just remove it entirely\n        editStack.dispose();\n\n        this._editStacks.delete(strResource);\n      }\n    }\n\n    if (DEBUG) {\n      this._print('restoreSnapshot');\n    }\n  }\n\n  getElements(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n\n      return editStack.getElements();\n    }\n\n    return {\n      past: [],\n      future: []\n    };\n  }\n\n  _findClosestUndoElementWithSource(sourceId) {\n    if (!sourceId) {\n      return [null, null];\n    } // find an element with the sourceId and with the highest sourceOrder ready to be undone\n\n\n    let matchedElement = null;\n    let matchedStrResource = null;\n\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestPastElement();\n\n      if (!candidate) {\n        continue;\n      }\n\n      if (candidate.sourceId === sourceId) {\n        if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n\n    return [matchedElement, matchedStrResource];\n  }\n\n  canUndo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n\n      return matchedStrResource ? true : false;\n    }\n\n    const strResource = this.getUriComparisonKey(resourceOrSource);\n\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n\n      return editStack.hasPastElements();\n    }\n\n    return false;\n  }\n\n  _onError(err, element) {\n    onUnexpectedError(err); // An error occurred while undoing or redoing => drop the undo/redo stack for all affected resources\n\n    for (const strResource of element.strResources) {\n      this.removeElements(strResource);\n    }\n\n    this._notificationService.error(err);\n  }\n\n  _acquireLocks(editStackSnapshot) {\n    // first, check if all locks can be acquired\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        throw new Error('Cannot acquire edit stack lock');\n      }\n    } // can acquire all locks\n\n\n    for (const editStack of editStackSnapshot.editStacks) {\n      editStack.locked = true;\n    }\n\n    return () => {\n      // release all locks\n      for (const editStack of editStackSnapshot.editStacks) {\n        editStack.locked = false;\n      }\n    };\n  }\n\n  _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\n    const releaseLocks = this._acquireLocks(editStackSnapshot);\n\n    let result;\n\n    try {\n      result = invoke();\n    } catch (err) {\n      releaseLocks();\n      cleanup.dispose();\n      return this._onError(err, element);\n    }\n\n    if (result) {\n      // result is Promise<void>\n      return result.then(() => {\n        releaseLocks();\n        cleanup.dispose();\n        return continuation();\n      }, err => {\n        releaseLocks();\n        cleanup.dispose();\n        return this._onError(err, element);\n      });\n    } else {\n      // result is void\n      releaseLocks();\n      cleanup.dispose();\n      return continuation();\n    }\n  }\n\n  _invokeWorkspacePrepare(element) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof element.actual.prepareUndoRedo === 'undefined') {\n        return Disposable.None;\n      }\n\n      const result = element.actual.prepareUndoRedo();\n\n      if (typeof result === 'undefined') {\n        return Disposable.None;\n      }\n\n      return result;\n    });\n  }\n\n  _invokeResourcePrepare(element, callback) {\n    if (element.actual.type !== 1\n    /* Workspace */\n    || typeof element.actual.prepareUndoRedo === 'undefined') {\n      // no preparation needed\n      return callback(Disposable.None);\n    }\n\n    const r = element.actual.prepareUndoRedo();\n\n    if (!r) {\n      // nothing to clean up\n      return callback(Disposable.None);\n    }\n\n    if (isDisposable(r)) {\n      return callback(r);\n    }\n\n    return r.then(disposable => {\n      return callback(disposable);\n    });\n  }\n\n  _getAffectedEditStacks(element) {\n    const affectedEditStacks = [];\n\n    for (const strResource of element.strResources) {\n      affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\n    }\n\n    return new EditStackSnapshot(affectedEditStacks);\n  }\n\n  _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\n    if (element.canSplit()) {\n      this._splitPastWorkspaceElement(element, ignoreResources);\n\n      this._notificationService.warn(message);\n\n      return new WorkspaceVerificationError(this._undo(strResource, 0, true));\n    } else {\n      // Cannot safely split this workspace element => flush all undo/redo stacks\n      for (const strResource of element.strResources) {\n        this.removeElements(strResource);\n      }\n\n      this._notificationService.warn(message);\n\n      return new WorkspaceVerificationError();\n    }\n  }\n\n  _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n    if (element.removedResources) {\n      return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({\n        key: 'cannotWorkspaceUndo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n    }\n\n    if (checkInvalidatedResources && element.invalidatedResources) {\n      return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({\n        key: 'cannotWorkspaceUndo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n    } // this must be the last past element in all the impacted resources!\n\n\n    const cannotUndoDueToResources = [];\n\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.getClosestPastElement() !== element) {\n        cannotUndoDueToResources.push(editStack.resourceLabel);\n      }\n    }\n\n    if (cannotUndoDueToResources.length > 0) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToChanges',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\n    }\n\n    const cannotLockDueToResources = [];\n\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        cannotLockDueToResources.push(editStack.resourceLabel);\n      }\n    }\n\n    if (cannotLockDueToResources.length > 0) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n    } // check if new stack elements were added in the meantime...\n\n\n    if (!editStackSnapshot.isValid()) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n    }\n\n    return null;\n  }\n\n  _workspaceUndo(strResource, element, undoConfirmed) {\n    const affectedEditStacks = this._getAffectedEditStacks(element);\n\n    const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks,\n    /*invalidated resources will be checked after the prepare call*/\n    false);\n\n    if (verificationError) {\n      return verificationError.returnValue;\n    }\n\n    return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\n  }\n\n  _isPartOfUndoGroup(element) {\n    if (!element.groupId) {\n      return false;\n    } // check that there is at least another element with the same groupId ready to be undone\n\n\n    for (const [, editStack] of this._editStacks) {\n      const pastElement = editStack.getClosestPastElement();\n\n      if (!pastElement) {\n        continue;\n      }\n\n      if (pastElement === element) {\n        const secondPastElement = editStack.getSecondClosestPastElement();\n\n        if (secondPastElement && secondPastElement.groupId === element.groupId) {\n          // there is another element with the same group id in the same stack!\n          return true;\n        }\n      }\n\n      if (pastElement.groupId === element.groupId) {\n        // there is another element with the same group id in another stack!\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\n        // this element can be split\n        const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label), [nls.localize({\n          key: 'ok',\n          comment: ['{0} denotes a number that is > 1']\n        }, \"Undo in {0} Files\", editStackSnapshot.editStacks.length), nls.localize('nok', \"Undo this File\"), nls.localize('cancel', \"Cancel\")], {\n          cancelId: 2\n        });\n\n        if (result.choice === 2) {\n          // choice: cancel\n          return;\n        }\n\n        if (result.choice === 1) {\n          // choice: undo this file\n          this._splitPastWorkspaceElement(element, null);\n\n          return this._undo(strResource, 0, true);\n        } // choice: undo in all files\n        // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\n\n\n        const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot,\n        /*invalidated resources will be checked after the prepare call*/\n        false);\n\n        if (verificationError1) {\n          return verificationError1.returnValue;\n        }\n\n        undoConfirmed = true;\n      } // prepare\n\n\n      let cleanup;\n\n      try {\n        cleanup = yield this._invokeWorkspacePrepare(element);\n      } catch (err) {\n        return this._onError(err, element);\n      } // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n\n\n      const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot,\n      /*now also check that there are no more invalidated resources*/\n      true);\n\n      if (verificationError2) {\n        cleanup.dispose();\n        return verificationError2.returnValue;\n      }\n\n      for (const editStack of editStackSnapshot.editStacks) {\n        editStack.moveBackward(element);\n      }\n\n      return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n    });\n  }\n\n  _resourceUndo(editStack, element, undoConfirmed) {\n    if (!element.isValid) {\n      // invalid element => immediately flush edit stack!\n      editStack.flushAllElements();\n      return;\n    }\n\n    if (editStack.locked) {\n      const message = nls.localize({\n        key: 'cannotResourceUndoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation.']\n      }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\n\n      this._notificationService.warn(message);\n\n      return;\n    }\n\n    return this._invokeResourcePrepare(element, cleanup => {\n      editStack.moveBackward(element);\n      return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n    });\n  }\n\n  _findClosestUndoElementInGroup(groupId) {\n    if (!groupId) {\n      return [null, null];\n    } // find another element with the same groupId and with the highest groupOrder ready to be undone\n\n\n    let matchedElement = null;\n    let matchedStrResource = null;\n\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestPastElement();\n\n      if (!candidate) {\n        continue;\n      }\n\n      if (candidate.groupId === groupId) {\n        if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n\n    return [matchedElement, matchedStrResource];\n  }\n\n  _continueUndoInGroup(groupId, undoConfirmed) {\n    if (!groupId) {\n      return;\n    }\n\n    const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\n\n    if (matchedStrResource) {\n      return this._undo(matchedStrResource, 0, undoConfirmed);\n    }\n  }\n\n  undo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n\n      return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\n    }\n\n    if (typeof resourceOrSource === 'string') {\n      return this._undo(resourceOrSource, 0, false);\n    }\n\n    return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\n  }\n\n  _undo(strResource, sourceId = 0, undoConfirmed) {\n    if (!this._editStacks.has(strResource)) {\n      return;\n    }\n\n    const editStack = this._editStacks.get(strResource);\n\n    const element = editStack.getClosestPastElement();\n\n    if (!element) {\n      return;\n    }\n\n    if (element.groupId) {\n      // this element is a part of a group, we need to make sure undoing in a group is in order\n      const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\n\n      if (element !== matchedElement && matchedStrResource) {\n        // there is an element in the same group that should be undone before this one\n        return this._undo(matchedStrResource, sourceId, undoConfirmed);\n      }\n    }\n\n    const shouldPromptForConfirmation = element.sourceId !== sourceId || element.confirmBeforeUndo;\n\n    if (shouldPromptForConfirmation && !undoConfirmed) {\n      // Hit a different source or the element asks for prompt before undo, prompt for confirmation\n      return this._confirmAndContinueUndo(strResource, sourceId, element);\n    }\n\n    try {\n      if (element.type === 1\n      /* Workspace */\n      ) {\n        return this._workspaceUndo(strResource, element, undoConfirmed);\n      } else {\n        return this._resourceUndo(editStack, element, undoConfirmed);\n      }\n    } finally {\n      if (DEBUG) {\n        this._print('undo');\n      }\n    }\n  }\n\n  _confirmAndContinueUndo(strResource, sourceId, element) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label), [nls.localize('confirmDifferentSource.yes', \"Yes\"), nls.localize('confirmDifferentSource.no', \"No\")], {\n        cancelId: 1\n      });\n\n      if (result.choice === 1) {\n        // choice: cancel\n        return;\n      } // choice: undo\n\n\n      return this._undo(strResource, sourceId, true);\n    });\n  }\n\n  _findClosestRedoElementWithSource(sourceId) {\n    if (!sourceId) {\n      return [null, null];\n    } // find an element with sourceId and with the lowest sourceOrder ready to be redone\n\n\n    let matchedElement = null;\n    let matchedStrResource = null;\n\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestFutureElement();\n\n      if (!candidate) {\n        continue;\n      }\n\n      if (candidate.sourceId === sourceId) {\n        if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n\n    return [matchedElement, matchedStrResource];\n  }\n\n  canRedo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n\n      return matchedStrResource ? true : false;\n    }\n\n    const strResource = this.getUriComparisonKey(resourceOrSource);\n\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n\n      return editStack.hasFutureElements();\n    }\n\n    return false;\n  }\n\n  _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\n    if (element.canSplit()) {\n      this._splitFutureWorkspaceElement(element, ignoreResources);\n\n      this._notificationService.warn(message);\n\n      return new WorkspaceVerificationError(this._redo(strResource));\n    } else {\n      // Cannot safely split this workspace element => flush all undo/redo stacks\n      for (const strResource of element.strResources) {\n        this.removeElements(strResource);\n      }\n\n      this._notificationService.warn(message);\n\n      return new WorkspaceVerificationError();\n    }\n  }\n\n  _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n    if (element.removedResources) {\n      return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({\n        key: 'cannotWorkspaceRedo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n    }\n\n    if (checkInvalidatedResources && element.invalidatedResources) {\n      return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({\n        key: 'cannotWorkspaceRedo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n    } // this must be the last future element in all the impacted resources!\n\n\n    const cannotRedoDueToResources = [];\n\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.getClosestFutureElement() !== element) {\n        cannotRedoDueToResources.push(editStack.resourceLabel);\n      }\n    }\n\n    if (cannotRedoDueToResources.length > 0) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToChanges',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\n    }\n\n    const cannotLockDueToResources = [];\n\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        cannotLockDueToResources.push(editStack.resourceLabel);\n      }\n    }\n\n    if (cannotLockDueToResources.length > 0) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n    } // check if new stack elements were added in the meantime...\n\n\n    if (!editStackSnapshot.isValid()) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n    }\n\n    return null;\n  }\n\n  _workspaceRedo(strResource, element) {\n    const affectedEditStacks = this._getAffectedEditStacks(element);\n\n    const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks,\n    /*invalidated resources will be checked after the prepare call*/\n    false);\n\n    if (verificationError) {\n      return verificationError.returnValue;\n    }\n\n    return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\n  }\n\n  _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // prepare\n      let cleanup;\n\n      try {\n        cleanup = yield this._invokeWorkspacePrepare(element);\n      } catch (err) {\n        return this._onError(err, element);\n      } // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n\n\n      const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot,\n      /*now also check that there are no more invalidated resources*/\n      true);\n\n      if (verificationError) {\n        cleanup.dispose();\n        return verificationError.returnValue;\n      }\n\n      for (const editStack of editStackSnapshot.editStacks) {\n        editStack.moveForward(element);\n      }\n\n      return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\n    });\n  }\n\n  _resourceRedo(editStack, element) {\n    if (!element.isValid) {\n      // invalid element => immediately flush edit stack!\n      editStack.flushAllElements();\n      return;\n    }\n\n    if (editStack.locked) {\n      const message = nls.localize({\n        key: 'cannotResourceRedoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation.']\n      }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\n\n      this._notificationService.warn(message);\n\n      return;\n    }\n\n    return this._invokeResourcePrepare(element, cleanup => {\n      editStack.moveForward(element);\n      return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\n    });\n  }\n\n  _findClosestRedoElementInGroup(groupId) {\n    if (!groupId) {\n      return [null, null];\n    } // find another element with the same groupId and with the lowest groupOrder ready to be redone\n\n\n    let matchedElement = null;\n    let matchedStrResource = null;\n\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestFutureElement();\n\n      if (!candidate) {\n        continue;\n      }\n\n      if (candidate.groupId === groupId) {\n        if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n\n    return [matchedElement, matchedStrResource];\n  }\n\n  _continueRedoInGroup(groupId) {\n    if (!groupId) {\n      return;\n    }\n\n    const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\n\n    if (matchedStrResource) {\n      return this._redo(matchedStrResource);\n    }\n  }\n\n  redo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n\n      return matchedStrResource ? this._redo(matchedStrResource) : undefined;\n    }\n\n    if (typeof resourceOrSource === 'string') {\n      return this._redo(resourceOrSource);\n    }\n\n    return this._redo(this.getUriComparisonKey(resourceOrSource));\n  }\n\n  _redo(strResource) {\n    if (!this._editStacks.has(strResource)) {\n      return;\n    }\n\n    const editStack = this._editStacks.get(strResource);\n\n    const element = editStack.getClosestFutureElement();\n\n    if (!element) {\n      return;\n    }\n\n    if (element.groupId) {\n      // this element is a part of a group, we need to make sure redoing in a group is in order\n      const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\n\n      if (element !== matchedElement && matchedStrResource) {\n        // there is an element in the same group that should be redone before this one\n        return this._redo(matchedStrResource);\n      }\n    }\n\n    try {\n      if (element.type === 1\n      /* Workspace */\n      ) {\n        return this._workspaceRedo(strResource, element);\n      } else {\n        return this._resourceRedo(editStack, element);\n      }\n    } finally {\n      if (DEBUG) {\n        this._print('redo');\n      }\n    }\n  }\n\n};\nUndoRedoService = __decorate([__param(0, IDialogService), __param(1, INotificationService)], UndoRedoService);\nexport { UndoRedoService };\n\nclass WorkspaceVerificationError {\n  constructor(returnValue) {\n    this.returnValue = returnValue;\n  }\n\n}\n\nregisterSingleton(IUndoRedoService, UndoRedoService);","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","onUnexpectedError","Disposable","isDisposable","Schemas","Severity","nls","IDialogService","registerSingleton","INotificationService","IUndoRedoService","ResourceEditStackSnapshot","UndoRedoGroup","UndoRedoSource","DEBUG","getResourceLabel","resource","scheme","file","fsPath","path","stackElementCounter","ResourceStackElement","constructor","actual","resourceLabel","strResource","groupId","groupOrder","sourceId","sourceOrder","id","type","label","confirmBeforeUndo","resourceLabels","strResources","isValid","setValid","toString","name","ResourceReasonPair","reason","RemovedResources","elements","Map","createMessage","externalRemoval","noParallelUniverses","element","dest","push","messages","localize","comment","join","size","has","set","delete","WorkspaceStackElement","removedResources","invalidatedResources","canSplit","split","removeResource","ResourceEditStack","_past","_future","locked","versionId","dispose","flushAllElements","_setElementValidFlag","setElementsValidFlag","filter","pushElement","futureElement","createSnapshot","len","restoreSnapshot","snapshot","snapshotLength","isOK","snapshotIndex","removePastAfter","removeFutureBefore","slice","getElements","past","future","getClosestPastElement","getSecondClosestPastElement","getClosestFutureElement","hasPastElements","hasFutureElements","splitPastWorkspaceElement","toRemove","individualMap","j","get","splice","splitFutureWorkspaceElement","moveBackward","pop","moveForward","EditStackSnapshot","editStacks","_versionIds","missingEditStack","UndoRedoService","_dialogService","_notificationService","_editStacks","_uriComparisonKeyComputers","getUriComparisonKey","uriComparisonKeyComputer","getComparisonKey","_print","console","log","str","group","None","source","_pushElement","nextOrder","seen","Set","resources","add","editStack","getLastElement","closestPastElement","_splitPastWorkspaceElement","ignoreResources","individualArr","_element","_splitFutureWorkspaceElement","removeElements","_findClosestUndoElementWithSource","matchedElement","matchedStrResource","candidate","canUndo","resourceOrSource","_onError","err","error","_acquireLocks","editStackSnapshot","Error","_safeInvokeWithLocks","invoke","cleanup","continuation","releaseLocks","_invokeWorkspacePrepare","prepareUndoRedo","_invokeResourcePrepare","callback","disposable","_getAffectedEditStacks","affectedEditStacks","_tryToSplitAndUndo","message","warn","WorkspaceVerificationError","_undo","_checkWorkspaceUndo","checkInvalidatedResources","cannotUndoDueToResources","cannotLockDueToResources","_workspaceUndo","undoConfirmed","verificationError","returnValue","_confirmAndExecuteWorkspaceUndo","_isPartOfUndoGroup","pastElement","secondPastElement","show","Info","cancelId","choice","verificationError1","verificationError2","undo","_continueUndoInGroup","_resourceUndo","_findClosestUndoElementInGroup","undefined","shouldPromptForConfirmation","_confirmAndContinueUndo","_findClosestRedoElementWithSource","canRedo","_tryToSplitAndRedo","_redo","_checkWorkspaceRedo","cannotRedoDueToResources","_workspaceRedo","_executeWorkspaceRedo","redo","_continueRedoInGroup","_resourceRedo","_findClosestRedoElementInGroup"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport Severity from '../../../base/common/severity.js';\nimport * as nls from '../../../nls.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\nconst DEBUG = false;\nfunction getResourceLabel(resource) {\n    return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\n}\nlet stackElementCounter = 0;\nclass ResourceStackElement {\n    constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\n        this.id = (++stackElementCounter);\n        this.type = 0 /* Resource */;\n        this.actual = actual;\n        this.label = actual.label;\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n        this.resourceLabel = resourceLabel;\n        this.strResource = strResource;\n        this.resourceLabels = [this.resourceLabel];\n        this.strResources = [this.strResource];\n        this.groupId = groupId;\n        this.groupOrder = groupOrder;\n        this.sourceId = sourceId;\n        this.sourceOrder = sourceOrder;\n        this.isValid = true;\n    }\n    setValid(isValid) {\n        this.isValid = isValid;\n    }\n    toString() {\n        return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? '  VALID' : 'INVALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n    }\n}\nclass ResourceReasonPair {\n    constructor(resourceLabel, reason) {\n        this.resourceLabel = resourceLabel;\n        this.reason = reason;\n    }\n}\nclass RemovedResources {\n    constructor() {\n        this.elements = new Map();\n    }\n    createMessage() {\n        const externalRemoval = [];\n        const noParallelUniverses = [];\n        for (const [, element] of this.elements) {\n            const dest = (element.reason === 0 /* ExternalRemoval */\n                ? externalRemoval\n                : noParallelUniverses);\n            dest.push(element.resourceLabel);\n        }\n        let messages = [];\n        if (externalRemoval.length > 0) {\n            messages.push(nls.localize({ key: 'externalRemoval', comment: ['{0} is a list of filenames'] }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\n        }\n        if (noParallelUniverses.length > 0) {\n            messages.push(nls.localize({ key: 'noParallelUniverses', comment: ['{0} is a list of filenames'] }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\n        }\n        return messages.join('\\n');\n    }\n    get size() {\n        return this.elements.size;\n    }\n    has(strResource) {\n        return this.elements.has(strResource);\n    }\n    set(strResource, value) {\n        this.elements.set(strResource, value);\n    }\n    delete(strResource) {\n        return this.elements.delete(strResource);\n    }\n}\nclass WorkspaceStackElement {\n    constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\n        this.id = (++stackElementCounter);\n        this.type = 1 /* Workspace */;\n        this.actual = actual;\n        this.label = actual.label;\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n        this.resourceLabels = resourceLabels;\n        this.strResources = strResources;\n        this.groupId = groupId;\n        this.groupOrder = groupOrder;\n        this.sourceId = sourceId;\n        this.sourceOrder = sourceOrder;\n        this.removedResources = null;\n        this.invalidatedResources = null;\n    }\n    canSplit() {\n        return (typeof this.actual.split === 'function');\n    }\n    removeResource(resourceLabel, strResource, reason) {\n        if (!this.removedResources) {\n            this.removedResources = new RemovedResources();\n        }\n        if (!this.removedResources.has(strResource)) {\n            this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\n        }\n    }\n    setValid(resourceLabel, strResource, isValid) {\n        if (isValid) {\n            if (this.invalidatedResources) {\n                this.invalidatedResources.delete(strResource);\n                if (this.invalidatedResources.size === 0) {\n                    this.invalidatedResources = null;\n                }\n            }\n        }\n        else {\n            if (!this.invalidatedResources) {\n                this.invalidatedResources = new RemovedResources();\n            }\n            if (!this.invalidatedResources.has(strResource)) {\n                this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0 /* ExternalRemoval */));\n            }\n        }\n    }\n    toString() {\n        return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? 'INVALID' : '  VALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n    }\n}\nclass ResourceEditStack {\n    constructor(resourceLabel, strResource) {\n        this.resourceLabel = resourceLabel;\n        this.strResource = strResource;\n        this._past = [];\n        this._future = [];\n        this.locked = false;\n        this.versionId = 1;\n    }\n    dispose() {\n        for (const element of this._past) {\n            if (element.type === 1 /* Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\n            }\n        }\n        for (const element of this._future) {\n            if (element.type === 1 /* Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\n            }\n        }\n        this.versionId++;\n    }\n    toString() {\n        let result = [];\n        result.push(`* ${this.strResource}:`);\n        for (let i = 0; i < this._past.length; i++) {\n            result.push(`   * [UNDO] ${this._past[i]}`);\n        }\n        for (let i = this._future.length - 1; i >= 0; i--) {\n            result.push(`   * [REDO] ${this._future[i]}`);\n        }\n        return result.join('\\n');\n    }\n    flushAllElements() {\n        this._past = [];\n        this._future = [];\n        this.versionId++;\n    }\n    _setElementValidFlag(element, isValid) {\n        if (element.type === 1 /* Workspace */) {\n            element.setValid(this.resourceLabel, this.strResource, isValid);\n        }\n        else {\n            element.setValid(isValid);\n        }\n    }\n    setElementsValidFlag(isValid, filter) {\n        for (const element of this._past) {\n            if (filter(element.actual)) {\n                this._setElementValidFlag(element, isValid);\n            }\n        }\n        for (const element of this._future) {\n            if (filter(element.actual)) {\n                this._setElementValidFlag(element, isValid);\n            }\n        }\n    }\n    pushElement(element) {\n        // remove the future\n        for (const futureElement of this._future) {\n            if (futureElement.type === 1 /* Workspace */) {\n                futureElement.removeResource(this.resourceLabel, this.strResource, 1 /* NoParallelUniverses */);\n            }\n        }\n        this._future = [];\n        this._past.push(element);\n        this.versionId++;\n    }\n    createSnapshot(resource) {\n        const elements = [];\n        for (let i = 0, len = this._past.length; i < len; i++) {\n            elements.push(this._past[i].id);\n        }\n        for (let i = this._future.length - 1; i >= 0; i--) {\n            elements.push(this._future[i].id);\n        }\n        return new ResourceEditStackSnapshot(resource, elements);\n    }\n    restoreSnapshot(snapshot) {\n        const snapshotLength = snapshot.elements.length;\n        let isOK = true;\n        let snapshotIndex = 0;\n        let removePastAfter = -1;\n        for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\n            const element = this._past[i];\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n                isOK = false;\n                removePastAfter = 0;\n            }\n            if (!isOK && element.type === 1 /* Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\n            }\n        }\n        let removeFutureBefore = -1;\n        for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\n            const element = this._future[i];\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n                isOK = false;\n                removeFutureBefore = i;\n            }\n            if (!isOK && element.type === 1 /* Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\n            }\n        }\n        if (removePastAfter !== -1) {\n            this._past = this._past.slice(0, removePastAfter);\n        }\n        if (removeFutureBefore !== -1) {\n            this._future = this._future.slice(removeFutureBefore + 1);\n        }\n        this.versionId++;\n    }\n    getElements() {\n        const past = [];\n        const future = [];\n        for (const element of this._past) {\n            past.push(element.actual);\n        }\n        for (const element of this._future) {\n            future.push(element.actual);\n        }\n        return { past, future };\n    }\n    getClosestPastElement() {\n        if (this._past.length === 0) {\n            return null;\n        }\n        return this._past[this._past.length - 1];\n    }\n    getSecondClosestPastElement() {\n        if (this._past.length < 2) {\n            return null;\n        }\n        return this._past[this._past.length - 2];\n    }\n    getClosestFutureElement() {\n        if (this._future.length === 0) {\n            return null;\n        }\n        return this._future[this._future.length - 1];\n    }\n    hasPastElements() {\n        return (this._past.length > 0);\n    }\n    hasFutureElements() {\n        return (this._future.length > 0);\n    }\n    splitPastWorkspaceElement(toRemove, individualMap) {\n        for (let j = this._past.length - 1; j >= 0; j--) {\n            if (this._past[j] === toRemove) {\n                if (individualMap.has(this.strResource)) {\n                    // gets replaced\n                    this._past[j] = individualMap.get(this.strResource);\n                }\n                else {\n                    // gets deleted\n                    this._past.splice(j, 1);\n                }\n                break;\n            }\n        }\n        this.versionId++;\n    }\n    splitFutureWorkspaceElement(toRemove, individualMap) {\n        for (let j = this._future.length - 1; j >= 0; j--) {\n            if (this._future[j] === toRemove) {\n                if (individualMap.has(this.strResource)) {\n                    // gets replaced\n                    this._future[j] = individualMap.get(this.strResource);\n                }\n                else {\n                    // gets deleted\n                    this._future.splice(j, 1);\n                }\n                break;\n            }\n        }\n        this.versionId++;\n    }\n    moveBackward(element) {\n        this._past.pop();\n        this._future.push(element);\n        this.versionId++;\n    }\n    moveForward(element) {\n        this._future.pop();\n        this._past.push(element);\n        this.versionId++;\n    }\n}\nclass EditStackSnapshot {\n    constructor(editStacks) {\n        this.editStacks = editStacks;\n        this._versionIds = [];\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\n            this._versionIds[i] = this.editStacks[i].versionId;\n        }\n    }\n    isValid() {\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\n            if (this._versionIds[i] !== this.editStacks[i].versionId) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nconst missingEditStack = new ResourceEditStack('', '');\nmissingEditStack.locked = true;\nlet UndoRedoService = class UndoRedoService {\n    constructor(_dialogService, _notificationService) {\n        this._dialogService = _dialogService;\n        this._notificationService = _notificationService;\n        this._editStacks = new Map();\n        this._uriComparisonKeyComputers = [];\n    }\n    getUriComparisonKey(resource) {\n        for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\n            if (uriComparisonKeyComputer[0] === resource.scheme) {\n                return uriComparisonKeyComputer[1].getComparisonKey(resource);\n            }\n        }\n        return resource.toString();\n    }\n    _print(label) {\n        console.log(`------------------------------------`);\n        console.log(`AFTER ${label}: `);\n        let str = [];\n        for (const element of this._editStacks) {\n            str.push(element[1].toString());\n        }\n        console.log(str.join('\\n'));\n    }\n    pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {\n        if (element.type === 0 /* Resource */) {\n            const resourceLabel = getResourceLabel(element.resource);\n            const strResource = this.getUriComparisonKey(element.resource);\n            this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\n        }\n        else {\n            const seen = new Set();\n            const resourceLabels = [];\n            const strResources = [];\n            for (const resource of element.resources) {\n                const resourceLabel = getResourceLabel(resource);\n                const strResource = this.getUriComparisonKey(resource);\n                if (seen.has(strResource)) {\n                    continue;\n                }\n                seen.add(strResource);\n                resourceLabels.push(resourceLabel);\n                strResources.push(strResource);\n            }\n            if (resourceLabels.length === 1) {\n                this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\n            }\n            else {\n                this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\n            }\n        }\n        if (DEBUG) {\n            this._print('pushElement');\n        }\n    }\n    _pushElement(element) {\n        for (let i = 0, len = element.strResources.length; i < len; i++) {\n            const resourceLabel = element.resourceLabels[i];\n            const strResource = element.strResources[i];\n            let editStack;\n            if (this._editStacks.has(strResource)) {\n                editStack = this._editStacks.get(strResource);\n            }\n            else {\n                editStack = new ResourceEditStack(resourceLabel, strResource);\n                this._editStacks.set(strResource, editStack);\n            }\n            editStack.pushElement(element);\n        }\n    }\n    getLastElement(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            if (editStack.hasFutureElements()) {\n                return null;\n            }\n            const closestPastElement = editStack.getClosestPastElement();\n            return closestPastElement ? closestPastElement.actual : null;\n        }\n        return null;\n    }\n    _splitPastWorkspaceElement(toRemove, ignoreResources) {\n        const individualArr = toRemove.actual.split();\n        const individualMap = new Map();\n        for (const _element of individualArr) {\n            const resourceLabel = getResourceLabel(_element.resource);\n            const strResource = this.getUriComparisonKey(_element.resource);\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n            individualMap.set(element.strResource, element);\n        }\n        for (const strResource of toRemove.strResources) {\n            if (ignoreResources && ignoreResources.has(strResource)) {\n                continue;\n            }\n            const editStack = this._editStacks.get(strResource);\n            editStack.splitPastWorkspaceElement(toRemove, individualMap);\n        }\n    }\n    _splitFutureWorkspaceElement(toRemove, ignoreResources) {\n        const individualArr = toRemove.actual.split();\n        const individualMap = new Map();\n        for (const _element of individualArr) {\n            const resourceLabel = getResourceLabel(_element.resource);\n            const strResource = this.getUriComparisonKey(_element.resource);\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n            individualMap.set(element.strResource, element);\n        }\n        for (const strResource of toRemove.strResources) {\n            if (ignoreResources && ignoreResources.has(strResource)) {\n                continue;\n            }\n            const editStack = this._editStacks.get(strResource);\n            editStack.splitFutureWorkspaceElement(toRemove, individualMap);\n        }\n    }\n    removeElements(resource) {\n        const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.dispose();\n            this._editStacks.delete(strResource);\n        }\n        if (DEBUG) {\n            this._print('removeElements');\n        }\n    }\n    setElementsValidFlag(resource, isValid, filter) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.setElementsValidFlag(isValid, filter);\n        }\n        if (DEBUG) {\n            this._print('setElementsValidFlag');\n        }\n    }\n    createSnapshot(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.createSnapshot(resource);\n        }\n        return new ResourceEditStackSnapshot(resource, []);\n    }\n    restoreSnapshot(snapshot) {\n        const strResource = this.getUriComparisonKey(snapshot.resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.restoreSnapshot(snapshot);\n            if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\n                // the edit stack is now empty, just remove it entirely\n                editStack.dispose();\n                this._editStacks.delete(strResource);\n            }\n        }\n        if (DEBUG) {\n            this._print('restoreSnapshot');\n        }\n    }\n    getElements(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.getElements();\n        }\n        return { past: [], future: [] };\n    }\n    _findClosestUndoElementWithSource(sourceId) {\n        if (!sourceId) {\n            return [null, null];\n        }\n        // find an element with the sourceId and with the highest sourceOrder ready to be undone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestPastElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.sourceId === sourceId) {\n                if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    canUndo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? true : false;\n        }\n        const strResource = this.getUriComparisonKey(resourceOrSource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.hasPastElements();\n        }\n        return false;\n    }\n    _onError(err, element) {\n        onUnexpectedError(err);\n        // An error occurred while undoing or redoing => drop the undo/redo stack for all affected resources\n        for (const strResource of element.strResources) {\n            this.removeElements(strResource);\n        }\n        this._notificationService.error(err);\n    }\n    _acquireLocks(editStackSnapshot) {\n        // first, check if all locks can be acquired\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                throw new Error('Cannot acquire edit stack lock');\n            }\n        }\n        // can acquire all locks\n        for (const editStack of editStackSnapshot.editStacks) {\n            editStack.locked = true;\n        }\n        return () => {\n            // release all locks\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.locked = false;\n            }\n        };\n    }\n    _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\n        const releaseLocks = this._acquireLocks(editStackSnapshot);\n        let result;\n        try {\n            result = invoke();\n        }\n        catch (err) {\n            releaseLocks();\n            cleanup.dispose();\n            return this._onError(err, element);\n        }\n        if (result) {\n            // result is Promise<void>\n            return result.then(() => {\n                releaseLocks();\n                cleanup.dispose();\n                return continuation();\n            }, (err) => {\n                releaseLocks();\n                cleanup.dispose();\n                return this._onError(err, element);\n            });\n        }\n        else {\n            // result is void\n            releaseLocks();\n            cleanup.dispose();\n            return continuation();\n        }\n    }\n    _invokeWorkspacePrepare(element) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof element.actual.prepareUndoRedo === 'undefined') {\n                return Disposable.None;\n            }\n            const result = element.actual.prepareUndoRedo();\n            if (typeof result === 'undefined') {\n                return Disposable.None;\n            }\n            return result;\n        });\n    }\n    _invokeResourcePrepare(element, callback) {\n        if (element.actual.type !== 1 /* Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {\n            // no preparation needed\n            return callback(Disposable.None);\n        }\n        const r = element.actual.prepareUndoRedo();\n        if (!r) {\n            // nothing to clean up\n            return callback(Disposable.None);\n        }\n        if (isDisposable(r)) {\n            return callback(r);\n        }\n        return r.then((disposable) => {\n            return callback(disposable);\n        });\n    }\n    _getAffectedEditStacks(element) {\n        const affectedEditStacks = [];\n        for (const strResource of element.strResources) {\n            affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\n        }\n        return new EditStackSnapshot(affectedEditStacks);\n    }\n    _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\n        if (element.canSplit()) {\n            this._splitPastWorkspaceElement(element, ignoreResources);\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError(this._undo(strResource, 0, true));\n        }\n        else {\n            // Cannot safely split this workspace element => flush all undo/redo stacks\n            for (const strResource of element.strResources) {\n                this.removeElements(strResource);\n            }\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError();\n        }\n    }\n    _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n        if (element.removedResources) {\n            return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n        }\n        if (checkInvalidatedResources && element.invalidatedResources) {\n            return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n        }\n        // this must be the last past element in all the impacted resources!\n        const cannotUndoDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.getClosestPastElement() !== element) {\n                cannotUndoDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotUndoDueToResources.length > 0) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\n        }\n        const cannotLockDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                cannotLockDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotLockDueToResources.length > 0) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n        }\n        // check if new stack elements were added in the meantime...\n        if (!editStackSnapshot.isValid()) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n        }\n        return null;\n    }\n    _workspaceUndo(strResource, element, undoConfirmed) {\n        const affectedEditStacks = this._getAffectedEditStacks(element);\n        const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\n        if (verificationError) {\n            return verificationError.returnValue;\n        }\n        return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\n    }\n    _isPartOfUndoGroup(element) {\n        if (!element.groupId) {\n            return false;\n        }\n        // check that there is at least another element with the same groupId ready to be undone\n        for (const [, editStack] of this._editStacks) {\n            const pastElement = editStack.getClosestPastElement();\n            if (!pastElement) {\n                continue;\n            }\n            if (pastElement === element) {\n                const secondPastElement = editStack.getSecondClosestPastElement();\n                if (secondPastElement && secondPastElement.groupId === element.groupId) {\n                    // there is another element with the same group id in the same stack!\n                    return true;\n                }\n            }\n            if (pastElement.groupId === element.groupId) {\n                // there is another element with the same group id in another stack!\n                return true;\n            }\n        }\n        return false;\n    }\n    _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\n                // this element can be split\n                const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label), [\n                    nls.localize({ key: 'ok', comment: ['{0} denotes a number that is > 1'] }, \"Undo in {0} Files\", editStackSnapshot.editStacks.length),\n                    nls.localize('nok', \"Undo this File\"),\n                    nls.localize('cancel', \"Cancel\"),\n                ], {\n                    cancelId: 2\n                });\n                if (result.choice === 2) {\n                    // choice: cancel\n                    return;\n                }\n                if (result.choice === 1) {\n                    // choice: undo this file\n                    this._splitPastWorkspaceElement(element, null);\n                    return this._undo(strResource, 0, true);\n                }\n                // choice: undo in all files\n                // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\n                const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/ false);\n                if (verificationError1) {\n                    return verificationError1.returnValue;\n                }\n                undoConfirmed = true;\n            }\n            // prepare\n            let cleanup;\n            try {\n                cleanup = yield this._invokeWorkspacePrepare(element);\n            }\n            catch (err) {\n                return this._onError(err, element);\n            }\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n            const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\n            if (verificationError2) {\n                cleanup.dispose();\n                return verificationError2.returnValue;\n            }\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.moveBackward(element);\n            }\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n        });\n    }\n    _resourceUndo(editStack, element, undoConfirmed) {\n        if (!element.isValid) {\n            // invalid element => immediately flush edit stack!\n            editStack.flushAllElements();\n            return;\n        }\n        if (editStack.locked) {\n            const message = nls.localize({ key: 'cannotResourceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\n            this._notificationService.warn(message);\n            return;\n        }\n        return this._invokeResourcePrepare(element, (cleanup) => {\n            editStack.moveBackward(element);\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n        });\n    }\n    _findClosestUndoElementInGroup(groupId) {\n        if (!groupId) {\n            return [null, null];\n        }\n        // find another element with the same groupId and with the highest groupOrder ready to be undone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestPastElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.groupId === groupId) {\n                if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    _continueUndoInGroup(groupId, undoConfirmed) {\n        if (!groupId) {\n            return;\n        }\n        const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\n        if (matchedStrResource) {\n            return this._undo(matchedStrResource, 0, undoConfirmed);\n        }\n    }\n    undo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\n        }\n        if (typeof resourceOrSource === 'string') {\n            return this._undo(resourceOrSource, 0, false);\n        }\n        return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\n    }\n    _undo(strResource, sourceId = 0, undoConfirmed) {\n        if (!this._editStacks.has(strResource)) {\n            return;\n        }\n        const editStack = this._editStacks.get(strResource);\n        const element = editStack.getClosestPastElement();\n        if (!element) {\n            return;\n        }\n        if (element.groupId) {\n            // this element is a part of a group, we need to make sure undoing in a group is in order\n            const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\n            if (element !== matchedElement && matchedStrResource) {\n                // there is an element in the same group that should be undone before this one\n                return this._undo(matchedStrResource, sourceId, undoConfirmed);\n            }\n        }\n        const shouldPromptForConfirmation = (element.sourceId !== sourceId || element.confirmBeforeUndo);\n        if (shouldPromptForConfirmation && !undoConfirmed) {\n            // Hit a different source or the element asks for prompt before undo, prompt for confirmation\n            return this._confirmAndContinueUndo(strResource, sourceId, element);\n        }\n        try {\n            if (element.type === 1 /* Workspace */) {\n                return this._workspaceUndo(strResource, element, undoConfirmed);\n            }\n            else {\n                return this._resourceUndo(editStack, element, undoConfirmed);\n            }\n        }\n        finally {\n            if (DEBUG) {\n                this._print('undo');\n            }\n        }\n    }\n    _confirmAndContinueUndo(strResource, sourceId, element) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label), [\n                nls.localize('confirmDifferentSource.yes', \"Yes\"),\n                nls.localize('confirmDifferentSource.no', \"No\"),\n            ], {\n                cancelId: 1\n            });\n            if (result.choice === 1) {\n                // choice: cancel\n                return;\n            }\n            // choice: undo\n            return this._undo(strResource, sourceId, true);\n        });\n    }\n    _findClosestRedoElementWithSource(sourceId) {\n        if (!sourceId) {\n            return [null, null];\n        }\n        // find an element with sourceId and with the lowest sourceOrder ready to be redone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestFutureElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.sourceId === sourceId) {\n                if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    canRedo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? true : false;\n        }\n        const strResource = this.getUriComparisonKey(resourceOrSource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.hasFutureElements();\n        }\n        return false;\n    }\n    _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\n        if (element.canSplit()) {\n            this._splitFutureWorkspaceElement(element, ignoreResources);\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError(this._redo(strResource));\n        }\n        else {\n            // Cannot safely split this workspace element => flush all undo/redo stacks\n            for (const strResource of element.strResources) {\n                this.removeElements(strResource);\n            }\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError();\n        }\n    }\n    _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n        if (element.removedResources) {\n            return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n        }\n        if (checkInvalidatedResources && element.invalidatedResources) {\n            return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n        }\n        // this must be the last future element in all the impacted resources!\n        const cannotRedoDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.getClosestFutureElement() !== element) {\n                cannotRedoDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotRedoDueToResources.length > 0) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\n        }\n        const cannotLockDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                cannotLockDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotLockDueToResources.length > 0) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n        }\n        // check if new stack elements were added in the meantime...\n        if (!editStackSnapshot.isValid()) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n        }\n        return null;\n    }\n    _workspaceRedo(strResource, element) {\n        const affectedEditStacks = this._getAffectedEditStacks(element);\n        const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\n        if (verificationError) {\n            return verificationError.returnValue;\n        }\n        return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\n    }\n    _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // prepare\n            let cleanup;\n            try {\n                cleanup = yield this._invokeWorkspacePrepare(element);\n            }\n            catch (err) {\n                return this._onError(err, element);\n            }\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n            const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\n            if (verificationError) {\n                cleanup.dispose();\n                return verificationError.returnValue;\n            }\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.moveForward(element);\n            }\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\n        });\n    }\n    _resourceRedo(editStack, element) {\n        if (!element.isValid) {\n            // invalid element => immediately flush edit stack!\n            editStack.flushAllElements();\n            return;\n        }\n        if (editStack.locked) {\n            const message = nls.localize({ key: 'cannotResourceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\n            this._notificationService.warn(message);\n            return;\n        }\n        return this._invokeResourcePrepare(element, (cleanup) => {\n            editStack.moveForward(element);\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\n        });\n    }\n    _findClosestRedoElementInGroup(groupId) {\n        if (!groupId) {\n            return [null, null];\n        }\n        // find another element with the same groupId and with the lowest groupOrder ready to be redone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestFutureElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.groupId === groupId) {\n                if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    _continueRedoInGroup(groupId) {\n        if (!groupId) {\n            return;\n        }\n        const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\n        if (matchedStrResource) {\n            return this._redo(matchedStrResource);\n        }\n    }\n    redo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? this._redo(matchedStrResource) : undefined;\n        }\n        if (typeof resourceOrSource === 'string') {\n            return this._redo(resourceOrSource);\n        }\n        return this._redo(this.getUriComparisonKey(resourceOrSource));\n    }\n    _redo(strResource) {\n        if (!this._editStacks.has(strResource)) {\n            return;\n        }\n        const editStack = this._editStacks.get(strResource);\n        const element = editStack.getClosestFutureElement();\n        if (!element) {\n            return;\n        }\n        if (element.groupId) {\n            // this element is a part of a group, we need to make sure redoing in a group is in order\n            const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\n            if (element !== matchedElement && matchedStrResource) {\n                // there is an element in the same group that should be redone before this one\n                return this._redo(matchedStrResource);\n            }\n        }\n        try {\n            if (element.type === 1 /* Workspace */) {\n                return this._workspaceRedo(strResource, element);\n            }\n            else {\n                return this._resourceRedo(editStack, element);\n            }\n        }\n        finally {\n            if (DEBUG) {\n                this._print('redo');\n            }\n        }\n    }\n};\nUndoRedoService = __decorate([\n    __param(0, IDialogService),\n    __param(1, INotificationService)\n], UndoRedoService);\nexport { UndoRedoService };\nclass WorkspaceVerificationError {\n    constructor(returnValue) {\n        this.returnValue = returnValue;\n    }\n}\nregisterSingleton(IUndoRedoService, UndoRedoService);\n"]},"metadata":{},"sourceType":"module"}