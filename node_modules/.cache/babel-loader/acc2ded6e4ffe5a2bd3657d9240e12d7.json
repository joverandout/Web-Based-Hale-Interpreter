{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { nullTokenizeEncoded } from '../languages/nullMode.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { runWhenIdle } from '../../../base/common/async.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\n\nclass ContiguousGrowingArray {\n  constructor(_default) {\n    this._default = _default;\n    this._store = [];\n  }\n\n  get(index) {\n    if (index < this._store.length) {\n      return this._store[index];\n    }\n\n    return this._default;\n  }\n\n  set(index, value) {\n    while (index >= this._store.length) {\n      this._store[this._store.length] = this._default;\n    }\n\n    this._store[index] = value;\n  }\n\n  delete(deleteIndex, deleteCount) {\n    if (deleteCount === 0 || deleteIndex >= this._store.length) {\n      return;\n    }\n\n    this._store.splice(deleteIndex, deleteCount);\n  }\n\n  insert(insertIndex, insertCount) {\n    if (insertCount === 0 || insertIndex >= this._store.length) {\n      return;\n    }\n\n    const arr = [];\n\n    for (let i = 0; i < insertCount; i++) {\n      arr[i] = this._default;\n    }\n\n    this._store = arrays.arrayInsert(this._store, insertIndex, arr);\n  }\n\n}\n/**\n * Stores the states at the start of each line and keeps track of which lines\n * must be retokenized. Also uses state equality to quickly validate lines\n * that don't need to be retokenized.\n *\n * For example, when typing on a line, the line gets marked as needing to be tokenized.\n * Once the line is tokenized, the end state is checked for equality against the begin\n * state of the next line. If the states are equal, tokenization doesn't need to run\n * again over the rest of the file. If the states are not equal, the next line gets marked\n * as needing to be tokenized.\n */\n\n\nexport class TokenizationStateStore {\n  constructor(tokenizationSupport, initialState) {\n    this.tokenizationSupport = tokenizationSupport;\n    this.initialState = initialState;\n    /**\n     * `lineBeginState[i]` contains the begin state used to tokenize line number `i + 1`.\n     */\n\n    this._lineBeginState = new ContiguousGrowingArray(null);\n    /**\n     * `lineNeedsTokenization[i]` describes if line number `i + 1` needs to be tokenized.\n     */\n\n    this._lineNeedsTokenization = new ContiguousGrowingArray(true);\n    this._firstLineNeedsTokenization = 0;\n\n    this._lineBeginState.set(0, this.initialState);\n  }\n\n  get invalidLineStartIndex() {\n    return this._firstLineNeedsTokenization;\n  }\n\n  markMustBeTokenized(lineIndex) {\n    this._lineNeedsTokenization.set(lineIndex, true);\n\n    this._firstLineNeedsTokenization = Math.min(this._firstLineNeedsTokenization, lineIndex);\n  }\n\n  getBeginState(lineIndex) {\n    return this._lineBeginState.get(lineIndex);\n  }\n\n  setEndState(linesLength, lineIndex, endState) {\n    this._lineNeedsTokenization.set(lineIndex, false);\n\n    this._firstLineNeedsTokenization = lineIndex + 1; // Check if this was the last line\n\n    if (lineIndex === linesLength - 1) {\n      return;\n    } // Check if the end state has changed\n\n\n    const previousEndState = this._lineBeginState.get(lineIndex + 1);\n\n    if (previousEndState === null || !endState.equals(previousEndState)) {\n      this._lineBeginState.set(lineIndex + 1, endState);\n\n      this.markMustBeTokenized(lineIndex + 1);\n      return;\n    } // Perhaps we can skip tokenizing some lines...\n\n\n    let i = lineIndex + 1;\n\n    while (i < linesLength) {\n      if (this._lineNeedsTokenization.get(i)) {\n        break;\n      }\n\n      i++;\n    }\n\n    this._firstLineNeedsTokenization = i;\n  } //#region Editing\n\n\n  applyEdits(range, eolCount) {\n    this.markMustBeTokenized(range.startLineNumber - 1);\n\n    this._lineBeginState.delete(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\n    this._lineNeedsTokenization.delete(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\n    this._lineBeginState.insert(range.startLineNumber, eolCount);\n\n    this._lineNeedsTokenization.insert(range.startLineNumber, eolCount);\n  }\n\n}\nexport class TextModelTokenization extends Disposable {\n  constructor(_textModel, _languageIdCodec) {\n    super();\n    this._textModel = _textModel;\n    this._languageIdCodec = _languageIdCodec;\n    this._isScheduled = false;\n    this._isDisposed = false;\n    this._tokenizationStateStore = null;\n\n    this._register(TokenizationRegistry.onDidChange(e => {\n      const languageId = this._textModel.getLanguageId();\n\n      if (e.changedLanguages.indexOf(languageId) === -1) {\n        return;\n      }\n\n      this._resetTokenizationState();\n\n      this._textModel.clearTokens();\n    }));\n\n    this._register(this._textModel.onDidChangeContentFast(e => {\n      if (e.isFlush) {\n        this._resetTokenizationState();\n\n        return;\n      }\n\n      if (this._tokenizationStateStore) {\n        for (let i = 0, len = e.changes.length; i < len; i++) {\n          const change = e.changes[i];\n          const [eolCount] = countEOL(change.text);\n\n          this._tokenizationStateStore.applyEdits(change.range, eolCount);\n        }\n      }\n\n      this._beginBackgroundTokenization();\n    }));\n\n    this._register(this._textModel.onDidChangeAttached(() => {\n      this._beginBackgroundTokenization();\n    }));\n\n    this._register(this._textModel.onDidChangeLanguage(() => {\n      this._resetTokenizationState();\n\n      this._textModel.clearTokens();\n    }));\n\n    this._resetTokenizationState();\n  }\n\n  dispose() {\n    this._isDisposed = true;\n    super.dispose();\n  }\n\n  _resetTokenizationState() {\n    const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);\n\n    if (tokenizationSupport && initialState) {\n      this._tokenizationStateStore = new TokenizationStateStore(tokenizationSupport, initialState);\n    } else {\n      this._tokenizationStateStore = null;\n    }\n\n    this._beginBackgroundTokenization();\n  }\n\n  _beginBackgroundTokenization() {\n    if (this._isScheduled || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n      return;\n    }\n\n    this._isScheduled = true;\n    runWhenIdle(deadline => {\n      this._isScheduled = false;\n\n      this._backgroundTokenizeWithDeadline(deadline);\n    });\n  }\n  /**\n   * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n   */\n\n\n  _backgroundTokenizeWithDeadline(deadline) {\n    // Read the time remaining from the `deadline` immediately because it is unclear\n    // if the `deadline` object will be valid after execution leaves this function.\n    const endTime = Date.now() + deadline.timeRemaining();\n\n    const execute = () => {\n      if (this._isDisposed || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n        // disposed in the meantime or detached or finished\n        return;\n      }\n\n      this._backgroundTokenizeForAtLeast1ms();\n\n      if (Date.now() < endTime) {\n        // There is still time before reaching the deadline, so yield to the browser and then\n        // continue execution\n        setTimeout0(execute);\n      } else {\n        // The deadline has been reached, so schedule a new idle callback if necessary\n        this._beginBackgroundTokenization();\n      }\n    };\n\n    execute();\n  }\n  /**\n   * Tokenize for at least 1ms.\n   */\n\n\n  _backgroundTokenizeForAtLeast1ms() {\n    const lineCount = this._textModel.getLineCount();\n\n    const builder = new ContiguousMultilineTokensBuilder();\n    const sw = StopWatch.create(false);\n\n    do {\n      if (sw.elapsed() > 1) {\n        // the comparison is intentionally > 1 and not >= 1 to ensure that\n        // a full millisecond has elapsed, given how microseconds are rounded\n        // to milliseconds\n        break;\n      }\n\n      const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n      if (tokenizedLineNumber >= lineCount) {\n        break;\n      }\n    } while (this._hasLinesToTokenize());\n\n    this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());\n  }\n\n  tokenizeViewport(startLineNumber, endLineNumber) {\n    const builder = new ContiguousMultilineTokensBuilder();\n\n    this._tokenizeViewport(builder, startLineNumber, endLineNumber);\n\n    this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());\n  }\n\n  reset() {\n    this._resetTokenizationState();\n\n    this._textModel.clearTokens();\n  }\n\n  forceTokenization(lineNumber) {\n    const builder = new ContiguousMultilineTokensBuilder();\n\n    this._updateTokensUntilLine(builder, lineNumber);\n\n    this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());\n  }\n\n  getTokenTypeIfInsertingCharacter(position, character) {\n    if (!this._tokenizationStateStore) {\n      return 0\n      /* Other */\n      ;\n    }\n\n    this.forceTokenization(position.lineNumber);\n\n    const lineStartState = this._tokenizationStateStore.getBeginState(position.lineNumber - 1);\n\n    if (!lineStartState) {\n      return 0\n      /* Other */\n      ;\n    }\n\n    const languageId = this._textModel.getLanguageId();\n\n    const lineContent = this._textModel.getLineContent(position.lineNumber); // Create the text as if `character` was inserted\n\n\n    const text = lineContent.substring(0, position.column - 1) + character + lineContent.substring(position.column - 1);\n    const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);\n    const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\n    if (lineTokens.getCount() === 0) {\n      return 0\n      /* Other */\n      ;\n    }\n\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    return lineTokens.getStandardTokenType(tokenIndex);\n  }\n\n  tokenizeLineWithEdit(position, length, newText) {\n    const lineNumber = position.lineNumber;\n    const column = position.column;\n\n    if (!this._tokenizationStateStore) {\n      return null;\n    }\n\n    this.forceTokenization(lineNumber);\n\n    const lineStartState = this._tokenizationStateStore.getBeginState(lineNumber - 1);\n\n    if (!lineStartState) {\n      return null;\n    }\n\n    const curLineContent = this._textModel.getLineContent(lineNumber);\n\n    const newLineContent = curLineContent.substring(0, column - 1) + newText + curLineContent.substring(column - 1 + length);\n\n    const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n\n    const result = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, newLineContent, true, lineStartState);\n    const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n    return lineTokens;\n  }\n\n  isCheapToTokenize(lineNumber) {\n    if (!this._tokenizationStateStore) {\n      return true;\n    }\n\n    const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n\n    if (lineNumber > firstInvalidLineNumber) {\n      return false;\n    }\n\n    if (lineNumber < firstInvalidLineNumber) {\n      return true;\n    }\n\n    if (this._textModel.getLineLength(lineNumber) < 2048\n    /* CHEAP_TOKENIZATION_LENGTH_LIMIT */\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  _hasLinesToTokenize() {\n    if (!this._tokenizationStateStore) {\n      return false;\n    }\n\n    return this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount();\n  }\n\n  _tokenizeOneInvalidLine(builder) {\n    if (!this._tokenizationStateStore || !this._hasLinesToTokenize()) {\n      return this._textModel.getLineCount() + 1;\n    }\n\n    const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n\n    this._updateTokensUntilLine(builder, lineNumber);\n\n    return lineNumber;\n  }\n\n  _updateTokensUntilLine(builder, lineNumber) {\n    if (!this._tokenizationStateStore) {\n      return;\n    }\n\n    const languageId = this._textModel.getLanguageId();\n\n    const linesLength = this._textModel.getLineCount();\n\n    const endLineIndex = lineNumber - 1; // Validate all states up to and including endLineIndex\n\n    for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n      const text = this._textModel.getLineContent(lineIndex + 1);\n\n      const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\n\n      const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);\n      builder.add(lineIndex + 1, r.tokens);\n\n      this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\n\n      lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n    }\n  }\n\n  _tokenizeViewport(builder, startLineNumber, endLineNumber) {\n    if (!this._tokenizationStateStore) {\n      // nothing to do\n      return;\n    }\n\n    if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n      // nothing to do\n      return;\n    }\n\n    if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n      // tokenization has reached the viewport start...\n      this._updateTokensUntilLine(builder, endLineNumber);\n\n      return;\n    }\n\n    let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\n\n    const fakeLines = [];\n    let initialState = null;\n\n    for (let i = startLineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n      const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n\n      if (newNonWhitespaceIndex === 0) {\n        continue;\n      }\n\n      if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n        initialState = this._tokenizationStateStore.getBeginState(i - 1);\n\n        if (initialState) {\n          break;\n        }\n\n        fakeLines.push(this._textModel.getLineContent(i));\n        nonWhitespaceColumn = newNonWhitespaceIndex;\n      }\n    }\n\n    if (!initialState) {\n      initialState = this._tokenizationStateStore.initialState;\n    }\n\n    const languageId = this._textModel.getLanguageId();\n\n    let state = initialState;\n\n    for (let i = fakeLines.length - 1; i >= 0; i--) {\n      const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, fakeLines[i], false, state);\n      state = r.endState;\n    }\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const text = this._textModel.getLineContent(lineNumber);\n\n      const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, state);\n      builder.add(lineNumber, r.tokens);\n\n      this._tokenizationStateStore.markMustBeTokenized(lineNumber - 1);\n\n      state = r.endState;\n    }\n  }\n\n}\n\nfunction initializeTokenization(textModel) {\n  if (textModel.isTooLargeForTokenization()) {\n    return [null, null];\n  }\n\n  const tokenizationSupport = TokenizationRegistry.get(textModel.getLanguageId());\n\n  if (!tokenizationSupport) {\n    return [null, null];\n  }\n\n  let initialState;\n\n  try {\n    initialState = tokenizationSupport.getInitialState();\n  } catch (e) {\n    onUnexpectedError(e);\n    return [null, null];\n  }\n\n  return [tokenizationSupport, initialState];\n}\n\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n  let r = null;\n\n  if (tokenizationSupport) {\n    try {\n      r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n  }\n\n  if (!r) {\n    r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n  }\n\n  LineTokens.convertToEndOffset(r.tokens, text.length);\n  return r;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js"],"names":["arrays","onUnexpectedError","LineTokens","TokenizationRegistry","nullTokenizeEncoded","Disposable","StopWatch","countEOL","ContiguousMultilineTokensBuilder","runWhenIdle","setTimeout0","ContiguousGrowingArray","constructor","_default","_store","get","index","length","set","value","delete","deleteIndex","deleteCount","splice","insert","insertIndex","insertCount","arr","i","arrayInsert","TokenizationStateStore","tokenizationSupport","initialState","_lineBeginState","_lineNeedsTokenization","_firstLineNeedsTokenization","invalidLineStartIndex","markMustBeTokenized","lineIndex","Math","min","getBeginState","setEndState","linesLength","endState","previousEndState","equals","applyEdits","range","eolCount","startLineNumber","endLineNumber","TextModelTokenization","_textModel","_languageIdCodec","_isScheduled","_isDisposed","_tokenizationStateStore","_register","onDidChange","e","languageId","getLanguageId","changedLanguages","indexOf","_resetTokenizationState","clearTokens","onDidChangeContentFast","isFlush","len","changes","change","text","_beginBackgroundTokenization","onDidChangeAttached","onDidChangeLanguage","dispose","initializeTokenization","isAttachedToEditor","_hasLinesToTokenize","deadline","_backgroundTokenizeWithDeadline","endTime","Date","now","timeRemaining","execute","_backgroundTokenizeForAtLeast1ms","lineCount","getLineCount","builder","sw","create","elapsed","tokenizedLineNumber","_tokenizeOneInvalidLine","setTokens","finalize","tokenizeViewport","_tokenizeViewport","reset","forceTokenization","lineNumber","_updateTokensUntilLine","getTokenTypeIfInsertingCharacter","position","character","lineStartState","lineContent","getLineContent","substring","column","r","safeTokenize","lineTokens","tokens","getCount","tokenIndex","findTokenIndexAtOffset","getStandardTokenType","tokenizeLineWithEdit","newText","curLineContent","newLineContent","getLanguageIdAtPosition","result","isCheapToTokenize","firstInvalidLineNumber","getLineLength","endLineIndex","add","nonWhitespaceColumn","getLineFirstNonWhitespaceColumn","fakeLines","newNonWhitespaceIndex","push","state","textModel","isTooLargeForTokenization","getInitialState","languageIdCodec","hasEOL","tokenizeEncoded","clone","encodeLanguageId","convertToEndOffset"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { nullTokenizeEncoded } from '../languages/nullMode.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { runWhenIdle } from '../../../base/common/async.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nclass ContiguousGrowingArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrays.arrayInsert(this._store, insertIndex, arr);\n    }\n}\n/**\n * Stores the states at the start of each line and keeps track of which lines\n * must be retokenized. Also uses state equality to quickly validate lines\n * that don't need to be retokenized.\n *\n * For example, when typing on a line, the line gets marked as needing to be tokenized.\n * Once the line is tokenized, the end state is checked for equality against the begin\n * state of the next line. If the states are equal, tokenization doesn't need to run\n * again over the rest of the file. If the states are not equal, the next line gets marked\n * as needing to be tokenized.\n */\nexport class TokenizationStateStore {\n    constructor(tokenizationSupport, initialState) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = initialState;\n        /**\n         * `lineBeginState[i]` contains the begin state used to tokenize line number `i + 1`.\n         */\n        this._lineBeginState = new ContiguousGrowingArray(null);\n        /**\n         * `lineNeedsTokenization[i]` describes if line number `i + 1` needs to be tokenized.\n         */\n        this._lineNeedsTokenization = new ContiguousGrowingArray(true);\n        this._firstLineNeedsTokenization = 0;\n        this._lineBeginState.set(0, this.initialState);\n    }\n    get invalidLineStartIndex() {\n        return this._firstLineNeedsTokenization;\n    }\n    markMustBeTokenized(lineIndex) {\n        this._lineNeedsTokenization.set(lineIndex, true);\n        this._firstLineNeedsTokenization = Math.min(this._firstLineNeedsTokenization, lineIndex);\n    }\n    getBeginState(lineIndex) {\n        return this._lineBeginState.get(lineIndex);\n    }\n    setEndState(linesLength, lineIndex, endState) {\n        this._lineNeedsTokenization.set(lineIndex, false);\n        this._firstLineNeedsTokenization = lineIndex + 1;\n        // Check if this was the last line\n        if (lineIndex === linesLength - 1) {\n            return;\n        }\n        // Check if the end state has changed\n        const previousEndState = this._lineBeginState.get(lineIndex + 1);\n        if (previousEndState === null || !endState.equals(previousEndState)) {\n            this._lineBeginState.set(lineIndex + 1, endState);\n            this.markMustBeTokenized(lineIndex + 1);\n            return;\n        }\n        // Perhaps we can skip tokenizing some lines...\n        let i = lineIndex + 1;\n        while (i < linesLength) {\n            if (this._lineNeedsTokenization.get(i)) {\n                break;\n            }\n            i++;\n        }\n        this._firstLineNeedsTokenization = i;\n    }\n    //#region Editing\n    applyEdits(range, eolCount) {\n        this.markMustBeTokenized(range.startLineNumber - 1);\n        this._lineBeginState.delete(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        this._lineNeedsTokenization.delete(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        this._lineBeginState.insert(range.startLineNumber, eolCount);\n        this._lineNeedsTokenization.insert(range.startLineNumber, eolCount);\n    }\n}\nexport class TextModelTokenization extends Disposable {\n    constructor(_textModel, _languageIdCodec) {\n        super();\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n        this._isScheduled = false;\n        this._isDisposed = false;\n        this._tokenizationStateStore = null;\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this._textModel.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this._resetTokenizationState();\n            this._textModel.clearTokens();\n        }));\n        this._register(this._textModel.onDidChangeContentFast((e) => {\n            if (e.isFlush) {\n                this._resetTokenizationState();\n                return;\n            }\n            if (this._tokenizationStateStore) {\n                for (let i = 0, len = e.changes.length; i < len; i++) {\n                    const change = e.changes[i];\n                    const [eolCount] = countEOL(change.text);\n                    this._tokenizationStateStore.applyEdits(change.range, eolCount);\n                }\n            }\n            this._beginBackgroundTokenization();\n        }));\n        this._register(this._textModel.onDidChangeAttached(() => {\n            this._beginBackgroundTokenization();\n        }));\n        this._register(this._textModel.onDidChangeLanguage(() => {\n            this._resetTokenizationState();\n            this._textModel.clearTokens();\n        }));\n        this._resetTokenizationState();\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    _resetTokenizationState() {\n        const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);\n        if (tokenizationSupport && initialState) {\n            this._tokenizationStateStore = new TokenizationStateStore(tokenizationSupport, initialState);\n        }\n        else {\n            this._tokenizationStateStore = null;\n        }\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizeViewport(builder, startLineNumber, endLineNumber);\n        this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());\n    }\n    reset() {\n        this._resetTokenizationState();\n        this._textModel.clearTokens();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._updateTokensUntilLine(builder, lineNumber);\n        this._textModel.setTokens(builder.finalize(), !this._hasLinesToTokenize());\n    }\n    getTokenTypeIfInsertingCharacter(position, character) {\n        if (!this._tokenizationStateStore) {\n            return 0 /* Other */;\n        }\n        this.forceTokenization(position.lineNumber);\n        const lineStartState = this._tokenizationStateStore.getBeginState(position.lineNumber - 1);\n        if (!lineStartState) {\n            return 0 /* Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        if (!this._tokenizationStateStore) {\n            return null;\n        }\n        this.forceTokenization(lineNumber);\n        const lineStartState = this._tokenizationStateStore.getBeginState(lineNumber - 1);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizationStateStore) {\n            return true;\n        }\n        const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n        if (lineNumber > firstInvalidLineNumber) {\n            return false;\n        }\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (this._textModel.getLineLength(lineNumber) < 2048 /* CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizationStateStore) {\n            return false;\n        }\n        return (this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount());\n    }\n    _tokenizeOneInvalidLine(builder) {\n        if (!this._tokenizationStateStore || !this._hasLinesToTokenize()) {\n            return this._textModel.getLineCount() + 1;\n        }\n        const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n        this._updateTokensUntilLine(builder, lineNumber);\n        return lineNumber;\n    }\n    _updateTokensUntilLine(builder, lineNumber) {\n        if (!this._tokenizationStateStore) {\n            return;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const linesLength = this._textModel.getLineCount();\n        const endLineIndex = lineNumber - 1;\n        // Validate all states up to and including endLineIndex\n        for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n            const text = this._textModel.getLineContent(lineIndex + 1);\n            const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);\n            builder.add(lineIndex + 1, r.tokens);\n            this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\n            lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n        }\n    }\n    _tokenizeViewport(builder, startLineNumber, endLineNumber) {\n        if (!this._tokenizationStateStore) {\n            // nothing to do\n            return;\n        }\n        if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n            // nothing to do\n            return;\n        }\n        if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n            // tokenization has reached the viewport start...\n            this._updateTokensUntilLine(builder, endLineNumber);\n            return;\n        }\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\n        const fakeLines = [];\n        let initialState = null;\n        for (let i = startLineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                initialState = this._tokenizationStateStore.getBeginState(i - 1);\n                if (initialState) {\n                    break;\n                }\n                fakeLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n            }\n        }\n        if (!initialState) {\n            initialState = this._tokenizationStateStore.initialState;\n        }\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (let i = fakeLines.length - 1; i >= 0; i--) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, fakeLines[i], false, state);\n            state = r.endState;\n        }\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            this._tokenizationStateStore.markMustBeTokenized(lineNumber - 1);\n            state = r.endState;\n        }\n    }\n}\nfunction initializeTokenization(textModel) {\n    if (textModel.isTooLargeForTokenization()) {\n        return [null, null];\n    }\n    const tokenizationSupport = TokenizationRegistry.get(textModel.getLanguageId());\n    if (!tokenizationSupport) {\n        return [null, null];\n    }\n    let initialState;\n    try {\n        initialState = tokenizationSupport.getInitialState();\n    }\n    catch (e) {\n        onUnexpectedError(e);\n        return [null, null];\n    }\n    return [tokenizationSupport, initialState];\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\n"]},"metadata":{},"sourceType":"module"}