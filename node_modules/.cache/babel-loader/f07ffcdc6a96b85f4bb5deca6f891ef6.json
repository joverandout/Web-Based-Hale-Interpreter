{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nexport class BracketPairsTextModelPart extends Disposable {\n  constructor(textModel, languageConfigurationService) {\n    super();\n    this.textModel = textModel;\n    this.languageConfigurationService = languageConfigurationService;\n    this.bracketPairsTree = this._register(new MutableDisposable());\n    this.onDidChangeEmitter = new Emitter();\n    this.onDidChange = this.onDidChangeEmitter.event;\n    this.bracketsRequested = false;\n\n    this._register(textModel.onDidChangeOptions(e => {\n      this.bracketPairsTree.clear();\n      this.updateBracketPairsTree();\n    }));\n\n    this._register(textModel.onDidChangeLanguage(e => {\n      this.bracketPairsTree.clear();\n      this.updateBracketPairsTree();\n    }));\n\n    this._register(this.languageConfigurationService.onDidChange(e => {\n      var _a;\n\n      if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n      }\n    }));\n  }\n\n  get isDocumentSupported() {\n    const maxSupportedDocumentLength =\n    /* max lines */\n    50000 *\n    /* average column count */\n    100;\n    return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n  }\n\n  updateBracketPairsTree() {\n    if (this.bracketsRequested && this.isDocumentSupported) {\n      if (!this.bracketPairsTree.value) {\n        const store = new DisposableStore();\n        this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, languageId => {\n          return this.languageConfigurationService.getLanguageConfiguration(languageId);\n        })), store);\n        store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n        this.onDidChangeEmitter.fire();\n      }\n    } else {\n      if (this.bracketPairsTree.value) {\n        this.bracketPairsTree.clear(); // Important: Don't call fire if there was no change!\n\n        this.onDidChangeEmitter.fire();\n      }\n    }\n  }\n\n  handleContentChanged(change) {\n    var _a;\n\n    (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n  }\n  /**\n   * Returns all bracket pairs that intersect the given range.\n   * The result is sorted by the start position.\n  */\n\n\n  getBracketPairsInRange(range) {\n    var _a;\n\n    this.bracketsRequested = true;\n    this.updateBracketPairsTree();\n    return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || [];\n  }\n\n  getBracketPairsInRangeWithMinIndentation(range) {\n    var _a;\n\n    this.bracketsRequested = true;\n    this.updateBracketPairsTree();\n    return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || [];\n  }\n\n  getBracketsInRange(range) {\n    var _a;\n\n    this.bracketsRequested = true;\n    this.updateBracketPairsTree();\n    return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range)) || [];\n  }\n\n  findMatchingBracketUp(_bracket, _position) {\n    const bracket = _bracket.toLowerCase();\n\n    const position = this.textModel.validatePosition(_position);\n    const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n    const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\n    if (!bracketsSupport) {\n      return null;\n    }\n\n    const data = bracketsSupport.textIsBracket[bracket];\n\n    if (!data) {\n      return null;\n    }\n\n    return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));\n  }\n\n  matchBracket(position) {\n    return this._matchBracket(this.textModel.validatePosition(position));\n  }\n\n  _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n    const tokenCount = lineTokens.getCount();\n    const currentLanguageId = lineTokens.getLanguageId(tokenIndex); // limit search to not go before `maxBracketLength`\n\n    let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n\n    for (let i = tokenIndex - 1; i >= 0; i--) {\n      const tokenEndOffset = lineTokens.getEndOffset(i);\n\n      if (tokenEndOffset <= searchStartOffset) {\n        break;\n      }\n\n      if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n        searchStartOffset = tokenEndOffset;\n        break;\n      }\n    } // limit search to not go after `maxBracketLength`\n\n\n    let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n\n    for (let i = tokenIndex + 1; i < tokenCount; i++) {\n      const tokenStartOffset = lineTokens.getStartOffset(i);\n\n      if (tokenStartOffset >= searchEndOffset) {\n        break;\n      }\n\n      if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n        searchEndOffset = tokenStartOffset;\n        break;\n      }\n    }\n\n    return {\n      searchStartOffset,\n      searchEndOffset\n    };\n  }\n\n  _matchBracket(position) {\n    const lineNumber = position.lineNumber;\n    const lineTokens = this.textModel.getLineTokens(lineNumber);\n    const lineText = this.textModel.getLineContent(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\n    if (tokenIndex < 0) {\n      return null;\n    }\n\n    const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets; // check that the token is not to be ignored\n\n    if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n      let {\n        searchStartOffset,\n        searchEndOffset\n      } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex); // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n      // `bestResult` will contain the most right-side result\n\n\n      let bestResult = null;\n\n      while (true) {\n        const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (!foundBracket) {\n          // there are no more brackets in this text\n          break;\n        } // check that we didn't hit a bracket too far away from position\n\n\n        if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n\n          const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);\n\n          if (r) {\n            if (r instanceof BracketSearchCanceled) {\n              return null;\n            }\n\n            bestResult = r;\n          }\n        }\n\n        searchStartOffset = foundBracket.endColumn - 1;\n      }\n\n      if (bestResult) {\n        return bestResult;\n      }\n    } // If position is in between two tokens, try also looking in the previous token\n\n\n    if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n      const prevTokenIndex = tokenIndex - 1;\n      const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets; // check that previous token is not to be ignored\n\n      if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n        const {\n          searchStartOffset,\n          searchEndOffset\n        } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n\n        const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset); // check that we didn't hit a bracket too far away from position\n\n        if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n\n          const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], null);\n\n          if (r) {\n            if (r instanceof BracketSearchCanceled) {\n              return null;\n            }\n\n            return r;\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n    if (!data) {\n      return null;\n    }\n\n    const matched = isOpen ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate) : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate);\n\n    if (!matched) {\n      return null;\n    }\n\n    if (matched instanceof BracketSearchCanceled) {\n      return matched;\n    }\n\n    return [foundBracket, matched];\n  }\n\n  _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n    // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    const languageId = bracket.languageId;\n    const reversedBracketRegex = bracket.reversedRegex;\n    let count = -1;\n    let totalCallCount = 0;\n\n    const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (!r) {\n          break;\n        }\n\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\n        if (bracket.isOpen(hitText)) {\n          count++;\n        } else if (bracket.isClose(hitText)) {\n          count--;\n        }\n\n        if (count === 0) {\n          return r;\n        }\n\n        searchEndOffset = r.startColumn - 1;\n      }\n\n      return null;\n    };\n\n    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      const lineTokens = this.textModel.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = tokenCount - 1;\n      let searchStartOffset = lineText.length;\n      let searchEndOffset = lineText.length;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n      }\n\n      let prevSearchInToken = true;\n\n      for (; tokenIndex >= 0; tokenIndex--) {\n        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchStartOffset\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return r;\n            }\n          }\n        }\n\n        prevSearchInToken = searchInToken;\n      }\n\n      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (r) {\n          return r;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n    // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    const languageId = bracket.languageId;\n    const bracketRegex = bracket.forwardRegex;\n    let count = 1;\n    let totalCallCount = 0;\n\n    const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n\n        const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (!r) {\n          break;\n        }\n\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\n        if (bracket.isOpen(hitText)) {\n          count++;\n        } else if (bracket.isClose(hitText)) {\n          count--;\n        }\n\n        if (count === 0) {\n          return r;\n        }\n\n        searchStartOffset = r.endColumn - 1;\n      }\n\n      return null;\n    };\n\n    const lineCount = this.textModel.getLineCount();\n\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this.textModel.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n      }\n\n      let prevSearchInToken = true;\n\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return r;\n            }\n          }\n        }\n\n        prevSearchInToken = searchInToken;\n      }\n\n      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (r) {\n          return r;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  findPrevBracket(_position) {\n    const position = this.textModel.validatePosition(_position);\n    let languageId = null;\n    let modeBrackets = null;\n\n    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      const lineTokens = this.textModel.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = tokenCount - 1;\n      let searchStartOffset = lineText.length;\n      let searchEndOffset = lineText.length;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n        }\n      }\n\n      let prevSearchInToken = true;\n\n      for (; tokenIndex >= 0; tokenIndex--) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n\n            prevSearchInToken = false;\n          }\n\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n        }\n\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchStartOffset\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n          }\n        }\n\n        prevSearchInToken = searchInToken;\n      }\n\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (r) {\n          return this._toFoundBracket(modeBrackets, r);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  findNextBracket(_position) {\n    const position = this.textModel.validatePosition(_position);\n    const lineCount = this.textModel.getLineCount();\n    let languageId = null;\n    let modeBrackets = null;\n\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this.textModel.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n        }\n      }\n\n      let prevSearchInToken = true;\n\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n\n            prevSearchInToken = false;\n          }\n\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n        }\n\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n          }\n        }\n\n        prevSearchInToken = searchInToken;\n      }\n\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (r) {\n          return this._toFoundBracket(modeBrackets, r);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  findEnclosingBrackets(_position, maxDuration) {\n    let continueSearchPredicate;\n\n    if (typeof maxDuration === 'undefined') {\n      continueSearchPredicate = null;\n    } else {\n      const startTime = Date.now();\n\n      continueSearchPredicate = () => {\n        return Date.now() - startTime <= maxDuration;\n      };\n    }\n\n    const position = this.textModel.validatePosition(_position);\n    const lineCount = this.textModel.getLineCount();\n    const savedCounts = new Map();\n    let counts = [];\n\n    const resetCounts = (languageId, modeBrackets) => {\n      if (!savedCounts.has(languageId)) {\n        const tmp = [];\n\n        for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n          tmp[i] = 0;\n        }\n\n        savedCounts.set(languageId, tmp);\n      }\n\n      counts = savedCounts.get(languageId);\n    };\n\n    let totalCallCount = 0;\n\n    const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n\n        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (!r) {\n          break;\n        }\n\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const bracket = modeBrackets.textIsBracket[hitText];\n\n        if (bracket) {\n          if (bracket.isOpen(hitText)) {\n            counts[bracket.index]++;\n          } else if (bracket.isClose(hitText)) {\n            counts[bracket.index]--;\n          }\n\n          if (counts[bracket.index] === -1) {\n            return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n          }\n        }\n\n        searchStartOffset = r.endColumn - 1;\n      }\n\n      return null;\n    };\n\n    let languageId = null;\n    let modeBrackets = null;\n\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this.textModel.getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this.textModel.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          resetCounts(languageId, modeBrackets);\n        }\n      }\n\n      let prevSearchInToken = true;\n\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return stripBracketSearchCanceled(r);\n            }\n\n            prevSearchInToken = false;\n          }\n\n          languageId = tokenLanguageId;\n          modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n          resetCounts(languageId, modeBrackets);\n        }\n\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n            if (r) {\n              return stripBracketSearchCanceled(r);\n            }\n          }\n        }\n\n        prevSearchInToken = searchInToken;\n      }\n\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (r) {\n          return stripBracketSearchCanceled(r);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  _toFoundBracket(modeBrackets, r) {\n    if (!r) {\n      return null;\n    }\n\n    let text = this.textModel.getValueInRange(r);\n    text = text.toLowerCase();\n    const data = modeBrackets.textIsBracket[text];\n\n    if (!data) {\n      return null;\n    }\n\n    return {\n      range: r,\n      open: data.open,\n      close: data.close,\n      isOpen: modeBrackets.textIsOpenBracket[text]\n    };\n  }\n\n}\n\nfunction createDisposableRef(object, disposable) {\n  return {\n    object,\n    dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose()\n  };\n}\n\nclass BracketSearchCanceled {\n  constructor() {\n    this._searchCanceledBrand = undefined;\n  }\n\n}\n\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\n\nfunction stripBracketSearchCanceled(result) {\n  if (result instanceof BracketSearchCanceled) {\n    return null;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js"],"names":["Emitter","Disposable","DisposableStore","MutableDisposable","BracketPairsTree","ignoreBracketsInToken","BracketsUtils","BracketPairsTextModelPart","constructor","textModel","languageConfigurationService","bracketPairsTree","_register","onDidChangeEmitter","onDidChange","event","bracketsRequested","onDidChangeOptions","e","clear","updateBracketPairsTree","onDidChangeLanguage","_a","languageId","value","object","didLanguageChange","isDocumentSupported","maxSupportedDocumentLength","getValueLength","store","createDisposableRef","add","getLanguageConfiguration","fire","handleContentChanged","change","getBracketPairsInRange","range","getBracketPairsInRangeWithMinIndentation","getBracketsInRange","findMatchingBracketUp","_bracket","_position","bracket","toLowerCase","position","validatePosition","getLanguageIdAtPosition","lineNumber","column","bracketsSupport","brackets","data","textIsBracket","stripBracketSearchCanceled","_findMatchingBracketUp","matchBracket","_matchBracket","_establishBracketSearchOffsets","lineTokens","modeBrackets","tokenIndex","tokenCount","getCount","currentLanguageId","getLanguageId","searchStartOffset","Math","max","maxBracketLength","i","tokenEndOffset","getEndOffset","getStandardTokenType","searchEndOffset","min","getLineContent","length","tokenStartOffset","getStartOffset","getLineTokens","lineText","findTokenIndexAtOffset","currentModeBrackets","bestResult","foundBracket","findNextBracketInRange","forwardRegex","startColumn","endColumn","foundBracketText","substring","r","_matchFoundBracket","textIsOpenBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","findPrevBracketInRange","reversedRegex","isOpen","continueSearchPredicate","matched","_findMatchingBracketDown","getEndPosition","getStartPosition","reversedBracketRegex","count","totalCallCount","searchPrevMatchingBracketInRange","INSTANCE","hitText","isClose","prevSearchInToken","searchInToken","bracketRegex","searchNextMatchingBracketInRange","lineCount","getLineCount","findPrevBracket","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","maxDuration","startTime","Date","now","savedCounts","Map","counts","resetCounts","has","tmp","len","set","get","searchInRange","index","text","getValueInRange","open","close","disposable","dispose","_searchCanceledBrand","undefined","result"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(textModel.onDidChangeOptions(e => {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }));\n        this._register(textModel.onDidChangeLanguage(e => {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }));\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.bracketPairsTree.clear();\n                this.updateBracketPairsTree();\n            }\n        }));\n    }\n    get isDocumentSupported() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.isDocumentSupported) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    handleContentChanged(change) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || [];\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || [];\n    }\n    getBracketsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range)) || [];\n    }\n    findMatchingBracketUp(_bracket, _position) {\n        const bracket = _bracket.toLowerCase();\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n        if (!bracketsSupport) {\n            return null;\n        }\n        const data = bracketsSupport.textIsBracket[bracket];\n        if (!data) {\n            return null;\n        }\n        return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));\n    }\n    matchBracket(position) {\n        return this._matchBracket(this.textModel.validatePosition(position));\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], null);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(modeBrackets, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(modeBrackets, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(modeBrackets, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        let continueSearchPredicate;\n        if (typeof maxDuration === 'undefined') {\n            continueSearchPredicate = null;\n        }\n        else {\n            const startTime = Date.now();\n            continueSearchPredicate = () => {\n                return (Date.now() - startTime <= maxDuration);\n            };\n        }\n        const position = this.textModel.validatePosition(_position);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(modeBrackets, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const data = modeBrackets.textIsBracket[text];\n        if (!data) {\n            return null;\n        }\n        return {\n            range: r,\n            open: data.open,\n            close: data.close,\n            isOpen: modeBrackets.textIsOpenBracket[text]\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}