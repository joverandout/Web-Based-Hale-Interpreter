{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\n/**\n * Return a hash value for an object.\n */\n\nexport function hash(obj) {\n  return doHash(obj, 0);\n}\nexport function doHash(obj, hashVal) {\n  switch (typeof obj) {\n    case 'object':\n      if (obj === null) {\n        return numberHash(349, hashVal);\n      } else if (Array.isArray(obj)) {\n        return arrayHash(obj, hashVal);\n      }\n\n      return objectHash(obj, hashVal);\n\n    case 'string':\n      return stringHash(obj, hashVal);\n\n    case 'boolean':\n      return booleanHash(obj, hashVal);\n\n    case 'number':\n      return numberHash(obj, hashVal);\n\n    case 'undefined':\n      return numberHash(937, hashVal);\n\n    default:\n      return numberHash(617, hashVal);\n  }\n}\nexport function numberHash(val, initialHashVal) {\n  return (initialHashVal << 5) - initialHashVal + val | 0; // hashVal * 31 + ch, keep as int32\n}\n\nfunction booleanHash(b, initialHashVal) {\n  return numberHash(b ? 433 : 863, initialHashVal);\n}\n\nexport function stringHash(s, hashVal) {\n  hashVal = numberHash(149417, hashVal);\n\n  for (let i = 0, length = s.length; i < length; i++) {\n    hashVal = numberHash(s.charCodeAt(i), hashVal);\n  }\n\n  return hashVal;\n}\n\nfunction arrayHash(arr, initialHashVal) {\n  initialHashVal = numberHash(104579, initialHashVal);\n  return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\n}\n\nfunction objectHash(obj, initialHashVal) {\n  initialHashVal = numberHash(181387, initialHashVal);\n  return Object.keys(obj).sort().reduce((hashVal, key) => {\n    hashVal = stringHash(key, hashVal);\n    return doHash(obj[key], hashVal);\n  }, initialHashVal);\n}\n\nfunction leftRotate(value, bits, totalBits = 32) {\n  // delta + bits = totalBits\n  const delta = totalBits - bits; // All ones, expect `delta` zeros aligned to the right\n\n  const mask = ~((1 << delta) - 1); // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\n\n  return (value << bits | (mask & value) >>> delta) >>> 0;\n}\n\nfunction fill(dest, index = 0, count = dest.byteLength, value = 0) {\n  for (let i = 0; i < count; i++) {\n    dest[index + i] = value;\n  }\n}\n\nfunction leftPad(value, length, char = '0') {\n  while (value.length < length) {\n    value = char + value;\n  }\n\n  return value;\n}\n\nexport function toHexString(bufferOrValue, bitsize = 32) {\n  if (bufferOrValue instanceof ArrayBuffer) {\n    return Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');\n  }\n\n  return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);\n}\n/**\n * A SHA1 implementation that works with strings and does not allocate.\n */\n\nexport class StringSHA1 {\n  constructor() {\n    this._h0 = 0x67452301;\n    this._h1 = 0xEFCDAB89;\n    this._h2 = 0x98BADCFE;\n    this._h3 = 0x10325476;\n    this._h4 = 0xC3D2E1F0;\n    this._buff = new Uint8Array(64\n    /* BLOCK_SIZE */\n    + 3\n    /* to fit any utf-8 */\n    );\n    this._buffDV = new DataView(this._buff.buffer);\n    this._buffLen = 0;\n    this._totalLen = 0;\n    this._leftoverHighSurrogate = 0;\n    this._finished = false;\n  }\n\n  update(str) {\n    const strLen = str.length;\n\n    if (strLen === 0) {\n      return;\n    }\n\n    const buff = this._buff;\n    let buffLen = this._buffLen;\n    let leftoverHighSurrogate = this._leftoverHighSurrogate;\n    let charCode;\n    let offset;\n\n    if (leftoverHighSurrogate !== 0) {\n      charCode = leftoverHighSurrogate;\n      offset = -1;\n      leftoverHighSurrogate = 0;\n    } else {\n      charCode = str.charCodeAt(0);\n      offset = 0;\n    }\n\n    while (true) {\n      let codePoint = charCode;\n\n      if (strings.isHighSurrogate(charCode)) {\n        if (offset + 1 < strLen) {\n          const nextCharCode = str.charCodeAt(offset + 1);\n\n          if (strings.isLowSurrogate(nextCharCode)) {\n            offset++;\n            codePoint = strings.computeCodePoint(charCode, nextCharCode);\n          } else {\n            // illegal => unicode replacement character\n            codePoint = 65533\n            /* UNICODE_REPLACEMENT */\n            ;\n          }\n        } else {\n          // last character is a surrogate pair\n          leftoverHighSurrogate = charCode;\n          break;\n        }\n      } else if (strings.isLowSurrogate(charCode)) {\n        // illegal => unicode replacement character\n        codePoint = 65533\n        /* UNICODE_REPLACEMENT */\n        ;\n      }\n\n      buffLen = this._push(buff, buffLen, codePoint);\n      offset++;\n\n      if (offset < strLen) {\n        charCode = str.charCodeAt(offset);\n      } else {\n        break;\n      }\n    }\n\n    this._buffLen = buffLen;\n    this._leftoverHighSurrogate = leftoverHighSurrogate;\n  }\n\n  _push(buff, buffLen, codePoint) {\n    if (codePoint < 0x0080) {\n      buff[buffLen++] = codePoint;\n    } else if (codePoint < 0x0800) {\n      buff[buffLen++] = 0b11000000 | (codePoint & 0b00000000000000000000011111000000) >>> 6;\n      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000000000000000111111) >>> 0;\n    } else if (codePoint < 0x10000) {\n      buff[buffLen++] = 0b11100000 | (codePoint & 0b00000000000000001111000000000000) >>> 12;\n      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000000000111111000000) >>> 6;\n      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000000000000000111111) >>> 0;\n    } else {\n      buff[buffLen++] = 0b11110000 | (codePoint & 0b00000000000111000000000000000000) >>> 18;\n      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000111111000000000000) >>> 12;\n      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000000000111111000000) >>> 6;\n      buff[buffLen++] = 0b10000000 | (codePoint & 0b00000000000000000000000000111111) >>> 0;\n    }\n\n    if (buffLen >= 64\n    /* BLOCK_SIZE */\n    ) {\n      this._step();\n\n      buffLen -= 64\n      /* BLOCK_SIZE */\n      ;\n      this._totalLen += 64\n      /* BLOCK_SIZE */\n      ; // take last 3 in case of UTF8 overflow\n\n      buff[0] = buff[64\n      /* BLOCK_SIZE */\n      + 0];\n      buff[1] = buff[64\n      /* BLOCK_SIZE */\n      + 1];\n      buff[2] = buff[64\n      /* BLOCK_SIZE */\n      + 2];\n    }\n\n    return buffLen;\n  }\n\n  digest() {\n    if (!this._finished) {\n      this._finished = true;\n\n      if (this._leftoverHighSurrogate) {\n        // illegal => unicode replacement character\n        this._leftoverHighSurrogate = 0;\n        this._buffLen = this._push(this._buff, this._buffLen, 65533\n        /* UNICODE_REPLACEMENT */\n        );\n      }\n\n      this._totalLen += this._buffLen;\n\n      this._wrapUp();\n    }\n\n    return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n  }\n\n  _wrapUp() {\n    this._buff[this._buffLen++] = 0x80;\n    fill(this._buff, this._buffLen);\n\n    if (this._buffLen > 56) {\n      this._step();\n\n      fill(this._buff);\n    } // this will fit because the mantissa can cover up to 52 bits\n\n\n    const ml = 8 * this._totalLen;\n\n    this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n\n    this._buffDV.setUint32(60, ml % 4294967296, false);\n\n    this._step();\n  }\n\n  _step() {\n    const bigBlock32 = StringSHA1._bigBlock32;\n    const data = this._buffDV;\n\n    for (let j = 0; j < 64\n    /* 16*4 */\n    ; j += 4) {\n      bigBlock32.setUint32(j, data.getUint32(j, false), false);\n    }\n\n    for (let j = 64; j < 320\n    /* 80*4 */\n    ; j += 4) {\n      bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);\n    }\n\n    let a = this._h0;\n    let b = this._h1;\n    let c = this._h2;\n    let d = this._h3;\n    let e = this._h4;\n    let f, k;\n    let temp;\n\n    for (let j = 0; j < 80; j++) {\n      if (j < 20) {\n        f = b & c | ~b & d;\n        k = 0x5A827999;\n      } else if (j < 40) {\n        f = b ^ c ^ d;\n        k = 0x6ED9EBA1;\n      } else if (j < 60) {\n        f = b & c | b & d | c & d;\n        k = 0x8F1BBCDC;\n      } else {\n        f = b ^ c ^ d;\n        k = 0xCA62C1D6;\n      }\n\n      temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 0xffffffff;\n      e = d;\n      d = c;\n      c = leftRotate(b, 30);\n      b = a;\n      a = temp;\n    }\n\n    this._h0 = this._h0 + a & 0xffffffff;\n    this._h1 = this._h1 + b & 0xffffffff;\n    this._h2 = this._h2 + c & 0xffffffff;\n    this._h3 = this._h3 + d & 0xffffffff;\n    this._h4 = this._h4 + e & 0xffffffff;\n  }\n\n}\nStringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/hash.js"],"names":["strings","hash","obj","doHash","hashVal","numberHash","Array","isArray","arrayHash","objectHash","stringHash","booleanHash","val","initialHashVal","b","s","i","length","charCodeAt","arr","reduce","item","Object","keys","sort","key","leftRotate","value","bits","totalBits","delta","mask","fill","dest","index","count","byteLength","leftPad","char","toHexString","bufferOrValue","bitsize","ArrayBuffer","from","Uint8Array","map","toString","padStart","join","StringSHA1","constructor","_h0","_h1","_h2","_h3","_h4","_buff","_buffDV","DataView","buffer","_buffLen","_totalLen","_leftoverHighSurrogate","_finished","update","str","strLen","buff","buffLen","leftoverHighSurrogate","charCode","offset","codePoint","isHighSurrogate","nextCharCode","isLowSurrogate","computeCodePoint","_push","_step","digest","_wrapUp","ml","setUint32","Math","floor","bigBlock32","_bigBlock32","data","j","getUint32","a","c","d","e","f","k","temp"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\n/**\n * Return a hash value for an object.\n */\nexport function hash(obj) {\n    return doHash(obj, 0);\n}\nexport function doHash(obj, hashVal) {\n    switch (typeof obj) {\n        case 'object':\n            if (obj === null) {\n                return numberHash(349, hashVal);\n            }\n            else if (Array.isArray(obj)) {\n                return arrayHash(obj, hashVal);\n            }\n            return objectHash(obj, hashVal);\n        case 'string':\n            return stringHash(obj, hashVal);\n        case 'boolean':\n            return booleanHash(obj, hashVal);\n        case 'number':\n            return numberHash(obj, hashVal);\n        case 'undefined':\n            return numberHash(937, hashVal);\n        default:\n            return numberHash(617, hashVal);\n    }\n}\nexport function numberHash(val, initialHashVal) {\n    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32\n}\nfunction booleanHash(b, initialHashVal) {\n    return numberHash(b ? 433 : 863, initialHashVal);\n}\nexport function stringHash(s, hashVal) {\n    hashVal = numberHash(149417, hashVal);\n    for (let i = 0, length = s.length; i < length; i++) {\n        hashVal = numberHash(s.charCodeAt(i), hashVal);\n    }\n    return hashVal;\n}\nfunction arrayHash(arr, initialHashVal) {\n    initialHashVal = numberHash(104579, initialHashVal);\n    return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\n}\nfunction objectHash(obj, initialHashVal) {\n    initialHashVal = numberHash(181387, initialHashVal);\n    return Object.keys(obj).sort().reduce((hashVal, key) => {\n        hashVal = stringHash(key, hashVal);\n        return doHash(obj[key], hashVal);\n    }, initialHashVal);\n}\nfunction leftRotate(value, bits, totalBits = 32) {\n    // delta + bits = totalBits\n    const delta = totalBits - bits;\n    // All ones, expect `delta` zeros aligned to the right\n    const mask = ~((1 << delta) - 1);\n    // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\n    return ((value << bits) | ((mask & value) >>> delta)) >>> 0;\n}\nfunction fill(dest, index = 0, count = dest.byteLength, value = 0) {\n    for (let i = 0; i < count; i++) {\n        dest[index + i] = value;\n    }\n}\nfunction leftPad(value, length, char = '0') {\n    while (value.length < length) {\n        value = char + value;\n    }\n    return value;\n}\nexport function toHexString(bufferOrValue, bitsize = 32) {\n    if (bufferOrValue instanceof ArrayBuffer) {\n        return Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');\n    }\n    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);\n}\n/**\n * A SHA1 implementation that works with strings and does not allocate.\n */\nexport class StringSHA1 {\n    constructor() {\n        this._h0 = 0x67452301;\n        this._h1 = 0xEFCDAB89;\n        this._h2 = 0x98BADCFE;\n        this._h3 = 0x10325476;\n        this._h4 = 0xC3D2E1F0;\n        this._buff = new Uint8Array(64 /* BLOCK_SIZE */ + 3 /* to fit any utf-8 */);\n        this._buffDV = new DataView(this._buff.buffer);\n        this._buffLen = 0;\n        this._totalLen = 0;\n        this._leftoverHighSurrogate = 0;\n        this._finished = false;\n    }\n    update(str) {\n        const strLen = str.length;\n        if (strLen === 0) {\n            return;\n        }\n        const buff = this._buff;\n        let buffLen = this._buffLen;\n        let leftoverHighSurrogate = this._leftoverHighSurrogate;\n        let charCode;\n        let offset;\n        if (leftoverHighSurrogate !== 0) {\n            charCode = leftoverHighSurrogate;\n            offset = -1;\n            leftoverHighSurrogate = 0;\n        }\n        else {\n            charCode = str.charCodeAt(0);\n            offset = 0;\n        }\n        while (true) {\n            let codePoint = charCode;\n            if (strings.isHighSurrogate(charCode)) {\n                if (offset + 1 < strLen) {\n                    const nextCharCode = str.charCodeAt(offset + 1);\n                    if (strings.isLowSurrogate(nextCharCode)) {\n                        offset++;\n                        codePoint = strings.computeCodePoint(charCode, nextCharCode);\n                    }\n                    else {\n                        // illegal => unicode replacement character\n                        codePoint = 65533 /* UNICODE_REPLACEMENT */;\n                    }\n                }\n                else {\n                    // last character is a surrogate pair\n                    leftoverHighSurrogate = charCode;\n                    break;\n                }\n            }\n            else if (strings.isLowSurrogate(charCode)) {\n                // illegal => unicode replacement character\n                codePoint = 65533 /* UNICODE_REPLACEMENT */;\n            }\n            buffLen = this._push(buff, buffLen, codePoint);\n            offset++;\n            if (offset < strLen) {\n                charCode = str.charCodeAt(offset);\n            }\n            else {\n                break;\n            }\n        }\n        this._buffLen = buffLen;\n        this._leftoverHighSurrogate = leftoverHighSurrogate;\n    }\n    _push(buff, buffLen, codePoint) {\n        if (codePoint < 0x0080) {\n            buff[buffLen++] = codePoint;\n        }\n        else if (codePoint < 0x0800) {\n            buff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        else if (codePoint < 0x10000) {\n            buff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        else {\n            buff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        if (buffLen >= 64 /* BLOCK_SIZE */) {\n            this._step();\n            buffLen -= 64 /* BLOCK_SIZE */;\n            this._totalLen += 64 /* BLOCK_SIZE */;\n            // take last 3 in case of UTF8 overflow\n            buff[0] = buff[64 /* BLOCK_SIZE */ + 0];\n            buff[1] = buff[64 /* BLOCK_SIZE */ + 1];\n            buff[2] = buff[64 /* BLOCK_SIZE */ + 2];\n        }\n        return buffLen;\n    }\n    digest() {\n        if (!this._finished) {\n            this._finished = true;\n            if (this._leftoverHighSurrogate) {\n                // illegal => unicode replacement character\n                this._leftoverHighSurrogate = 0;\n                this._buffLen = this._push(this._buff, this._buffLen, 65533 /* UNICODE_REPLACEMENT */);\n            }\n            this._totalLen += this._buffLen;\n            this._wrapUp();\n        }\n        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n    }\n    _wrapUp() {\n        this._buff[this._buffLen++] = 0x80;\n        fill(this._buff, this._buffLen);\n        if (this._buffLen > 56) {\n            this._step();\n            fill(this._buff);\n        }\n        // this will fit because the mantissa can cover up to 52 bits\n        const ml = 8 * this._totalLen;\n        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n        this._buffDV.setUint32(60, ml % 4294967296, false);\n        this._step();\n    }\n    _step() {\n        const bigBlock32 = StringSHA1._bigBlock32;\n        const data = this._buffDV;\n        for (let j = 0; j < 64 /* 16*4 */; j += 4) {\n            bigBlock32.setUint32(j, data.getUint32(j, false), false);\n        }\n        for (let j = 64; j < 320 /* 80*4 */; j += 4) {\n            bigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);\n        }\n        let a = this._h0;\n        let b = this._h1;\n        let c = this._h2;\n        let d = this._h3;\n        let e = this._h4;\n        let f, k;\n        let temp;\n        for (let j = 0; j < 80; j++) {\n            if (j < 20) {\n                f = (b & c) | ((~b) & d);\n                k = 0x5A827999;\n            }\n            else if (j < 40) {\n                f = b ^ c ^ d;\n                k = 0x6ED9EBA1;\n            }\n            else if (j < 60) {\n                f = (b & c) | (b & d) | (c & d);\n                k = 0x8F1BBCDC;\n            }\n            else {\n                f = b ^ c ^ d;\n                k = 0xCA62C1D6;\n            }\n            temp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;\n            e = d;\n            d = c;\n            c = leftRotate(b, 30);\n            b = a;\n            a = temp;\n        }\n        this._h0 = (this._h0 + a) & 0xffffffff;\n        this._h1 = (this._h1 + b) & 0xffffffff;\n        this._h2 = (this._h2 + c) & 0xffffffff;\n        this._h3 = (this._h3 + d) & 0xffffffff;\n        this._h4 = (this._h4 + e) & 0xffffffff;\n    }\n}\nStringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320\n"]},"metadata":{},"sourceType":"module"}