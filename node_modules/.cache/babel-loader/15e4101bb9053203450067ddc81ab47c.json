{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isLowerAsciiLetter, isUpperAsciiLetter } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nexport class WordSelectionRangeProvider {\n  provideSelectionRanges(model, positions) {\n    const result = [];\n\n    for (const position of positions) {\n      const bucket = [];\n      result.push(bucket);\n\n      this._addInWordRanges(bucket, model, position);\n\n      this._addWordRanges(bucket, model, position);\n\n      this._addWhitespaceLine(bucket, model, position);\n\n      bucket.push({\n        range: model.getFullModelRange()\n      });\n    }\n\n    return result;\n  }\n\n  _addInWordRanges(bucket, model, pos) {\n    const obj = model.getWordAtPosition(pos);\n\n    if (!obj) {\n      return;\n    }\n\n    let {\n      word,\n      startColumn\n    } = obj;\n    let offset = pos.column - startColumn;\n    let start = offset;\n    let end = offset;\n    let lastCh = 0; // LEFT anchor (start)\n\n    for (; start >= 0; start--) {\n      let ch = word.charCodeAt(start);\n\n      if (start !== offset && (ch === 95\n      /* Underline */\n      || ch === 45\n      /* Dash */\n      )) {\n        // foo-bar OR foo_bar\n        break;\n      } else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {\n        // fooBar\n        break;\n      }\n\n      lastCh = ch;\n    }\n\n    start += 1; // RIGHT anchor (end)\n\n    for (; end < word.length; end++) {\n      let ch = word.charCodeAt(end);\n\n      if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {\n        // fooBar\n        break;\n      } else if (ch === 95\n      /* Underline */\n      || ch === 45\n      /* Dash */\n      ) {\n        // foo-bar OR foo_bar\n        break;\n      }\n\n      lastCh = ch;\n    }\n\n    if (start < end) {\n      bucket.push({\n        range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end)\n      });\n    }\n  }\n\n  _addWordRanges(bucket, model, pos) {\n    const word = model.getWordAtPosition(pos);\n\n    if (word) {\n      bucket.push({\n        range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn)\n      });\n    }\n  }\n\n  _addWhitespaceLine(bucket, model, pos) {\n    if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {\n      bucket.push({\n        range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber))\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/wordSelections.js"],"names":["isLowerAsciiLetter","isUpperAsciiLetter","Range","WordSelectionRangeProvider","provideSelectionRanges","model","positions","result","position","bucket","push","_addInWordRanges","_addWordRanges","_addWhitespaceLine","range","getFullModelRange","pos","obj","getWordAtPosition","word","startColumn","offset","column","start","end","lastCh","ch","charCodeAt","length","lineNumber","endColumn","getLineLength","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","getLineMaxColumn"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isLowerAsciiLetter, isUpperAsciiLetter } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nexport class WordSelectionRangeProvider {\n    provideSelectionRanges(model, positions) {\n        const result = [];\n        for (const position of positions) {\n            const bucket = [];\n            result.push(bucket);\n            this._addInWordRanges(bucket, model, position);\n            this._addWordRanges(bucket, model, position);\n            this._addWhitespaceLine(bucket, model, position);\n            bucket.push({ range: model.getFullModelRange() });\n        }\n        return result;\n    }\n    _addInWordRanges(bucket, model, pos) {\n        const obj = model.getWordAtPosition(pos);\n        if (!obj) {\n            return;\n        }\n        let { word, startColumn } = obj;\n        let offset = pos.column - startColumn;\n        let start = offset;\n        let end = offset;\n        let lastCh = 0;\n        // LEFT anchor (start)\n        for (; start >= 0; start--) {\n            let ch = word.charCodeAt(start);\n            if ((start !== offset) && (ch === 95 /* Underline */ || ch === 45 /* Dash */)) {\n                // foo-bar OR foo_bar\n                break;\n            }\n            else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {\n                // fooBar\n                break;\n            }\n            lastCh = ch;\n        }\n        start += 1;\n        // RIGHT anchor (end)\n        for (; end < word.length; end++) {\n            let ch = word.charCodeAt(end);\n            if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {\n                // fooBar\n                break;\n            }\n            else if (ch === 95 /* Underline */ || ch === 45 /* Dash */) {\n                // foo-bar OR foo_bar\n                break;\n            }\n            lastCh = ch;\n        }\n        if (start < end) {\n            bucket.push({ range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end) });\n        }\n    }\n    _addWordRanges(bucket, model, pos) {\n        const word = model.getWordAtPosition(pos);\n        if (word) {\n            bucket.push({ range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn) });\n        }\n    }\n    _addWhitespaceLine(bucket, model, pos) {\n        if (model.getLineLength(pos.lineNumber) > 0\n            && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0\n            && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {\n            bucket.push({ range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)) });\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}