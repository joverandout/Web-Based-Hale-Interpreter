{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\n\nexport class Range {\n  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {\n      this.startLineNumber = endLineNumber;\n      this.startColumn = endColumn;\n      this.endLineNumber = startLineNumber;\n      this.endColumn = startColumn;\n    } else {\n      this.startLineNumber = startLineNumber;\n      this.startColumn = startColumn;\n      this.endLineNumber = endLineNumber;\n      this.endColumn = endColumn;\n    }\n  }\n  /**\n   * Test if this range is empty.\n   */\n\n\n  isEmpty() {\n    return Range.isEmpty(this);\n  }\n  /**\n   * Test if `range` is empty.\n   */\n\n\n  static isEmpty(range) {\n    return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;\n  }\n  /**\n   * Test if position is in this range. If the position is at the edges, will return true.\n   */\n\n\n  containsPosition(position) {\n    return Range.containsPosition(this, position);\n  }\n  /**\n   * Test if `position` is in `range`. If the position is at the edges, will return true.\n   */\n\n\n  static containsPosition(range, position) {\n    if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n      return false;\n    }\n\n    if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n      return false;\n    }\n\n    if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Test if `position` is in `range`. If the position is at the edges, will return false.\n   * @internal\n   */\n\n\n  static strictContainsPosition(range, position) {\n    if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n      return false;\n    }\n\n    if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n      return false;\n    }\n\n    if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Test if range is in this range. If the range is equal to this range, will return true.\n   */\n\n\n  containsRange(range) {\n    return Range.containsRange(this, range);\n  }\n  /**\n   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n   */\n\n\n  static containsRange(range, otherRange) {\n    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n      return false;\n    }\n\n    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n      return false;\n    }\n\n    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n      return false;\n    }\n\n    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n   */\n\n\n  strictContainsRange(range) {\n    return Range.strictContainsRange(this, range);\n  }\n  /**\n   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n   */\n\n\n  static strictContainsRange(range, otherRange) {\n    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n      return false;\n    }\n\n    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n      return false;\n    }\n\n    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n      return false;\n    }\n\n    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * A reunion of the two ranges.\n   * The smallest position will be used as the start point, and the largest one as the end point.\n   */\n\n\n  plusRange(range) {\n    return Range.plusRange(this, range);\n  }\n  /**\n   * A reunion of the two ranges.\n   * The smallest position will be used as the start point, and the largest one as the end point.\n   */\n\n\n  static plusRange(a, b) {\n    let startLineNumber;\n    let startColumn;\n    let endLineNumber;\n    let endColumn;\n\n    if (b.startLineNumber < a.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = b.startColumn;\n    } else if (b.startLineNumber === a.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = Math.min(b.startColumn, a.startColumn);\n    } else {\n      startLineNumber = a.startLineNumber;\n      startColumn = a.startColumn;\n    }\n\n    if (b.endLineNumber > a.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = b.endColumn;\n    } else if (b.endLineNumber === a.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = Math.max(b.endColumn, a.endColumn);\n    } else {\n      endLineNumber = a.endLineNumber;\n      endColumn = a.endColumn;\n    }\n\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  /**\n   * A intersection of the two ranges.\n   */\n\n\n  intersectRanges(range) {\n    return Range.intersectRanges(this, range);\n  }\n  /**\n   * A intersection of the two ranges.\n   */\n\n\n  static intersectRanges(a, b) {\n    let resultStartLineNumber = a.startLineNumber;\n    let resultStartColumn = a.startColumn;\n    let resultEndLineNumber = a.endLineNumber;\n    let resultEndColumn = a.endColumn;\n    let otherStartLineNumber = b.startLineNumber;\n    let otherStartColumn = b.startColumn;\n    let otherEndLineNumber = b.endLineNumber;\n    let otherEndColumn = b.endColumn;\n\n    if (resultStartLineNumber < otherStartLineNumber) {\n      resultStartLineNumber = otherStartLineNumber;\n      resultStartColumn = otherStartColumn;\n    } else if (resultStartLineNumber === otherStartLineNumber) {\n      resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n    }\n\n    if (resultEndLineNumber > otherEndLineNumber) {\n      resultEndLineNumber = otherEndLineNumber;\n      resultEndColumn = otherEndColumn;\n    } else if (resultEndLineNumber === otherEndLineNumber) {\n      resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n    } // Check if selection is now empty\n\n\n    if (resultStartLineNumber > resultEndLineNumber) {\n      return null;\n    }\n\n    if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n      return null;\n    }\n\n    return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n  }\n  /**\n   * Test if this range equals other.\n   */\n\n\n  equalsRange(other) {\n    return Range.equalsRange(this, other);\n  }\n  /**\n   * Test if range `a` equals `b`.\n   */\n\n\n  static equalsRange(a, b) {\n    return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;\n  }\n  /**\n   * Return the end position (which will be after or equal to the start position)\n   */\n\n\n  getEndPosition() {\n    return Range.getEndPosition(this);\n  }\n  /**\n   * Return the end position (which will be after or equal to the start position)\n   */\n\n\n  static getEndPosition(range) {\n    return new Position(range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Return the start position (which will be before or equal to the end position)\n   */\n\n\n  getStartPosition() {\n    return Range.getStartPosition(this);\n  }\n  /**\n   * Return the start position (which will be before or equal to the end position)\n   */\n\n\n  static getStartPosition(range) {\n    return new Position(range.startLineNumber, range.startColumn);\n  }\n  /**\n   * Transform to a user presentable string representation.\n   */\n\n\n  toString() {\n    return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n  }\n  /**\n   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n   */\n\n\n  setEndPosition(endLineNumber, endColumn) {\n    return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n  }\n  /**\n   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n   */\n\n\n  setStartPosition(startLineNumber, startColumn) {\n    return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n  }\n  /**\n   * Create a new empty range using this range's start position.\n   */\n\n\n  collapseToStart() {\n    return Range.collapseToStart(this);\n  }\n  /**\n   * Create a new empty range using this range's start position.\n   */\n\n\n  static collapseToStart(range) {\n    return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n  } // ---\n\n\n  static fromPositions(start, end = start) {\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n\n  static lift(range) {\n    if (!range) {\n      return null;\n    }\n\n    return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n  }\n  /**\n   * Test if `obj` is an `IRange`.\n   */\n\n\n  static isIRange(obj) {\n    return obj && typeof obj.startLineNumber === 'number' && typeof obj.startColumn === 'number' && typeof obj.endLineNumber === 'number' && typeof obj.endColumn === 'number';\n  }\n  /**\n   * Test if the two ranges are touching in any way.\n   */\n\n\n  static areIntersectingOrTouching(a, b) {\n    // Check if `a` is before `b`\n    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {\n      return false;\n    } // Check if `b` is before `a`\n\n\n    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {\n      return false;\n    } // These ranges must intersect\n\n\n    return true;\n  }\n  /**\n   * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n   */\n\n\n  static areIntersecting(a, b) {\n    // Check if `a` is before `b`\n    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {\n      return false;\n    } // Check if `b` is before `a`\n\n\n    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {\n      return false;\n    } // These ranges must intersect\n\n\n    return true;\n  }\n  /**\n   * A function that compares ranges, useful for sorting ranges\n   * It will first compare ranges on the startPosition and then on the endPosition\n   */\n\n\n  static compareRangesUsingStarts(a, b) {\n    if (a && b) {\n      const aStartLineNumber = a.startLineNumber | 0;\n      const bStartLineNumber = b.startLineNumber | 0;\n\n      if (aStartLineNumber === bStartLineNumber) {\n        const aStartColumn = a.startColumn | 0;\n        const bStartColumn = b.startColumn | 0;\n\n        if (aStartColumn === bStartColumn) {\n          const aEndLineNumber = a.endLineNumber | 0;\n          const bEndLineNumber = b.endLineNumber | 0;\n\n          if (aEndLineNumber === bEndLineNumber) {\n            const aEndColumn = a.endColumn | 0;\n            const bEndColumn = b.endColumn | 0;\n            return aEndColumn - bEndColumn;\n          }\n\n          return aEndLineNumber - bEndLineNumber;\n        }\n\n        return aStartColumn - bStartColumn;\n      }\n\n      return aStartLineNumber - bStartLineNumber;\n    }\n\n    const aExists = a ? 1 : 0;\n    const bExists = b ? 1 : 0;\n    return aExists - bExists;\n  }\n  /**\n   * A function that compares ranges, useful for sorting ranges\n   * It will first compare ranges on the endPosition and then on the startPosition\n   */\n\n\n  static compareRangesUsingEnds(a, b) {\n    if (a.endLineNumber === b.endLineNumber) {\n      if (a.endColumn === b.endColumn) {\n        if (a.startLineNumber === b.startLineNumber) {\n          return a.startColumn - b.startColumn;\n        }\n\n        return a.startLineNumber - b.startLineNumber;\n      }\n\n      return a.endColumn - b.endColumn;\n    }\n\n    return a.endLineNumber - b.endLineNumber;\n  }\n  /**\n   * Test if the range spans multiple lines.\n   */\n\n\n  static spansMultipleLines(range) {\n    return range.endLineNumber > range.startLineNumber;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/core/range.js"],"names":["Position","Range","constructor","startLineNumber","startColumn","endLineNumber","endColumn","isEmpty","range","containsPosition","position","lineNumber","column","strictContainsPosition","containsRange","otherRange","strictContainsRange","plusRange","a","b","Math","min","max","intersectRanges","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","equalsRange","other","getEndPosition","getStartPosition","toString","setEndPosition","setStartPosition","collapseToStart","fromPositions","start","end","lift","isIRange","obj","areIntersectingOrTouching","areIntersecting","compareRangesUsingStarts","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","aEndColumn","bEndColumn","aExists","bExists","compareRangesUsingEnds","spansMultipleLines"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        let otherStartLineNumber = b.startLineNumber;\n        let otherStartColumn = b.startColumn;\n        let otherEndLineNumber = b.endLineNumber;\n        let otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}