{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\n\nclass LinePart {\n  constructor(endIndex, type, metadata) {\n    this._linePartBrand = undefined;\n    this.endIndex = endIndex;\n    this.type = type;\n    this.metadata = metadata;\n  }\n\n  isWhitespace() {\n    return this.metadata & 1\n    /* IS_WHITESPACE_MASK */\n    ? true : false;\n  }\n\n  isPseudoAfter() {\n    return this.metadata & 4\n    /* PSEUDO_AFTER_MASK */\n    ? true : false;\n  }\n\n}\n\nexport class LineRange {\n  constructor(startIndex, endIndex) {\n    this.startOffset = startIndex;\n    this.endOffset = endIndex;\n  }\n\n  equals(otherLineRange) {\n    return this.startOffset === otherLineRange.startOffset && this.endOffset === otherLineRange.endOffset;\n  }\n\n}\nexport class RenderLineInput {\n  constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n    this.useMonospaceOptimizations = useMonospaceOptimizations;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.continuesWithWrappedLine = continuesWithWrappedLine;\n    this.isBasicASCII = isBasicASCII;\n    this.containsRTL = containsRTL;\n    this.fauxIndentLength = fauxIndentLength;\n    this.lineTokens = lineTokens;\n    this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.spaceWidth = spaceWidth;\n    this.stopRenderingLineAfter = stopRenderingLineAfter;\n    this.renderWhitespace = renderWhitespace === 'all' ? 4\n    /* All */\n    : renderWhitespace === 'boundary' ? 1\n    /* Boundary */\n    : renderWhitespace === 'selection' ? 2\n    /* Selection */\n    : renderWhitespace === 'trailing' ? 3\n    /* Trailing */\n    : 0\n    /* None */\n    ;\n    this.renderControlCharacters = renderControlCharacters;\n    this.fontLigatures = fontLigatures;\n    this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n    const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n    const middotDiff = Math.abs(middotWidth - spaceWidth);\n\n    if (wsmiddotDiff < middotDiff) {\n      this.renderSpaceWidth = wsmiddotWidth;\n      this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n    } else {\n      this.renderSpaceWidth = middotWidth;\n      this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n    }\n  }\n\n  sameSelection(otherSelections) {\n    if (this.selectionsOnLine === null) {\n      return otherSelections === null;\n    }\n\n    if (otherSelections === null) {\n      return false;\n    }\n\n    if (otherSelections.length !== this.selectionsOnLine.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.selectionsOnLine.length; i++) {\n      if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  equals(other) {\n    return this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineContent === other.lineContent && this.continuesWithWrappedLine === other.continuesWithWrappedLine && this.isBasicASCII === other.isBasicASCII && this.containsRTL === other.containsRTL && this.fauxIndentLength === other.fauxIndentLength && this.tabSize === other.tabSize && this.startVisibleColumn === other.startVisibleColumn && this.spaceWidth === other.spaceWidth && this.renderSpaceWidth === other.renderSpaceWidth && this.renderSpaceCharCode === other.renderSpaceCharCode && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.fontLigatures === other.fontLigatures && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations) && this.lineTokens.equals(other.lineTokens) && this.sameSelection(other.selectionsOnLine);\n  }\n\n}\nexport class DomPosition {\n  constructor(partIndex, charIndex) {\n    this.partIndex = partIndex;\n    this.charIndex = charIndex;\n  }\n\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\n\nexport class CharacterMapping {\n  constructor(length, partCount) {\n    this.length = length;\n    this._data = new Uint32Array(this.length);\n    this._absoluteOffsets = new Uint32Array(this.length);\n  }\n\n  static getPartIndex(partData) {\n    return (partData & 4294901760\n    /* PART_INDEX_MASK */\n    ) >>> 16\n    /* PART_INDEX_OFFSET */\n    ;\n  }\n\n  static getCharIndex(partData) {\n    return (partData & 65535\n    /* CHAR_INDEX_MASK */\n    ) >>> 0\n    /* CHAR_INDEX_OFFSET */\n    ;\n  }\n\n  setColumnInfo(column, partIndex, charIndex, partAbsoluteOffset) {\n    const partData = (partIndex << 16\n    /* PART_INDEX_OFFSET */\n    | charIndex << 0\n    /* CHAR_INDEX_OFFSET */\n    ) >>> 0;\n    this._data[column - 1] = partData;\n    this._absoluteOffsets[column - 1] = partAbsoluteOffset + charIndex;\n  }\n\n  getAbsoluteOffset(column) {\n    if (this._absoluteOffsets.length === 0) {\n      // No characters on this line\n      return 0;\n    }\n\n    return this._absoluteOffsets[column - 1];\n  }\n\n  charOffsetToPartData(charOffset) {\n    if (this.length === 0) {\n      return 0;\n    }\n\n    if (charOffset < 0) {\n      return this._data[0];\n    }\n\n    if (charOffset >= this.length) {\n      return this._data[this.length - 1];\n    }\n\n    return this._data[charOffset];\n  }\n\n  getDomPosition(column) {\n    const partData = this.charOffsetToPartData(column - 1);\n    const partIndex = CharacterMapping.getPartIndex(partData);\n    const charIndex = CharacterMapping.getCharIndex(partData);\n    return new DomPosition(partIndex, charIndex);\n  }\n\n  getColumn(domPosition, partLength) {\n    const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n    return charOffset + 1;\n  }\n\n  partDataToCharOffset(partIndex, partLength, charIndex) {\n    if (this.length === 0) {\n      return 0;\n    }\n\n    const searchEntry = (partIndex << 16\n    /* PART_INDEX_OFFSET */\n    | charIndex << 0\n    /* CHAR_INDEX_OFFSET */\n    ) >>> 0;\n    let min = 0;\n    let max = this.length - 1;\n\n    while (min + 1 < max) {\n      const mid = min + max >>> 1;\n      const midEntry = this._data[mid];\n\n      if (midEntry === searchEntry) {\n        return mid;\n      } else if (midEntry > searchEntry) {\n        max = mid;\n      } else {\n        min = mid;\n      }\n    }\n\n    if (min === max) {\n      return min;\n    }\n\n    const minEntry = this._data[min];\n    const maxEntry = this._data[max];\n\n    if (minEntry === searchEntry) {\n      return min;\n    }\n\n    if (maxEntry === searchEntry) {\n      return max;\n    }\n\n    const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n    const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n    const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n    let maxCharIndex;\n\n    if (minPartIndex !== maxPartIndex) {\n      // sitting between parts\n      maxCharIndex = partLength;\n    } else {\n      maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n    }\n\n    const minEntryDistance = charIndex - minCharIndex;\n    const maxEntryDistance = maxCharIndex - charIndex;\n\n    if (minEntryDistance <= maxEntryDistance) {\n      return min;\n    }\n\n    return max;\n  }\n\n}\nexport class RenderLineOutput {\n  constructor(characterMapping, containsRTL, containsForeignElements) {\n    this._renderLineOutputBrand = undefined;\n    this.characterMapping = characterMapping;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n\n}\nexport function renderViewLine(input, sb) {\n  if (input.lineContent.length === 0) {\n    if (input.lineDecorations.length > 0) {\n      // This line is empty, but it contains inline decorations\n      sb.appendASCIIString(`<span>`);\n      let beforeCount = 0;\n      let afterCount = 0;\n      let containsForeignElements = 0\n      /* None */\n      ;\n\n      for (const lineDecoration of input.lineDecorations) {\n        if (lineDecoration.type === 1\n        /* Before */\n        || lineDecoration.type === 2\n        /* After */\n        ) {\n          sb.appendASCIIString(`<span class=\"`);\n          sb.appendASCIIString(lineDecoration.className);\n          sb.appendASCIIString(`\"></span>`);\n\n          if (lineDecoration.type === 1\n          /* Before */\n          ) {\n            containsForeignElements |= 1\n            /* Before */\n            ;\n            beforeCount++;\n          }\n\n          if (lineDecoration.type === 2\n          /* After */\n          ) {\n            containsForeignElements |= 2\n            /* After */\n            ;\n            afterCount++;\n          }\n        }\n      }\n\n      sb.appendASCIIString(`</span>`);\n      const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n      characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n      return new RenderLineOutput(characterMapping, false, containsForeignElements);\n    } // completely empty line\n\n\n    sb.appendASCIIString('<span><span></span></span>');\n    return new RenderLineOutput(new CharacterMapping(0, 0), false, 0\n    /* None */\n    );\n  }\n\n  return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n  constructor(characterMapping, html, containsRTL, containsForeignElements) {\n    this.characterMapping = characterMapping;\n    this.html = html;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n\n}\nexport function renderViewLine2(input) {\n  const sb = createStringBuilder(10000);\n  const out = renderViewLine(input, sb);\n  return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\n\nclass ResolvedRenderLineInput {\n  constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n    this.fontIsMonospace = fontIsMonospace;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.len = len;\n    this.isOverflowing = isOverflowing;\n    this.parts = parts;\n    this.containsForeignElements = containsForeignElements;\n    this.fauxIndentLength = fauxIndentLength;\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.containsRTL = containsRTL;\n    this.spaceWidth = spaceWidth;\n    this.renderSpaceCharCode = renderSpaceCharCode;\n    this.renderWhitespace = renderWhitespace;\n    this.renderControlCharacters = renderControlCharacters; //\n  }\n\n}\n\nfunction resolveRenderLineInput(input) {\n  const lineContent = input.lineContent;\n  let isOverflowing;\n  let len;\n\n  if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n    isOverflowing = true;\n    len = input.stopRenderingLineAfter;\n  } else {\n    isOverflowing = false;\n    len = lineContent.length;\n  }\n\n  let tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n\n  if (input.renderControlCharacters && !input.isBasicASCII) {\n    // Calling `extractControlCharacters` before adding (possibly empty) line parts\n    // for inline decorations. `extractControlCharacters` removes empty line parts.\n    tokens = extractControlCharacters(lineContent, tokens);\n  }\n\n  if (input.renderWhitespace === 4\n  /* All */\n  || input.renderWhitespace === 1\n  /* Boundary */\n  || input.renderWhitespace === 2\n  /* Selection */\n  && !!input.selectionsOnLine || input.renderWhitespace === 3\n  /* Trailing */\n  ) {\n    tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n  }\n\n  let containsForeignElements = 0\n  /* None */\n  ;\n\n  if (input.lineDecorations.length > 0) {\n    for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n      const lineDecoration = input.lineDecorations[i];\n\n      if (lineDecoration.type === 3\n      /* RegularAffectingLetterSpacing */\n      ) {\n        // Pretend there are foreign elements... although not 100% accurate.\n        containsForeignElements |= 1\n        /* Before */\n        ;\n      } else if (lineDecoration.type === 1\n      /* Before */\n      ) {\n        containsForeignElements |= 1\n        /* Before */\n        ;\n      } else if (lineDecoration.type === 2\n      /* After */\n      ) {\n        containsForeignElements |= 2\n        /* After */\n        ;\n      }\n    }\n\n    tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n  }\n\n  if (!input.containsRTL) {\n    // We can never split RTL text, as it ruins the rendering\n    tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n  }\n\n  return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\n\n\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n  const result = [];\n  let resultLen = 0; // The faux indent part of the line should have no token type\n\n  if (fauxIndentLength > 0) {\n    result[resultLen++] = new LinePart(fauxIndentLength, '', 0);\n  }\n\n  for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n    const endIndex = tokens.getEndOffset(tokenIndex);\n\n    if (endIndex <= fauxIndentLength) {\n      // The faux indent part of the line should have no token type\n      continue;\n    }\n\n    const type = tokens.getClassName(tokenIndex);\n\n    if (endIndex >= len) {\n      result[resultLen++] = new LinePart(len, type, 0);\n      break;\n    }\n\n    result[resultLen++] = new LinePart(endIndex, type, 0);\n  }\n\n  return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\n\n\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n  let lastTokenEndIndex = 0;\n  const result = [];\n  let resultLen = 0;\n\n  if (onlyAtSpaces) {\n    // Split only at spaces => we need to walk each character\n    for (let i = 0, len = tokens.length; i < len; i++) {\n      const token = tokens[i];\n      const tokenEndIndex = token.endIndex;\n\n      if (lastTokenEndIndex + 50\n      /* LongToken */\n      < tokenEndIndex) {\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        let lastSpaceOffset = -1;\n        let currTokenStart = lastTokenEndIndex;\n\n        for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n          if (lineContent.charCodeAt(j) === 32\n          /* Space */\n          ) {\n            lastSpaceOffset = j;\n          }\n\n          if (lastSpaceOffset !== -1 && j - currTokenStart >= 50\n          /* LongToken */\n          ) {\n            // Split at `lastSpaceOffset` + 1\n            result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata);\n            currTokenStart = lastSpaceOffset + 1;\n            lastSpaceOffset = -1;\n          }\n        }\n\n        if (currTokenStart !== tokenEndIndex) {\n          result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n        }\n      } else {\n        result[resultLen++] = token;\n      }\n\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  } else {\n    // Split anywhere => we don't need to walk each character\n    for (let i = 0, len = tokens.length; i < len; i++) {\n      const token = tokens[i];\n      const tokenEndIndex = token.endIndex;\n      const diff = tokenEndIndex - lastTokenEndIndex;\n\n      if (diff > 50\n      /* LongToken */\n      ) {\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const piecesCount = Math.ceil(diff / 50\n        /* LongToken */\n        );\n\n        for (let j = 1; j < piecesCount; j++) {\n          const pieceEndIndex = lastTokenEndIndex + j * 50\n          /* LongToken */\n          ;\n          result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata);\n        }\n\n        result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n      } else {\n        result[resultLen++] = token;\n      }\n\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  }\n\n  return result;\n}\n\nfunction isControlCharacter(charCode) {\n  if (charCode < 32) {\n    return charCode !== 9\n    /* Tab */\n    ;\n  }\n\n  if (charCode === 127) {\n    // DEL\n    return true;\n  }\n\n  if (charCode >= 0x202A && charCode <= 0x202E || charCode >= 0x2066 && charCode <= 0x2069 || charCode >= 0x200E && charCode <= 0x200F || charCode === 0x061C) {\n    // Unicode Directional Formatting Characters\n    // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n    // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n    // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n    // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n    // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n    // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n    // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n    // FSI\tU+2068\tFIRST STRONG ISOLATE\n    // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n    // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n    // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n    // ALM\tU+061C\tARABIC LETTER MARK\n    return true;\n  }\n\n  return false;\n}\n\nfunction extractControlCharacters(lineContent, tokens) {\n  const result = [];\n  let lastLinePart = new LinePart(0, '', 0);\n  let charOffset = 0;\n\n  for (const token of tokens) {\n    const tokenEndIndex = token.endIndex;\n\n    for (; charOffset < tokenEndIndex; charOffset++) {\n      const charCode = lineContent.charCodeAt(charOffset);\n\n      if (isControlCharacter(charCode)) {\n        if (charOffset > lastLinePart.endIndex) {\n          // emit previous part if it has text\n          lastLinePart = new LinePart(charOffset, token.type, token.metadata);\n          result.push(lastLinePart);\n        }\n\n        lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata);\n        result.push(lastLinePart);\n      }\n    }\n\n    if (charOffset > lastLinePart.endIndex) {\n      // emit previous part if it has text\n      lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata);\n      result.push(lastLinePart);\n    }\n  }\n\n  return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\n\n\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n  const continuesWithWrappedLine = input.continuesWithWrappedLine;\n  const fauxIndentLength = input.fauxIndentLength;\n  const tabSize = input.tabSize;\n  const startVisibleColumn = input.startVisibleColumn;\n  const useMonospaceOptimizations = input.useMonospaceOptimizations;\n  const selections = input.selectionsOnLine;\n  const onlyBoundary = input.renderWhitespace === 1\n  /* Boundary */\n  ;\n  const onlyTrailing = input.renderWhitespace === 3\n  /* Trailing */\n  ;\n  const generateLinePartForEachWhitespace = input.renderSpaceWidth !== input.spaceWidth;\n  const result = [];\n  let resultLen = 0;\n  let tokenIndex = 0;\n  let tokenType = tokens[tokenIndex].type;\n  let tokenEndIndex = tokens[tokenIndex].endIndex;\n  const tokensLength = tokens.length;\n  let lineIsEmptyOrWhitespace = false;\n  let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n  let lastNonWhitespaceIndex;\n\n  if (firstNonWhitespaceIndex === -1) {\n    lineIsEmptyOrWhitespace = true;\n    firstNonWhitespaceIndex = len;\n    lastNonWhitespaceIndex = len;\n  } else {\n    lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n  }\n\n  let wasInWhitespace = false;\n  let currentSelectionIndex = 0;\n  let currentSelection = selections && selections[currentSelectionIndex];\n  let tmpIndent = startVisibleColumn % tabSize;\n\n  for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n    const chCode = lineContent.charCodeAt(charIndex);\n\n    if (currentSelection && charIndex >= currentSelection.endOffset) {\n      currentSelectionIndex++;\n      currentSelection = selections && selections[currentSelectionIndex];\n    }\n\n    let isInWhitespace;\n\n    if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n      // in leading or trailing whitespace\n      isInWhitespace = true;\n    } else if (chCode === 9\n    /* Tab */\n    ) {\n      // a tab character is rendered both in all and boundary cases\n      isInWhitespace = true;\n    } else if (chCode === 32\n    /* Space */\n    ) {\n      // hit a space character\n      if (onlyBoundary) {\n        // rendering only boundary whitespace\n        if (wasInWhitespace) {\n          isInWhitespace = true;\n        } else {\n          const nextChCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0\n          /* Null */\n          ;\n          isInWhitespace = nextChCode === 32\n          /* Space */\n          || nextChCode === 9\n          /* Tab */\n          ;\n        }\n      } else {\n        isInWhitespace = true;\n      }\n    } else {\n      isInWhitespace = false;\n    } // If rendering whitespace on selection, check that the charIndex falls within a selection\n\n\n    if (isInWhitespace && selections) {\n      isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n    } // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n\n\n    if (isInWhitespace && onlyTrailing) {\n      isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n    }\n\n    if (wasInWhitespace) {\n      // was in whitespace token\n      if (!isInWhitespace || !useMonospaceOptimizations && tmpIndent >= tabSize) {\n        // leaving whitespace token or entering a new indent\n        if (generateLinePartForEachWhitespace) {\n          const lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;\n\n          for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n            result[resultLen++] = new LinePart(i, 'mtkw', 1\n            /* IS_WHITESPACE */\n            );\n          }\n        } else {\n          result[resultLen++] = new LinePart(charIndex, 'mtkw', 1\n          /* IS_WHITESPACE */\n          );\n        }\n\n        tmpIndent = tmpIndent % tabSize;\n      }\n    } else {\n      // was in regular token\n      if (charIndex === tokenEndIndex || isInWhitespace && charIndex > fauxIndentLength) {\n        result[resultLen++] = new LinePart(charIndex, tokenType, 0);\n        tmpIndent = tmpIndent % tabSize;\n      }\n    }\n\n    if (chCode === 9\n    /* Tab */\n    ) {\n      tmpIndent = tabSize;\n    } else if (strings.isFullWidthCharacter(chCode)) {\n      tmpIndent += 2;\n    } else {\n      tmpIndent++;\n    }\n\n    wasInWhitespace = isInWhitespace;\n\n    while (charIndex === tokenEndIndex) {\n      tokenIndex++;\n\n      if (tokenIndex < tokensLength) {\n        tokenType = tokens[tokenIndex].type;\n        tokenEndIndex = tokens[tokenIndex].endIndex;\n      } else {\n        break;\n      }\n    }\n  }\n\n  let generateWhitespace = false;\n\n  if (wasInWhitespace) {\n    // was in whitespace token\n    if (continuesWithWrappedLine && onlyBoundary) {\n      const lastCharCode = len > 0 ? lineContent.charCodeAt(len - 1) : 0\n      /* Null */\n      ;\n      const prevCharCode = len > 1 ? lineContent.charCodeAt(len - 2) : 0\n      /* Null */\n      ;\n      const isSingleTrailingSpace = lastCharCode === 32\n      /* Space */\n      && prevCharCode !== 32\n      /* Space */\n      && prevCharCode !== 9\n      /* Tab */\n      ;\n\n      if (!isSingleTrailingSpace) {\n        generateWhitespace = true;\n      }\n    } else {\n      generateWhitespace = true;\n    }\n  }\n\n  if (generateWhitespace) {\n    if (generateLinePartForEachWhitespace) {\n      const lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;\n\n      for (let i = lastEndIndex + 1; i <= len; i++) {\n        result[resultLen++] = new LinePart(i, 'mtkw', 1\n        /* IS_WHITESPACE */\n        );\n      }\n    } else {\n      result[resultLen++] = new LinePart(len, 'mtkw', 1\n      /* IS_WHITESPACE */\n      );\n    }\n  } else {\n    result[resultLen++] = new LinePart(len, tokenType, 0);\n  }\n\n  return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\n\n\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n  _lineDecorations.sort(LineDecoration.compare);\n\n  const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n  const lineDecorationsLen = lineDecorations.length;\n  let lineDecorationIndex = 0;\n  const result = [];\n  let resultLen = 0;\n  let lastResultEndIndex = 0;\n\n  for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n    const token = tokens[tokenIndex];\n    const tokenEndIndex = token.endIndex;\n    const tokenType = token.type;\n    const tokenMetadata = token.metadata;\n\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n      const lineDecoration = lineDecorations[lineDecorationIndex];\n\n      if (lineDecoration.startOffset > lastResultEndIndex) {\n        lastResultEndIndex = lineDecoration.startOffset;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n      }\n\n      if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n        // This line decoration ends before this token ends\n        lastResultEndIndex = lineDecoration.endOffset + 1;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n        lineDecorationIndex++;\n      } else {\n        // This line decoration continues on to the next token\n        lastResultEndIndex = tokenEndIndex;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n        break;\n      }\n    }\n\n    if (tokenEndIndex > lastResultEndIndex) {\n      lastResultEndIndex = tokenEndIndex;\n      result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n    }\n  }\n\n  const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n\n  if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n      const lineDecoration = lineDecorations[lineDecorationIndex];\n      result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata);\n      lineDecorationIndex++;\n    }\n  }\n\n  return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\n\n\nfunction _renderLine(input, sb) {\n  const fontIsMonospace = input.fontIsMonospace;\n  const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n  const containsForeignElements = input.containsForeignElements;\n  const lineContent = input.lineContent;\n  const len = input.len;\n  const isOverflowing = input.isOverflowing;\n  const parts = input.parts;\n  const fauxIndentLength = input.fauxIndentLength;\n  const tabSize = input.tabSize;\n  const startVisibleColumn = input.startVisibleColumn;\n  const containsRTL = input.containsRTL;\n  const spaceWidth = input.spaceWidth;\n  const renderSpaceCharCode = input.renderSpaceCharCode;\n  const renderWhitespace = input.renderWhitespace;\n  const renderControlCharacters = input.renderControlCharacters;\n  const characterMapping = new CharacterMapping(len + 1, parts.length);\n  let lastCharacterMappingDefined = false;\n  let charIndex = 0;\n  let visibleColumn = startVisibleColumn;\n  let charOffsetInPart = 0;\n  let partDisplacement = 0;\n  let prevPartContentCnt = 0;\n  let partAbsoluteOffset = 0;\n\n  if (containsRTL) {\n    sb.appendASCIIString('<span dir=\"ltr\">');\n  } else {\n    sb.appendASCIIString('<span>');\n  }\n\n  for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n    partAbsoluteOffset += prevPartContentCnt;\n    const part = parts[partIndex];\n    const partEndIndex = part.endIndex;\n    const partType = part.type;\n    const partRendersWhitespace = renderWhitespace !== 0\n    /* None */\n    && part.isWhitespace();\n    const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw'\n    /*only whitespace*/\n    || !containsForeignElements);\n    const partIsEmptyAndHasPseudoAfter = charIndex === partEndIndex && part.isPseudoAfter();\n    charOffsetInPart = 0;\n    sb.appendASCIIString('<span class=\"');\n    sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n    sb.appendASCII(34\n    /* DoubleQuote */\n    );\n\n    if (partRendersWhitespace) {\n      let partContentCnt = 0;\n      {\n        let _charIndex = charIndex;\n        let _visibleColumn = visibleColumn;\n\n        for (; _charIndex < partEndIndex; _charIndex++) {\n          const charCode = lineContent.charCodeAt(_charIndex);\n          const charWidth = (charCode === 9\n          /* Tab */\n          ? tabSize - _visibleColumn % tabSize : 1) | 0;\n          partContentCnt += charWidth;\n\n          if (_charIndex >= fauxIndentLength) {\n            _visibleColumn += charWidth;\n          }\n        }\n      }\n\n      if (partRendersWhitespaceWithWidth) {\n        sb.appendASCIIString(' style=\"width:');\n        sb.appendASCIIString(String(spaceWidth * partContentCnt));\n        sb.appendASCIIString('px\"');\n      }\n\n      sb.appendASCII(62\n      /* GreaterThan */\n      );\n\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n        partDisplacement = 0;\n        const charCode = lineContent.charCodeAt(charIndex);\n        let charWidth;\n\n        if (charCode === 9\n        /* Tab */\n        ) {\n          charWidth = tabSize - visibleColumn % tabSize | 0;\n\n          if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n            sb.write1(0x2192); // RIGHTWARDS ARROW\n          } else {\n            sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n          }\n\n          for (let space = 2; space <= charWidth; space++) {\n            sb.write1(0xA0); // &nbsp;\n          }\n        } else {\n          // must be CharCode.Space\n          charWidth = 1;\n          sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\n        }\n\n        charOffsetInPart += charWidth;\n\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += charWidth;\n        }\n      }\n\n      prevPartContentCnt = partContentCnt;\n    } else {\n      let partContentCnt = 0;\n      sb.appendASCII(62\n      /* GreaterThan */\n      );\n\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n        partDisplacement = 0;\n        const charCode = lineContent.charCodeAt(charIndex);\n        let producedCharacters = 1;\n        let charWidth = 1;\n\n        switch (charCode) {\n          case 9\n          /* Tab */\n          :\n            producedCharacters = tabSize - visibleColumn % tabSize;\n            charWidth = producedCharacters;\n\n            for (let space = 1; space <= producedCharacters; space++) {\n              sb.write1(0xA0); // &nbsp;\n            }\n\n            break;\n\n          case 32\n          /* Space */\n          :\n            sb.write1(0xA0); // &nbsp;\n\n            break;\n\n          case 60\n          /* LessThan */\n          :\n            sb.appendASCIIString('&lt;');\n            break;\n\n          case 62\n          /* GreaterThan */\n          :\n            sb.appendASCIIString('&gt;');\n            break;\n\n          case 38\n          /* Ampersand */\n          :\n            sb.appendASCIIString('&amp;');\n            break;\n\n          case 0\n          /* Null */\n          :\n            if (renderControlCharacters) {\n              // See https://unicode-table.com/en/blocks/control-pictures/\n              sb.write1(9216);\n            } else {\n              sb.appendASCIIString('&#00;');\n            }\n\n            break;\n\n          case 65279\n          /* UTF8_BOM */\n          :\n          case 8232\n          /* LINE_SEPARATOR */\n          :\n          case 8233\n          /* PARAGRAPH_SEPARATOR */\n          :\n          case 133\n          /* NEXT_LINE */\n          :\n            sb.write1(0xFFFD);\n            break;\n\n          default:\n            if (strings.isFullWidthCharacter(charCode)) {\n              charWidth++;\n            } // See https://unicode-table.com/en/blocks/control-pictures/\n\n\n            if (renderControlCharacters && charCode < 32) {\n              sb.write1(9216 + charCode);\n            } else if (renderControlCharacters && charCode === 127) {\n              // DEL\n              sb.write1(9249);\n            } else if (renderControlCharacters && isControlCharacter(charCode)) {\n              sb.appendASCIIString('[U+');\n              sb.appendASCIIString(to4CharHex(charCode));\n              sb.appendASCIIString(']');\n              producedCharacters = 8;\n            } else {\n              sb.write1(charCode);\n            }\n\n        }\n\n        charOffsetInPart += producedCharacters;\n        partContentCnt += producedCharacters;\n\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += charWidth;\n        }\n      }\n\n      prevPartContentCnt = partContentCnt;\n    }\n\n    if (partIsEmptyAndHasPseudoAfter) {\n      partDisplacement++;\n    } else {\n      partDisplacement = 0;\n    }\n\n    if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n      lastCharacterMappingDefined = true;\n      characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, partAbsoluteOffset);\n    }\n\n    sb.appendASCIIString('</span>');\n  }\n\n  if (!lastCharacterMappingDefined) {\n    // When getting client rects for the last character, we will position the\n    // text range at the end of the span, insteaf of at the beginning of next span\n    characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n  }\n\n  if (isOverflowing) {\n    sb.appendASCIIString('<span>&hellip;</span>');\n  }\n\n  sb.appendASCIIString('</span>');\n  return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\n\nfunction to4CharHex(n) {\n  return n.toString(16).toUpperCase().padStart(4, '0');\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js"],"names":["strings","createStringBuilder","LineDecoration","LineDecorationsNormalizer","LinePart","constructor","endIndex","type","metadata","_linePartBrand","undefined","isWhitespace","isPseudoAfter","LineRange","startIndex","startOffset","endOffset","equals","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","lineContent","continuesWithWrappedLine","isBasicASCII","containsRTL","fauxIndentLength","lineTokens","lineDecorations","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","sort","compare","a","b","wsmiddotDiff","Math","abs","middotDiff","renderSpaceWidth","renderSpaceCharCode","sameSelection","otherSelections","length","i","other","equalsArr","DomPosition","partIndex","charIndex","CharacterMapping","partCount","_data","Uint32Array","_absoluteOffsets","getPartIndex","partData","getCharIndex","setColumnInfo","column","partAbsoluteOffset","getAbsoluteOffset","charOffsetToPartData","charOffset","getDomPosition","getColumn","domPosition","partLength","partDataToCharOffset","searchEntry","min","max","mid","midEntry","minEntry","maxEntry","minPartIndex","minCharIndex","maxPartIndex","maxCharIndex","minEntryDistance","maxEntryDistance","RenderLineOutput","characterMapping","containsForeignElements","_renderLineOutputBrand","renderViewLine","input","sb","appendASCIIString","beforeCount","afterCount","lineDecoration","className","_renderLine","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","out","build","ResolvedRenderLineInput","fontIsMonospace","len","isOverflowing","parts","tokens","transformAndRemoveOverflowing","extractControlCharacters","_applyRenderWhitespace","_applyInlineDecorations","splitLargeTokens","result","resultLen","tokenIndex","tokensLen","getCount","getEndOffset","getClassName","onlyAtSpaces","lastTokenEndIndex","token","tokenEndIndex","tokenType","tokenMetadata","lastSpaceOffset","currTokenStart","j","charCodeAt","diff","piecesCount","ceil","pieceEndIndex","isControlCharacter","charCode","lastLinePart","push","selections","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokensLength","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","lastNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","lastEndIndex","isFullWidthCharacter","generateWhitespace","lastCharCode","prevCharCode","isSingleTrailingSpace","_lineDecorations","normalize","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastCharacterMappingDefined","visibleColumn","charOffsetInPart","partDisplacement","prevPartContentCnt","part","partEndIndex","partType","partRendersWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","appendASCII","partContentCnt","_charIndex","_visibleColumn","charWidth","String","write1","space","producedCharacters","to4CharHex","n","toString","toUpperCase","padStart"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nclass LinePart {\n    constructor(endIndex, type, metadata) {\n        this._linePartBrand = undefined;\n        this.endIndex = endIndex;\n        this.type = type;\n        this.metadata = metadata;\n    }\n    isWhitespace() {\n        return (this.metadata & 1 /* IS_WHITESPACE_MASK */ ? true : false);\n    }\n    isPseudoAfter() {\n        return (this.metadata & 4 /* PSEUDO_AFTER_MASK */ ? true : false);\n    }\n}\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* Trailing */\n                        : 0 /* None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\nexport class DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._absoluteOffsets = new Uint32Array(this.length);\n    }\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;\n    }\n    setColumnInfo(column, partIndex, charIndex, partAbsoluteOffset) {\n        const partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._absoluteOffsets[column - 1] = partAbsoluteOffset + charIndex;\n    }\n    getAbsoluteOffset(column) {\n        if (this._absoluteOffsets.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._absoluteOffsets[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendASCIIString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* Before */ || lineDecoration.type === 2 /* After */) {\n                    sb.appendASCIIString(`<span class=\"`);\n                    sb.appendASCIIString(lineDecoration.className);\n                    sb.appendASCIIString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* Before */) {\n                        containsForeignElements |= 1 /* Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* After */) {\n                        containsForeignElements |= 2 /* After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendASCIIString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendASCIIString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    const sb = createStringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* All */ ||\n        input.renderWhitespace === 1 /* Boundary */ ||\n        (input.renderWhitespace === 2 /* Selection */ && !!input.selectionsOnLine) ||\n        input.renderWhitespace === 3 /* Trailing */) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* Before */;\n            }\n            else if (lineDecoration.type === 1 /* Before */) {\n                containsForeignElements |= 1 /* Before */;\n            }\n            else if (lineDecoration.type === 2 /* After */) {\n                containsForeignElements |= 2 /* After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0);\n    }\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            result[resultLen++] = new LinePart(len, type, 0);\n            break;\n        }\n        result[resultLen++] = new LinePart(endIndex, type, 0);\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const piecesCount = Math.ceil(diff / 50 /* LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\n                    isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* IS_WHITESPACE */);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* Space */ && (prevCharCode !== 32 /* Space */ && prevCharCode !== 9 /* Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* IS_WHITESPACE */);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0;\n    let partDisplacement = 0;\n    let prevPartContentCnt = 0;\n    let partAbsoluteOffset = 0;\n    if (containsRTL) {\n        sb.appendASCIIString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendASCIIString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        partAbsoluteOffset += prevPartContentCnt;\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendASCIIString('<span class=\"');\n        sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCII(34 /* DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partContentCnt = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partContentCnt += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendASCIIString(' style=\"width:');\n                sb.appendASCIIString(String(spaceWidth * partContentCnt));\n                sb.appendASCIIString('px\"');\n            }\n            sb.appendASCII(62 /* GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let charWidth;\n                if (charCode === 9 /* Tab */) {\n                    charWidth = (tabSize - (visibleColumn % tabSize)) | 0;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.write1(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.write1(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    charWidth = 1;\n                    sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\n                }\n                charOffsetInPart += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n            prevPartContentCnt = partContentCnt;\n        }\n        else {\n            let partContentCnt = 0;\n            sb.appendASCII(62 /* GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.write1(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* Space */:\n                        sb.write1(0xA0); // &nbsp;\n                        break;\n                    case 60 /* LessThan */:\n                        sb.appendASCIIString('&lt;');\n                        break;\n                    case 62 /* GreaterThan */:\n                        sb.appendASCIIString('&gt;');\n                        break;\n                    case 38 /* Ampersand */:\n                        sb.appendASCIIString('&amp;');\n                        break;\n                    case 0 /* Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.write1(9216);\n                        }\n                        else {\n                            sb.appendASCIIString('&#00;');\n                        }\n                        break;\n                    case 65279 /* UTF8_BOM */:\n                    case 8232 /* LINE_SEPARATOR */:\n                    case 8233 /* PARAGRAPH_SEPARATOR */:\n                    case 133 /* NEXT_LINE */:\n                        sb.write1(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.write1(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.write1(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendASCIIString('[U+');\n                            sb.appendASCIIString(to4CharHex(charCode));\n                            sb.appendASCIIString(']');\n                            producedCharacters = 8;\n                        }\n                        else {\n                            sb.write1(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                partContentCnt += producedCharacters;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n            prevPartContentCnt = partContentCnt;\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, partAbsoluteOffset);\n        }\n        sb.appendASCIIString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n    }\n    if (isOverflowing) {\n        sb.appendASCIIString('<span>&hellip;</span>');\n    }\n    sb.appendASCIIString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\n"]},"metadata":{},"sourceType":"module"}