{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nexport class StringDiffSequence {\n  constructor(source) {\n    this.source = source;\n  }\n\n  getElements() {\n    const source = this.source;\n    const characters = new Int32Array(source.length);\n\n    for (let i = 0, len = source.length; i < len; i++) {\n      characters[i] = source.charCodeAt(i);\n    }\n\n    return characters;\n  }\n\n}\nexport function stringDiff(original, modified, pretty) {\n  return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n} //\n// The code below has been ported from a C# implementation in VS\n//\n\nexport class Debug {\n  static Assert(condition, message) {\n    if (!condition) {\n      throw new Error(message);\n    }\n  }\n\n}\nexport class MyArray {\n  /**\n   * Copies a range of elements from an Array starting at the specified source index and pastes\n   * them to another Array starting at the specified destination index. The length and the indexes\n   * are specified as 64-bit integers.\n   * sourceArray:\n   *\t\tThe Array that contains the data to copy.\n   * sourceIndex:\n   *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n   * destinationArray:\n   *\t\tThe Array that receives the data.\n   * destinationIndex:\n   *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n   * length:\n   *\t\tA 64-bit integer that represents the number of elements to copy.\n   */\n  static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n    for (let i = 0; i < length; i++) {\n      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n    }\n  }\n\n  static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n    for (let i = 0; i < length; i++) {\n      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n    }\n  }\n\n}\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarkNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\n\nclass DiffChangeHelper {\n  /**\n   * Constructs a new DiffChangeHelper for the given DiffSequences.\n   */\n  constructor() {\n    this.m_changes = [];\n    this.m_originalStart = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ;\n    this.m_modifiedStart = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ;\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n  }\n  /**\n   * Marks the beginning of the next change in the set of differences.\n   */\n\n\n  MarkNextChange() {\n    // Only add to the list if there is something to add\n    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n      // Add the new change to our list\n      this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n    } // Reset for the next change\n\n\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n    this.m_originalStart = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ;\n    this.m_modifiedStart = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ;\n  }\n  /**\n   * Adds the original element at the given position to the elements\n   * affected by the current change. The modified index gives context\n   * to the change position with respect to the original sequence.\n   * @param originalIndex The index of the original element to add.\n   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n   */\n\n\n  AddOriginalElement(originalIndex, modifiedIndex) {\n    // The 'true' start index is the smallest of the ones we've seen\n    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n    this.m_originalCount++;\n  }\n  /**\n   * Adds the modified element at the given position to the elements\n   * affected by the current change. The original index gives context\n   * to the change position with respect to the modified sequence.\n   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n   * @param modifiedIndex The index of the modified element to add.\n   */\n\n\n  AddModifiedElement(originalIndex, modifiedIndex) {\n    // The 'true' start index is the smallest of the ones we've seen\n    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n    this.m_modifiedCount++;\n  }\n  /**\n   * Retrieves all of the changes marked by the class.\n   */\n\n\n  getChanges() {\n    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n      // Finish up on whatever is left\n      this.MarkNextChange();\n    }\n\n    return this.m_changes;\n  }\n  /**\n   * Retrieves all of the changes marked by the class in the reverse order\n   */\n\n\n  getReverseChanges() {\n    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n      // Finish up on whatever is left\n      this.MarkNextChange();\n    }\n\n    this.m_changes.reverse();\n    return this.m_changes;\n  }\n\n}\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\n\n\nexport class LcsDiff {\n  /**\n   * Constructs the DiffFinder\n   */\n  constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n    this.ContinueProcessingPredicate = continueProcessingPredicate;\n    this._originalSequence = originalSequence;\n    this._modifiedSequence = modifiedSequence;\n\n    const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n\n    const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n\n    this._hasStrings = originalHasStrings && modifiedHasStrings;\n    this._originalStringElements = originalStringElements;\n    this._originalElementsOrHash = originalElementsOrHash;\n    this._modifiedStringElements = modifiedStringElements;\n    this._modifiedElementsOrHash = modifiedElementsOrHash;\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = [];\n  }\n\n  static _isStringArray(arr) {\n    return arr.length > 0 && typeof arr[0] === 'string';\n  }\n\n  static _getElements(sequence) {\n    const elements = sequence.getElements();\n\n    if (LcsDiff._isStringArray(elements)) {\n      const hashes = new Int32Array(elements.length);\n\n      for (let i = 0, len = elements.length; i < len; i++) {\n        hashes[i] = stringHash(elements[i], 0);\n      }\n\n      return [elements, hashes, true];\n    }\n\n    if (elements instanceof Int32Array) {\n      return [[], elements, false];\n    }\n\n    return [[], new Int32Array(elements), false];\n  }\n\n  ElementsAreEqual(originalIndex, newIndex) {\n    if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n      return false;\n    }\n\n    return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;\n  }\n\n  ElementsAreStrictEqual(originalIndex, newIndex) {\n    if (!this.ElementsAreEqual(originalIndex, newIndex)) {\n      return false;\n    }\n\n    const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n\n    const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n\n    return originalElement === modifiedElement;\n  }\n\n  static _getStrictElement(sequence, index) {\n    if (typeof sequence.getStrictElement === 'function') {\n      return sequence.getStrictElement(index);\n    }\n\n    return null;\n  }\n\n  OriginalElementsAreEqual(index1, index2) {\n    if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n      return false;\n    }\n\n    return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;\n  }\n\n  ModifiedElementsAreEqual(index1, index2) {\n    if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n      return false;\n    }\n\n    return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;\n  }\n\n  ComputeDiff(pretty) {\n    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n  }\n  /**\n   * Computes the differences between the original and modified input\n   * sequences on the bounded range.\n   * @returns An array of the differences between the two input sequences.\n   */\n\n\n  _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n    const quitEarlyArr = [false];\n    let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n\n    if (pretty) {\n      // We have to clean up the computed diff to be more intuitive\n      // but it turns out this cannot be done correctly until the entire set\n      // of diffs have been computed\n      changes = this.PrettifyChanges(changes);\n    }\n\n    return {\n      quitEarly: quitEarlyArr[0],\n      changes: changes\n    };\n  }\n  /**\n   * Private helper method which computes the differences on the bounded range\n   * recursively.\n   * @returns An array of the differences between the two input sequences.\n   */\n\n\n  ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n    quitEarlyArr[0] = false; // Find the start of the differences\n\n    while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n      originalStart++;\n      modifiedStart++;\n    } // Find the end of the differences\n\n\n    while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n      originalEnd--;\n      modifiedEnd--;\n    } // In the special case where we either have all insertions or all deletions or the sequences are identical\n\n\n    if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n      let changes;\n\n      if (modifiedStart <= modifiedEnd) {\n        Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd'); // All insertions\n\n        changes = [new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)];\n      } else if (originalStart <= originalEnd) {\n        Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd'); // All deletions\n\n        changes = [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)];\n      } else {\n        Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n        Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd'); // Identical sequences - No differences\n\n        changes = [];\n      }\n\n      return changes;\n    } // This problem can be solved using the Divide-And-Conquer technique.\n\n\n    const midOriginalArr = [0];\n    const midModifiedArr = [0];\n    const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n    const midOriginal = midOriginalArr[0];\n    const midModified = midModifiedArr[0];\n\n    if (result !== null) {\n      // Result is not-null when there was enough memory to compute the changes while\n      // searching for the recursion point\n      return result;\n    } else if (!quitEarlyArr[0]) {\n      // We can break the problem down recursively by finding the changes in the\n      // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n      // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n      // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n      const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n      let rightChanges = [];\n\n      if (!quitEarlyArr[0]) {\n        rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n      } else {\n        // We didn't have time to finish the first half, so we don't have time to compute this half.\n        // Consider the entire rest of the sequence different.\n        rightChanges = [new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)];\n      }\n\n      return this.ConcatenateChanges(leftChanges, rightChanges);\n    } // If we hit here, we quit early, and so can't return anything meaningful\n\n\n    return [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];\n  }\n\n  WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n    let forwardChanges = null;\n    let reverseChanges = null; // First, walk backward through the forward diagonals history\n\n    let changeHelper = new DiffChangeHelper();\n    let diagonalMin = diagonalForwardStart;\n    let diagonalMax = diagonalForwardEnd;\n    let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;\n    let lastOriginalIndex = -1073741824\n    /* MIN_SAFE_SMALL_INTEGER */\n    ;\n    let historyIndex = this.m_forwardHistory.length - 1;\n\n    do {\n      // Get the diagonal index from the relative diagonal number\n      const diagonal = diagonalRelative + diagonalForwardBase; // Figure out where we came from\n\n      if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {\n        // Vertical line (the element is an insert)\n        originalIndex = forwardPoints[diagonal + 1];\n        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\n        if (originalIndex < lastOriginalIndex) {\n          changeHelper.MarkNextChange();\n        }\n\n        lastOriginalIndex = originalIndex;\n        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n        diagonalRelative = diagonal + 1 - diagonalForwardBase; //Setup for the next iteration\n      } else {\n        // Horizontal line (the element is a deletion)\n        originalIndex = forwardPoints[diagonal - 1] + 1;\n        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\n        if (originalIndex < lastOriginalIndex) {\n          changeHelper.MarkNextChange();\n        }\n\n        lastOriginalIndex = originalIndex - 1;\n        changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n        diagonalRelative = diagonal - 1 - diagonalForwardBase; //Setup for the next iteration\n      }\n\n      if (historyIndex >= 0) {\n        forwardPoints = this.m_forwardHistory[historyIndex];\n        diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n\n        diagonalMin = 1;\n        diagonalMax = forwardPoints.length - 1;\n      }\n    } while (--historyIndex >= -1); // Ironically, we get the forward changes as the reverse of the\n    // order we added them since we technically added them backwards\n\n\n    forwardChanges = changeHelper.getReverseChanges();\n\n    if (quitEarlyArr[0]) {\n      // TODO: Calculate a partial from the reverse diagonals.\n      //       For now, just assume everything after the midOriginal/midModified point is a diff\n      let originalStartPoint = midOriginalArr[0] + 1;\n      let modifiedStartPoint = midModifiedArr[0] + 1;\n\n      if (forwardChanges !== null && forwardChanges.length > 0) {\n        const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n        originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n        modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n      }\n\n      reverseChanges = [new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)];\n    } else {\n      // Now walk backward through the reverse diagonals history\n      changeHelper = new DiffChangeHelper();\n      diagonalMin = diagonalReverseStart;\n      diagonalMax = diagonalReverseEnd;\n      diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;\n      lastOriginalIndex = 1073741824\n      /* MAX_SAFE_SMALL_INTEGER */\n      ;\n      historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n\n      do {\n        // Get the diagonal index from the relative diagonal number\n        const diagonal = diagonalRelative + diagonalReverseBase; // Figure out where we came from\n\n        if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {\n          // Horizontal line (the element is a deletion))\n          originalIndex = reversePoints[diagonal + 1] - 1;\n          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\n          if (originalIndex > lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n\n          lastOriginalIndex = originalIndex + 1;\n          changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n          diagonalRelative = diagonal + 1 - diagonalReverseBase; //Setup for the next iteration\n        } else {\n          // Vertical line (the element is an insertion)\n          originalIndex = reversePoints[diagonal - 1];\n          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\n          if (originalIndex > lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n\n          lastOriginalIndex = originalIndex;\n          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n          diagonalRelative = diagonal - 1 - diagonalReverseBase; //Setup for the next iteration\n        }\n\n        if (historyIndex >= 0) {\n          reversePoints = this.m_reverseHistory[historyIndex];\n          diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n\n          diagonalMin = 1;\n          diagonalMax = reversePoints.length - 1;\n        }\n      } while (--historyIndex >= -1); // There are cases where the reverse history will find diffs that\n      // are correct, but not intuitive, so we need shift them.\n\n\n      reverseChanges = changeHelper.getChanges();\n    }\n\n    return this.ConcatenateChanges(forwardChanges, reverseChanges);\n  }\n  /**\n   * Given the range to compute the diff on, this method finds the point:\n   * (midOriginal, midModified)\n   * that exists in the middle of the LCS of the two sequences and\n   * is the point at which the LCS problem may be broken down recursively.\n   * This method will try to keep the LCS trace in memory. If the LCS recursion\n   * point is calculated and the full trace is available in memory, then this method\n   * will return the change list.\n   * @param originalStart The start bound of the original sequence range\n   * @param originalEnd The end bound of the original sequence range\n   * @param modifiedStart The start bound of the modified sequence range\n   * @param modifiedEnd The end bound of the modified sequence range\n   * @param midOriginal The middle point of the original sequence range\n   * @param midModified The middle point of the modified sequence range\n   * @returns The diff changes, if available, otherwise null\n   */\n\n\n  ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n    let originalIndex = 0,\n        modifiedIndex = 0;\n    let diagonalForwardStart = 0,\n        diagonalForwardEnd = 0;\n    let diagonalReverseStart = 0,\n        diagonalReverseEnd = 0; // To traverse the edit graph and produce the proper LCS, our actual\n    // start position is just outside the given boundary\n\n    originalStart--;\n    modifiedStart--; // We set these up to make the compiler happy, but they will\n    // be replaced before we return with the actual recursion point\n\n    midOriginalArr[0] = 0;\n    midModifiedArr[0] = 0; // Clear out the history\n\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = []; // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n    // The integer value in the cell represents the originalIndex of the furthest\n    // reaching point found so far that ends in that diagonal.\n    // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n\n    const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);\n    const numDiagonals = maxDifferences + 1;\n    const forwardPoints = new Int32Array(numDiagonals);\n    const reversePoints = new Int32Array(numDiagonals); // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n    // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n\n    const diagonalForwardBase = modifiedEnd - modifiedStart;\n    const diagonalReverseBase = originalEnd - originalStart; // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n    //    diagonal number (relative to diagonalForwardBase)\n    // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n    //    diagonal number (relative to diagonalReverseBase)\n\n    const diagonalForwardOffset = originalStart - modifiedStart;\n    const diagonalReverseOffset = originalEnd - modifiedEnd; // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n    //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n    // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n\n    const delta = diagonalReverseBase - diagonalForwardBase;\n    const deltaIsEven = delta % 2 === 0; // Here we set up the start and end points as the furthest points found so far\n    // in both the forward and reverse directions, respectively\n\n    forwardPoints[diagonalForwardBase] = originalStart;\n    reversePoints[diagonalReverseBase] = originalEnd; // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n\n    quitEarlyArr[0] = false; // A couple of points:\n    // --With this method, we iterate on the number of differences between the two sequences.\n    //   The more differences there actually are, the longer this will take.\n    // --Also, as the number of differences increases, we have to search on diagonals further\n    //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n    // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n    //   is even and odd diagonals only when numDifferences is odd.\n\n    for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {\n      let furthestOriginalIndex = 0;\n      let furthestModifiedIndex = 0; // Run the algorithm in the forward direction\n\n      diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n      diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\n      for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n        // STEP 1: We extend the furthest reaching point in the present diagonal\n        // by looking at the diagonals above and below and picking the one whose point\n        // is further away from the start point (originalStart, modifiedStart)\n        if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {\n          originalIndex = forwardPoints[diagonal + 1];\n        } else {\n          originalIndex = forwardPoints[diagonal - 1] + 1;\n        }\n\n        modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset; // Save the current originalIndex so we can test for false overlap in step 3\n\n        const tempOriginalIndex = originalIndex; // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n        // so long as the elements are equal.\n\n        while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n          originalIndex++;\n          modifiedIndex++;\n        }\n\n        forwardPoints[diagonal] = originalIndex;\n\n        if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n          furthestOriginalIndex = originalIndex;\n          furthestModifiedIndex = modifiedIndex;\n        } // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n        // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n        // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n        // then check for overlap.\n\n\n        if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {\n          if (originalIndex >= reversePoints[diagonal]) {\n            midOriginalArr[0] = originalIndex;\n            midModifiedArr[0] = modifiedIndex;\n\n            if (tempOriginalIndex <= reversePoints[diagonal] && 1447\n            /* MaxDifferencesHistory */\n            > 0 && numDifferences <= 1447\n            /* MaxDifferencesHistory */\n            + 1) {\n              // BINGO! We overlapped, and we have the full trace in memory!\n              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n            } else {\n              // Either false overlap, or we didn't have enough memory for the full trace\n              // Just return the recursion point\n              return null;\n            }\n          }\n        }\n      } // Check to see if we should be quitting early, before moving on to the next iteration.\n\n\n      const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n\n      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n        // We can't finish, so skip ahead to generating a result from what we have.\n        quitEarlyArr[0] = true; // Use the furthest distance we got in the forward direction.\n\n        midOriginalArr[0] = furthestOriginalIndex;\n        midModifiedArr[0] = furthestModifiedIndex;\n\n        if (matchLengthOfLongest > 0 && 1447\n        /* MaxDifferencesHistory */\n        > 0 && numDifferences <= 1447\n        /* MaxDifferencesHistory */\n        + 1) {\n          // Enough of the history is in memory to walk it backwards\n          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n        } else {\n          // We didn't actually remember enough of the history.\n          //Since we are quitting the diff early, we need to shift back the originalStart and modified start\n          //back into the boundary limits since we decremented their value above beyond the boundary limit.\n          originalStart++;\n          modifiedStart++;\n          return [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];\n        }\n      } // Run the algorithm in the reverse direction\n\n\n      diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n      diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\n      for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n        // STEP 1: We extend the furthest reaching point in the present diagonal\n        // by looking at the diagonals above and below and picking the one whose point\n        // is further away from the start point (originalEnd, modifiedEnd)\n        if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {\n          originalIndex = reversePoints[diagonal + 1] - 1;\n        } else {\n          originalIndex = reversePoints[diagonal - 1];\n        }\n\n        modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset; // Save the current originalIndex so we can test for false overlap\n\n        const tempOriginalIndex = originalIndex; // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n        // as long as the elements are equal.\n\n        while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n          originalIndex--;\n          modifiedIndex--;\n        }\n\n        reversePoints[diagonal] = originalIndex; // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n        // and diagonal is in the range of forward diagonals computed for numDifferences\n        // then check for overlap.\n\n        if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n          if (originalIndex <= forwardPoints[diagonal]) {\n            midOriginalArr[0] = originalIndex;\n            midModifiedArr[0] = modifiedIndex;\n\n            if (tempOriginalIndex >= forwardPoints[diagonal] && 1447\n            /* MaxDifferencesHistory */\n            > 0 && numDifferences <= 1447\n            /* MaxDifferencesHistory */\n            + 1) {\n              // BINGO! We overlapped, and we have the full trace in memory!\n              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n            } else {\n              // Either false overlap, or we didn't have enough memory for the full trace\n              // Just return the recursion point\n              return null;\n            }\n          }\n        }\n      } // Save current vectors to history before the next iteration\n\n\n      if (numDifferences <= 1447\n      /* MaxDifferencesHistory */\n      ) {\n        // We are allocating space for one extra int, which we fill with\n        // the index of the diagonal base index\n        let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n        temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n        MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n        this.m_forwardHistory.push(temp);\n        temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n        temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n        MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n        this.m_reverseHistory.push(temp);\n      }\n    } // If we got here, then we have the full trace in history. We just have to convert it to a change list\n    // NOTE: This part is a bit messy\n\n\n    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n  }\n  /**\n   * Shifts the given changes to provide a more intuitive diff.\n   * While the first element in a diff matches the first element after the diff,\n   * we shift the diff down.\n   *\n   * @param changes The list of changes to shift\n   * @returns The shifted changes\n   */\n\n\n  PrettifyChanges(changes) {\n    // Shift all the changes down first\n    for (let i = 0; i < changes.length; i++) {\n      const change = changes[i];\n      const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n      const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n      const checkOriginal = change.originalLength > 0;\n      const checkModified = change.modifiedLength > 0;\n\n      while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n        const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n        const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n\n        if (endStrictEqual && !startStrictEqual) {\n          // moving the change down would create an equal change, but the elements are not strict equal\n          break;\n        }\n\n        change.originalStart++;\n        change.modifiedStart++;\n      }\n\n      let mergedChangeArr = [null];\n\n      if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n        changes[i] = mergedChangeArr[0];\n        changes.splice(i + 1, 1);\n        i--;\n        continue;\n      }\n    } // Shift changes back up until we hit empty or whitespace-only lines\n\n\n    for (let i = changes.length - 1; i >= 0; i--) {\n      const change = changes[i];\n      let originalStop = 0;\n      let modifiedStop = 0;\n\n      if (i > 0) {\n        const prevChange = changes[i - 1];\n        originalStop = prevChange.originalStart + prevChange.originalLength;\n        modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n      }\n\n      const checkOriginal = change.originalLength > 0;\n      const checkModified = change.modifiedLength > 0;\n      let bestDelta = 0;\n\n      let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n\n      for (let delta = 1;; delta++) {\n        const originalStart = change.originalStart - delta;\n        const modifiedStart = change.modifiedStart - delta;\n\n        if (originalStart < originalStop || modifiedStart < modifiedStop) {\n          break;\n        }\n\n        if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n          break;\n        }\n\n        if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n          break;\n        }\n\n        const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;\n\n        const score = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\n\n        if (score > bestScore) {\n          bestScore = score;\n          bestDelta = delta;\n        }\n      }\n\n      change.originalStart -= bestDelta;\n      change.modifiedStart -= bestDelta;\n      const mergedChangeArr = [null];\n\n      if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n        changes[i - 1] = mergedChangeArr[0];\n        changes.splice(i, 1);\n        i++;\n        continue;\n      }\n    } // There could be multiple longest common substrings.\n    // Give preference to the ones containing longer lines\n\n\n    if (this._hasStrings) {\n      for (let i = 1, len = changes.length; i < len; i++) {\n        const aChange = changes[i - 1];\n        const bChange = changes[i];\n        const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n        const aOriginalStart = aChange.originalStart;\n        const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n        const abOriginalLength = bOriginalEnd - aOriginalStart;\n        const aModifiedStart = aChange.modifiedStart;\n        const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n        const abModifiedLength = bModifiedEnd - aModifiedStart; // Avoid wasting a lot of time with these searches\n\n        if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n          const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n\n          if (t) {\n            const [originalMatchStart, modifiedMatchStart] = t;\n\n            if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n              // switch to another sequence that has a better score\n              aChange.originalLength = originalMatchStart - aChange.originalStart;\n              aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n              bChange.originalStart = originalMatchStart + matchedLength;\n              bChange.modifiedStart = modifiedMatchStart + matchedLength;\n              bChange.originalLength = bOriginalEnd - bChange.originalStart;\n              bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n            }\n          }\n        }\n      }\n    }\n\n    return changes;\n  }\n\n  _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n    if (originalLength < desiredLength || modifiedLength < desiredLength) {\n      return null;\n    }\n\n    const originalMax = originalStart + originalLength - desiredLength + 1;\n    const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n    let bestScore = 0;\n    let bestOriginalStart = 0;\n    let bestModifiedStart = 0;\n\n    for (let i = originalStart; i < originalMax; i++) {\n      for (let j = modifiedStart; j < modifiedMax; j++) {\n        const score = this._contiguousSequenceScore(i, j, desiredLength);\n\n        if (score > 0 && score > bestScore) {\n          bestScore = score;\n          bestOriginalStart = i;\n          bestModifiedStart = j;\n        }\n      }\n    }\n\n    if (bestScore > 0) {\n      return [bestOriginalStart, bestModifiedStart];\n    }\n\n    return null;\n  }\n\n  _contiguousSequenceScore(originalStart, modifiedStart, length) {\n    let score = 0;\n\n    for (let l = 0; l < length; l++) {\n      if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n        return 0;\n      }\n\n      score += this._originalStringElements[originalStart + l].length;\n    }\n\n    return score;\n  }\n\n  _OriginalIsBoundary(index) {\n    if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n      return true;\n    }\n\n    return this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]);\n  }\n\n  _OriginalRegionIsBoundary(originalStart, originalLength) {\n    if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n      return true;\n    }\n\n    if (originalLength > 0) {\n      const originalEnd = originalStart + originalLength;\n\n      if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _ModifiedIsBoundary(index) {\n    if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n      return true;\n    }\n\n    return this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]);\n  }\n\n  _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n    if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n      return true;\n    }\n\n    if (modifiedLength > 0) {\n      const modifiedEnd = modifiedStart + modifiedLength;\n\n      if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n    const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;\n    const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;\n    return originalScore + modifiedScore;\n  }\n  /**\n   * Concatenates the two input DiffChange lists and returns the resulting\n   * list.\n   * @param The left changes\n   * @param The right changes\n   * @returns The concatenated list\n   */\n\n\n  ConcatenateChanges(left, right) {\n    let mergedChangeArr = [];\n\n    if (left.length === 0 || right.length === 0) {\n      return right.length > 0 ? right : left;\n    } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n      // Since we break the problem down recursively, it is possible that we\n      // might recurse in the middle of a change thereby splitting it into\n      // two changes. Here in the combining stage, we detect and fuse those\n      // changes back together\n      const result = new Array(left.length + right.length - 1);\n      MyArray.Copy(left, 0, result, 0, left.length - 1);\n      result[left.length - 1] = mergedChangeArr[0];\n      MyArray.Copy(right, 1, result, left.length, right.length - 1);\n      return result;\n    } else {\n      const result = new Array(left.length + right.length);\n      MyArray.Copy(left, 0, result, 0, left.length);\n      MyArray.Copy(right, 0, result, left.length, right.length);\n      return result;\n    }\n  }\n  /**\n   * Returns true if the two changes overlap and can be merged into a single\n   * change\n   * @param left The left change\n   * @param right The right change\n   * @param mergedChange The merged change if the two overlap, null otherwise\n   * @returns True if the two changes overlap\n   */\n\n\n  ChangesOverlap(left, right, mergedChangeArr) {\n    Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n    Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n\n    if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n      const originalStart = left.originalStart;\n      let originalLength = left.originalLength;\n      const modifiedStart = left.modifiedStart;\n      let modifiedLength = left.modifiedLength;\n\n      if (left.originalStart + left.originalLength >= right.originalStart) {\n        originalLength = right.originalStart + right.originalLength - left.originalStart;\n      }\n\n      if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n        modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n      }\n\n      mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n      return true;\n    } else {\n      mergedChangeArr[0] = null;\n      return false;\n    }\n  }\n  /**\n   * Helper method used to clip a diagonal index to the range of valid\n   * diagonals. This also decides whether or not the diagonal index,\n   * if it exceeds the boundary, should be clipped to the boundary or clipped\n   * one inside the boundary depending on the Even/Odd status of the boundary\n   * and numDifferences.\n   * @param diagonal The index of the diagonal to clip.\n   * @param numDifferences The current number of differences being iterated upon.\n   * @param diagonalBaseIndex The base reference diagonal.\n   * @param numDiagonals The total number of diagonals.\n   * @returns The clipped diagonal index.\n   */\n\n\n  ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n    if (diagonal >= 0 && diagonal < numDiagonals) {\n      // Nothing to clip, its in range\n      return diagonal;\n    } // diagonalsBelow: The number of diagonals below the reference diagonal\n    // diagonalsAbove: The number of diagonals above the reference diagonal\n\n\n    const diagonalsBelow = diagonalBaseIndex;\n    const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n    const diffEven = numDifferences % 2 === 0;\n\n    if (diagonal < 0) {\n      const lowerBoundEven = diagonalsBelow % 2 === 0;\n      return diffEven === lowerBoundEven ? 0 : 1;\n    } else {\n      const upperBoundEven = diagonalsAbove % 2 === 0;\n      return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js"],"names":["DiffChange","stringHash","StringDiffSequence","constructor","source","getElements","characters","Int32Array","length","i","len","charCodeAt","stringDiff","original","modified","pretty","LcsDiff","ComputeDiff","changes","Debug","Assert","condition","message","Error","MyArray","Copy","sourceArray","sourceIndex","destinationArray","destinationIndex","Copy2","DiffChangeHelper","m_changes","m_originalStart","m_modifiedStart","m_originalCount","m_modifiedCount","MarkNextChange","push","AddOriginalElement","originalIndex","modifiedIndex","Math","min","AddModifiedElement","getChanges","getReverseChanges","reverse","originalSequence","modifiedSequence","continueProcessingPredicate","ContinueProcessingPredicate","_originalSequence","_modifiedSequence","originalStringElements","originalElementsOrHash","originalHasStrings","_getElements","modifiedStringElements","modifiedElementsOrHash","modifiedHasStrings","_hasStrings","_originalStringElements","_originalElementsOrHash","_modifiedStringElements","_modifiedElementsOrHash","m_forwardHistory","m_reverseHistory","_isStringArray","arr","sequence","elements","hashes","ElementsAreEqual","newIndex","ElementsAreStrictEqual","originalElement","_getStrictElement","modifiedElement","index","getStrictElement","OriginalElementsAreEqual","index1","index2","ModifiedElementsAreEqual","_ComputeDiff","originalStart","originalEnd","modifiedStart","modifiedEnd","quitEarlyArr","ComputeDiffRecursive","PrettifyChanges","quitEarly","midOriginalArr","midModifiedArr","result","ComputeRecursionPoint","midOriginal","midModified","leftChanges","rightChanges","ConcatenateChanges","WALKTRACE","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","forwardChanges","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","historyIndex","diagonal","originalStartPoint","modifiedStartPoint","lastForwardChange","max","getOriginalEnd","getModifiedEnd","maxDifferences","numDiagonals","delta","numDifferences","furthestOriginalIndex","furthestModifiedIndex","ClipDiagonalBound","tempOriginalIndex","abs","matchLengthOfLongest","temp","change","originalStop","modifiedStop","checkOriginal","originalLength","checkModified","modifiedLength","startStrictEqual","endStrictEqual","mergedChangeArr","ChangesOverlap","splice","prevChange","bestDelta","bestScore","_boundaryScore","touchingPreviousChange","score","aChange","bChange","matchedLength","aOriginalStart","bOriginalEnd","abOriginalLength","aModifiedStart","bModifiedEnd","abModifiedLength","t","_findBetterContiguousSequence","originalMatchStart","modifiedMatchStart","desiredLength","originalMax","modifiedMax","bestOriginalStart","bestModifiedStart","j","_contiguousSequenceScore","l","_OriginalIsBoundary","test","_OriginalRegionIsBoundary","_ModifiedIsBoundary","_ModifiedRegionIsBoundary","originalScore","modifiedScore","left","right","Array","diagonalBaseIndex","diagonalsBelow","diagonalsAbove","diffEven","lowerBoundEven","upperBoundEven"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nexport class StringDiffSequence {\n    constructor(source) {\n        this.source = source;\n    }\n    getElements() {\n        const source = this.source;\n        const characters = new Int32Array(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            characters[i] = source.charCodeAt(i);\n        }\n        return characters;\n    }\n}\nexport function stringDiff(original, modified, pretty) {\n    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n//\n// The code below has been ported from a C# implementation in VS\n//\nexport class Debug {\n    static Assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nexport class MyArray {\n    /**\n     * Copies a range of elements from an Array starting at the specified source index and pastes\n     * them to another Array starting at the specified destination index. The length and the indexes\n     * are specified as 64-bit integers.\n     * sourceArray:\n     *\t\tThe Array that contains the data to copy.\n     * sourceIndex:\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n     * destinationArray:\n     *\t\tThe Array that receives the data.\n     * destinationIndex:\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n     * length:\n     *\t\tA 64-bit integer that represents the number of elements to copy.\n     */\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n}\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarkNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n    /**\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\n     */\n    constructor() {\n        this.m_changes = [];\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n    }\n    /**\n     * Marks the beginning of the next change in the set of differences.\n     */\n    MarkNextChange() {\n        // Only add to the list if there is something to add\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Add the new change to our list\n            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n        }\n        // Reset for the next change\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    }\n    /**\n     * Adds the original element at the given position to the elements\n     * affected by the current change. The modified index gives context\n     * to the change position with respect to the original sequence.\n     * @param originalIndex The index of the original element to add.\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n     */\n    AddOriginalElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_originalCount++;\n    }\n    /**\n     * Adds the modified element at the given position to the elements\n     * affected by the current change. The original index gives context\n     * to the change position with respect to the modified sequence.\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n     * @param modifiedIndex The index of the modified element to add.\n     */\n    AddModifiedElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_modifiedCount++;\n    }\n    /**\n     * Retrieves all of the changes marked by the class.\n     */\n    getChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        return this.m_changes;\n    }\n    /**\n     * Retrieves all of the changes marked by the class in the reverse order\n     */\n    getReverseChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        this.m_changes.reverse();\n        return this.m_changes;\n    }\n}\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n    /**\n     * Constructs the DiffFinder\n     */\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\n        this._originalSequence = originalSequence;\n        this._modifiedSequence = modifiedSequence;\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\n        this._originalStringElements = originalStringElements;\n        this._originalElementsOrHash = originalElementsOrHash;\n        this._modifiedStringElements = modifiedStringElements;\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n    }\n    static _isStringArray(arr) {\n        return (arr.length > 0 && typeof arr[0] === 'string');\n    }\n    static _getElements(sequence) {\n        const elements = sequence.getElements();\n        if (LcsDiff._isStringArray(elements)) {\n            const hashes = new Int32Array(elements.length);\n            for (let i = 0, len = elements.length; i < len; i++) {\n                hashes[i] = stringHash(elements[i], 0);\n            }\n            return [elements, hashes, true];\n        }\n        if (elements instanceof Int32Array) {\n            return [[], elements, false];\n        }\n        return [[], new Int32Array(elements), false];\n    }\n    ElementsAreEqual(originalIndex, newIndex) {\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n    }\n    ElementsAreStrictEqual(originalIndex, newIndex) {\n        if (!this.ElementsAreEqual(originalIndex, newIndex)) {\n            return false;\n        }\n        const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n        const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n        return (originalElement === modifiedElement);\n    }\n    static _getStrictElement(sequence, index) {\n        if (typeof sequence.getStrictElement === 'function') {\n            return sequence.getStrictElement(index);\n        }\n        return null;\n    }\n    OriginalElementsAreEqual(index1, index2) {\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n    }\n    ModifiedElementsAreEqual(index1, index2) {\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n    }\n    ComputeDiff(pretty) {\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n    }\n    /**\n     * Computes the differences between the original and modified input\n     * sequences on the bounded range.\n     * @returns An array of the differences between the two input sequences.\n     */\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n        const quitEarlyArr = [false];\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n        if (pretty) {\n            // We have to clean up the computed diff to be more intuitive\n            // but it turns out this cannot be done correctly until the entire set\n            // of diffs have been computed\n            changes = this.PrettifyChanges(changes);\n        }\n        return {\n            quitEarly: quitEarlyArr[0],\n            changes: changes\n        };\n    }\n    /**\n     * Private helper method which computes the differences on the bounded range\n     * recursively.\n     * @returns An array of the differences between the two input sequences.\n     */\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n        quitEarlyArr[0] = false;\n        // Find the start of the differences\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n            originalStart++;\n            modifiedStart++;\n        }\n        // Find the end of the differences\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n            originalEnd--;\n            modifiedEnd--;\n        }\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n            let changes;\n            if (modifiedStart <= modifiedEnd) {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                // All insertions\n                changes = [\n                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n                ];\n            }\n            else if (originalStart <= originalEnd) {\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // All deletions\n                changes = [\n                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n                ];\n            }\n            else {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // Identical sequences - No differences\n                changes = [];\n            }\n            return changes;\n        }\n        // This problem can be solved using the Divide-And-Conquer technique.\n        const midOriginalArr = [0];\n        const midModifiedArr = [0];\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n        const midOriginal = midOriginalArr[0];\n        const midModified = midModifiedArr[0];\n        if (result !== null) {\n            // Result is not-null when there was enough memory to compute the changes while\n            // searching for the recursion point\n            return result;\n        }\n        else if (!quitEarlyArr[0]) {\n            // We can break the problem down recursively by finding the changes in the\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n            let rightChanges = [];\n            if (!quitEarlyArr[0]) {\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n            }\n            else {\n                // We didn't have time to finish the first half, so we don't have time to compute this half.\n                // Consider the entire rest of the sequence different.\n                rightChanges = [\n                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n                ];\n            }\n            return this.ConcatenateChanges(leftChanges, rightChanges);\n        }\n        // If we hit here, we quit early, and so can't return anything meaningful\n        return [\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n    }\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n        let forwardChanges = null;\n        let reverseChanges = null;\n        // First, walk backward through the forward diagonals history\n        let changeHelper = new DiffChangeHelper();\n        let diagonalMin = diagonalForwardStart;\n        let diagonalMax = diagonalForwardEnd;\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n        let lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;\n        let historyIndex = this.m_forwardHistory.length - 1;\n        do {\n            // Get the diagonal index from the relative diagonal number\n            const diagonal = diagonalRelative + diagonalForwardBase;\n            // Figure out where we came from\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                // Vertical line (the element is an insert)\n                originalIndex = forwardPoints[diagonal + 1];\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex;\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            else {\n                // Horizontal line (the element is a deletion)\n                originalIndex = forwardPoints[diagonal - 1] + 1;\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex - 1;\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            if (historyIndex >= 0) {\n                forwardPoints = this.m_forwardHistory[historyIndex];\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n                diagonalMin = 1;\n                diagonalMax = forwardPoints.length - 1;\n            }\n        } while (--historyIndex >= -1);\n        // Ironically, we get the forward changes as the reverse of the\n        // order we added them since we technically added them backwards\n        forwardChanges = changeHelper.getReverseChanges();\n        if (quitEarlyArr[0]) {\n            // TODO: Calculate a partial from the reverse diagonals.\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\n            let originalStartPoint = midOriginalArr[0] + 1;\n            let modifiedStartPoint = midModifiedArr[0] + 1;\n            if (forwardChanges !== null && forwardChanges.length > 0) {\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n            }\n            reverseChanges = [\n                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n            ];\n        }\n        else {\n            // Now walk backward through the reverse diagonals history\n            changeHelper = new DiffChangeHelper();\n            diagonalMin = diagonalReverseStart;\n            diagonalMax = diagonalReverseEnd;\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n            lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n            do {\n                // Get the diagonal index from the relative diagonal number\n                const diagonal = diagonalRelative + diagonalReverseBase;\n                // Figure out where we came from\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    // Horizontal line (the element is a deletion))\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex + 1;\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                else {\n                    // Vertical line (the element is an insertion)\n                    originalIndex = reversePoints[diagonal - 1];\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex;\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                if (historyIndex >= 0) {\n                    reversePoints = this.m_reverseHistory[historyIndex];\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n                    diagonalMin = 1;\n                    diagonalMax = reversePoints.length - 1;\n                }\n            } while (--historyIndex >= -1);\n            // There are cases where the reverse history will find diffs that\n            // are correct, but not intuitive, so we need shift them.\n            reverseChanges = changeHelper.getChanges();\n        }\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    }\n    /**\n     * Given the range to compute the diff on, this method finds the point:\n     * (midOriginal, midModified)\n     * that exists in the middle of the LCS of the two sequences and\n     * is the point at which the LCS problem may be broken down recursively.\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\n     * point is calculated and the full trace is available in memory, then this method\n     * will return the change list.\n     * @param originalStart The start bound of the original sequence range\n     * @param originalEnd The end bound of the original sequence range\n     * @param modifiedStart The start bound of the modified sequence range\n     * @param modifiedEnd The end bound of the modified sequence range\n     * @param midOriginal The middle point of the original sequence range\n     * @param midModified The middle point of the modified sequence range\n     * @returns The diff changes, if available, otherwise null\n     */\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n        let originalIndex = 0, modifiedIndex = 0;\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\n        // To traverse the edit graph and produce the proper LCS, our actual\n        // start position is just outside the given boundary\n        originalStart--;\n        modifiedStart--;\n        // We set these up to make the compiler happy, but they will\n        // be replaced before we return with the actual recursion point\n        midOriginalArr[0] = 0;\n        midModifiedArr[0] = 0;\n        // Clear out the history\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n        // The integer value in the cell represents the originalIndex of the furthest\n        // reaching point found so far that ends in that diagonal.\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n        const numDiagonals = maxDifferences + 1;\n        const forwardPoints = new Int32Array(numDiagonals);\n        const reversePoints = new Int32Array(numDiagonals);\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\n        const diagonalReverseBase = (originalEnd - originalStart);\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalForwardBase)\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalReverseBase)\n        const diagonalForwardOffset = (originalStart - modifiedStart);\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n        const delta = diagonalReverseBase - diagonalForwardBase;\n        const deltaIsEven = (delta % 2 === 0);\n        // Here we set up the start and end points as the furthest points found so far\n        // in both the forward and reverse directions, respectively\n        forwardPoints[diagonalForwardBase] = originalStart;\n        reversePoints[diagonalReverseBase] = originalEnd;\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n        quitEarlyArr[0] = false;\n        // A couple of points:\n        // --With this method, we iterate on the number of differences between the two sequences.\n        //   The more differences there actually are, the longer this will take.\n        // --Also, as the number of differences increases, we have to search on diagonals further\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n        //   is even and odd diagonals only when numDifferences is odd.\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n            let furthestOriginalIndex = 0;\n            let furthestModifiedIndex = 0;\n            // Run the algorithm in the forward direction\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalStart, modifiedStart)\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                    originalIndex = forwardPoints[diagonal + 1];\n                }\n                else {\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n                // Save the current originalIndex so we can test for false overlap in step 3\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // so long as the elements are equal.\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n                    originalIndex++;\n                    modifiedIndex++;\n                }\n                forwardPoints[diagonal] = originalIndex;\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n                    furthestOriginalIndex = originalIndex;\n                    furthestModifiedIndex = modifiedIndex;\n                }\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n                // then check for overlap.\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n                    if (originalIndex >= reversePoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Check to see if we should be quitting early, before moving on to the next iteration.\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n                // We can't finish, so skip ahead to generating a result from what we have.\n                quitEarlyArr[0] = true;\n                // Use the furthest distance we got in the forward direction.\n                midOriginalArr[0] = furthestOriginalIndex;\n                midModifiedArr[0] = furthestModifiedIndex;\n                if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                    // Enough of the history is in memory to walk it backwards\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                }\n                else {\n                    // We didn't actually remember enough of the history.\n                    //Since we are quitting the diff early, we need to shift back the originalStart and modified start\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\n                    originalStart++;\n                    modifiedStart++;\n                    return [\n                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n                    ];\n                }\n            }\n            // Run the algorithm in the reverse direction\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalEnd, modifiedEnd)\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n                // Save the current originalIndex so we can test for false overlap\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // as long as the elements are equal.\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n                    originalIndex--;\n                    modifiedIndex--;\n                }\n                reversePoints[diagonal] = originalIndex;\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n                // and diagonal is in the range of forward diagonals computed for numDifferences\n                // then check for overlap.\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n                    if (originalIndex <= forwardPoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Save current vectors to history before the next iteration\n            if (numDifferences <= 1447 /* MaxDifferencesHistory */) {\n                // We are allocating space for one extra int, which we fill with\n                // the index of the diagonal base index\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n                this.m_forwardHistory.push(temp);\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n                this.m_reverseHistory.push(temp);\n            }\n        }\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\n        // NOTE: This part is a bit messy\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    }\n    /**\n     * Shifts the given changes to provide a more intuitive diff.\n     * While the first element in a diff matches the first element after the diff,\n     * we shift the diff down.\n     *\n     * @param changes The list of changes to shift\n     * @returns The shifted changes\n     */\n    PrettifyChanges(changes) {\n        // Shift all the changes down first\n        for (let i = 0; i < changes.length; i++) {\n            const change = changes[i];\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            while (change.originalStart + change.originalLength < originalStop\n                && change.modifiedStart + change.modifiedLength < modifiedStop\n                && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\n                && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n                const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n                const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n                if (endStrictEqual && !startStrictEqual) {\n                    // moving the change down would create an equal change, but the elements are not strict equal\n                    break;\n                }\n                change.originalStart++;\n                change.modifiedStart++;\n            }\n            let mergedChangeArr = [null];\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n                changes[i] = mergedChangeArr[0];\n                changes.splice(i + 1, 1);\n                i--;\n                continue;\n            }\n        }\n        // Shift changes back up until we hit empty or whitespace-only lines\n        for (let i = changes.length - 1; i >= 0; i--) {\n            const change = changes[i];\n            let originalStop = 0;\n            let modifiedStop = 0;\n            if (i > 0) {\n                const prevChange = changes[i - 1];\n                originalStop = prevChange.originalStart + prevChange.originalLength;\n                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n            }\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            let bestDelta = 0;\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n            for (let delta = 1;; delta++) {\n                const originalStart = change.originalStart - delta;\n                const modifiedStart = change.modifiedStart - delta;\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\n                    break;\n                }\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n                    break;\n                }\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n                    break;\n                }\n                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\n                const score = ((touchingPreviousChange ? 5 : 0)\n                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestDelta = delta;\n                }\n            }\n            change.originalStart -= bestDelta;\n            change.modifiedStart -= bestDelta;\n            const mergedChangeArr = [null];\n            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n                changes[i - 1] = mergedChangeArr[0];\n                changes.splice(i, 1);\n                i++;\n                continue;\n            }\n        }\n        // There could be multiple longest common substrings.\n        // Give preference to the ones containing longer lines\n        if (this._hasStrings) {\n            for (let i = 1, len = changes.length; i < len; i++) {\n                const aChange = changes[i - 1];\n                const bChange = changes[i];\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n                const aOriginalStart = aChange.originalStart;\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\n                const aModifiedStart = aChange.modifiedStart;\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\n                // Avoid wasting a lot of time with these searches\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n                    if (t) {\n                        const [originalMatchStart, modifiedMatchStart] = t;\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n                            // switch to another sequence that has a better score\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n                            bChange.originalStart = originalMatchStart + matchedLength;\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n                        }\n                    }\n                }\n            }\n        }\n        return changes;\n    }\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\n            return null;\n        }\n        const originalMax = originalStart + originalLength - desiredLength + 1;\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n        let bestScore = 0;\n        let bestOriginalStart = 0;\n        let bestModifiedStart = 0;\n        for (let i = originalStart; i < originalMax; i++) {\n            for (let j = modifiedStart; j < modifiedMax; j++) {\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\n                if (score > 0 && score > bestScore) {\n                    bestScore = score;\n                    bestOriginalStart = i;\n                    bestModifiedStart = j;\n                }\n            }\n        }\n        if (bestScore > 0) {\n            return [bestOriginalStart, bestModifiedStart];\n        }\n        return null;\n    }\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\n        let score = 0;\n        for (let l = 0; l < length; l++) {\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n                return 0;\n            }\n            score += this._originalStringElements[originalStart + l].length;\n        }\n        return score;\n    }\n    _OriginalIsBoundary(index) {\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n    }\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n            return true;\n        }\n        if (originalLength > 0) {\n            const originalEnd = originalStart + originalLength;\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _ModifiedIsBoundary(index) {\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n    }\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n            return true;\n        }\n        if (modifiedLength > 0) {\n            const modifiedEnd = modifiedStart + modifiedLength;\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n        return (originalScore + modifiedScore);\n    }\n    /**\n     * Concatenates the two input DiffChange lists and returns the resulting\n     * list.\n     * @param The left changes\n     * @param The right changes\n     * @returns The concatenated list\n     */\n    ConcatenateChanges(left, right) {\n        let mergedChangeArr = [];\n        if (left.length === 0 || right.length === 0) {\n            return (right.length > 0) ? right : left;\n        }\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n            // Since we break the problem down recursively, it is possible that we\n            // might recurse in the middle of a change thereby splitting it into\n            // two changes. Here in the combining stage, we detect and fuse those\n            // changes back together\n            const result = new Array(left.length + right.length - 1);\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\n            result[left.length - 1] = mergedChangeArr[0];\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\n            return result;\n        }\n        else {\n            const result = new Array(left.length + right.length);\n            MyArray.Copy(left, 0, result, 0, left.length);\n            MyArray.Copy(right, 0, result, left.length, right.length);\n            return result;\n        }\n    }\n    /**\n     * Returns true if the two changes overlap and can be merged into a single\n     * change\n     * @param left The left change\n     * @param right The right change\n     * @param mergedChange The merged change if the two overlap, null otherwise\n     * @returns True if the two changes overlap\n     */\n    ChangesOverlap(left, right, mergedChangeArr) {\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n            const originalStart = left.originalStart;\n            let originalLength = left.originalLength;\n            const modifiedStart = left.modifiedStart;\n            let modifiedLength = left.modifiedLength;\n            if (left.originalStart + left.originalLength >= right.originalStart) {\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\n            }\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n            }\n            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n            return true;\n        }\n        else {\n            mergedChangeArr[0] = null;\n            return false;\n        }\n    }\n    /**\n     * Helper method used to clip a diagonal index to the range of valid\n     * diagonals. This also decides whether or not the diagonal index,\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\n     * one inside the boundary depending on the Even/Odd status of the boundary\n     * and numDifferences.\n     * @param diagonal The index of the diagonal to clip.\n     * @param numDifferences The current number of differences being iterated upon.\n     * @param diagonalBaseIndex The base reference diagonal.\n     * @param numDiagonals The total number of diagonals.\n     * @returns The clipped diagonal index.\n     */\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n        if (diagonal >= 0 && diagonal < numDiagonals) {\n            // Nothing to clip, its in range\n            return diagonal;\n        }\n        // diagonalsBelow: The number of diagonals below the reference diagonal\n        // diagonalsAbove: The number of diagonals above the reference diagonal\n        const diagonalsBelow = diagonalBaseIndex;\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n        const diffEven = (numDifferences % 2 === 0);\n        if (diagonal < 0) {\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\n            return (diffEven === lowerBoundEven) ? 0 : 1;\n        }\n        else {\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}