{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n\n(function (IndentAction) {\n  /**\n   * Insert new line and copy the previous line's indentation.\n   */\n  IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n  /**\n   * Insert new line and indent once (relative to the previous line's indentation).\n   */\n\n  IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n  /**\n   * Insert two new lines:\n   *  - the first one indented which will hold the cursor\n   *  - the second one at the same indentation level\n   */\n\n  IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n  /**\n   * Insert new line and outdent once (relative to the previous line's indentation).\n   */\n\n  IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\n\n\nexport class StandardAutoClosingPairConditional {\n  constructor(source) {\n    this._neutralCharacter = null;\n    this._neutralCharacterSearched = false;\n    this.open = source.open;\n    this.close = source.close; // initially allowed in all tokens\n\n    this._inString = true;\n    this._inComment = true;\n    this._inRegEx = true;\n\n    if (Array.isArray(source.notIn)) {\n      for (let i = 0, len = source.notIn.length; i < len; i++) {\n        const notIn = source.notIn[i];\n\n        switch (notIn) {\n          case 'string':\n            this._inString = false;\n            break;\n\n          case 'comment':\n            this._inComment = false;\n            break;\n\n          case 'regex':\n            this._inRegEx = false;\n            break;\n        }\n      }\n    }\n  }\n\n  isOK(standardToken) {\n    switch (standardToken) {\n      case 0\n      /* Other */\n      :\n        return true;\n\n      case 1\n      /* Comment */\n      :\n        return this._inComment;\n\n      case 2\n      /* String */\n      :\n        return this._inString;\n\n      case 3\n      /* RegEx */\n      :\n        return this._inRegEx;\n    }\n  }\n\n  shouldAutoClose(context, column) {\n    // Always complete on empty line\n    if (context.getTokenCount() === 0) {\n      return true;\n    }\n\n    const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n    const standardTokenType = context.getStandardTokenType(tokenIndex);\n    return this.isOK(standardTokenType);\n  }\n\n  _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n    for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n      const character = String.fromCharCode(charCode);\n\n      if (!this.open.includes(character) && !this.close.includes(character)) {\n        return character;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n   */\n\n\n  findNeutralCharacter() {\n    if (!this._neutralCharacterSearched) {\n      this._neutralCharacterSearched = true;\n\n      if (!this._neutralCharacter) {\n        this._neutralCharacter = this._findNeutralCharacterInRange(48\n        /* Digit0 */\n        , 57\n        /* Digit9 */\n        );\n      }\n\n      if (!this._neutralCharacter) {\n        this._neutralCharacter = this._findNeutralCharacterInRange(97\n        /* a */\n        , 122\n        /* z */\n        );\n      }\n\n      if (!this._neutralCharacter) {\n        this._neutralCharacter = this._findNeutralCharacterInRange(65\n        /* A */\n        , 90\n        /* Z */\n        );\n      }\n    }\n\n    return this._neutralCharacter;\n  }\n\n}\n/**\n * @internal\n */\n\nexport class AutoClosingPairs {\n  constructor(autoClosingPairs) {\n    this.autoClosingPairsOpenByStart = new Map();\n    this.autoClosingPairsOpenByEnd = new Map();\n    this.autoClosingPairsCloseByStart = new Map();\n    this.autoClosingPairsCloseByEnd = new Map();\n    this.autoClosingPairsCloseSingleChar = new Map();\n\n    for (const pair of autoClosingPairs) {\n      appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n      appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n      appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n      appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n\n      if (pair.close.length === 1 && pair.open.length === 1) {\n        appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n      }\n    }\n  }\n\n}\n\nfunction appendEntry(target, key, value) {\n  if (target.has(key)) {\n    target.get(key).push(value);\n  } else {\n    target.set(key, [value]);\n  }\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js"],"names":["IndentAction","StandardAutoClosingPairConditional","constructor","source","_neutralCharacter","_neutralCharacterSearched","open","close","_inString","_inComment","_inRegEx","Array","isArray","notIn","i","len","length","isOK","standardToken","shouldAutoClose","context","column","getTokenCount","tokenIndex","findTokenIndexAtOffset","standardTokenType","getStandardTokenType","_findNeutralCharacterInRange","fromCharCode","toCharCode","charCode","character","String","includes","findNeutralCharacter","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","Map","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","charAt","target","key","value","has","get","push","set"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* Other */:\n                return true;\n            case 1 /* Comment */:\n                return this._inComment;\n            case 2 /* String */:\n                return this._inString;\n            case 3 /* RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* Digit0 */, 57 /* Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* a */, 122 /* z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* A */, 90 /* Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}