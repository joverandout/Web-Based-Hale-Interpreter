{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\n\nfunction createWordRegExp(allowInWords = '') {\n  let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\n  for (const sep of USUAL_WORD_SEPARATORS) {\n    if (allowInWords.indexOf(sep) >= 0) {\n      continue;\n    }\n\n    source += '\\\\' + sep;\n  }\n\n  source += '\\\\s]+)';\n  return new RegExp(source, 'g');\n} // catches numbers (including floating numbers) in the first group, and alphanum in the second\n\n\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n  let result = DEFAULT_WORD_REGEXP;\n\n  if (wordDefinition && wordDefinition instanceof RegExp) {\n    if (!wordDefinition.global) {\n      let flags = 'g';\n\n      if (wordDefinition.ignoreCase) {\n        flags += 'i';\n      }\n\n      if (wordDefinition.multiline) {\n        flags += 'm';\n      }\n\n      if (wordDefinition.unicode) {\n        flags += 'u';\n      }\n\n      result = new RegExp(wordDefinition.source, flags);\n    } else {\n      result = wordDefinition;\n    }\n  }\n\n  result.lastIndex = 0;\n  return result;\n}\nconst _defaultConfig = {\n  maxLen: 1000,\n  windowSize: 15,\n  timeBudget: 150\n};\nexport function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {\n  if (text.length > config.maxLen) {\n    // don't throw strings that long at the regexp\n    // but use a sub-string in which a word must occur\n    let start = column - config.maxLen / 2;\n\n    if (start < 0) {\n      start = 0;\n    } else {\n      textOffset += start;\n    }\n\n    text = text.substring(start, column + config.maxLen / 2);\n    return getWordAtText(column, wordDefinition, text, textOffset, config);\n  }\n\n  const t1 = Date.now();\n  const pos = column - 1 - textOffset;\n  let prevRegexIndex = -1;\n  let match = null;\n\n  for (let i = 1;; i++) {\n    // check time budget\n    if (Date.now() - t1 >= config.timeBudget) {\n      break;\n    } // reset the index at which the regexp should start matching, also know where it\n    // should stop so that subsequent search don't repeat previous searches\n\n\n    const regexIndex = pos - config.windowSize * i;\n    wordDefinition.lastIndex = Math.max(0, regexIndex);\n\n    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n\n    if (!thisMatch && match) {\n      // stop: we have something\n      break;\n    }\n\n    match = thisMatch; // stop: searched at start\n\n    if (regexIndex <= 0) {\n      break;\n    }\n\n    prevRegexIndex = regexIndex;\n  }\n\n  if (match) {\n    const result = {\n      word: match[0],\n      startColumn: textOffset + 1 + match.index,\n      endColumn: textOffset + 1 + match.index + match[0].length\n    };\n    wordDefinition.lastIndex = 0;\n    return result;\n  }\n\n  return null;\n}\n\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n  let match;\n\n  while (match = wordDefinition.exec(text)) {\n    const matchIndex = match.index || 0;\n\n    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n      return match;\n    } else if (stopPos > 0 && matchIndex > stopPos) {\n      return null;\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"],"names":["USUAL_WORD_SEPARATORS","createWordRegExp","allowInWords","source","sep","indexOf","RegExp","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","wordDefinition","result","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","maxLen","windowSize","timeBudget","getWordAtText","column","text","textOffset","config","length","start","substring","t1","Date","now","pos","prevRegexIndex","match","i","regexIndex","Math","max","thisMatch","_findRegexMatchEnclosingPosition","word","startColumn","index","endColumn","stopPos","exec","matchIndex"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = {\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n};\nexport function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n"]},"metadata":{},"sourceType":"module"}