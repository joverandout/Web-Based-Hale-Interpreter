{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\n\nimport { CancellationTokenSource } from './cancellation.js';\nimport { CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { toDisposable } from './lifecycle.js';\nimport { setTimeout0 } from './platform.js';\nexport function isThenable(obj) {\n  return !!obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n  const source = new CancellationTokenSource();\n  const thenable = callback(source.token);\n  const promise = new Promise((resolve, reject) => {\n    const subscription = source.token.onCancellationRequested(() => {\n      subscription.dispose();\n      source.dispose();\n      reject(new CancellationError());\n    });\n    Promise.resolve(thenable).then(value => {\n      subscription.dispose();\n      source.dispose();\n      resolve(value);\n    }, err => {\n      subscription.dispose();\n      source.dispose();\n      reject(err);\n    });\n  });\n  return new class {\n    cancel() {\n      source.cancel();\n    }\n\n    then(resolve, reject) {\n      return promise.then(resolve, reject);\n    }\n\n    catch(reject) {\n      return this.then(undefined, reject);\n    }\n\n    finally(onfinally) {\n      return promise.finally(onfinally);\n    }\n\n  }();\n}\nexport function raceCancellation(promise, token, defaultValue) {\n  return new Promise((resolve, reject) => {\n    const ref = token.onCancellationRequested(() => {\n      ref.dispose();\n      resolve(defaultValue);\n    });\n    promise.then(resolve, reject).finally(() => ref.dispose());\n  });\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\n\nexport class Throttler {\n  constructor() {\n    this.activePromise = null;\n    this.queuedPromise = null;\n    this.queuedPromiseFactory = null;\n  }\n\n  queue(promiseFactory) {\n    if (this.activePromise) {\n      this.queuedPromiseFactory = promiseFactory;\n\n      if (!this.queuedPromise) {\n        const onComplete = () => {\n          this.queuedPromise = null;\n          const result = this.queue(this.queuedPromiseFactory);\n          this.queuedPromiseFactory = null;\n          return result;\n        };\n\n        this.queuedPromise = new Promise(resolve => {\n          this.activePromise.then(onComplete, onComplete).then(resolve);\n        });\n      }\n\n      return new Promise((resolve, reject) => {\n        this.queuedPromise.then(resolve, reject);\n      });\n    }\n\n    this.activePromise = promiseFactory();\n    return new Promise((resolve, reject) => {\n      this.activePromise.then(result => {\n        this.activePromise = null;\n        resolve(result);\n      }, err => {\n        this.activePromise = null;\n        reject(err);\n      });\n    });\n  }\n\n}\n\nconst timeoutDeferred = (timeout, fn) => {\n  let scheduled = true;\n  const handle = setTimeout(() => {\n    scheduled = false;\n    fn();\n  }, timeout);\n  return {\n    isTriggered: () => scheduled,\n    dispose: () => {\n      clearTimeout(handle);\n      scheduled = false;\n    }\n  };\n};\n\nconst microtaskDeferred = fn => {\n  let scheduled = true;\n  queueMicrotask(() => {\n    if (scheduled) {\n      scheduled = false;\n      fn();\n    }\n  });\n  return {\n    isTriggered: () => scheduled,\n    dispose: () => {\n      scheduled = false;\n    }\n  };\n};\n/** Can be passed into the Delayed to defer using a microtask */\n\n\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\n\nexport class Delayer {\n  constructor(defaultDelay) {\n    this.defaultDelay = defaultDelay;\n    this.deferred = null;\n    this.completionPromise = null;\n    this.doResolve = null;\n    this.doReject = null;\n    this.task = null;\n  }\n\n  trigger(task, delay = this.defaultDelay) {\n    this.task = task;\n    this.cancelTimeout();\n\n    if (!this.completionPromise) {\n      this.completionPromise = new Promise((resolve, reject) => {\n        this.doResolve = resolve;\n        this.doReject = reject;\n      }).then(() => {\n        this.completionPromise = null;\n        this.doResolve = null;\n\n        if (this.task) {\n          const task = this.task;\n          this.task = null;\n          return task();\n        }\n\n        return undefined;\n      });\n    }\n\n    const fn = () => {\n      var _a;\n\n      this.deferred = null;\n      (_a = this.doResolve) === null || _a === void 0 ? void 0 : _a.call(this, null);\n    };\n\n    this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n    return this.completionPromise;\n  }\n\n  isTriggered() {\n    var _a;\n\n    return !!((_a = this.deferred) === null || _a === void 0 ? void 0 : _a.isTriggered());\n  }\n\n  cancel() {\n    this.cancelTimeout();\n\n    if (this.completionPromise) {\n      if (this.doReject) {\n        this.doReject(new CancellationError());\n      }\n\n      this.completionPromise = null;\n    }\n  }\n\n  cancelTimeout() {\n    var _a;\n\n    (_a = this.deferred) === null || _a === void 0 ? void 0 : _a.dispose();\n    this.deferred = null;\n  }\n\n  dispose() {\n    this.cancel();\n  }\n\n}\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\n\nexport class ThrottledDelayer {\n  constructor(defaultDelay) {\n    this.delayer = new Delayer(defaultDelay);\n    this.throttler = new Throttler();\n  }\n\n  trigger(promiseFactory, delay) {\n    return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n  }\n\n  dispose() {\n    this.delayer.dispose();\n  }\n\n}\nexport function timeout(millis, token) {\n  if (!token) {\n    return createCancelablePromise(token => timeout(millis, token));\n  }\n\n  return new Promise((resolve, reject) => {\n    const handle = setTimeout(() => {\n      disposable.dispose();\n      resolve();\n    }, millis);\n    const disposable = token.onCancellationRequested(() => {\n      clearTimeout(handle);\n      disposable.dispose();\n      reject(new CancellationError());\n    });\n  });\n}\nexport function disposableTimeout(handler, timeout = 0) {\n  const timer = setTimeout(handler, timeout);\n  return toDisposable(() => clearTimeout(timer));\n}\nexport function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n  let index = 0;\n  const len = promiseFactories.length;\n\n  const loop = () => {\n    if (index >= len) {\n      return Promise.resolve(defaultValue);\n    }\n\n    const factory = promiseFactories[index++];\n    const promise = Promise.resolve(factory());\n    return promise.then(result => {\n      if (shouldStop(result)) {\n        return Promise.resolve(result);\n      }\n\n      return loop();\n    });\n  };\n\n  return loop();\n}\nexport class TimeoutTimer {\n  constructor(runner, timeout) {\n    this._token = -1;\n\n    if (typeof runner === 'function' && typeof timeout === 'number') {\n      this.setIfNotSet(runner, timeout);\n    }\n  }\n\n  dispose() {\n    this.cancel();\n  }\n\n  cancel() {\n    if (this._token !== -1) {\n      clearTimeout(this._token);\n      this._token = -1;\n    }\n  }\n\n  cancelAndSet(runner, timeout) {\n    this.cancel();\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n\n  setIfNotSet(runner, timeout) {\n    if (this._token !== -1) {\n      // timer is already set\n      return;\n    }\n\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n\n}\nexport class IntervalTimer {\n  constructor() {\n    this._token = -1;\n  }\n\n  dispose() {\n    this.cancel();\n  }\n\n  cancel() {\n    if (this._token !== -1) {\n      clearInterval(this._token);\n      this._token = -1;\n    }\n  }\n\n  cancelAndSet(runner, interval) {\n    this.cancel();\n    this._token = setInterval(() => {\n      runner();\n    }, interval);\n  }\n\n}\nexport class RunOnceScheduler {\n  constructor(runner, delay) {\n    this.timeoutToken = -1;\n    this.runner = runner;\n    this.timeout = delay;\n    this.timeoutHandler = this.onTimeout.bind(this);\n  }\n  /**\n   * Dispose RunOnceScheduler\n   */\n\n\n  dispose() {\n    this.cancel();\n    this.runner = null;\n  }\n  /**\n   * Cancel current scheduled runner (if any).\n   */\n\n\n  cancel() {\n    if (this.isScheduled()) {\n      clearTimeout(this.timeoutToken);\n      this.timeoutToken = -1;\n    }\n  }\n  /**\n   * Cancel previous runner (if any) & schedule a new runner.\n   */\n\n\n  schedule(delay = this.timeout) {\n    this.cancel();\n    this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n  }\n\n  get delay() {\n    return this.timeout;\n  }\n\n  set delay(value) {\n    this.timeout = value;\n  }\n  /**\n   * Returns true if scheduled.\n   */\n\n\n  isScheduled() {\n    return this.timeoutToken !== -1;\n  }\n\n  onTimeout() {\n    this.timeoutToken = -1;\n\n    if (this.runner) {\n      this.doRun();\n    }\n  }\n\n  doRun() {\n    if (this.runner) {\n      this.runner();\n    }\n  }\n\n}\n/**\n * Execute the callback the next time the browser is idle\n */\n\nexport let runWhenIdle;\n\n(function () {\n  if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n    runWhenIdle = runner => {\n      setTimeout0(() => {\n        if (disposed) {\n          return;\n        }\n\n        const end = Date.now() + 15; // one frame at 64fps\n\n        runner(Object.freeze({\n          didTimeout: true,\n\n          timeRemaining() {\n            return Math.max(0, end - Date.now());\n          }\n\n        }));\n      });\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n\n          disposed = true;\n        }\n\n      };\n    };\n  } else {\n    runWhenIdle = (runner, timeout) => {\n      const handle = requestIdleCallback(runner, typeof timeout === 'number' ? {\n        timeout\n      } : undefined);\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n\n          disposed = true;\n          cancelIdleCallback(handle);\n        }\n\n      };\n    };\n  }\n})();\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\n\n\nexport class IdleValue {\n  constructor(executor) {\n    this._didRun = false;\n\n    this._executor = () => {\n      try {\n        this._value = executor();\n      } catch (err) {\n        this._error = err;\n      } finally {\n        this._didRun = true;\n      }\n    };\n\n    this._handle = runWhenIdle(() => this._executor());\n  }\n\n  dispose() {\n    this._handle.dispose();\n  }\n\n  get value() {\n    if (!this._didRun) {\n      this._handle.dispose();\n\n      this._executor();\n    }\n\n    if (this._error) {\n      throw this._error;\n    }\n\n    return this._value;\n  }\n\n  get isInitialized() {\n    return this._didRun;\n  }\n\n}\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\n\nexport class DeferredPromise {\n  constructor() {\n    this.rejected = false;\n    this.resolved = false;\n    this.p = new Promise((c, e) => {\n      this.completeCallback = c;\n      this.errorCallback = e;\n    });\n  }\n\n  get isRejected() {\n    return this.rejected;\n  }\n\n  get isSettled() {\n    return this.rejected || this.resolved;\n  }\n\n  complete(value) {\n    return new Promise(resolve => {\n      this.completeCallback(value);\n      this.resolved = true;\n      resolve();\n    });\n  }\n\n  cancel() {\n    new Promise(resolve => {\n      this.errorCallback(new CancellationError());\n      this.rejected = true;\n      resolve();\n    });\n  }\n\n} //#endregion\n//#region Promises\n\nexport var Promises;\n\n(function (Promises) {\n  /**\n   * A drop-in replacement for `Promise.all` with the only difference\n   * that the method awaits every promise to either fulfill or reject.\n   *\n   * Similar to `Promise.all`, only the first error will be returned\n   * if any.\n   */\n  function settled(promises) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let firstError = undefined;\n      const result = yield Promise.all(promises.map(promise => promise.then(value => value, error => {\n        if (!firstError) {\n          firstError = error;\n        }\n\n        return undefined; // do not rethrow so that other promises can settle\n      })));\n\n      if (typeof firstError !== 'undefined') {\n        throw firstError;\n      }\n\n      return result; // cast is needed and protected by the `throw` above\n    });\n  }\n\n  Promises.settled = settled;\n  /**\n   * A helper to create a new `Promise<T>` with a body that is a promise\n   * itself. By default, an error that raises from the async body will\n   * end up as a unhandled rejection, so this utility properly awaits the\n   * body and rejects the promise as a normal promise does without async\n   * body.\n   *\n   * This method should only be used in rare cases where otherwise `async`\n   * cannot be used (e.g. when callbacks are involved that require this).\n   */\n\n  function withAsyncBody(bodyFn) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield bodyFn(resolve, reject);\n      } catch (error) {\n        reject(error);\n      }\n    }));\n  }\n\n  Promises.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {}));\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\n\n\nexport class AsyncIterableObject {\n  constructor(executor) {\n    this._state = 0\n    /* Initial */\n    ;\n    this._results = [];\n    this._error = null;\n    this._onStateChanged = new Emitter();\n    queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {\n      const writer = {\n        emitOne: item => this.emitOne(item),\n        emitMany: items => this.emitMany(items),\n        reject: error => this.reject(error)\n      };\n\n      try {\n        yield Promise.resolve(executor(writer));\n        this.resolve();\n      } catch (err) {\n        this.reject(err);\n      } finally {\n        writer.emitOne = undefined;\n        writer.emitMany = undefined;\n        writer.reject = undefined;\n      }\n    }));\n  }\n\n  static fromArray(items) {\n    return new AsyncIterableObject(writer => {\n      writer.emitMany(items);\n    });\n  }\n\n  static fromPromise(promise) {\n    return new AsyncIterableObject(emitter => __awaiter(this, void 0, void 0, function* () {\n      emitter.emitMany(yield promise);\n    }));\n  }\n\n  static fromPromises(promises) {\n    return new AsyncIterableObject(emitter => __awaiter(this, void 0, void 0, function* () {\n      yield Promise.all(promises.map(p => __awaiter(this, void 0, void 0, function* () {\n        return emitter.emitOne(yield p);\n      })));\n    }));\n  }\n\n  static merge(iterables) {\n    return new AsyncIterableObject(emitter => __awaiter(this, void 0, void 0, function* () {\n      yield Promise.all(iterables.map(iterable => {\n        var iterable_1, iterable_1_1;\n        return __awaiter(this, void 0, void 0, function* () {\n          var e_1, _a;\n\n          try {\n            for (iterable_1 = __asyncValues(iterable); iterable_1_1 = yield iterable_1.next(), !iterable_1_1.done;) {\n              const item = iterable_1_1.value;\n              emitter.emitOne(item);\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield _a.call(iterable_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n        });\n      }));\n    }));\n  }\n\n  [Symbol.asyncIterator]() {\n    let i = 0;\n    return {\n      next: () => __awaiter(this, void 0, void 0, function* () {\n        do {\n          if (this._state === 2\n          /* DoneError */\n          ) {\n            throw this._error;\n          }\n\n          if (i < this._results.length) {\n            return {\n              done: false,\n              value: this._results[i++]\n            };\n          }\n\n          if (this._state === 1\n          /* DoneOK */\n          ) {\n            return {\n              done: true,\n              value: undefined\n            };\n          }\n\n          yield Event.toPromise(this._onStateChanged.event);\n        } while (true);\n      })\n    };\n  }\n\n  static map(iterable, mapFn) {\n    return new AsyncIterableObject(emitter => __awaiter(this, void 0, void 0, function* () {\n      var e_2, _a;\n\n      try {\n        for (var iterable_2 = __asyncValues(iterable), iterable_2_1; iterable_2_1 = yield iterable_2.next(), !iterable_2_1.done;) {\n          const item = iterable_2_1.value;\n          emitter.emitOne(mapFn(item));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (iterable_2_1 && !iterable_2_1.done && (_a = iterable_2.return)) yield _a.call(iterable_2);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }));\n  }\n\n  map(mapFn) {\n    return AsyncIterableObject.map(this, mapFn);\n  }\n\n  static filter(iterable, filterFn) {\n    return new AsyncIterableObject(emitter => __awaiter(this, void 0, void 0, function* () {\n      var e_3, _a;\n\n      try {\n        for (var iterable_3 = __asyncValues(iterable), iterable_3_1; iterable_3_1 = yield iterable_3.next(), !iterable_3_1.done;) {\n          const item = iterable_3_1.value;\n\n          if (filterFn(item)) {\n            emitter.emitOne(item);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (iterable_3_1 && !iterable_3_1.done && (_a = iterable_3.return)) yield _a.call(iterable_3);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }));\n  }\n\n  filter(filterFn) {\n    return AsyncIterableObject.filter(this, filterFn);\n  }\n\n  static coalesce(iterable) {\n    return AsyncIterableObject.filter(iterable, item => !!item);\n  }\n\n  coalesce() {\n    return AsyncIterableObject.coalesce(this);\n  }\n\n  static toPromise(iterable) {\n    var iterable_4, iterable_4_1;\n\n    var e_4, _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = [];\n\n      try {\n        for (iterable_4 = __asyncValues(iterable); iterable_4_1 = yield iterable_4.next(), !iterable_4_1.done;) {\n          const item = iterable_4_1.value;\n          result.push(item);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (iterable_4_1 && !iterable_4_1.done && (_a = iterable_4.return)) yield _a.call(iterable_4);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n\n      return result;\n    });\n  }\n\n  toPromise() {\n    return AsyncIterableObject.toPromise(this);\n  }\n  /**\n   * The value will be appended at the end.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n\n\n  emitOne(value) {\n    if (this._state !== 0\n    /* Initial */\n    ) {\n      return;\n    } // it is important to add new values at the end,\n    // as we may have iterators already running on the array\n\n\n    this._results.push(value);\n\n    this._onStateChanged.fire();\n  }\n  /**\n   * The values will be appended at the end.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n\n\n  emitMany(values) {\n    if (this._state !== 0\n    /* Initial */\n    ) {\n      return;\n    } // it is important to add new values at the end,\n    // as we may have iterators already running on the array\n\n\n    this._results = this._results.concat(values);\n\n    this._onStateChanged.fire();\n  }\n  /**\n   * Calling `resolve()` will mark the result array as complete.\n   *\n   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n\n\n  resolve() {\n    if (this._state !== 0\n    /* Initial */\n    ) {\n      return;\n    }\n\n    this._state = 1\n    /* DoneOK */\n    ;\n\n    this._onStateChanged.fire();\n  }\n  /**\n   * Writing an error will permanently invalidate this iterable.\n   * The current users will receive an error thrown, as will all future users.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n\n\n  reject(error) {\n    if (this._state !== 0\n    /* Initial */\n    ) {\n      return;\n    }\n\n    this._state = 2\n    /* DoneError */\n    ;\n    this._error = error;\n\n    this._onStateChanged.fire();\n  }\n\n}\nAsyncIterableObject.EMPTY = AsyncIterableObject.fromArray([]);\nexport class CancelableAsyncIterableObject extends AsyncIterableObject {\n  constructor(_source, executor) {\n    super(executor);\n    this._source = _source;\n  }\n\n  cancel() {\n    this._source.cancel();\n  }\n\n}\nexport function createCancelableAsyncIterable(callback) {\n  const source = new CancellationTokenSource();\n  const innerIterable = callback(source.token);\n  return new CancelableAsyncIterableObject(source, emitter => __awaiter(this, void 0, void 0, function* () {\n    var e_5, _a;\n\n    const subscription = source.token.onCancellationRequested(() => {\n      subscription.dispose();\n      source.dispose();\n      emitter.reject(new CancellationError());\n    });\n\n    try {\n      try {\n        for (var innerIterable_1 = __asyncValues(innerIterable), innerIterable_1_1; innerIterable_1_1 = yield innerIterable_1.next(), !innerIterable_1_1.done;) {\n          const item = innerIterable_1_1.value;\n\n          if (source.token.isCancellationRequested) {\n            // canceled in the meantime\n            return;\n          }\n\n          emitter.emitOne(item);\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (innerIterable_1_1 && !innerIterable_1_1.done && (_a = innerIterable_1.return)) yield _a.call(innerIterable_1);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n\n      subscription.dispose();\n      source.dispose();\n    } catch (err) {\n      subscription.dispose();\n      source.dispose();\n      emitter.reject(err);\n    }\n  }));\n} //#endregion","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/async.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","settle","d","CancellationTokenSource","CancellationError","Emitter","Event","toDisposable","setTimeout0","isThenable","obj","createCancelablePromise","callback","source","thenable","token","promise","subscription","onCancellationRequested","dispose","err","cancel","catch","undefined","finally","onfinally","raceCancellation","defaultValue","ref","Throttler","constructor","activePromise","queuedPromise","queuedPromiseFactory","queue","promiseFactory","onComplete","timeoutDeferred","timeout","fn","scheduled","handle","setTimeout","isTriggered","clearTimeout","microtaskDeferred","queueMicrotask","MicrotaskDelay","Delayer","defaultDelay","deferred","completionPromise","doResolve","doReject","task","trigger","delay","cancelTimeout","_a","ThrottledDelayer","delayer","throttler","millis","disposable","disposableTimeout","handler","timer","first","promiseFactories","shouldStop","t","index","len","length","loop","factory","TimeoutTimer","runner","_token","setIfNotSet","cancelAndSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","bind","isScheduled","schedule","doRun","runWhenIdle","requestIdleCallback","cancelIdleCallback","disposed","end","Date","now","Object","freeze","didTimeout","timeRemaining","Math","max","IdleValue","executor","_didRun","_executor","_value","_error","_handle","isInitialized","DeferredPromise","resolved","p","c","completeCallback","errorCallback","isRejected","isSettled","complete","Promises","settled","promises","firstError","all","map","error","withAsyncBody","bodyFn","AsyncIterableObject","_state","_results","_onStateChanged","writer","emitOne","item","emitMany","items","fromArray","fromPromise","emitter","fromPromises","merge","iterables","iterable","iterable_1","iterable_1_1","e_1","e_1_1","return","toPromise","event","mapFn","e_2","iterable_2","iterable_2_1","e_2_1","filter","filterFn","e_3","iterable_3","iterable_3_1","e_3_1","coalesce","iterable_4","iterable_4_1","e_4","push","e_4_1","fire","values","concat","EMPTY","CancelableAsyncIterableObject","_source","createCancelableAsyncIterable","innerIterable","e_5","innerIterable_1","innerIterable_1_1","isCancellationRequested","e_5_1"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport { CancellationTokenSource } from './cancellation.js';\nimport { CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { toDisposable } from './lifecycle.js';\nimport { setTimeout0 } from './platform.js';\nexport function isThenable(obj) {\n    return !!obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n    const source = new CancellationTokenSource();\n    const thenable = callback(source.token);\n    const promise = new Promise((resolve, reject) => {\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            source.dispose();\n            reject(new CancellationError());\n        });\n        Promise.resolve(thenable).then(value => {\n            subscription.dispose();\n            source.dispose();\n            resolve(value);\n        }, err => {\n            subscription.dispose();\n            source.dispose();\n            reject(err);\n        });\n    });\n    return new class {\n        cancel() {\n            source.cancel();\n        }\n        then(resolve, reject) {\n            return promise.then(resolve, reject);\n        }\n        catch(reject) {\n            return this.then(undefined, reject);\n        }\n        finally(onfinally) {\n            return promise.finally(onfinally);\n        }\n    };\n}\nexport function raceCancellation(promise, token, defaultValue) {\n    return new Promise((resolve, reject) => {\n        const ref = token.onCancellationRequested(() => {\n            ref.dispose();\n            resolve(defaultValue);\n        });\n        promise.then(resolve, reject).finally(() => ref.dispose());\n    });\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n    constructor() {\n        this.activePromise = null;\n        this.queuedPromise = null;\n        this.queuedPromiseFactory = null;\n    }\n    queue(promiseFactory) {\n        if (this.activePromise) {\n            this.queuedPromiseFactory = promiseFactory;\n            if (!this.queuedPromise) {\n                const onComplete = () => {\n                    this.queuedPromise = null;\n                    const result = this.queue(this.queuedPromiseFactory);\n                    this.queuedPromiseFactory = null;\n                    return result;\n                };\n                this.queuedPromise = new Promise(resolve => {\n                    this.activePromise.then(onComplete, onComplete).then(resolve);\n                });\n            }\n            return new Promise((resolve, reject) => {\n                this.queuedPromise.then(resolve, reject);\n            });\n        }\n        this.activePromise = promiseFactory();\n        return new Promise((resolve, reject) => {\n            this.activePromise.then((result) => {\n                this.activePromise = null;\n                resolve(result);\n            }, (err) => {\n                this.activePromise = null;\n                reject(err);\n            });\n        });\n    }\n}\nconst timeoutDeferred = (timeout, fn) => {\n    let scheduled = true;\n    const handle = setTimeout(() => {\n        scheduled = false;\n        fn();\n    }, timeout);\n    return {\n        isTriggered: () => scheduled,\n        dispose: () => {\n            clearTimeout(handle);\n            scheduled = false;\n        },\n    };\n};\nconst microtaskDeferred = (fn) => {\n    let scheduled = true;\n    queueMicrotask(() => {\n        if (scheduled) {\n            scheduled = false;\n            fn();\n        }\n    });\n    return {\n        isTriggered: () => scheduled,\n        dispose: () => { scheduled = false; },\n    };\n};\n/** Can be passed into the Delayed to defer using a microtask */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer {\n    constructor(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.deferred = null;\n        this.completionPromise = null;\n        this.doResolve = null;\n        this.doReject = null;\n        this.task = null;\n    }\n    trigger(task, delay = this.defaultDelay) {\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = new Promise((resolve, reject) => {\n                this.doResolve = resolve;\n                this.doReject = reject;\n            }).then(() => {\n                this.completionPromise = null;\n                this.doResolve = null;\n                if (this.task) {\n                    const task = this.task;\n                    this.task = null;\n                    return task();\n                }\n                return undefined;\n            });\n        }\n        const fn = () => {\n            var _a;\n            this.deferred = null;\n            (_a = this.doResolve) === null || _a === void 0 ? void 0 : _a.call(this, null);\n        };\n        this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n        return this.completionPromise;\n    }\n    isTriggered() {\n        var _a;\n        return !!((_a = this.deferred) === null || _a === void 0 ? void 0 : _a.isTriggered());\n    }\n    cancel() {\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            if (this.doReject) {\n                this.doReject(new CancellationError());\n            }\n            this.completionPromise = null;\n        }\n    }\n    cancelTimeout() {\n        var _a;\n        (_a = this.deferred) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.deferred = null;\n    }\n    dispose() {\n        this.cancel();\n    }\n}\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer {\n    constructor(defaultDelay) {\n        this.delayer = new Delayer(defaultDelay);\n        this.throttler = new Throttler();\n    }\n    trigger(promiseFactory, delay) {\n        return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n    }\n    dispose() {\n        this.delayer.dispose();\n    }\n}\nexport function timeout(millis, token) {\n    if (!token) {\n        return createCancelablePromise(token => timeout(millis, token));\n    }\n    return new Promise((resolve, reject) => {\n        const handle = setTimeout(() => {\n            disposable.dispose();\n            resolve();\n        }, millis);\n        const disposable = token.onCancellationRequested(() => {\n            clearTimeout(handle);\n            disposable.dispose();\n            reject(new CancellationError());\n        });\n    });\n}\nexport function disposableTimeout(handler, timeout = 0) {\n    const timer = setTimeout(handler, timeout);\n    return toDisposable(() => clearTimeout(timer));\n}\nexport function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n    let index = 0;\n    const len = promiseFactories.length;\n    const loop = () => {\n        if (index >= len) {\n            return Promise.resolve(defaultValue);\n        }\n        const factory = promiseFactories[index++];\n        const promise = Promise.resolve(factory());\n        return promise.then(result => {\n            if (shouldStop(result)) {\n                return Promise.resolve(result);\n            }\n            return loop();\n        });\n    };\n    return loop();\n}\nexport class TimeoutTimer {\n    constructor(runner, timeout) {\n        this._token = -1;\n        if (typeof runner === 'function' && typeof timeout === 'number') {\n            this.setIfNotSet(runner, timeout);\n        }\n    }\n    dispose() {\n        this.cancel();\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearTimeout(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, timeout) {\n        this.cancel();\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n    setIfNotSet(runner, timeout) {\n        if (this._token !== -1) {\n            // timer is already set\n            return;\n        }\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n}\nexport class IntervalTimer {\n    constructor() {\n        this._token = -1;\n    }\n    dispose() {\n        this.cancel();\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearInterval(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, interval) {\n        this.cancel();\n        this._token = setInterval(() => {\n            runner();\n        }, interval);\n    }\n}\nexport class RunOnceScheduler {\n    constructor(runner, delay) {\n        this.timeoutToken = -1;\n        this.runner = runner;\n        this.timeout = delay;\n        this.timeoutHandler = this.onTimeout.bind(this);\n    }\n    /**\n     * Dispose RunOnceScheduler\n     */\n    dispose() {\n        this.cancel();\n        this.runner = null;\n    }\n    /**\n     * Cancel current scheduled runner (if any).\n     */\n    cancel() {\n        if (this.isScheduled()) {\n            clearTimeout(this.timeoutToken);\n            this.timeoutToken = -1;\n        }\n    }\n    /**\n     * Cancel previous runner (if any) & schedule a new runner.\n     */\n    schedule(delay = this.timeout) {\n        this.cancel();\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n    }\n    get delay() {\n        return this.timeout;\n    }\n    set delay(value) {\n        this.timeout = value;\n    }\n    /**\n     * Returns true if scheduled.\n     */\n    isScheduled() {\n        return this.timeoutToken !== -1;\n    }\n    onTimeout() {\n        this.timeoutToken = -1;\n        if (this.runner) {\n            this.doRun();\n        }\n    }\n    doRun() {\n        if (this.runner) {\n            this.runner();\n        }\n    }\n}\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle;\n(function () {\n    if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n        runWhenIdle = (runner) => {\n            setTimeout0(() => {\n                if (disposed) {\n                    return;\n                }\n                const end = Date.now() + 15; // one frame at 64fps\n                runner(Object.freeze({\n                    didTimeout: true,\n                    timeRemaining() {\n                        return Math.max(0, end - Date.now());\n                    }\n                }));\n            });\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                }\n            };\n        };\n    }\n    else {\n        runWhenIdle = (runner, timeout) => {\n            const handle = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    cancelIdleCallback(handle);\n                }\n            };\n        };\n    }\n})();\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue {\n    constructor(executor) {\n        this._didRun = false;\n        this._executor = () => {\n            try {\n                this._value = executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        };\n        this._handle = runWhenIdle(() => this._executor());\n    }\n    dispose() {\n        this._handle.dispose();\n    }\n    get value() {\n        if (!this._didRun) {\n            this._handle.dispose();\n            this._executor();\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    get isInitialized() {\n        return this._didRun;\n    }\n}\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise {\n    constructor() {\n        this.rejected = false;\n        this.resolved = false;\n        this.p = new Promise((c, e) => {\n            this.completeCallback = c;\n            this.errorCallback = e;\n        });\n    }\n    get isRejected() {\n        return this.rejected;\n    }\n    get isSettled() {\n        return this.rejected || this.resolved;\n    }\n    complete(value) {\n        return new Promise(resolve => {\n            this.completeCallback(value);\n            this.resolved = true;\n            resolve();\n        });\n    }\n    cancel() {\n        new Promise(resolve => {\n            this.errorCallback(new CancellationError());\n            this.rejected = true;\n            resolve();\n        });\n    }\n}\n//#endregion\n//#region Promises\nexport var Promises;\n(function (Promises) {\n    /**\n     * A drop-in replacement for `Promise.all` with the only difference\n     * that the method awaits every promise to either fulfill or reject.\n     *\n     * Similar to `Promise.all`, only the first error will be returned\n     * if any.\n     */\n    function settled(promises) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let firstError = undefined;\n            const result = yield Promise.all(promises.map(promise => promise.then(value => value, error => {\n                if (!firstError) {\n                    firstError = error;\n                }\n                return undefined; // do not rethrow so that other promises can settle\n            })));\n            if (typeof firstError !== 'undefined') {\n                throw firstError;\n            }\n            return result; // cast is needed and protected by the `throw` above\n        });\n    }\n    Promises.settled = settled;\n    /**\n     * A helper to create a new `Promise<T>` with a body that is a promise\n     * itself. By default, an error that raises from the async body will\n     * end up as a unhandled rejection, so this utility properly awaits the\n     * body and rejects the promise as a normal promise does without async\n     * body.\n     *\n     * This method should only be used in rare cases where otherwise `async`\n     * cannot be used (e.g. when callbacks are involved that require this).\n     */\n    function withAsyncBody(bodyFn) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield bodyFn(resolve, reject);\n            }\n            catch (error) {\n                reject(error);\n            }\n        }));\n    }\n    Promises.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {}));\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject {\n    constructor(executor) {\n        this._state = 0 /* Initial */;\n        this._results = [];\n        this._error = null;\n        this._onStateChanged = new Emitter();\n        queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {\n            const writer = {\n                emitOne: (item) => this.emitOne(item),\n                emitMany: (items) => this.emitMany(items),\n                reject: (error) => this.reject(error)\n            };\n            try {\n                yield Promise.resolve(executor(writer));\n                this.resolve();\n            }\n            catch (err) {\n                this.reject(err);\n            }\n            finally {\n                writer.emitOne = undefined;\n                writer.emitMany = undefined;\n                writer.reject = undefined;\n            }\n        }));\n    }\n    static fromArray(items) {\n        return new AsyncIterableObject((writer) => {\n            writer.emitMany(items);\n        });\n    }\n    static fromPromise(promise) {\n        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {\n            emitter.emitMany(yield promise);\n        }));\n    }\n    static fromPromises(promises) {\n        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {\n            yield Promise.all(promises.map((p) => __awaiter(this, void 0, void 0, function* () { return emitter.emitOne(yield p); })));\n        }));\n    }\n    static merge(iterables) {\n        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {\n            yield Promise.all(iterables.map((iterable) => { var iterable_1, iterable_1_1; return __awaiter(this, void 0, void 0, function* () {\n                var e_1, _a;\n                try {\n                    for (iterable_1 = __asyncValues(iterable); iterable_1_1 = yield iterable_1.next(), !iterable_1_1.done;) {\n                        const item = iterable_1_1.value;\n                        emitter.emitOne(item);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield _a.call(iterable_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }); }));\n        }));\n    }\n    [Symbol.asyncIterator]() {\n        let i = 0;\n        return {\n            next: () => __awaiter(this, void 0, void 0, function* () {\n                do {\n                    if (this._state === 2 /* DoneError */) {\n                        throw this._error;\n                    }\n                    if (i < this._results.length) {\n                        return { done: false, value: this._results[i++] };\n                    }\n                    if (this._state === 1 /* DoneOK */) {\n                        return { done: true, value: undefined };\n                    }\n                    yield Event.toPromise(this._onStateChanged.event);\n                } while (true);\n            })\n        };\n    }\n    static map(iterable, mapFn) {\n        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {\n            var e_2, _a;\n            try {\n                for (var iterable_2 = __asyncValues(iterable), iterable_2_1; iterable_2_1 = yield iterable_2.next(), !iterable_2_1.done;) {\n                    const item = iterable_2_1.value;\n                    emitter.emitOne(mapFn(item));\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (iterable_2_1 && !iterable_2_1.done && (_a = iterable_2.return)) yield _a.call(iterable_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }));\n    }\n    map(mapFn) {\n        return AsyncIterableObject.map(this, mapFn);\n    }\n    static filter(iterable, filterFn) {\n        return new AsyncIterableObject((emitter) => __awaiter(this, void 0, void 0, function* () {\n            var e_3, _a;\n            try {\n                for (var iterable_3 = __asyncValues(iterable), iterable_3_1; iterable_3_1 = yield iterable_3.next(), !iterable_3_1.done;) {\n                    const item = iterable_3_1.value;\n                    if (filterFn(item)) {\n                        emitter.emitOne(item);\n                    }\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (iterable_3_1 && !iterable_3_1.done && (_a = iterable_3.return)) yield _a.call(iterable_3);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        }));\n    }\n    filter(filterFn) {\n        return AsyncIterableObject.filter(this, filterFn);\n    }\n    static coalesce(iterable) {\n        return AsyncIterableObject.filter(iterable, item => !!item);\n    }\n    coalesce() {\n        return AsyncIterableObject.coalesce(this);\n    }\n    static toPromise(iterable) {\n        var iterable_4, iterable_4_1;\n        var e_4, _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = [];\n            try {\n                for (iterable_4 = __asyncValues(iterable); iterable_4_1 = yield iterable_4.next(), !iterable_4_1.done;) {\n                    const item = iterable_4_1.value;\n                    result.push(item);\n                }\n            }\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\n            finally {\n                try {\n                    if (iterable_4_1 && !iterable_4_1.done && (_a = iterable_4.return)) yield _a.call(iterable_4);\n                }\n                finally { if (e_4) throw e_4.error; }\n            }\n            return result;\n        });\n    }\n    toPromise() {\n        return AsyncIterableObject.toPromise(this);\n    }\n    /**\n     * The value will be appended at the end.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    emitOne(value) {\n        if (this._state !== 0 /* Initial */) {\n            return;\n        }\n        // it is important to add new values at the end,\n        // as we may have iterators already running on the array\n        this._results.push(value);\n        this._onStateChanged.fire();\n    }\n    /**\n     * The values will be appended at the end.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    emitMany(values) {\n        if (this._state !== 0 /* Initial */) {\n            return;\n        }\n        // it is important to add new values at the end,\n        // as we may have iterators already running on the array\n        this._results = this._results.concat(values);\n        this._onStateChanged.fire();\n    }\n    /**\n     * Calling `resolve()` will mark the result array as complete.\n     *\n     * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    resolve() {\n        if (this._state !== 0 /* Initial */) {\n            return;\n        }\n        this._state = 1 /* DoneOK */;\n        this._onStateChanged.fire();\n    }\n    /**\n     * Writing an error will permanently invalidate this iterable.\n     * The current users will receive an error thrown, as will all future users.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    reject(error) {\n        if (this._state !== 0 /* Initial */) {\n            return;\n        }\n        this._state = 2 /* DoneError */;\n        this._error = error;\n        this._onStateChanged.fire();\n    }\n}\nAsyncIterableObject.EMPTY = AsyncIterableObject.fromArray([]);\nexport class CancelableAsyncIterableObject extends AsyncIterableObject {\n    constructor(_source, executor) {\n        super(executor);\n        this._source = _source;\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nexport function createCancelableAsyncIterable(callback) {\n    const source = new CancellationTokenSource();\n    const innerIterable = callback(source.token);\n    return new CancelableAsyncIterableObject(source, (emitter) => __awaiter(this, void 0, void 0, function* () {\n        var e_5, _a;\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            source.dispose();\n            emitter.reject(new CancellationError());\n        });\n        try {\n            try {\n                for (var innerIterable_1 = __asyncValues(innerIterable), innerIterable_1_1; innerIterable_1_1 = yield innerIterable_1.next(), !innerIterable_1_1.done;) {\n                    const item = innerIterable_1_1.value;\n                    if (source.token.isCancellationRequested) {\n                        // canceled in the meantime\n                        return;\n                    }\n                    emitter.emitOne(item);\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (innerIterable_1_1 && !innerIterable_1_1.done && (_a = innerIterable_1.return)) yield _a.call(innerIterable_1);\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n            subscription.dispose();\n            source.dispose();\n        }\n        catch (err) {\n            subscription.dispose();\n            source.dispose();\n            emitter.reject(err);\n        }\n    }));\n}\n//#endregion\n"]},"metadata":{},"sourceType":"module"}