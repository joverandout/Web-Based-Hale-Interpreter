{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Scanner {\n  constructor() {\n    this.value = '';\n    this.pos = 0;\n  }\n\n  static isDigitCharacter(ch) {\n    return ch >= 48\n    /* Digit0 */\n    && ch <= 57\n    /* Digit9 */\n    ;\n  }\n\n  static isVariableCharacter(ch) {\n    return ch === 95\n    /* Underline */\n    || ch >= 97\n    /* a */\n    && ch <= 122\n    /* z */\n    || ch >= 65\n    /* A */\n    && ch <= 90\n    /* Z */\n    ;\n  }\n\n  text(value) {\n    this.value = value;\n    this.pos = 0;\n  }\n\n  tokenText(token) {\n    return this.value.substr(token.pos, token.len);\n  }\n\n  next() {\n    if (this.pos >= this.value.length) {\n      return {\n        type: 14\n        /* EOF */\n        ,\n        pos: this.pos,\n        len: 0\n      };\n    }\n\n    let pos = this.pos;\n    let len = 0;\n    let ch = this.value.charCodeAt(pos);\n    let type; // static types\n\n    type = Scanner._table[ch];\n\n    if (typeof type === 'number') {\n      this.pos += 1;\n      return {\n        type,\n        pos,\n        len: 1\n      };\n    } // number\n\n\n    if (Scanner.isDigitCharacter(ch)) {\n      type = 8\n      /* Int */\n      ;\n\n      do {\n        len += 1;\n        ch = this.value.charCodeAt(pos + len);\n      } while (Scanner.isDigitCharacter(ch));\n\n      this.pos += len;\n      return {\n        type,\n        pos,\n        len\n      };\n    } // variable name\n\n\n    if (Scanner.isVariableCharacter(ch)) {\n      type = 9\n      /* VariableName */\n      ;\n\n      do {\n        ch = this.value.charCodeAt(pos + ++len);\n      } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));\n\n      this.pos += len;\n      return {\n        type,\n        pos,\n        len\n      };\n    } // format\n\n\n    type = 10\n    /* Format */\n    ;\n\n    do {\n      len += 1;\n      ch = this.value.charCodeAt(pos + len);\n    } while (!isNaN(ch) && typeof Scanner._table[ch] === 'undefined' // not static token\n    && !Scanner.isDigitCharacter(ch) // not number\n    && !Scanner.isVariableCharacter(ch) // not variable\n    );\n\n    this.pos += len;\n    return {\n      type,\n      pos,\n      len\n    };\n  }\n\n}\nScanner._table = {\n  [36\n  /* DollarSign */\n  ]: 0\n  /* Dollar */\n  ,\n  [58\n  /* Colon */\n  ]: 1\n  /* Colon */\n  ,\n  [44\n  /* Comma */\n  ]: 2\n  /* Comma */\n  ,\n  [123\n  /* OpenCurlyBrace */\n  ]: 3\n  /* CurlyOpen */\n  ,\n  [125\n  /* CloseCurlyBrace */\n  ]: 4\n  /* CurlyClose */\n  ,\n  [92\n  /* Backslash */\n  ]: 5\n  /* Backslash */\n  ,\n  [47\n  /* Slash */\n  ]: 6\n  /* Forwardslash */\n  ,\n  [124\n  /* Pipe */\n  ]: 7\n  /* Pipe */\n  ,\n  [43\n  /* Plus */\n  ]: 11\n  /* Plus */\n  ,\n  [45\n  /* Dash */\n  ]: 12\n  /* Dash */\n  ,\n  [63\n  /* QuestionMark */\n  ]: 13\n  /* QuestionMark */\n\n};\nexport class Marker {\n  constructor() {\n    this._children = [];\n  }\n\n  appendChild(child) {\n    if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {\n      // this and previous child are text -> merge them\n      this._children[this._children.length - 1].value += child.value;\n    } else {\n      // normal adoption of child\n      child.parent = this;\n\n      this._children.push(child);\n    }\n\n    return this;\n  }\n\n  replace(child, others) {\n    const {\n      parent\n    } = child;\n    const idx = parent.children.indexOf(child);\n    const newChildren = parent.children.slice(0);\n    newChildren.splice(idx, 1, ...others);\n    parent._children = newChildren;\n\n    (function _fixParent(children, parent) {\n      for (const child of children) {\n        child.parent = parent;\n\n        _fixParent(child.children, child);\n      }\n    })(others, parent);\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  get snippet() {\n    let candidate = this;\n\n    while (true) {\n      if (!candidate) {\n        return undefined;\n      }\n\n      if (candidate instanceof TextmateSnippet) {\n        return candidate;\n      }\n\n      candidate = candidate.parent;\n    }\n  }\n\n  toString() {\n    return this.children.reduce((prev, cur) => prev + cur.toString(), '');\n  }\n\n  len() {\n    return 0;\n  }\n\n}\nexport class Text extends Marker {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  len() {\n    return this.value.length;\n  }\n\n  clone() {\n    return new Text(this.value);\n  }\n\n}\nexport class TransformableMarker extends Marker {}\nexport class Placeholder extends TransformableMarker {\n  constructor(index) {\n    super();\n    this.index = index;\n  }\n\n  static compareByIndex(a, b) {\n    if (a.index === b.index) {\n      return 0;\n    } else if (a.isFinalTabstop) {\n      return 1;\n    } else if (b.isFinalTabstop) {\n      return -1;\n    } else if (a.index < b.index) {\n      return -1;\n    } else if (a.index > b.index) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  get isFinalTabstop() {\n    return this.index === 0;\n  }\n\n  get choice() {\n    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : undefined;\n  }\n\n  clone() {\n    let ret = new Placeholder(this.index);\n\n    if (this.transform) {\n      ret.transform = this.transform.clone();\n    }\n\n    ret._children = this.children.map(child => child.clone());\n    return ret;\n  }\n\n}\nexport class Choice extends Marker {\n  constructor() {\n    super(...arguments);\n    this.options = [];\n  }\n\n  appendChild(marker) {\n    if (marker instanceof Text) {\n      marker.parent = this;\n      this.options.push(marker);\n    }\n\n    return this;\n  }\n\n  toString() {\n    return this.options[0].value;\n  }\n\n  len() {\n    return this.options[0].len();\n  }\n\n  clone() {\n    let ret = new Choice();\n    this.options.forEach(ret.appendChild, ret);\n    return ret;\n  }\n\n}\nexport class Transform extends Marker {\n  constructor() {\n    super(...arguments);\n    this.regexp = new RegExp('');\n  }\n\n  resolve(value) {\n    const _this = this;\n\n    let didMatch = false;\n    let ret = value.replace(this.regexp, function () {\n      didMatch = true;\n      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));\n    }); // when the regex didn't match and when the transform has\n    // else branches, then run those\n\n    if (!didMatch && this._children.some(child => child instanceof FormatString && Boolean(child.elseValue))) {\n      ret = this._replace([]);\n    }\n\n    return ret;\n  }\n\n  _replace(groups) {\n    let ret = '';\n\n    for (const marker of this._children) {\n      if (marker instanceof FormatString) {\n        let value = groups[marker.index] || '';\n        value = marker.resolve(value);\n        ret += value;\n      } else {\n        ret += marker.toString();\n      }\n    }\n\n    return ret;\n  }\n\n  toString() {\n    return '';\n  }\n\n  clone() {\n    let ret = new Transform();\n    ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));\n    ret._children = this.children.map(child => child.clone());\n    return ret;\n  }\n\n}\nexport class FormatString extends Marker {\n  constructor(index, shorthandName, ifValue, elseValue) {\n    super();\n    this.index = index;\n    this.shorthandName = shorthandName;\n    this.ifValue = ifValue;\n    this.elseValue = elseValue;\n  }\n\n  resolve(value) {\n    if (this.shorthandName === 'upcase') {\n      return !value ? '' : value.toLocaleUpperCase();\n    } else if (this.shorthandName === 'downcase') {\n      return !value ? '' : value.toLocaleLowerCase();\n    } else if (this.shorthandName === 'capitalize') {\n      return !value ? '' : value[0].toLocaleUpperCase() + value.substr(1);\n    } else if (this.shorthandName === 'pascalcase') {\n      return !value ? '' : this._toPascalCase(value);\n    } else if (this.shorthandName === 'camelcase') {\n      return !value ? '' : this._toCamelCase(value);\n    } else if (Boolean(value) && typeof this.ifValue === 'string') {\n      return this.ifValue;\n    } else if (!Boolean(value) && typeof this.elseValue === 'string') {\n      return this.elseValue;\n    } else {\n      return value || '';\n    }\n  }\n\n  _toPascalCase(value) {\n    const match = value.match(/[a-z0-9]+/gi);\n\n    if (!match) {\n      return value;\n    }\n\n    return match.map(word => {\n      return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();\n    }).join('');\n  }\n\n  _toCamelCase(value) {\n    const match = value.match(/[a-z0-9]+/gi);\n\n    if (!match) {\n      return value;\n    }\n\n    return match.map((word, index) => {\n      if (index === 0) {\n        return word.toLowerCase();\n      } else {\n        return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();\n      }\n    }).join('');\n  }\n\n  clone() {\n    let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);\n    return ret;\n  }\n\n}\nexport class Variable extends TransformableMarker {\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n\n  resolve(resolver) {\n    let value = resolver.resolve(this);\n\n    if (this.transform) {\n      value = this.transform.resolve(value || '');\n    }\n\n    if (value !== undefined) {\n      this._children = [new Text(value)];\n      return true;\n    }\n\n    return false;\n  }\n\n  clone() {\n    const ret = new Variable(this.name);\n\n    if (this.transform) {\n      ret.transform = this.transform.clone();\n    }\n\n    ret._children = this.children.map(child => child.clone());\n    return ret;\n  }\n\n}\n\nfunction walk(marker, visitor) {\n  const stack = [...marker];\n\n  while (stack.length > 0) {\n    const marker = stack.shift();\n    const recurse = visitor(marker);\n\n    if (!recurse) {\n      break;\n    }\n\n    stack.unshift(...marker.children);\n  }\n}\n\nexport class TextmateSnippet extends Marker {\n  get placeholderInfo() {\n    if (!this._placeholders) {\n      // fill in placeholders\n      let all = [];\n      let last;\n      this.walk(function (candidate) {\n        if (candidate instanceof Placeholder) {\n          all.push(candidate);\n          last = !last || last.index < candidate.index ? candidate : last;\n        }\n\n        return true;\n      });\n      this._placeholders = {\n        all,\n        last\n      };\n    }\n\n    return this._placeholders;\n  }\n\n  get placeholders() {\n    const {\n      all\n    } = this.placeholderInfo;\n    return all;\n  }\n\n  offset(marker) {\n    let pos = 0;\n    let found = false;\n    this.walk(candidate => {\n      if (candidate === marker) {\n        found = true;\n        return false;\n      }\n\n      pos += candidate.len();\n      return true;\n    });\n\n    if (!found) {\n      return -1;\n    }\n\n    return pos;\n  }\n\n  fullLen(marker) {\n    let ret = 0;\n    walk([marker], marker => {\n      ret += marker.len();\n      return true;\n    });\n    return ret;\n  }\n\n  enclosingPlaceholders(placeholder) {\n    let ret = [];\n    let {\n      parent\n    } = placeholder;\n\n    while (parent) {\n      if (parent instanceof Placeholder) {\n        ret.push(parent);\n      }\n\n      parent = parent.parent;\n    }\n\n    return ret;\n  }\n\n  resolveVariables(resolver) {\n    this.walk(candidate => {\n      if (candidate instanceof Variable) {\n        if (candidate.resolve(resolver)) {\n          this._placeholders = undefined;\n        }\n      }\n\n      return true;\n    });\n    return this;\n  }\n\n  appendChild(child) {\n    this._placeholders = undefined;\n    return super.appendChild(child);\n  }\n\n  replace(child, others) {\n    this._placeholders = undefined;\n    return super.replace(child, others);\n  }\n\n  clone() {\n    let ret = new TextmateSnippet();\n    this._children = this.children.map(child => child.clone());\n    return ret;\n  }\n\n  walk(visitor) {\n    walk(this.children, visitor);\n  }\n\n}\nexport class SnippetParser {\n  constructor() {\n    this._scanner = new Scanner();\n    this._token = {\n      type: 14\n      /* EOF */\n      ,\n      pos: 0,\n      len: 0\n    };\n  }\n\n  static escape(value) {\n    return value.replace(/\\$|}|\\\\/g, '\\\\$&');\n  }\n\n  static guessNeedsClipboard(template) {\n    return /\\${?CLIPBOARD/.test(template);\n  }\n\n  parse(value, insertFinalTabstop, enforceFinalTabstop) {\n    this._scanner.text(value);\n\n    this._token = this._scanner.next();\n    const snippet = new TextmateSnippet();\n\n    while (this._parse(snippet)) {// nothing\n    } // fill in values for placeholders. the first placeholder of an index\n    // that has a value defines the value for all placeholders with that index\n\n\n    const placeholderDefaultValues = new Map();\n    const incompletePlaceholders = [];\n    let placeholderCount = 0;\n    snippet.walk(marker => {\n      if (marker instanceof Placeholder) {\n        placeholderCount += 1;\n\n        if (marker.isFinalTabstop) {\n          placeholderDefaultValues.set(0, undefined);\n        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {\n          placeholderDefaultValues.set(marker.index, marker.children);\n        } else {\n          incompletePlaceholders.push(marker);\n        }\n      }\n\n      return true;\n    });\n\n    for (const placeholder of incompletePlaceholders) {\n      const defaultValues = placeholderDefaultValues.get(placeholder.index);\n\n      if (defaultValues) {\n        const clone = new Placeholder(placeholder.index);\n        clone.transform = placeholder.transform;\n\n        for (const child of defaultValues) {\n          clone.appendChild(child.clone());\n        }\n\n        snippet.replace(placeholder, [clone]);\n      }\n    }\n\n    if (!enforceFinalTabstop) {\n      enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;\n    }\n\n    if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {\n      // the snippet uses placeholders but has no\n      // final tabstop defined -> insert at the end\n      snippet.appendChild(new Placeholder(0));\n    }\n\n    return snippet;\n  }\n\n  _accept(type, value) {\n    if (type === undefined || this._token.type === type) {\n      let ret = !value ? true : this._scanner.tokenText(this._token);\n      this._token = this._scanner.next();\n      return ret;\n    }\n\n    return false;\n  }\n\n  _backTo(token) {\n    this._scanner.pos = token.pos + token.len;\n    this._token = token;\n    return false;\n  }\n\n  _until(type) {\n    const start = this._token;\n\n    while (this._token.type !== type) {\n      if (this._token.type === 14\n      /* EOF */\n      ) {\n        return false;\n      } else if (this._token.type === 5\n      /* Backslash */\n      ) {\n        const nextToken = this._scanner.next();\n\n        if (nextToken.type !== 0\n        /* Dollar */\n        && nextToken.type !== 4\n        /* CurlyClose */\n        && nextToken.type !== 5\n        /* Backslash */\n        ) {\n          return false;\n        }\n      }\n\n      this._token = this._scanner.next();\n    }\n\n    const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\\\(\\$|}|\\\\)/g, '$1');\n\n    this._token = this._scanner.next();\n    return value;\n  }\n\n  _parse(marker) {\n    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);\n  } // \\$, \\\\, \\} -> just text\n\n\n  _parseEscaped(marker) {\n    let value;\n\n    if (value = this._accept(5\n    /* Backslash */\n    , true)) {\n      // saw a backslash, append escaped token or that backslash\n      value = this._accept(0\n      /* Dollar */\n      , true) || this._accept(4\n      /* CurlyClose */\n      , true) || this._accept(5\n      /* Backslash */\n      , true) || value;\n      marker.appendChild(new Text(value));\n      return true;\n    }\n\n    return false;\n  } // $foo -> variable, $1 -> tabstop\n\n\n  _parseTabstopOrVariableName(parent) {\n    let value;\n    const token = this._token;\n\n    const match = this._accept(0\n    /* Dollar */\n    ) && (value = this._accept(9\n    /* VariableName */\n    , true) || this._accept(8\n    /* Int */\n    , true));\n\n    if (!match) {\n      return this._backTo(token);\n    }\n\n    parent.appendChild(/^\\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));\n    return true;\n  } // ${1:<children>}, ${1} -> placeholder\n\n\n  _parseComplexPlaceholder(parent) {\n    let index;\n    const token = this._token;\n\n    const match = this._accept(0\n    /* Dollar */\n    ) && this._accept(3\n    /* CurlyOpen */\n    ) && (index = this._accept(8\n    /* Int */\n    , true));\n\n    if (!match) {\n      return this._backTo(token);\n    }\n\n    const placeholder = new Placeholder(Number(index));\n\n    if (this._accept(1\n    /* Colon */\n    )) {\n      // ${1:<children>}\n      while (true) {\n        // ...} -> done\n        if (this._accept(4\n        /* CurlyClose */\n        )) {\n          parent.appendChild(placeholder);\n          return true;\n        }\n\n        if (this._parse(placeholder)) {\n          continue;\n        } // fallback\n\n\n        parent.appendChild(new Text('${' + index + ':'));\n        placeholder.children.forEach(parent.appendChild, parent);\n        return true;\n      }\n    } else if (placeholder.index > 0 && this._accept(7\n    /* Pipe */\n    )) {\n      // ${1|one,two,three|}\n      const choice = new Choice();\n\n      while (true) {\n        if (this._parseChoiceElement(choice)) {\n          if (this._accept(2\n          /* Comma */\n          )) {\n            // opt, -> more\n            continue;\n          }\n\n          if (this._accept(7\n          /* Pipe */\n          )) {\n            placeholder.appendChild(choice);\n\n            if (this._accept(4\n            /* CurlyClose */\n            )) {\n              // ..|} -> done\n              parent.appendChild(placeholder);\n              return true;\n            }\n          }\n        }\n\n        this._backTo(token);\n\n        return false;\n      }\n    } else if (this._accept(6\n    /* Forwardslash */\n    )) {\n      // ${1/<regex>/<format>/<options>}\n      if (this._parseTransform(placeholder)) {\n        parent.appendChild(placeholder);\n        return true;\n      }\n\n      this._backTo(token);\n\n      return false;\n    } else if (this._accept(4\n    /* CurlyClose */\n    )) {\n      // ${1}\n      parent.appendChild(placeholder);\n      return true;\n    } else {\n      // ${1 <- missing curly or colon\n      return this._backTo(token);\n    }\n  }\n\n  _parseChoiceElement(parent) {\n    const token = this._token;\n    const values = [];\n\n    while (true) {\n      if (this._token.type === 2\n      /* Comma */\n      || this._token.type === 7\n      /* Pipe */\n      ) {\n        break;\n      }\n\n      let value;\n\n      if (value = this._accept(5\n      /* Backslash */\n      , true)) {\n        // \\, \\|, or \\\\\n        value = this._accept(2\n        /* Comma */\n        , true) || this._accept(7\n        /* Pipe */\n        , true) || this._accept(5\n        /* Backslash */\n        , true) || value;\n      } else {\n        value = this._accept(undefined, true);\n      }\n\n      if (!value) {\n        // EOF\n        this._backTo(token);\n\n        return false;\n      }\n\n      values.push(value);\n    }\n\n    if (values.length === 0) {\n      this._backTo(token);\n\n      return false;\n    }\n\n    parent.appendChild(new Text(values.join('')));\n    return true;\n  } // ${foo:<children>}, ${foo} -> variable\n\n\n  _parseComplexVariable(parent) {\n    let name;\n    const token = this._token;\n\n    const match = this._accept(0\n    /* Dollar */\n    ) && this._accept(3\n    /* CurlyOpen */\n    ) && (name = this._accept(9\n    /* VariableName */\n    , true));\n\n    if (!match) {\n      return this._backTo(token);\n    }\n\n    const variable = new Variable(name);\n\n    if (this._accept(1\n    /* Colon */\n    )) {\n      // ${foo:<children>}\n      while (true) {\n        // ...} -> done\n        if (this._accept(4\n        /* CurlyClose */\n        )) {\n          parent.appendChild(variable);\n          return true;\n        }\n\n        if (this._parse(variable)) {\n          continue;\n        } // fallback\n\n\n        parent.appendChild(new Text('${' + name + ':'));\n        variable.children.forEach(parent.appendChild, parent);\n        return true;\n      }\n    } else if (this._accept(6\n    /* Forwardslash */\n    )) {\n      // ${foo/<regex>/<format>/<options>}\n      if (this._parseTransform(variable)) {\n        parent.appendChild(variable);\n        return true;\n      }\n\n      this._backTo(token);\n\n      return false;\n    } else if (this._accept(4\n    /* CurlyClose */\n    )) {\n      // ${foo}\n      parent.appendChild(variable);\n      return true;\n    } else {\n      // ${foo <- missing curly or colon\n      return this._backTo(token);\n    }\n  }\n\n  _parseTransform(parent) {\n    // ...<regex>/<format>/<options>}\n    let transform = new Transform();\n    let regexValue = '';\n    let regexOptions = ''; // (1) /regex\n\n    while (true) {\n      if (this._accept(6\n      /* Forwardslash */\n      )) {\n        break;\n      }\n\n      let escaped;\n\n      if (escaped = this._accept(5\n      /* Backslash */\n      , true)) {\n        escaped = this._accept(6\n        /* Forwardslash */\n        , true) || escaped;\n        regexValue += escaped;\n        continue;\n      }\n\n      if (this._token.type !== 14\n      /* EOF */\n      ) {\n        regexValue += this._accept(undefined, true);\n        continue;\n      }\n\n      return false;\n    } // (2) /format\n\n\n    while (true) {\n      if (this._accept(6\n      /* Forwardslash */\n      )) {\n        break;\n      }\n\n      let escaped;\n\n      if (escaped = this._accept(5\n      /* Backslash */\n      , true)) {\n        escaped = this._accept(5\n        /* Backslash */\n        , true) || this._accept(6\n        /* Forwardslash */\n        , true) || escaped;\n        transform.appendChild(new Text(escaped));\n        continue;\n      }\n\n      if (this._parseFormatString(transform) || this._parseAnything(transform)) {\n        continue;\n      }\n\n      return false;\n    } // (3) /option\n\n\n    while (true) {\n      if (this._accept(4\n      /* CurlyClose */\n      )) {\n        break;\n      }\n\n      if (this._token.type !== 14\n      /* EOF */\n      ) {\n        regexOptions += this._accept(undefined, true);\n        continue;\n      }\n\n      return false;\n    }\n\n    try {\n      transform.regexp = new RegExp(regexValue, regexOptions);\n    } catch (e) {\n      // invalid regexp\n      return false;\n    }\n\n    parent.transform = transform;\n    return true;\n  }\n\n  _parseFormatString(parent) {\n    const token = this._token;\n\n    if (!this._accept(0\n    /* Dollar */\n    )) {\n      return false;\n    }\n\n    let complex = false;\n\n    if (this._accept(3\n    /* CurlyOpen */\n    )) {\n      complex = true;\n    }\n\n    let index = this._accept(8\n    /* Int */\n    , true);\n\n    if (!index) {\n      this._backTo(token);\n\n      return false;\n    } else if (!complex) {\n      // $1\n      parent.appendChild(new FormatString(Number(index)));\n      return true;\n    } else if (this._accept(4\n    /* CurlyClose */\n    )) {\n      // ${1}\n      parent.appendChild(new FormatString(Number(index)));\n      return true;\n    } else if (!this._accept(1\n    /* Colon */\n    )) {\n      this._backTo(token);\n\n      return false;\n    }\n\n    if (this._accept(6\n    /* Forwardslash */\n    )) {\n      // ${1:/upcase}\n      let shorthand = this._accept(9\n      /* VariableName */\n      , true);\n\n      if (!shorthand || !this._accept(4\n      /* CurlyClose */\n      )) {\n        this._backTo(token);\n\n        return false;\n      } else {\n        parent.appendChild(new FormatString(Number(index), shorthand));\n        return true;\n      }\n    } else if (this._accept(11\n    /* Plus */\n    )) {\n      // ${1:+<if>}\n      let ifValue = this._until(4\n      /* CurlyClose */\n      );\n\n      if (ifValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));\n        return true;\n      }\n    } else if (this._accept(12\n    /* Dash */\n    )) {\n      // ${2:-<else>}\n      let elseValue = this._until(4\n      /* CurlyClose */\n      );\n\n      if (elseValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n        return true;\n      }\n    } else if (this._accept(13\n    /* QuestionMark */\n    )) {\n      // ${2:?<if>:<else>}\n      let ifValue = this._until(1\n      /* Colon */\n      );\n\n      if (ifValue) {\n        let elseValue = this._until(4\n        /* CurlyClose */\n        );\n\n        if (elseValue) {\n          parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));\n          return true;\n        }\n      }\n    } else {\n      // ${1:<else>}\n      let elseValue = this._until(4\n      /* CurlyClose */\n      );\n\n      if (elseValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n        return true;\n      }\n    }\n\n    this._backTo(token);\n\n    return false;\n  }\n\n  _parseAnything(marker) {\n    if (this._token.type !== 14\n    /* EOF */\n    ) {\n      marker.appendChild(new Text(this._scanner.tokenText(this._token)));\n\n      this._accept(undefined);\n\n      return true;\n    }\n\n    return false;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetParser.js"],"names":["Scanner","constructor","value","pos","isDigitCharacter","ch","isVariableCharacter","text","tokenText","token","substr","len","next","length","type","charCodeAt","_table","isNaN","Marker","_children","appendChild","child","Text","parent","push","replace","others","idx","children","indexOf","newChildren","slice","splice","_fixParent","snippet","candidate","undefined","TextmateSnippet","toString","reduce","prev","cur","clone","TransformableMarker","Placeholder","index","compareByIndex","a","b","isFinalTabstop","choice","Choice","ret","transform","map","arguments","options","marker","forEach","Transform","regexp","RegExp","resolve","_this","didMatch","_replace","Array","prototype","call","some","FormatString","Boolean","elseValue","groups","source","ignoreCase","global","shorthandName","ifValue","toLocaleUpperCase","toLocaleLowerCase","_toPascalCase","_toCamelCase","match","word","charAt","toUpperCase","toLowerCase","join","Variable","name","resolver","walk","visitor","stack","shift","recurse","unshift","placeholderInfo","_placeholders","all","last","placeholders","offset","found","fullLen","enclosingPlaceholders","placeholder","resolveVariables","SnippetParser","_scanner","_token","escape","guessNeedsClipboard","template","test","parse","insertFinalTabstop","enforceFinalTabstop","_parse","placeholderDefaultValues","Map","incompletePlaceholders","placeholderCount","set","has","defaultValues","get","_accept","_backTo","_until","start","nextToken","substring","_parseEscaped","_parseTabstopOrVariableName","_parseComplexPlaceholder","_parseComplexVariable","_parseAnything","Number","_parseChoiceElement","_parseTransform","values","variable","regexValue","regexOptions","escaped","_parseFormatString","e","complex","shorthand"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Scanner {\n    constructor() {\n        this.value = '';\n        this.pos = 0;\n    }\n    static isDigitCharacter(ch) {\n        return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;\n    }\n    static isVariableCharacter(ch) {\n        return ch === 95 /* Underline */\n            || (ch >= 97 /* a */ && ch <= 122 /* z */)\n            || (ch >= 65 /* A */ && ch <= 90 /* Z */);\n    }\n    text(value) {\n        this.value = value;\n        this.pos = 0;\n    }\n    tokenText(token) {\n        return this.value.substr(token.pos, token.len);\n    }\n    next() {\n        if (this.pos >= this.value.length) {\n            return { type: 14 /* EOF */, pos: this.pos, len: 0 };\n        }\n        let pos = this.pos;\n        let len = 0;\n        let ch = this.value.charCodeAt(pos);\n        let type;\n        // static types\n        type = Scanner._table[ch];\n        if (typeof type === 'number') {\n            this.pos += 1;\n            return { type, pos, len: 1 };\n        }\n        // number\n        if (Scanner.isDigitCharacter(ch)) {\n            type = 8 /* Int */;\n            do {\n                len += 1;\n                ch = this.value.charCodeAt(pos + len);\n            } while (Scanner.isDigitCharacter(ch));\n            this.pos += len;\n            return { type, pos, len };\n        }\n        // variable name\n        if (Scanner.isVariableCharacter(ch)) {\n            type = 9 /* VariableName */;\n            do {\n                ch = this.value.charCodeAt(pos + (++len));\n            } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));\n            this.pos += len;\n            return { type, pos, len };\n        }\n        // format\n        type = 10 /* Format */;\n        do {\n            len += 1;\n            ch = this.value.charCodeAt(pos + len);\n        } while (!isNaN(ch)\n            && typeof Scanner._table[ch] === 'undefined' // not static token\n            && !Scanner.isDigitCharacter(ch) // not number\n            && !Scanner.isVariableCharacter(ch) // not variable\n        );\n        this.pos += len;\n        return { type, pos, len };\n    }\n}\nScanner._table = {\n    [36 /* DollarSign */]: 0 /* Dollar */,\n    [58 /* Colon */]: 1 /* Colon */,\n    [44 /* Comma */]: 2 /* Comma */,\n    [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,\n    [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,\n    [92 /* Backslash */]: 5 /* Backslash */,\n    [47 /* Slash */]: 6 /* Forwardslash */,\n    [124 /* Pipe */]: 7 /* Pipe */,\n    [43 /* Plus */]: 11 /* Plus */,\n    [45 /* Dash */]: 12 /* Dash */,\n    [63 /* QuestionMark */]: 13 /* QuestionMark */,\n};\nexport class Marker {\n    constructor() {\n        this._children = [];\n    }\n    appendChild(child) {\n        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {\n            // this and previous child are text -> merge them\n            this._children[this._children.length - 1].value += child.value;\n        }\n        else {\n            // normal adoption of child\n            child.parent = this;\n            this._children.push(child);\n        }\n        return this;\n    }\n    replace(child, others) {\n        const { parent } = child;\n        const idx = parent.children.indexOf(child);\n        const newChildren = parent.children.slice(0);\n        newChildren.splice(idx, 1, ...others);\n        parent._children = newChildren;\n        (function _fixParent(children, parent) {\n            for (const child of children) {\n                child.parent = parent;\n                _fixParent(child.children, child);\n            }\n        })(others, parent);\n    }\n    get children() {\n        return this._children;\n    }\n    get snippet() {\n        let candidate = this;\n        while (true) {\n            if (!candidate) {\n                return undefined;\n            }\n            if (candidate instanceof TextmateSnippet) {\n                return candidate;\n            }\n            candidate = candidate.parent;\n        }\n    }\n    toString() {\n        return this.children.reduce((prev, cur) => prev + cur.toString(), '');\n    }\n    len() {\n        return 0;\n    }\n}\nexport class Text extends Marker {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    toString() {\n        return this.value;\n    }\n    len() {\n        return this.value.length;\n    }\n    clone() {\n        return new Text(this.value);\n    }\n}\nexport class TransformableMarker extends Marker {\n}\nexport class Placeholder extends TransformableMarker {\n    constructor(index) {\n        super();\n        this.index = index;\n    }\n    static compareByIndex(a, b) {\n        if (a.index === b.index) {\n            return 0;\n        }\n        else if (a.isFinalTabstop) {\n            return 1;\n        }\n        else if (b.isFinalTabstop) {\n            return -1;\n        }\n        else if (a.index < b.index) {\n            return -1;\n        }\n        else if (a.index > b.index) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    get isFinalTabstop() {\n        return this.index === 0;\n    }\n    get choice() {\n        return this._children.length === 1 && this._children[0] instanceof Choice\n            ? this._children[0]\n            : undefined;\n    }\n    clone() {\n        let ret = new Placeholder(this.index);\n        if (this.transform) {\n            ret.transform = this.transform.clone();\n        }\n        ret._children = this.children.map(child => child.clone());\n        return ret;\n    }\n}\nexport class Choice extends Marker {\n    constructor() {\n        super(...arguments);\n        this.options = [];\n    }\n    appendChild(marker) {\n        if (marker instanceof Text) {\n            marker.parent = this;\n            this.options.push(marker);\n        }\n        return this;\n    }\n    toString() {\n        return this.options[0].value;\n    }\n    len() {\n        return this.options[0].len();\n    }\n    clone() {\n        let ret = new Choice();\n        this.options.forEach(ret.appendChild, ret);\n        return ret;\n    }\n}\nexport class Transform extends Marker {\n    constructor() {\n        super(...arguments);\n        this.regexp = new RegExp('');\n    }\n    resolve(value) {\n        const _this = this;\n        let didMatch = false;\n        let ret = value.replace(this.regexp, function () {\n            didMatch = true;\n            return _this._replace(Array.prototype.slice.call(arguments, 0, -2));\n        });\n        // when the regex didn't match and when the transform has\n        // else branches, then run those\n        if (!didMatch && this._children.some(child => child instanceof FormatString && Boolean(child.elseValue))) {\n            ret = this._replace([]);\n        }\n        return ret;\n    }\n    _replace(groups) {\n        let ret = '';\n        for (const marker of this._children) {\n            if (marker instanceof FormatString) {\n                let value = groups[marker.index] || '';\n                value = marker.resolve(value);\n                ret += value;\n            }\n            else {\n                ret += marker.toString();\n            }\n        }\n        return ret;\n    }\n    toString() {\n        return '';\n    }\n    clone() {\n        let ret = new Transform();\n        ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));\n        ret._children = this.children.map(child => child.clone());\n        return ret;\n    }\n}\nexport class FormatString extends Marker {\n    constructor(index, shorthandName, ifValue, elseValue) {\n        super();\n        this.index = index;\n        this.shorthandName = shorthandName;\n        this.ifValue = ifValue;\n        this.elseValue = elseValue;\n    }\n    resolve(value) {\n        if (this.shorthandName === 'upcase') {\n            return !value ? '' : value.toLocaleUpperCase();\n        }\n        else if (this.shorthandName === 'downcase') {\n            return !value ? '' : value.toLocaleLowerCase();\n        }\n        else if (this.shorthandName === 'capitalize') {\n            return !value ? '' : (value[0].toLocaleUpperCase() + value.substr(1));\n        }\n        else if (this.shorthandName === 'pascalcase') {\n            return !value ? '' : this._toPascalCase(value);\n        }\n        else if (this.shorthandName === 'camelcase') {\n            return !value ? '' : this._toCamelCase(value);\n        }\n        else if (Boolean(value) && typeof this.ifValue === 'string') {\n            return this.ifValue;\n        }\n        else if (!Boolean(value) && typeof this.elseValue === 'string') {\n            return this.elseValue;\n        }\n        else {\n            return value || '';\n        }\n    }\n    _toPascalCase(value) {\n        const match = value.match(/[a-z0-9]+/gi);\n        if (!match) {\n            return value;\n        }\n        return match.map(word => {\n            return word.charAt(0).toUpperCase()\n                + word.substr(1).toLowerCase();\n        })\n            .join('');\n    }\n    _toCamelCase(value) {\n        const match = value.match(/[a-z0-9]+/gi);\n        if (!match) {\n            return value;\n        }\n        return match.map((word, index) => {\n            if (index === 0) {\n                return word.toLowerCase();\n            }\n            else {\n                return word.charAt(0).toUpperCase()\n                    + word.substr(1).toLowerCase();\n            }\n        })\n            .join('');\n    }\n    clone() {\n        let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);\n        return ret;\n    }\n}\nexport class Variable extends TransformableMarker {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    resolve(resolver) {\n        let value = resolver.resolve(this);\n        if (this.transform) {\n            value = this.transform.resolve(value || '');\n        }\n        if (value !== undefined) {\n            this._children = [new Text(value)];\n            return true;\n        }\n        return false;\n    }\n    clone() {\n        const ret = new Variable(this.name);\n        if (this.transform) {\n            ret.transform = this.transform.clone();\n        }\n        ret._children = this.children.map(child => child.clone());\n        return ret;\n    }\n}\nfunction walk(marker, visitor) {\n    const stack = [...marker];\n    while (stack.length > 0) {\n        const marker = stack.shift();\n        const recurse = visitor(marker);\n        if (!recurse) {\n            break;\n        }\n        stack.unshift(...marker.children);\n    }\n}\nexport class TextmateSnippet extends Marker {\n    get placeholderInfo() {\n        if (!this._placeholders) {\n            // fill in placeholders\n            let all = [];\n            let last;\n            this.walk(function (candidate) {\n                if (candidate instanceof Placeholder) {\n                    all.push(candidate);\n                    last = !last || last.index < candidate.index ? candidate : last;\n                }\n                return true;\n            });\n            this._placeholders = { all, last };\n        }\n        return this._placeholders;\n    }\n    get placeholders() {\n        const { all } = this.placeholderInfo;\n        return all;\n    }\n    offset(marker) {\n        let pos = 0;\n        let found = false;\n        this.walk(candidate => {\n            if (candidate === marker) {\n                found = true;\n                return false;\n            }\n            pos += candidate.len();\n            return true;\n        });\n        if (!found) {\n            return -1;\n        }\n        return pos;\n    }\n    fullLen(marker) {\n        let ret = 0;\n        walk([marker], marker => {\n            ret += marker.len();\n            return true;\n        });\n        return ret;\n    }\n    enclosingPlaceholders(placeholder) {\n        let ret = [];\n        let { parent } = placeholder;\n        while (parent) {\n            if (parent instanceof Placeholder) {\n                ret.push(parent);\n            }\n            parent = parent.parent;\n        }\n        return ret;\n    }\n    resolveVariables(resolver) {\n        this.walk(candidate => {\n            if (candidate instanceof Variable) {\n                if (candidate.resolve(resolver)) {\n                    this._placeholders = undefined;\n                }\n            }\n            return true;\n        });\n        return this;\n    }\n    appendChild(child) {\n        this._placeholders = undefined;\n        return super.appendChild(child);\n    }\n    replace(child, others) {\n        this._placeholders = undefined;\n        return super.replace(child, others);\n    }\n    clone() {\n        let ret = new TextmateSnippet();\n        this._children = this.children.map(child => child.clone());\n        return ret;\n    }\n    walk(visitor) {\n        walk(this.children, visitor);\n    }\n}\nexport class SnippetParser {\n    constructor() {\n        this._scanner = new Scanner();\n        this._token = { type: 14 /* EOF */, pos: 0, len: 0 };\n    }\n    static escape(value) {\n        return value.replace(/\\$|}|\\\\/g, '\\\\$&');\n    }\n    static guessNeedsClipboard(template) {\n        return /\\${?CLIPBOARD/.test(template);\n    }\n    parse(value, insertFinalTabstop, enforceFinalTabstop) {\n        this._scanner.text(value);\n        this._token = this._scanner.next();\n        const snippet = new TextmateSnippet();\n        while (this._parse(snippet)) {\n            // nothing\n        }\n        // fill in values for placeholders. the first placeholder of an index\n        // that has a value defines the value for all placeholders with that index\n        const placeholderDefaultValues = new Map();\n        const incompletePlaceholders = [];\n        let placeholderCount = 0;\n        snippet.walk(marker => {\n            if (marker instanceof Placeholder) {\n                placeholderCount += 1;\n                if (marker.isFinalTabstop) {\n                    placeholderDefaultValues.set(0, undefined);\n                }\n                else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {\n                    placeholderDefaultValues.set(marker.index, marker.children);\n                }\n                else {\n                    incompletePlaceholders.push(marker);\n                }\n            }\n            return true;\n        });\n        for (const placeholder of incompletePlaceholders) {\n            const defaultValues = placeholderDefaultValues.get(placeholder.index);\n            if (defaultValues) {\n                const clone = new Placeholder(placeholder.index);\n                clone.transform = placeholder.transform;\n                for (const child of defaultValues) {\n                    clone.appendChild(child.clone());\n                }\n                snippet.replace(placeholder, [clone]);\n            }\n        }\n        if (!enforceFinalTabstop) {\n            enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;\n        }\n        if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {\n            // the snippet uses placeholders but has no\n            // final tabstop defined -> insert at the end\n            snippet.appendChild(new Placeholder(0));\n        }\n        return snippet;\n    }\n    _accept(type, value) {\n        if (type === undefined || this._token.type === type) {\n            let ret = !value ? true : this._scanner.tokenText(this._token);\n            this._token = this._scanner.next();\n            return ret;\n        }\n        return false;\n    }\n    _backTo(token) {\n        this._scanner.pos = token.pos + token.len;\n        this._token = token;\n        return false;\n    }\n    _until(type) {\n        const start = this._token;\n        while (this._token.type !== type) {\n            if (this._token.type === 14 /* EOF */) {\n                return false;\n            }\n            else if (this._token.type === 5 /* Backslash */) {\n                const nextToken = this._scanner.next();\n                if (nextToken.type !== 0 /* Dollar */\n                    && nextToken.type !== 4 /* CurlyClose */\n                    && nextToken.type !== 5 /* Backslash */) {\n                    return false;\n                }\n            }\n            this._token = this._scanner.next();\n        }\n        const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\\\(\\$|}|\\\\)/g, '$1');\n        this._token = this._scanner.next();\n        return value;\n    }\n    _parse(marker) {\n        return this._parseEscaped(marker)\n            || this._parseTabstopOrVariableName(marker)\n            || this._parseComplexPlaceholder(marker)\n            || this._parseComplexVariable(marker)\n            || this._parseAnything(marker);\n    }\n    // \\$, \\\\, \\} -> just text\n    _parseEscaped(marker) {\n        let value;\n        if (value = this._accept(5 /* Backslash */, true)) {\n            // saw a backslash, append escaped token or that backslash\n            value = this._accept(0 /* Dollar */, true)\n                || this._accept(4 /* CurlyClose */, true)\n                || this._accept(5 /* Backslash */, true)\n                || value;\n            marker.appendChild(new Text(value));\n            return true;\n        }\n        return false;\n    }\n    // $foo -> variable, $1 -> tabstop\n    _parseTabstopOrVariableName(parent) {\n        let value;\n        const token = this._token;\n        const match = this._accept(0 /* Dollar */)\n            && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));\n        if (!match) {\n            return this._backTo(token);\n        }\n        parent.appendChild(/^\\d+$/.test(value)\n            ? new Placeholder(Number(value))\n            : new Variable(value));\n        return true;\n    }\n    // ${1:<children>}, ${1} -> placeholder\n    _parseComplexPlaceholder(parent) {\n        let index;\n        const token = this._token;\n        const match = this._accept(0 /* Dollar */)\n            && this._accept(3 /* CurlyOpen */)\n            && (index = this._accept(8 /* Int */, true));\n        if (!match) {\n            return this._backTo(token);\n        }\n        const placeholder = new Placeholder(Number(index));\n        if (this._accept(1 /* Colon */)) {\n            // ${1:<children>}\n            while (true) {\n                // ...} -> done\n                if (this._accept(4 /* CurlyClose */)) {\n                    parent.appendChild(placeholder);\n                    return true;\n                }\n                if (this._parse(placeholder)) {\n                    continue;\n                }\n                // fallback\n                parent.appendChild(new Text('${' + index + ':'));\n                placeholder.children.forEach(parent.appendChild, parent);\n                return true;\n            }\n        }\n        else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {\n            // ${1|one,two,three|}\n            const choice = new Choice();\n            while (true) {\n                if (this._parseChoiceElement(choice)) {\n                    if (this._accept(2 /* Comma */)) {\n                        // opt, -> more\n                        continue;\n                    }\n                    if (this._accept(7 /* Pipe */)) {\n                        placeholder.appendChild(choice);\n                        if (this._accept(4 /* CurlyClose */)) {\n                            // ..|} -> done\n                            parent.appendChild(placeholder);\n                            return true;\n                        }\n                    }\n                }\n                this._backTo(token);\n                return false;\n            }\n        }\n        else if (this._accept(6 /* Forwardslash */)) {\n            // ${1/<regex>/<format>/<options>}\n            if (this._parseTransform(placeholder)) {\n                parent.appendChild(placeholder);\n                return true;\n            }\n            this._backTo(token);\n            return false;\n        }\n        else if (this._accept(4 /* CurlyClose */)) {\n            // ${1}\n            parent.appendChild(placeholder);\n            return true;\n        }\n        else {\n            // ${1 <- missing curly or colon\n            return this._backTo(token);\n        }\n    }\n    _parseChoiceElement(parent) {\n        const token = this._token;\n        const values = [];\n        while (true) {\n            if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {\n                break;\n            }\n            let value;\n            if (value = this._accept(5 /* Backslash */, true)) {\n                // \\, \\|, or \\\\\n                value = this._accept(2 /* Comma */, true)\n                    || this._accept(7 /* Pipe */, true)\n                    || this._accept(5 /* Backslash */, true)\n                    || value;\n            }\n            else {\n                value = this._accept(undefined, true);\n            }\n            if (!value) {\n                // EOF\n                this._backTo(token);\n                return false;\n            }\n            values.push(value);\n        }\n        if (values.length === 0) {\n            this._backTo(token);\n            return false;\n        }\n        parent.appendChild(new Text(values.join('')));\n        return true;\n    }\n    // ${foo:<children>}, ${foo} -> variable\n    _parseComplexVariable(parent) {\n        let name;\n        const token = this._token;\n        const match = this._accept(0 /* Dollar */)\n            && this._accept(3 /* CurlyOpen */)\n            && (name = this._accept(9 /* VariableName */, true));\n        if (!match) {\n            return this._backTo(token);\n        }\n        const variable = new Variable(name);\n        if (this._accept(1 /* Colon */)) {\n            // ${foo:<children>}\n            while (true) {\n                // ...} -> done\n                if (this._accept(4 /* CurlyClose */)) {\n                    parent.appendChild(variable);\n                    return true;\n                }\n                if (this._parse(variable)) {\n                    continue;\n                }\n                // fallback\n                parent.appendChild(new Text('${' + name + ':'));\n                variable.children.forEach(parent.appendChild, parent);\n                return true;\n            }\n        }\n        else if (this._accept(6 /* Forwardslash */)) {\n            // ${foo/<regex>/<format>/<options>}\n            if (this._parseTransform(variable)) {\n                parent.appendChild(variable);\n                return true;\n            }\n            this._backTo(token);\n            return false;\n        }\n        else if (this._accept(4 /* CurlyClose */)) {\n            // ${foo}\n            parent.appendChild(variable);\n            return true;\n        }\n        else {\n            // ${foo <- missing curly or colon\n            return this._backTo(token);\n        }\n    }\n    _parseTransform(parent) {\n        // ...<regex>/<format>/<options>}\n        let transform = new Transform();\n        let regexValue = '';\n        let regexOptions = '';\n        // (1) /regex\n        while (true) {\n            if (this._accept(6 /* Forwardslash */)) {\n                break;\n            }\n            let escaped;\n            if (escaped = this._accept(5 /* Backslash */, true)) {\n                escaped = this._accept(6 /* Forwardslash */, true) || escaped;\n                regexValue += escaped;\n                continue;\n            }\n            if (this._token.type !== 14 /* EOF */) {\n                regexValue += this._accept(undefined, true);\n                continue;\n            }\n            return false;\n        }\n        // (2) /format\n        while (true) {\n            if (this._accept(6 /* Forwardslash */)) {\n                break;\n            }\n            let escaped;\n            if (escaped = this._accept(5 /* Backslash */, true)) {\n                escaped = this._accept(5 /* Backslash */, true) || this._accept(6 /* Forwardslash */, true) || escaped;\n                transform.appendChild(new Text(escaped));\n                continue;\n            }\n            if (this._parseFormatString(transform) || this._parseAnything(transform)) {\n                continue;\n            }\n            return false;\n        }\n        // (3) /option\n        while (true) {\n            if (this._accept(4 /* CurlyClose */)) {\n                break;\n            }\n            if (this._token.type !== 14 /* EOF */) {\n                regexOptions += this._accept(undefined, true);\n                continue;\n            }\n            return false;\n        }\n        try {\n            transform.regexp = new RegExp(regexValue, regexOptions);\n        }\n        catch (e) {\n            // invalid regexp\n            return false;\n        }\n        parent.transform = transform;\n        return true;\n    }\n    _parseFormatString(parent) {\n        const token = this._token;\n        if (!this._accept(0 /* Dollar */)) {\n            return false;\n        }\n        let complex = false;\n        if (this._accept(3 /* CurlyOpen */)) {\n            complex = true;\n        }\n        let index = this._accept(8 /* Int */, true);\n        if (!index) {\n            this._backTo(token);\n            return false;\n        }\n        else if (!complex) {\n            // $1\n            parent.appendChild(new FormatString(Number(index)));\n            return true;\n        }\n        else if (this._accept(4 /* CurlyClose */)) {\n            // ${1}\n            parent.appendChild(new FormatString(Number(index)));\n            return true;\n        }\n        else if (!this._accept(1 /* Colon */)) {\n            this._backTo(token);\n            return false;\n        }\n        if (this._accept(6 /* Forwardslash */)) {\n            // ${1:/upcase}\n            let shorthand = this._accept(9 /* VariableName */, true);\n            if (!shorthand || !this._accept(4 /* CurlyClose */)) {\n                this._backTo(token);\n                return false;\n            }\n            else {\n                parent.appendChild(new FormatString(Number(index), shorthand));\n                return true;\n            }\n        }\n        else if (this._accept(11 /* Plus */)) {\n            // ${1:+<if>}\n            let ifValue = this._until(4 /* CurlyClose */);\n            if (ifValue) {\n                parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));\n                return true;\n            }\n        }\n        else if (this._accept(12 /* Dash */)) {\n            // ${2:-<else>}\n            let elseValue = this._until(4 /* CurlyClose */);\n            if (elseValue) {\n                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n                return true;\n            }\n        }\n        else if (this._accept(13 /* QuestionMark */)) {\n            // ${2:?<if>:<else>}\n            let ifValue = this._until(1 /* Colon */);\n            if (ifValue) {\n                let elseValue = this._until(4 /* CurlyClose */);\n                if (elseValue) {\n                    parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));\n                    return true;\n                }\n            }\n        }\n        else {\n            // ${1:<else>}\n            let elseValue = this._until(4 /* CurlyClose */);\n            if (elseValue) {\n                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n                return true;\n            }\n        }\n        this._backTo(token);\n        return false;\n    }\n    _parseAnything(marker) {\n        if (this._token.type !== 14 /* EOF */) {\n            marker.appendChild(new Text(this._scanner.tokenText(this._token)));\n            this._accept(undefined);\n            return true;\n        }\n        return false;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}