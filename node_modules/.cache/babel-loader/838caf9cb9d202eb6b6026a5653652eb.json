{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursor/cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from './viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from './viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from './viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n  constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService) {\n    super();\n    this.languageConfigurationService = languageConfigurationService;\n    this._editorId = editorId;\n    this._configuration = configuration;\n    this.model = model;\n    this._eventDispatcher = new ViewModelEventDispatcher();\n    this.onEvent = this._eventDispatcher.onEvent;\n    this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n    this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n    this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n    this._hasFocus = false;\n    this._viewportStartLine = -1;\n    this._viewportStartLineTrackedRange = null;\n    this._viewportStartLineDelta = 0;\n\n    if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n      this._lines = new ViewModelLinesFromModelAsIs(this.model);\n    } else {\n      const options = this._configuration.options;\n      const fontInfo = options.get(44\n      /* fontInfo */\n      );\n      const wrappingStrategy = options.get(125\n      /* wrappingStrategy */\n      );\n      const wrappingInfo = options.get(132\n      /* wrappingInfo */\n      );\n      const wrappingIndent = options.get(124\n      /* wrappingIndent */\n      );\n      this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n    }\n\n    this.coordinatesConverter = this._lines.createCoordinatesConverter();\n    this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n    this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n\n    this._register(this.viewLayout.onDidScroll(e => {\n      if (e.scrollTopChanged) {\n        this._tokenizeViewportSoon.schedule();\n      }\n\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n\n      this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n    }));\n\n    this._register(this.viewLayout.onDidContentSizeChange(e => {\n      this._eventDispatcher.emitOutgoingEvent(e);\n    }));\n\n    this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n\n    this._registerModelEvents();\n\n    this._register(this._configuration.onDidChangeFast(e => {\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n        this._onConfigurationChanged(eventsCollector, e);\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n    }));\n\n    this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n    }));\n\n    this._updateConfigurationViewLineCountNow();\n  }\n\n  dispose() {\n    // First remove listeners, as disposing the lines might end up sending\n    // model decoration changed events ... and we no longer care about them ...\n    super.dispose();\n\n    this._decorations.dispose();\n\n    this._lines.dispose();\n\n    this.invalidateMinimapColorCache();\n    this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1\n    /* NeverGrowsWhenTypingAtEdges */\n    );\n\n    this._eventDispatcher.dispose();\n  }\n\n  createLineBreaksComputer() {\n    return this._lines.createLineBreaksComputer();\n  }\n\n  addViewEventHandler(eventHandler) {\n    this._eventDispatcher.addViewEventHandler(eventHandler);\n  }\n\n  removeViewEventHandler(eventHandler) {\n    this._eventDispatcher.removeViewEventHandler(eventHandler);\n  }\n\n  _updateConfigurationViewLineCountNow() {\n    this._configuration.setViewLineCount(this._lines.getViewLineCount());\n  }\n\n  tokenizeViewport() {\n    const linesViewportData = this.viewLayout.getLinesViewportData();\n    const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n\n    const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n\n    for (const modelVisibleRange of modelVisibleRanges) {\n      this.model.tokenizeViewport(modelVisibleRange.startLineNumber, modelVisibleRange.endLineNumber);\n    }\n  }\n\n  setHasFocus(hasFocus) {\n    this._hasFocus = hasFocus;\n\n    this._cursor.setHasFocus(hasFocus);\n\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n\n    this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n  }\n\n  onCompositionStart() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n  }\n\n  onCompositionEnd() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n  }\n\n  onDidColorThemeChange() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent());\n  }\n\n  _onConfigurationChanged(eventsCollector, e) {\n    // We might need to restore the current centered view range, so save it (if available)\n    let previousViewportStartModelPosition = null;\n\n    if (this._viewportStartLine !== -1) {\n      const previousViewportStartViewPosition = new Position(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));\n      previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n    }\n\n    let restorePreviousViewportStart = false;\n    const options = this._configuration.options;\n    const fontInfo = options.get(44\n    /* fontInfo */\n    );\n    const wrappingStrategy = options.get(125\n    /* wrappingStrategy */\n    );\n    const wrappingInfo = options.get(132\n    /* wrappingInfo */\n    );\n    const wrappingIndent = options.get(124\n    /* wrappingIndent */\n    );\n\n    if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n      eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n      eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n      eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n\n      this._cursor.onLineMappingChanged(eventsCollector);\n\n      this._decorations.onLineMappingChanged();\n\n      this.viewLayout.onFlushed(this.getLineCount());\n\n      if (this.viewLayout.getCurrentScrollTop() !== 0) {\n        // Never change the scroll position from 0 to something else...\n        restorePreviousViewportStart = true;\n      }\n\n      this._updateConfigurationViewLineCount.schedule();\n    }\n\n    if (e.hasChanged(81\n    /* readOnly */\n    )) {\n      // Must read again all decorations due to readOnly filtering\n      this._decorations.reset();\n\n      eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n    }\n\n    eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n    this.viewLayout.onConfigurationChanged(e);\n\n    if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n      const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n      const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n      this.viewLayout.setScrollPosition({\n        scrollTop: viewPositionTop + this._viewportStartLineDelta\n      }, 1\n      /* Immediate */\n      );\n    }\n\n    if (CursorConfiguration.shouldRecreate(e)) {\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }\n  }\n\n  _registerModelEvents() {\n    this._register(this.model.onDidChangeContentOrInjectedText(e => {\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n        let hadOtherModelChange = false;\n        let hadModelLineChangeThatChangedLineMapping = false;\n        const changes = e.changes;\n        const versionId = e instanceof textModelEvents.ModelRawContentChangedEvent ? e.versionId : null; // Do a first pass to compute line mappings, and a second pass to actually interpret them\n\n        const lineBreaksComputer = this._lines.createLineBreaksComputer();\n\n        for (const change of changes) {\n          switch (change.changeType) {\n            case 4\n            /* LinesInserted */\n            :\n              {\n                for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                  const line = change.detail[lineIdx];\n                  let injectedText = change.injectedTexts[lineIdx];\n\n                  if (injectedText) {\n                    injectedText = injectedText.filter(element => !element.ownerId || element.ownerId === this._editorId);\n                  }\n\n                  lineBreaksComputer.addRequest(line, injectedText, null);\n                }\n\n                break;\n              }\n\n            case 2\n            /* LineChanged */\n            :\n              {\n                let injectedText = null;\n\n                if (change.injectedText) {\n                  injectedText = change.injectedText.filter(element => !element.ownerId || element.ownerId === this._editorId);\n                }\n\n                lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                break;\n              }\n          }\n        }\n\n        const lineBreaks = lineBreaksComputer.finalize();\n        const lineBreakQueue = new ArrayQueue(lineBreaks);\n\n        for (const change of changes) {\n          switch (change.changeType) {\n            case 1\n            /* Flush */\n            :\n              {\n                this._lines.onModelFlushed();\n\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n\n                this._decorations.reset();\n\n                this.viewLayout.onFlushed(this.getLineCount());\n                hadOtherModelChange = true;\n                break;\n              }\n\n            case 3\n            /* LinesDeleted */\n            :\n              {\n                const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n\n                if (linesDeletedEvent !== null) {\n                  eventsCollector.emitViewEvent(linesDeletedEvent);\n                  this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n\n                hadOtherModelChange = true;\n                break;\n              }\n\n            case 4\n            /* LinesInserted */\n            :\n              {\n                const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n\n                const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n\n                if (linesInsertedEvent !== null) {\n                  eventsCollector.emitViewEvent(linesInsertedEvent);\n                  this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n\n                hadOtherModelChange = true;\n                break;\n              }\n\n            case 2\n            /* LineChanged */\n            :\n              {\n                const changedLineBreakData = lineBreakQueue.dequeue();\n\n                const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n\n                hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n\n                if (linesChangedEvent) {\n                  eventsCollector.emitViewEvent(linesChangedEvent);\n                }\n\n                if (linesInsertedEvent) {\n                  eventsCollector.emitViewEvent(linesInsertedEvent);\n                  this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n\n                if (linesDeletedEvent) {\n                  eventsCollector.emitViewEvent(linesDeletedEvent);\n                  this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n\n                break;\n              }\n\n            case 5\n            /* EOLChanged */\n            :\n              {\n                // Nothing to do. The new version will be accepted below\n                break;\n              }\n          }\n        }\n\n        if (versionId !== null) {\n          this._lines.acceptVersionId(versionId);\n        }\n\n        this.viewLayout.onHeightMaybeChanged();\n\n        if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n          eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n\n          this._cursor.onLineMappingChanged(eventsCollector);\n\n          this._decorations.onLineMappingChanged();\n        }\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      } // Update the configuration and reset the centered view line\n\n\n      this._viewportStartLine = -1;\n\n      this._configuration.setModelLineCount(this.model.getLineCount());\n\n      this._updateConfigurationViewLineCountNow(); // Recover viewport\n\n\n      if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {\n        const modelRange = this.model._getTrackedRange(this._viewportStartLineTrackedRange);\n\n        if (modelRange) {\n          const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n          const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n          this.viewLayout.setScrollPosition({\n            scrollTop: viewPositionTop + this._viewportStartLineDelta\n          }, 1\n          /* Immediate */\n          );\n        }\n      }\n\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n        this._cursor.onModelContentChanged(eventsCollector, e);\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n\n      this._tokenizeViewportSoon.schedule();\n    }));\n\n    this._register(this.model.onDidChangeTokens(e => {\n      const viewRanges = [];\n\n      for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n        const modelRange = e.ranges[j];\n        const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n        const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n        viewRanges[j] = {\n          fromLineNumber: viewStartLineNumber,\n          toLineNumber: viewEndLineNumber\n        };\n      }\n\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n\n      if (e.tokenizationSupportChanged) {\n        this._tokenizeViewportSoon.schedule();\n      }\n    }));\n\n    this._register(this.model.onDidChangeLanguageConfiguration(e => {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }));\n\n    this._register(this.model.onDidChangeLanguage(e => {\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }));\n\n    this._register(this.model.onDidChangeOptions(e => {\n      // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n        try {\n          const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n          eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n\n          this._cursor.onLineMappingChanged(eventsCollector);\n\n          this._decorations.onLineMappingChanged();\n\n          this.viewLayout.onFlushed(this.getLineCount());\n        } finally {\n          this._eventDispatcher.endEmitViewEvents();\n        }\n\n        this._updateConfigurationViewLineCount.schedule();\n      }\n\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }));\n\n    this._register(this.model.onDidChangeDecorations(e => {\n      this._decorations.onModelDecorationsChanged();\n\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n    }));\n  }\n\n  setHiddenAreas(ranges) {\n    let lineMappingChanged = false;\n\n    try {\n      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n      lineMappingChanged = this._lines.setHiddenAreas(ranges);\n\n      if (lineMappingChanged) {\n        eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n        eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n        eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n\n        this._cursor.onLineMappingChanged(eventsCollector);\n\n        this._decorations.onLineMappingChanged();\n\n        this.viewLayout.onFlushed(this.getLineCount());\n        this.viewLayout.onHeightMaybeChanged();\n      }\n    } finally {\n      this._eventDispatcher.endEmitViewEvents();\n    }\n\n    this._updateConfigurationViewLineCount.schedule();\n\n    if (lineMappingChanged) {\n      this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n    }\n  }\n\n  getVisibleRangesPlusViewportAboveBelow() {\n    const layoutInfo = this._configuration.options.get(131\n    /* layoutInfo */\n    );\n\n    const lineHeight = this._configuration.options.get(59\n    /* lineHeight */\n    );\n\n    const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n    const partialData = this.viewLayout.getLinesViewportData();\n    const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n    const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n    return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n  }\n\n  getVisibleRanges() {\n    const visibleViewRange = this.getCompletelyVisibleViewRange();\n    return this._toModelVisibleRanges(visibleViewRange);\n  }\n\n  _toModelVisibleRanges(visibleViewRange) {\n    const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n\n    const hiddenAreas = this._lines.getHiddenAreas();\n\n    if (hiddenAreas.length === 0) {\n      return [visibleRange];\n    }\n\n    const result = [];\n    let resultLen = 0;\n    let startLineNumber = visibleRange.startLineNumber;\n    let startColumn = visibleRange.startColumn;\n    const endLineNumber = visibleRange.endLineNumber;\n    const endColumn = visibleRange.endColumn;\n\n    for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n      const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n      const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n\n      if (hiddenEndLineNumber < startLineNumber) {\n        continue;\n      }\n\n      if (hiddenStartLineNumber > endLineNumber) {\n        continue;\n      }\n\n      if (startLineNumber < hiddenStartLineNumber) {\n        result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n      }\n\n      startLineNumber = hiddenEndLineNumber + 1;\n      startColumn = 1;\n    }\n\n    if (startLineNumber < endLineNumber || startLineNumber === endLineNumber && startColumn < endColumn) {\n      result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n\n    return result;\n  }\n\n  getCompletelyVisibleViewRange() {\n    const partialData = this.viewLayout.getLinesViewportData();\n    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  }\n\n  getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n    const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  }\n\n  saveState() {\n    const compatViewState = this.viewLayout.saveState();\n    const scrollTop = compatViewState.scrollTop;\n    const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n    const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n    const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n    return {\n      scrollLeft: compatViewState.scrollLeft,\n      firstPosition: firstPosition,\n      firstPositionDeltaTop: firstPositionDeltaTop\n    };\n  }\n\n  reduceRestoreState(state) {\n    if (typeof state.firstPosition === 'undefined') {\n      // This is a view state serialized by an older version\n      return this._reduceRestoreStateCompatibility(state);\n    }\n\n    const modelPosition = this.model.validatePosition(state.firstPosition);\n    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n    const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n\n  _reduceRestoreStateCompatibility(state) {\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: state.scrollTopWithoutViewZones\n    };\n  }\n\n  getTabSize() {\n    return this.model.getOptions().tabSize;\n  }\n\n  getTextModelOptions() {\n    return this.model.getOptions();\n  }\n\n  getLineCount() {\n    return this._lines.getViewLineCount();\n  }\n  /**\n   * Gives a hint that a lot of requests are about to come in for these line numbers.\n   */\n\n\n  setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n    this._viewportStartLine = startLineNumber;\n    const position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\n    this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1\n    /* NeverGrowsWhenTypingAtEdges */\n    );\n    const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n    const scrollTop = this.viewLayout.getCurrentScrollTop();\n    this._viewportStartLineDelta = scrollTop - viewportStartLineTop;\n  }\n\n  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n    return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n  }\n\n  getLinesIndentGuides(startLineNumber, endLineNumber) {\n    return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n  }\n\n  getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n    return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n  }\n\n  getLineContent(lineNumber) {\n    return this._lines.getViewLineContent(lineNumber);\n  }\n\n  getLineLength(lineNumber) {\n    return this._lines.getViewLineLength(lineNumber);\n  }\n\n  getLineMinColumn(lineNumber) {\n    return this._lines.getViewLineMinColumn(lineNumber);\n  }\n\n  getLineMaxColumn(lineNumber) {\n    return this._lines.getViewLineMaxColumn(lineNumber);\n  }\n\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 1;\n  }\n\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 2;\n  }\n\n  getDecorationsInViewport(visibleRange) {\n    return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n  }\n\n  getInjectedTextAt(viewPosition) {\n    return this._lines.getInjectedTextAt(viewPosition);\n  }\n\n  getViewLineRenderingData(visibleRange, lineNumber) {\n    const mightContainRTL = this.model.mightContainRTL();\n    const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n    const tabSize = this.getTabSize();\n\n    const lineData = this._lines.getViewLineData(lineNumber);\n\n    const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n\n    let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n\n    if (lineData.inlineDecorations) {\n      inlineDecorations = [...inlineDecorations, ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))];\n    }\n\n    return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n  }\n\n  getViewLineData(lineNumber) {\n    return this._lines.getViewLineData(lineNumber);\n  }\n\n  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n    const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n\n    return new MinimapLinesRenderingData(this.getTabSize(), result);\n  }\n\n  getAllOverviewRulerDecorations(theme) {\n    const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n    const result = new OverviewRulerDecorations();\n\n    for (const decoration of decorations) {\n      const decorationOptions = decoration.options;\n      const opts = decorationOptions.overviewRuler;\n\n      if (!opts) {\n        continue;\n      }\n\n      const lane = opts.position;\n\n      if (lane === 0) {\n        continue;\n      }\n\n      const color = opts.getColor(theme.value);\n      const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n      const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n      result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n    }\n\n    return result.asArray;\n  }\n\n  invalidateOverviewRulerColorCache() {\n    const decorations = this.model.getOverviewRulerDecorations();\n\n    for (const decoration of decorations) {\n      const opts = decoration.options.overviewRuler;\n\n      if (opts) {\n        opts.invalidateCachedColor();\n      }\n    }\n  }\n\n  invalidateMinimapColorCache() {\n    const decorations = this.model.getAllDecorations();\n\n    for (const decoration of decorations) {\n      const opts = decoration.options.minimap;\n\n      if (opts) {\n        opts.invalidateCachedColor();\n      }\n    }\n  }\n\n  getValueInRange(range, eol) {\n    const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n    return this.model.getValueInRange(modelRange, eol);\n  }\n\n  getModelLineMaxColumn(modelLineNumber) {\n    return this.model.getLineMaxColumn(modelLineNumber);\n  }\n\n  validateModelPosition(position) {\n    return this.model.validatePosition(position);\n  }\n\n  validateModelRange(range) {\n    return this.model.validateRange(range);\n  }\n\n  deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n    const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n\n    if (this.model.getEOL().length === 2) {\n      // This model uses CRLF, so the delta must take that into account\n      if (deltaOffset < 0) {\n        deltaOffset -= lineFeedCnt;\n      } else {\n        deltaOffset += lineFeedCnt;\n      }\n    }\n\n    const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n    const resultOffset = modelAnchorOffset + deltaOffset;\n    return this.model.getPositionAt(resultOffset);\n  }\n\n  getEOL() {\n    return this.model.getEOL();\n  }\n\n  getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n    const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n    modelRanges = modelRanges.slice(0);\n    modelRanges.sort(Range.compareRangesUsingStarts);\n    let hasEmptyRange = false;\n    let hasNonEmptyRange = false;\n\n    for (const range of modelRanges) {\n      if (range.isEmpty()) {\n        hasEmptyRange = true;\n      } else {\n        hasNonEmptyRange = true;\n      }\n    }\n\n    if (!hasNonEmptyRange) {\n      // all ranges are empty\n      if (!emptySelectionClipboard) {\n        return '';\n      }\n\n      const modelLineNumbers = modelRanges.map(r => r.startLineNumber);\n      let result = '';\n\n      for (let i = 0; i < modelLineNumbers.length; i++) {\n        if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n          continue;\n        }\n\n        result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n      }\n\n      return result;\n    }\n\n    if (hasEmptyRange && emptySelectionClipboard) {\n      // mixed empty selections and non-empty selections\n      const result = [];\n      let prevModelLineNumber = 0;\n\n      for (const modelRange of modelRanges) {\n        const modelLineNumber = modelRange.startLineNumber;\n\n        if (modelRange.isEmpty()) {\n          if (modelLineNumber !== prevModelLineNumber) {\n            result.push(this.model.getLineContent(modelLineNumber));\n          }\n        } else {\n          result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2\n          /* CRLF */\n          : 0\n          /* TextDefined */\n          ));\n        }\n\n        prevModelLineNumber = modelLineNumber;\n      }\n\n      return result.length === 1 ? result[0] : result;\n    }\n\n    const result = [];\n\n    for (const modelRange of modelRanges) {\n      if (!modelRange.isEmpty()) {\n        result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2\n        /* CRLF */\n        : 0\n        /* TextDefined */\n        ));\n      }\n    }\n\n    return result.length === 1 ? result[0] : result;\n  }\n\n  getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n    const languageId = this.model.getLanguageId();\n\n    if (languageId === PLAINTEXT_LANGUAGE_ID) {\n      return null;\n    }\n\n    if (modelRanges.length !== 1) {\n      // no multiple selection support at this time\n      return null;\n    }\n\n    let range = modelRanges[0];\n\n    if (range.isEmpty()) {\n      if (!emptySelectionClipboard) {\n        // nothing to copy\n        return null;\n      }\n\n      const lineNumber = range.startLineNumber;\n      range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n    }\n\n    const fontInfo = this._configuration.options.get(44\n    /* fontInfo */\n    );\n\n    const colorMap = this._getColorMap();\n\n    const hasBadChars = /[:;\\\\\\/<>]/.test(fontInfo.fontFamily);\n    const useDefaultFontFamily = hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily;\n    let fontFamily;\n\n    if (useDefaultFontFamily) {\n      fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n    } else {\n      fontFamily = fontInfo.fontFamily;\n      fontFamily = fontFamily.replace(/\"/g, '\\'');\n      const hasQuotesOrIsList = /[,']/.test(fontFamily);\n\n      if (!hasQuotesOrIsList) {\n        const needsQuotes = /[+ ]/.test(fontFamily);\n\n        if (needsQuotes) {\n          fontFamily = `'${fontFamily}'`;\n        }\n      }\n\n      fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n    }\n\n    return {\n      mode: languageId,\n      html: `<div style=\"` + `color: ${colorMap[1\n      /* DefaultForeground */\n      ]};` + `background-color: ${colorMap[2\n      /* DefaultBackground */\n      ]};` + `font-family: ${fontFamily};` + `font-weight: ${fontInfo.fontWeight};` + `font-size: ${fontInfo.fontSize}px;` + `line-height: ${fontInfo.lineHeight}px;` + `white-space: pre;` + `\">` + this._getHTMLToCopy(range, colorMap) + '</div>'\n    };\n  }\n\n  _getHTMLToCopy(modelRange, colorMap) {\n    const startLineNumber = modelRange.startLineNumber;\n    const startColumn = modelRange.startColumn;\n    const endLineNumber = modelRange.endLineNumber;\n    const endColumn = modelRange.endColumn;\n    const tabSize = this.getTabSize();\n    let result = '';\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineTokens = this.model.getLineTokens(lineNumber);\n      const lineContent = lineTokens.getLineContent();\n      const startOffset = lineNumber === startLineNumber ? startColumn - 1 : 0;\n      const endOffset = lineNumber === endLineNumber ? endColumn - 1 : lineContent.length;\n\n      if (lineContent === '') {\n        result += '<br>';\n      } else {\n        result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n      }\n    }\n\n    return result;\n  }\n\n  _getColorMap() {\n    const colorMap = TokenizationRegistry.getColorMap();\n    const result = ['#000000'];\n\n    if (colorMap) {\n      for (let i = 1, len = colorMap.length; i < len; i++) {\n        result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n      }\n    }\n\n    return result;\n  } //#region model\n\n\n  pushStackElement() {\n    this.model.pushStackElement();\n  } //#endregion\n  //#region cursor operations\n\n\n  getPrimaryCursorState() {\n    return this._cursor.getPrimaryCursorState();\n  }\n\n  getLastAddedCursorIndex() {\n    return this._cursor.getLastAddedCursorIndex();\n  }\n\n  getCursorStates() {\n    return this._cursor.getCursorStates();\n  }\n\n  setCursorStates(source, reason, states) {\n    return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n  }\n\n  getCursorColumnSelectData() {\n    return this._cursor.getCursorColumnSelectData();\n  }\n\n  getCursorAutoClosedCharacters() {\n    return this._cursor.getAutoClosedCharacters();\n  }\n\n  setCursorColumnSelectData(columnSelectData) {\n    this._cursor.setCursorColumnSelectData(columnSelectData);\n  }\n\n  getPrevEditOperationType() {\n    return this._cursor.getPrevEditOperationType();\n  }\n\n  setPrevEditOperationType(type) {\n    this._cursor.setPrevEditOperationType(type);\n  }\n\n  getSelection() {\n    return this._cursor.getSelection();\n  }\n\n  getSelections() {\n    return this._cursor.getSelections();\n  }\n\n  getPosition() {\n    return this._cursor.getPrimaryCursorState().modelState.position;\n  }\n\n  setSelections(source, selections, reason = 0\n  /* NotSet */\n  ) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n  }\n\n  saveCursorState() {\n    return this._cursor.saveState();\n  }\n\n  restoreCursorState(states) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n  }\n\n  _executeCursorEdit(callback) {\n    if (this._cursor.context.cursorConfig.readOnly) {\n      // we cannot edit when read only...\n      this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n\n      return;\n    }\n\n    this._withViewEventsCollector(callback);\n  }\n\n  executeEdits(source, edits, cursorStateComputer) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n  }\n\n  startComposition() {\n    this._cursor.setIsDoingComposition(true);\n\n    this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n  }\n\n  endComposition(source) {\n    this._cursor.setIsDoingComposition(false);\n\n    this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n  }\n\n  type(text, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n  }\n\n  compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n  }\n\n  paste(text, pasteOnNewLine, multicursorText, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n  }\n\n  cut(source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n  }\n\n  executeCommand(command, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n  }\n\n  executeCommands(commands, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n  }\n\n  revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0\n    /* Simple */\n    , revealHorizontal, 0\n    /* Smooth */\n    ));\n  }\n\n  revealTopMostCursor(source) {\n    const viewPosition = this._cursor.getTopMostViewPosition();\n\n    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0\n    /* Simple */\n    , true, 0\n    /* Smooth */\n    )));\n  }\n\n  revealBottomMostCursor(source) {\n    const viewPosition = this._cursor.getBottomMostViewPosition();\n\n    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0\n    /* Simple */\n    , true, 0\n    /* Smooth */\n    )));\n  }\n\n  revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n  } //#endregion\n  //#region viewLayout\n\n\n  getVerticalOffsetForLineNumber(viewLineNumber) {\n    return this.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);\n  }\n\n  getScrollTop() {\n    return this.viewLayout.getCurrentScrollTop();\n  }\n\n  setScrollTop(newScrollTop, scrollType) {\n    this.viewLayout.setScrollPosition({\n      scrollTop: newScrollTop\n    }, scrollType);\n  }\n\n  setScrollPosition(position, type) {\n    this.viewLayout.setScrollPosition(position, type);\n  }\n\n  deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n    this.viewLayout.deltaScrollNow(deltaScrollLeft, deltaScrollTop);\n  }\n\n  changeWhitespace(callback) {\n    const hadAChange = this.viewLayout.changeWhitespace(callback);\n\n    if (hadAChange) {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n\n      this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n    }\n  }\n\n  setMaxLineWidth(maxLineWidth) {\n    this.viewLayout.setMaxLineWidth(maxLineWidth);\n  } //#endregion\n\n\n  _withViewEventsCollector(callback) {\n    try {\n      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n\n      return callback(eventsCollector);\n    } finally {\n      this._eventDispatcher.endEmitViewEvents();\n    }\n  }\n\n  normalizePosition(position, affinity) {\n    return this._lines.normalizePosition(position, affinity);\n  }\n  /**\n   * Gets the column at which indentation stops at a given line.\n   * @internal\n  */\n\n\n  getLineIndentColumn(lineNumber) {\n    return this._lines.getLineIndentColumn(lineNumber);\n  }\n\n}\n\nclass OverviewRulerDecorations {\n  constructor() {\n    this._asMap = Object.create(null);\n    this.asArray = [];\n  }\n\n  accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n    const prevGroup = this._asMap[color];\n\n    if (prevGroup) {\n      const prevData = prevGroup.data;\n      const prevLane = prevData[prevData.length - 3];\n      const prevEndLineNumber = prevData[prevData.length - 1];\n\n      if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n        // merge into prev\n        if (endLineNumber > prevEndLineNumber) {\n          prevData[prevData.length - 1] = endLineNumber;\n        }\n\n        return;\n      } // push\n\n\n      prevData.push(lane, startLineNumber, endLineNumber);\n    } else {\n      const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n      this._asMap[color] = group;\n      this.asArray.push(group);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js"],"names":["ArrayQueue","RunOnceScheduler","Color","Disposable","platform","strings","EDITOR_FONT_DEFAULTS","filterValidationDecorations","CursorsController","CursorConfiguration","Position","Range","textModelEvents","TokenizationRegistry","PLAINTEXT_LANGUAGE_ID","tokenizeLineToHTML","viewEvents","ViewLayout","MinimapTokensColorTracker","MinimapLinesRenderingData","OverviewRulerDecorationsGroup","ViewLineRenderingData","ViewModelDecorations","FocusChangedEvent","ReadOnlyEditAttemptEvent","ScrollChangedEvent","ViewModelEventDispatcher","ViewZonesChangedEvent","ViewModelLinesFromModelAsIs","ViewModelLinesFromProjectedModel","USE_IDENTITY_LINES_COLLECTION","ViewModel","constructor","editorId","configuration","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","scheduleAtNextAnimationFrame","languageConfigurationService","_editorId","_configuration","_eventDispatcher","onEvent","cursorConfig","getLanguageId","getOptions","_tokenizeViewportSoon","_register","tokenizeViewport","_updateConfigurationViewLineCount","_updateConfigurationViewLineCountNow","_hasFocus","_viewportStartLine","_viewportStartLineTrackedRange","_viewportStartLineDelta","isTooLargeForTokenization","_lines","options","fontInfo","get","wrappingStrategy","wrappingInfo","wrappingIndent","tabSize","wrappingColumn","coordinatesConverter","createCoordinatesConverter","_cursor","viewLayout","getLineCount","onDidScroll","e","scrollTopChanged","schedule","emitSingleViewEvent","ViewScrollChangedEvent","emitOutgoingEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","scrollWidth","scrollLeft","scrollHeight","scrollTop","onDidContentSizeChange","_decorations","_registerModelEvents","onDidChangeFast","eventsCollector","beginEmitViewEvents","_onConfigurationChanged","endEmitViewEvents","getInstance","onDidChange","ViewTokensColorsChangedEvent","dispose","invalidateMinimapColorCache","_setTrackedRange","createLineBreaksComputer","addViewEventHandler","eventHandler","removeViewEventHandler","setViewLineCount","getViewLineCount","linesViewportData","getLinesViewportData","viewVisibleRange","startLineNumber","getLineMinColumn","endLineNumber","getLineMaxColumn","modelVisibleRanges","_toModelVisibleRanges","modelVisibleRange","setHasFocus","hasFocus","ViewFocusChangedEvent","onCompositionStart","ViewCompositionStartEvent","onCompositionEnd","ViewCompositionEndEvent","onDidColorThemeChange","ViewThemeChangedEvent","previousViewportStartModelPosition","previousViewportStartViewPosition","convertViewPositionToModelPosition","restorePreviousViewportStart","setWrappingSettings","emitViewEvent","ViewFlushedEvent","ViewLineMappingChangedEvent","ViewDecorationsChangedEvent","onLineMappingChanged","onFlushed","getCurrentScrollTop","hasChanged","reset","ViewConfigurationChangedEvent","onConfigurationChanged","viewPosition","convertModelPositionToViewPosition","viewPositionTop","getVerticalOffsetForLineNumber","lineNumber","setScrollPosition","shouldRecreate","updateConfiguration","onDidChangeContentOrInjectedText","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","changes","versionId","ModelRawContentChangedEvent","lineBreaksComputer","change","changeType","lineIdx","detail","length","line","injectedText","injectedTexts","filter","element","ownerId","addRequest","lineBreaks","finalize","lineBreakQueue","onModelFlushed","linesDeletedEvent","onModelLinesDeleted","fromLineNumber","toLineNumber","onLinesDeleted","insertedLineBreaks","takeCount","linesInsertedEvent","onModelLinesInserted","onLinesInserted","changedLineBreakData","dequeue","lineMappingChanged","linesChangedEvent","onModelLineChanged","acceptVersionId","onHeightMaybeChanged","setModelLineCount","getAttachedEditorCount","modelRange","_getTrackedRange","getStartPosition","onModelContentChanged","onDidChangeTokens","viewRanges","j","lenJ","ranges","viewStartLineNumber","viewEndLineNumber","ViewTokensChangedEvent","tokenizationSupportChanged","onDidChangeLanguageConfiguration","ViewLanguageConfigurationEvent","onDidChangeLanguage","onDidChangeOptions","setTabSize","onDidChangeDecorations","onModelDecorationsChanged","setHiddenAreas","getVisibleRangesPlusViewportAboveBelow","layoutInfo","lineHeight","linesAround","Math","max","round","height","partialData","startViewLineNumber","completelyVisibleStartLineNumber","endViewLineNumber","min","completelyVisibleEndLineNumber","getVisibleRanges","visibleViewRange","getCompletelyVisibleViewRange","visibleRange","convertViewRangeToModelRange","hiddenAreas","getHiddenAreas","result","resultLen","startColumn","endColumn","i","len","hiddenStartLineNumber","hiddenEndLineNumber","getCompletelyVisibleViewRangeAtScrollTop","getLinesViewportDataAtScrollTop","saveState","compatViewState","firstViewLineNumber","getLineNumberAtVerticalOffset","firstPosition","firstPositionDeltaTop","reduceRestoreState","state","_reduceRestoreStateCompatibility","modelPosition","validatePosition","scrollTopWithoutViewZones","getTabSize","getTextModelOptions","setViewport","centeredLineNumber","position","column","viewportStartLineTop","getActiveIndentGuide","minLineNumber","maxLineNumber","getLinesIndentGuides","getViewLinesIndentGuides","getBracketGuidesInRangeByLine","activePosition","getViewLinesBracketGuides","getLineContent","getViewLineContent","getLineLength","getViewLineLength","getViewLineMinColumn","getViewLineMaxColumn","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","getDecorationsInViewport","getDecorationsViewportData","decorations","getInjectedTextAt","getViewLineRenderingData","mightContainRTL","mightContainNonBasicASCII","lineData","getViewLineData","allInlineDecorations","inlineDecorations","map","d","toInlineDecoration","minColumn","maxColumn","content","continuesWithWrappedLine","tokens","startVisibleColumn","getMinimapLinesRenderingData","needed","getViewLinesData","getAllOverviewRulerDecorations","theme","getOverviewRulerDecorations","OverviewRulerDecorations","decoration","decorationOptions","opts","overviewRuler","lane","color","getColor","value","getViewLineNumberOfModelPosition","range","accept","zIndex","asArray","invalidateOverviewRulerColorCache","invalidateCachedColor","getAllDecorations","minimap","getValueInRange","eol","getModelLineMaxColumn","modelLineNumber","validateModelPosition","validateModelRange","validateRange","deduceModelPositionRelativeToViewPosition","viewAnchorPosition","deltaOffset","lineFeedCnt","modelAnchor","getEOL","modelAnchorOffset","getOffsetAt","resultOffset","getPositionAt","getPlainTextToCopy","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","slice","sort","compareRangesUsingStarts","hasEmptyRange","hasNonEmptyRange","isEmpty","modelLineNumbers","r","prevModelLineNumber","push","getRichTextToCopy","languageId","colorMap","_getColorMap","hasBadChars","test","fontFamily","useDefaultFontFamily","replace","hasQuotesOrIsList","needsQuotes","mode","html","fontWeight","fontSize","_getHTMLToCopy","lineTokens","getLineTokens","lineContent","startOffset","endOffset","inflate","isWindows","getColorMap","Format","CSS","formatHex","pushStackElement","getPrimaryCursorState","getLastAddedCursorIndex","getCursorStates","setCursorStates","source","reason","states","_withViewEventsCollector","setStates","getCursorColumnSelectData","getCursorAutoClosedCharacters","getAutoClosedCharacters","setCursorColumnSelectData","columnSelectData","getPrevEditOperationType","setPrevEditOperationType","type","getSelection","getSelections","getPosition","modelState","setSelections","selections","saveCursorState","restoreCursorState","restoreState","_executeCursorEdit","callback","context","readOnly","executeEdits","edits","cursorStateComputer","startComposition","setIsDoingComposition","endComposition","text","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","paste","pasteOnNewLine","multicursorText","cut","executeCommand","command","executeCommands","commands","revealPrimaryCursor","revealHorizontal","minimalReveal","revealPrimary","revealTopMostCursor","getTopMostViewPosition","viewRange","ViewRevealRangeRequestEvent","revealBottomMostCursor","getBottomMostViewPosition","revealRange","verticalType","scrollType","viewLineNumber","getScrollTop","setScrollTop","newScrollTop","deltaScrollNow","deltaScrollLeft","deltaScrollTop","changeWhitespace","hadAChange","setMaxLineWidth","maxLineWidth","normalizePosition","affinity","getLineIndentColumn","_asMap","Object","create","prevGroup","prevData","data","prevLane","prevEndLineNumber","group"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursor/cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from './viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from './viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from './viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStartLine = -1;\n        this._viewportStartLineTrackedRange = null;\n        this._viewportStartLineDelta = 0;\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(44 /* fontInfo */);\n            const wrappingStrategy = options.get(125 /* wrappingStrategy */);\n            const wrappingInfo = options.get(132 /* wrappingInfo */);\n            const wrappingIndent = options.get(124 /* wrappingIndent */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this.invalidateMinimapColorCache();\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1 /* NeverGrowsWhenTypingAtEdges */);\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    tokenizeViewport() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        for (const modelVisibleRange of modelVisibleRanges) {\n            this.model.tokenizeViewport(modelVisibleRange.startLineNumber, modelVisibleRange.endLineNumber);\n        }\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    onDidColorThemeChange() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent());\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        // We might need to restore the current centered view range, so save it (if available)\n        let previousViewportStartModelPosition = null;\n        if (this._viewportStartLine !== -1) {\n            const previousViewportStartViewPosition = new Position(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));\n            previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n        }\n        let restorePreviousViewportStart = false;\n        const options = this._configuration.options;\n        const fontInfo = options.get(44 /* fontInfo */);\n        const wrappingStrategy = options.get(125 /* wrappingStrategy */);\n        const wrappingInfo = options.get(132 /* wrappingInfo */);\n        const wrappingIndent = options.get(124 /* wrappingIndent */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            if (this.viewLayout.getCurrentScrollTop() !== 0) {\n                // Never change the scroll position from 0 to something else...\n                restorePreviousViewportStart = true;\n            }\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(81 /* readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n            const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n            const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n            this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\n        }\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = e.changes;\n                const versionId = (e instanceof textModelEvents.ModelRawContentChangedEvent ? e.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            this._viewportStartLine = -1;\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {\n                const modelRange = this.model._getTrackedRange(this._viewportStartLineTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._tokenizeViewportSoon.schedule();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            if (e.tokenizationSupportChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges) {\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(ranges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(131 /* layoutInfo */);\n        const lineHeight = this._configuration.options.get(59 /* lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getTextModelOptions() {\n        return this.model.getOptions();\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStartLine = startLineNumber;\n        const position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = this.viewLayout.getCurrentScrollTop();\n        this._viewportStartLineDelta = scrollTop - viewportStartLineTop;\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewLineRenderingData(visibleRange, lineNumber) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    invalidateOverviewRulerColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts = decoration.options.overviewRuler;\n            if (opts) {\n                opts.invalidateCachedColor();\n            }\n        }\n    }\n    invalidateMinimapColorCache() {\n        const decorations = this.model.getAllDecorations();\n        for (const decoration of decorations) {\n            const opts = decoration.options.minimap;\n            if (opts) {\n                opts.invalidateCachedColor();\n            }\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    getModelLineMaxColumn(modelLineNumber) {\n        return this.model.getLineMaxColumn(modelLineNumber);\n    }\n    validateModelPosition(position) {\n        return this.model.validatePosition(position);\n    }\n    validateModelRange(range) {\n        return this.model.validateRange(range);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getEOL() {\n        return this.model.getEOL();\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(44 /* fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region model\n    pushStackElement() {\n        this.model.pushStackElement();\n    }\n    //#endregion\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._cursor.setIsDoingComposition(true);\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._cursor.setIsDoingComposition(false);\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* Simple */, revealHorizontal, 0 /* Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    getVerticalOffsetForLineNumber(viewLineNumber) {\n        return this.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);\n    }\n    getScrollTop() {\n        return this.viewLayout.getCurrentScrollTop();\n    }\n    setScrollTop(newScrollTop, scrollType) {\n        this.viewLayout.setScrollPosition({ scrollTop: newScrollTop }, scrollType);\n    }\n    setScrollPosition(position, type) {\n        this.viewLayout.setScrollPosition(position, type);\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        this.viewLayout.deltaScrollNow(deltaScrollLeft, deltaScrollTop);\n    }\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        this.viewLayout.setMaxLineWidth(maxLineWidth);\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            return callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}