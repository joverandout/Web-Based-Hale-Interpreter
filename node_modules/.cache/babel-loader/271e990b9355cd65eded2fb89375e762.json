{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/core/range.js';\nimport { MinimapPosition, OverviewRulerLane } from '../../../common/model.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { minimapFindMatch, overviewRulerFindMatchForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { themeColorFromId } from '../../../../platform/theme/common/themeService.js';\nexport class FindDecorations {\n  constructor(editor) {\n    this._editor = editor;\n    this._decorations = [];\n    this._overviewRulerApproximateDecorations = [];\n    this._findScopeDecorationIds = [];\n    this._rangeHighlightDecorationId = null;\n    this._highlightedDecorationId = null;\n    this._startPosition = this._editor.getPosition();\n  }\n\n  dispose() {\n    this._editor.deltaDecorations(this._allDecorations(), []);\n\n    this._decorations = [];\n    this._overviewRulerApproximateDecorations = [];\n    this._findScopeDecorationIds = [];\n    this._rangeHighlightDecorationId = null;\n    this._highlightedDecorationId = null;\n  }\n\n  reset() {\n    this._decorations = [];\n    this._overviewRulerApproximateDecorations = [];\n    this._findScopeDecorationIds = [];\n    this._rangeHighlightDecorationId = null;\n    this._highlightedDecorationId = null;\n  }\n\n  getCount() {\n    return this._decorations.length;\n  }\n  /** @deprecated use getFindScopes to support multiple selections */\n\n\n  getFindScope() {\n    if (this._findScopeDecorationIds[0]) {\n      return this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]);\n    }\n\n    return null;\n  }\n\n  getFindScopes() {\n    if (this._findScopeDecorationIds.length) {\n      const scopes = this._findScopeDecorationIds.map(findScopeDecorationId => this._editor.getModel().getDecorationRange(findScopeDecorationId)).filter(element => !!element);\n\n      if (scopes.length) {\n        return scopes;\n      }\n    }\n\n    return null;\n  }\n\n  getStartPosition() {\n    return this._startPosition;\n  }\n\n  setStartPosition(newStartPosition) {\n    this._startPosition = newStartPosition;\n    this.setCurrentFindMatch(null);\n  }\n\n  _getDecorationIndex(decorationId) {\n    const index = this._decorations.indexOf(decorationId);\n\n    if (index >= 0) {\n      return index + 1;\n    }\n\n    return 1;\n  }\n\n  getCurrentMatchesPosition(desiredRange) {\n    let candidates = this._editor.getModel().getDecorationsInRange(desiredRange);\n\n    for (const candidate of candidates) {\n      const candidateOpts = candidate.options;\n\n      if (candidateOpts === FindDecorations._FIND_MATCH_DECORATION || candidateOpts === FindDecorations._CURRENT_FIND_MATCH_DECORATION) {\n        return this._getDecorationIndex(candidate.id);\n      }\n    } // We don't know the current match position, so returns zero to show '?' in find widget\n\n\n    return 0;\n  }\n\n  setCurrentFindMatch(nextMatch) {\n    let newCurrentDecorationId = null;\n    let matchPosition = 0;\n\n    if (nextMatch) {\n      for (let i = 0, len = this._decorations.length; i < len; i++) {\n        let range = this._editor.getModel().getDecorationRange(this._decorations[i]);\n\n        if (nextMatch.equalsRange(range)) {\n          newCurrentDecorationId = this._decorations[i];\n          matchPosition = i + 1;\n          break;\n        }\n      }\n    }\n\n    if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {\n      this._editor.changeDecorations(changeAccessor => {\n        if (this._highlightedDecorationId !== null) {\n          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._FIND_MATCH_DECORATION);\n          this._highlightedDecorationId = null;\n        }\n\n        if (newCurrentDecorationId !== null) {\n          this._highlightedDecorationId = newCurrentDecorationId;\n          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._CURRENT_FIND_MATCH_DECORATION);\n        }\n\n        if (this._rangeHighlightDecorationId !== null) {\n          changeAccessor.removeDecoration(this._rangeHighlightDecorationId);\n          this._rangeHighlightDecorationId = null;\n        }\n\n        if (newCurrentDecorationId !== null) {\n          let rng = this._editor.getModel().getDecorationRange(newCurrentDecorationId);\n\n          if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {\n            let lineBeforeEnd = rng.endLineNumber - 1;\n\n            let lineBeforeEndMaxColumn = this._editor.getModel().getLineMaxColumn(lineBeforeEnd);\n\n            rng = new Range(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);\n          }\n\n          this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, FindDecorations._RANGE_HIGHLIGHT_DECORATION);\n        }\n      });\n    }\n\n    return matchPosition;\n  }\n\n  set(findMatches, findScopes) {\n    this._editor.changeDecorations(accessor => {\n      let findMatchesOptions = FindDecorations._FIND_MATCH_DECORATION;\n      let newOverviewRulerApproximateDecorations = [];\n\n      if (findMatches.length > 1000) {\n        // we go into a mode where the overview ruler gets \"approximate\" decorations\n        // the reason is that the overview ruler paints all the decorations in the file and we don't want to cause freezes\n        findMatchesOptions = FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION; // approximate a distance in lines where matches should be merged\n\n        const lineCount = this._editor.getModel().getLineCount();\n\n        const height = this._editor.getLayoutInfo().height;\n\n        const approxPixelsPerLine = height / lineCount;\n        const mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine)); // merge decorations as much as possible\n\n        let prevStartLineNumber = findMatches[0].range.startLineNumber;\n        let prevEndLineNumber = findMatches[0].range.endLineNumber;\n\n        for (let i = 1, len = findMatches.length; i < len; i++) {\n          const range = findMatches[i].range;\n\n          if (prevEndLineNumber + mergeLinesDelta >= range.startLineNumber) {\n            if (range.endLineNumber > prevEndLineNumber) {\n              prevEndLineNumber = range.endLineNumber;\n            }\n          } else {\n            newOverviewRulerApproximateDecorations.push({\n              range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),\n              options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION\n            });\n            prevStartLineNumber = range.startLineNumber;\n            prevEndLineNumber = range.endLineNumber;\n          }\n        }\n\n        newOverviewRulerApproximateDecorations.push({\n          range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),\n          options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION\n        });\n      } // Find matches\n\n\n      let newFindMatchesDecorations = new Array(findMatches.length);\n\n      for (let i = 0, len = findMatches.length; i < len; i++) {\n        newFindMatchesDecorations[i] = {\n          range: findMatches[i].range,\n          options: findMatchesOptions\n        };\n      }\n\n      this._decorations = accessor.deltaDecorations(this._decorations, newFindMatchesDecorations); // Overview ruler approximate decorations\n\n      this._overviewRulerApproximateDecorations = accessor.deltaDecorations(this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations); // Range highlight\n\n      if (this._rangeHighlightDecorationId) {\n        accessor.removeDecoration(this._rangeHighlightDecorationId);\n        this._rangeHighlightDecorationId = null;\n      } // Find scope\n\n\n      if (this._findScopeDecorationIds.length) {\n        this._findScopeDecorationIds.forEach(findScopeDecorationId => accessor.removeDecoration(findScopeDecorationId));\n\n        this._findScopeDecorationIds = [];\n      }\n\n      if (findScopes === null || findScopes === void 0 ? void 0 : findScopes.length) {\n        this._findScopeDecorationIds = findScopes.map(findScope => accessor.addDecoration(findScope, FindDecorations._FIND_SCOPE_DECORATION));\n      }\n    });\n  }\n\n  matchBeforePosition(position) {\n    if (this._decorations.length === 0) {\n      return null;\n    }\n\n    for (let i = this._decorations.length - 1; i >= 0; i--) {\n      let decorationId = this._decorations[i];\n\n      let r = this._editor.getModel().getDecorationRange(decorationId);\n\n      if (!r || r.endLineNumber > position.lineNumber) {\n        continue;\n      }\n\n      if (r.endLineNumber < position.lineNumber) {\n        return r;\n      }\n\n      if (r.endColumn > position.column) {\n        continue;\n      }\n\n      return r;\n    }\n\n    return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);\n  }\n\n  matchAfterPosition(position) {\n    if (this._decorations.length === 0) {\n      return null;\n    }\n\n    for (let i = 0, len = this._decorations.length; i < len; i++) {\n      let decorationId = this._decorations[i];\n\n      let r = this._editor.getModel().getDecorationRange(decorationId);\n\n      if (!r || r.startLineNumber < position.lineNumber) {\n        continue;\n      }\n\n      if (r.startLineNumber > position.lineNumber) {\n        return r;\n      }\n\n      if (r.startColumn < position.column) {\n        continue;\n      }\n\n      return r;\n    }\n\n    return this._editor.getModel().getDecorationRange(this._decorations[0]);\n  }\n\n  _allDecorations() {\n    let result = [];\n    result = result.concat(this._decorations);\n    result = result.concat(this._overviewRulerApproximateDecorations);\n\n    if (this._findScopeDecorationIds.length) {\n      result.push(...this._findScopeDecorationIds);\n    }\n\n    if (this._rangeHighlightDecorationId) {\n      result.push(this._rangeHighlightDecorationId);\n    }\n\n    return result;\n  }\n\n}\nFindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({\n  description: 'current-find-match',\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n  ,\n  zIndex: 13,\n  className: 'currentFindMatch',\n  showIfCollapsed: true,\n  overviewRuler: {\n    color: themeColorFromId(overviewRulerFindMatchForeground),\n    position: OverviewRulerLane.Center\n  },\n  minimap: {\n    color: themeColorFromId(minimapFindMatch),\n    position: MinimapPosition.Inline\n  }\n});\nFindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({\n  description: 'find-match',\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n  ,\n  zIndex: 10,\n  className: 'findMatch',\n  showIfCollapsed: true,\n  overviewRuler: {\n    color: themeColorFromId(overviewRulerFindMatchForeground),\n    position: OverviewRulerLane.Center\n  },\n  minimap: {\n    color: themeColorFromId(minimapFindMatch),\n    position: MinimapPosition.Inline\n  }\n});\nFindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({\n  description: 'find-match-no-overview',\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n  ,\n  className: 'findMatch',\n  showIfCollapsed: true\n});\nFindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({\n  description: 'find-match-only-overview',\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n  ,\n  overviewRuler: {\n    color: themeColorFromId(overviewRulerFindMatchForeground),\n    position: OverviewRulerLane.Center\n  }\n});\nFindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({\n  description: 'find-range-highlight',\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n  ,\n  className: 'rangeHighlight',\n  isWholeLine: true\n});\nFindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({\n  description: 'find-scope',\n  className: 'findScope',\n  isWholeLine: true\n});","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findDecorations.js"],"names":["Range","MinimapPosition","OverviewRulerLane","ModelDecorationOptions","minimapFindMatch","overviewRulerFindMatchForeground","themeColorFromId","FindDecorations","constructor","editor","_editor","_decorations","_overviewRulerApproximateDecorations","_findScopeDecorationIds","_rangeHighlightDecorationId","_highlightedDecorationId","_startPosition","getPosition","dispose","deltaDecorations","_allDecorations","reset","getCount","length","getFindScope","getModel","getDecorationRange","getFindScopes","scopes","map","findScopeDecorationId","filter","element","getStartPosition","setStartPosition","newStartPosition","setCurrentFindMatch","_getDecorationIndex","decorationId","index","indexOf","getCurrentMatchesPosition","desiredRange","candidates","getDecorationsInRange","candidate","candidateOpts","options","_FIND_MATCH_DECORATION","_CURRENT_FIND_MATCH_DECORATION","id","nextMatch","newCurrentDecorationId","matchPosition","i","len","range","equalsRange","changeDecorations","changeAccessor","changeDecorationOptions","removeDecoration","rng","startLineNumber","endLineNumber","endColumn","lineBeforeEnd","lineBeforeEndMaxColumn","getLineMaxColumn","startColumn","addDecoration","_RANGE_HIGHLIGHT_DECORATION","set","findMatches","findScopes","accessor","findMatchesOptions","newOverviewRulerApproximateDecorations","_FIND_MATCH_NO_OVERVIEW_DECORATION","lineCount","getLineCount","height","getLayoutInfo","approxPixelsPerLine","mergeLinesDelta","Math","max","ceil","prevStartLineNumber","prevEndLineNumber","push","_FIND_MATCH_ONLY_OVERVIEW_DECORATION","newFindMatchesDecorations","Array","forEach","findScope","_FIND_SCOPE_DECORATION","matchBeforePosition","position","r","lineNumber","column","matchAfterPosition","result","concat","register","description","stickiness","zIndex","className","showIfCollapsed","overviewRuler","color","Center","minimap","Inline","isWholeLine"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/core/range.js';\nimport { MinimapPosition, OverviewRulerLane } from '../../../common/model.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { minimapFindMatch, overviewRulerFindMatchForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { themeColorFromId } from '../../../../platform/theme/common/themeService.js';\nexport class FindDecorations {\n    constructor(editor) {\n        this._editor = editor;\n        this._decorations = [];\n        this._overviewRulerApproximateDecorations = [];\n        this._findScopeDecorationIds = [];\n        this._rangeHighlightDecorationId = null;\n        this._highlightedDecorationId = null;\n        this._startPosition = this._editor.getPosition();\n    }\n    dispose() {\n        this._editor.deltaDecorations(this._allDecorations(), []);\n        this._decorations = [];\n        this._overviewRulerApproximateDecorations = [];\n        this._findScopeDecorationIds = [];\n        this._rangeHighlightDecorationId = null;\n        this._highlightedDecorationId = null;\n    }\n    reset() {\n        this._decorations = [];\n        this._overviewRulerApproximateDecorations = [];\n        this._findScopeDecorationIds = [];\n        this._rangeHighlightDecorationId = null;\n        this._highlightedDecorationId = null;\n    }\n    getCount() {\n        return this._decorations.length;\n    }\n    /** @deprecated use getFindScopes to support multiple selections */\n    getFindScope() {\n        if (this._findScopeDecorationIds[0]) {\n            return this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]);\n        }\n        return null;\n    }\n    getFindScopes() {\n        if (this._findScopeDecorationIds.length) {\n            const scopes = this._findScopeDecorationIds.map(findScopeDecorationId => this._editor.getModel().getDecorationRange(findScopeDecorationId)).filter(element => !!element);\n            if (scopes.length) {\n                return scopes;\n            }\n        }\n        return null;\n    }\n    getStartPosition() {\n        return this._startPosition;\n    }\n    setStartPosition(newStartPosition) {\n        this._startPosition = newStartPosition;\n        this.setCurrentFindMatch(null);\n    }\n    _getDecorationIndex(decorationId) {\n        const index = this._decorations.indexOf(decorationId);\n        if (index >= 0) {\n            return index + 1;\n        }\n        return 1;\n    }\n    getCurrentMatchesPosition(desiredRange) {\n        let candidates = this._editor.getModel().getDecorationsInRange(desiredRange);\n        for (const candidate of candidates) {\n            const candidateOpts = candidate.options;\n            if (candidateOpts === FindDecorations._FIND_MATCH_DECORATION || candidateOpts === FindDecorations._CURRENT_FIND_MATCH_DECORATION) {\n                return this._getDecorationIndex(candidate.id);\n            }\n        }\n        // We don't know the current match position, so returns zero to show '?' in find widget\n        return 0;\n    }\n    setCurrentFindMatch(nextMatch) {\n        let newCurrentDecorationId = null;\n        let matchPosition = 0;\n        if (nextMatch) {\n            for (let i = 0, len = this._decorations.length; i < len; i++) {\n                let range = this._editor.getModel().getDecorationRange(this._decorations[i]);\n                if (nextMatch.equalsRange(range)) {\n                    newCurrentDecorationId = this._decorations[i];\n                    matchPosition = (i + 1);\n                    break;\n                }\n            }\n        }\n        if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {\n            this._editor.changeDecorations((changeAccessor) => {\n                if (this._highlightedDecorationId !== null) {\n                    changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._FIND_MATCH_DECORATION);\n                    this._highlightedDecorationId = null;\n                }\n                if (newCurrentDecorationId !== null) {\n                    this._highlightedDecorationId = newCurrentDecorationId;\n                    changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._CURRENT_FIND_MATCH_DECORATION);\n                }\n                if (this._rangeHighlightDecorationId !== null) {\n                    changeAccessor.removeDecoration(this._rangeHighlightDecorationId);\n                    this._rangeHighlightDecorationId = null;\n                }\n                if (newCurrentDecorationId !== null) {\n                    let rng = this._editor.getModel().getDecorationRange(newCurrentDecorationId);\n                    if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {\n                        let lineBeforeEnd = rng.endLineNumber - 1;\n                        let lineBeforeEndMaxColumn = this._editor.getModel().getLineMaxColumn(lineBeforeEnd);\n                        rng = new Range(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);\n                    }\n                    this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, FindDecorations._RANGE_HIGHLIGHT_DECORATION);\n                }\n            });\n        }\n        return matchPosition;\n    }\n    set(findMatches, findScopes) {\n        this._editor.changeDecorations((accessor) => {\n            let findMatchesOptions = FindDecorations._FIND_MATCH_DECORATION;\n            let newOverviewRulerApproximateDecorations = [];\n            if (findMatches.length > 1000) {\n                // we go into a mode where the overview ruler gets \"approximate\" decorations\n                // the reason is that the overview ruler paints all the decorations in the file and we don't want to cause freezes\n                findMatchesOptions = FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION;\n                // approximate a distance in lines where matches should be merged\n                const lineCount = this._editor.getModel().getLineCount();\n                const height = this._editor.getLayoutInfo().height;\n                const approxPixelsPerLine = height / lineCount;\n                const mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine));\n                // merge decorations as much as possible\n                let prevStartLineNumber = findMatches[0].range.startLineNumber;\n                let prevEndLineNumber = findMatches[0].range.endLineNumber;\n                for (let i = 1, len = findMatches.length; i < len; i++) {\n                    const range = findMatches[i].range;\n                    if (prevEndLineNumber + mergeLinesDelta >= range.startLineNumber) {\n                        if (range.endLineNumber > prevEndLineNumber) {\n                            prevEndLineNumber = range.endLineNumber;\n                        }\n                    }\n                    else {\n                        newOverviewRulerApproximateDecorations.push({\n                            range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),\n                            options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION\n                        });\n                        prevStartLineNumber = range.startLineNumber;\n                        prevEndLineNumber = range.endLineNumber;\n                    }\n                }\n                newOverviewRulerApproximateDecorations.push({\n                    range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),\n                    options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION\n                });\n            }\n            // Find matches\n            let newFindMatchesDecorations = new Array(findMatches.length);\n            for (let i = 0, len = findMatches.length; i < len; i++) {\n                newFindMatchesDecorations[i] = {\n                    range: findMatches[i].range,\n                    options: findMatchesOptions\n                };\n            }\n            this._decorations = accessor.deltaDecorations(this._decorations, newFindMatchesDecorations);\n            // Overview ruler approximate decorations\n            this._overviewRulerApproximateDecorations = accessor.deltaDecorations(this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations);\n            // Range highlight\n            if (this._rangeHighlightDecorationId) {\n                accessor.removeDecoration(this._rangeHighlightDecorationId);\n                this._rangeHighlightDecorationId = null;\n            }\n            // Find scope\n            if (this._findScopeDecorationIds.length) {\n                this._findScopeDecorationIds.forEach(findScopeDecorationId => accessor.removeDecoration(findScopeDecorationId));\n                this._findScopeDecorationIds = [];\n            }\n            if (findScopes === null || findScopes === void 0 ? void 0 : findScopes.length) {\n                this._findScopeDecorationIds = findScopes.map(findScope => accessor.addDecoration(findScope, FindDecorations._FIND_SCOPE_DECORATION));\n            }\n        });\n    }\n    matchBeforePosition(position) {\n        if (this._decorations.length === 0) {\n            return null;\n        }\n        for (let i = this._decorations.length - 1; i >= 0; i--) {\n            let decorationId = this._decorations[i];\n            let r = this._editor.getModel().getDecorationRange(decorationId);\n            if (!r || r.endLineNumber > position.lineNumber) {\n                continue;\n            }\n            if (r.endLineNumber < position.lineNumber) {\n                return r;\n            }\n            if (r.endColumn > position.column) {\n                continue;\n            }\n            return r;\n        }\n        return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);\n    }\n    matchAfterPosition(position) {\n        if (this._decorations.length === 0) {\n            return null;\n        }\n        for (let i = 0, len = this._decorations.length; i < len; i++) {\n            let decorationId = this._decorations[i];\n            let r = this._editor.getModel().getDecorationRange(decorationId);\n            if (!r || r.startLineNumber < position.lineNumber) {\n                continue;\n            }\n            if (r.startLineNumber > position.lineNumber) {\n                return r;\n            }\n            if (r.startColumn < position.column) {\n                continue;\n            }\n            return r;\n        }\n        return this._editor.getModel().getDecorationRange(this._decorations[0]);\n    }\n    _allDecorations() {\n        let result = [];\n        result = result.concat(this._decorations);\n        result = result.concat(this._overviewRulerApproximateDecorations);\n        if (this._findScopeDecorationIds.length) {\n            result.push(...this._findScopeDecorationIds);\n        }\n        if (this._rangeHighlightDecorationId) {\n            result.push(this._rangeHighlightDecorationId);\n        }\n        return result;\n    }\n}\nFindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({\n    description: 'current-find-match',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    zIndex: 13,\n    className: 'currentFindMatch',\n    showIfCollapsed: true,\n    overviewRuler: {\n        color: themeColorFromId(overviewRulerFindMatchForeground),\n        position: OverviewRulerLane.Center\n    },\n    minimap: {\n        color: themeColorFromId(minimapFindMatch),\n        position: MinimapPosition.Inline\n    }\n});\nFindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({\n    description: 'find-match',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    zIndex: 10,\n    className: 'findMatch',\n    showIfCollapsed: true,\n    overviewRuler: {\n        color: themeColorFromId(overviewRulerFindMatchForeground),\n        position: OverviewRulerLane.Center\n    },\n    minimap: {\n        color: themeColorFromId(minimapFindMatch),\n        position: MinimapPosition.Inline\n    }\n});\nFindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({\n    description: 'find-match-no-overview',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    className: 'findMatch',\n    showIfCollapsed: true\n});\nFindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({\n    description: 'find-match-only-overview',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    overviewRuler: {\n        color: themeColorFromId(overviewRulerFindMatchForeground),\n        position: OverviewRulerLane.Center\n    }\n});\nFindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({\n    description: 'find-range-highlight',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    className: 'rangeHighlight',\n    isWholeLine: true\n});\nFindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({\n    description: 'find-scope',\n    className: 'findScope',\n    isWholeLine: true\n});\n"]},"metadata":{},"sourceType":"module"}