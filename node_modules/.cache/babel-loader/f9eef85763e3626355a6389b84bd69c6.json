{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst foldingContext = {};\nexport const ID_SYNTAX_PROVIDER = 'syntax';\nexport class SyntaxRangeProvider {\n  constructor(editorModel, providers, handleFoldingRangesChange, limit) {\n    this.editorModel = editorModel;\n    this.providers = providers;\n    this.limit = limit;\n    this.id = ID_SYNTAX_PROVIDER;\n\n    for (const provider of providers) {\n      if (typeof provider.onDidChange === 'function') {\n        if (!this.disposables) {\n          this.disposables = new DisposableStore();\n        }\n\n        this.disposables.add(provider.onDidChange(handleFoldingRangesChange));\n      }\n    }\n  }\n\n  compute(cancellationToken, notifyTooManyRegions) {\n    return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {\n      if (ranges) {\n        let res = sanitizeRanges(ranges, this.limit, notifyTooManyRegions);\n        return res;\n      }\n\n      return null;\n    });\n  }\n\n  dispose() {\n    var _a;\n\n    (_a = this.disposables) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n\n}\n\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\n  let rangeData = null;\n  let promises = providers.map((provider, i) => {\n    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {\n      if (cancellationToken.isCancellationRequested) {\n        return;\n      }\n\n      if (Array.isArray(ranges)) {\n        if (!Array.isArray(rangeData)) {\n          rangeData = [];\n        }\n\n        let nLines = model.getLineCount();\n\n        for (let r of ranges) {\n          if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n            rangeData.push({\n              start: r.start,\n              end: r.end,\n              rank: i,\n              kind: r.kind\n            });\n          }\n        }\n      }\n    }, onUnexpectedExternalError);\n  });\n  return Promise.all(promises).then(_ => {\n    return rangeData;\n  });\n}\n\nexport class RangesCollector {\n  constructor(foldingRangesLimit, _notifyTooManyRegions) {\n    this._notifyTooManyRegions = _notifyTooManyRegions;\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._nestingLevels = [];\n    this._nestingLevelCounts = [];\n    this._types = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n\n  add(startLineNumber, endLineNumber, type, nestingLevel) {\n    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n      return;\n    }\n\n    let index = this._length;\n    this._startIndexes[index] = startLineNumber;\n    this._endIndexes[index] = endLineNumber;\n    this._nestingLevels[index] = nestingLevel;\n    this._types[index] = type;\n    this._length++;\n\n    if (nestingLevel < 30) {\n      this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n    }\n  }\n\n  toIndentRanges() {\n    if (this._length <= this._foldingRangesLimit) {\n      let startIndexes = new Uint32Array(this._length);\n      let endIndexes = new Uint32Array(this._length);\n\n      for (let i = 0; i < this._length; i++) {\n        startIndexes[i] = this._startIndexes[i];\n        endIndexes[i] = this._endIndexes[i];\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes, this._types);\n    } else {\n      if (this._notifyTooManyRegions) {\n        this._notifyTooManyRegions(this._foldingRangesLimit);\n      }\n\n      let entries = 0;\n      let maxLevel = this._nestingLevelCounts.length;\n\n      for (let i = 0; i < this._nestingLevelCounts.length; i++) {\n        let n = this._nestingLevelCounts[i];\n\n        if (n) {\n          if (n + entries > this._foldingRangesLimit) {\n            maxLevel = i;\n            break;\n          }\n\n          entries += n;\n        }\n      }\n\n      let startIndexes = new Uint32Array(this._foldingRangesLimit);\n      let endIndexes = new Uint32Array(this._foldingRangesLimit);\n      let types = [];\n\n      for (let i = 0, k = 0; i < this._length; i++) {\n        let level = this._nestingLevels[i];\n\n        if (level < maxLevel || level === maxLevel && entries++ < this._foldingRangesLimit) {\n          startIndexes[k] = this._startIndexes[i];\n          endIndexes[k] = this._endIndexes[i];\n          types[k] = this._types[i];\n          k++;\n        }\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes, types);\n    }\n  }\n\n}\nexport function sanitizeRanges(rangeData, limit, notifyTooManyRegions) {\n  let sorted = rangeData.sort((d1, d2) => {\n    let diff = d1.start - d2.start;\n\n    if (diff === 0) {\n      diff = d1.rank - d2.rank;\n    }\n\n    return diff;\n  });\n  let collector = new RangesCollector(limit, notifyTooManyRegions);\n  let top = undefined;\n  let previous = [];\n\n  for (let entry of sorted) {\n    if (!top) {\n      top = entry;\n      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n    } else {\n      if (entry.start > top.start) {\n        if (entry.end <= top.end) {\n          previous.push(top);\n          top = entry;\n          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        } else {\n          if (entry.start > top.end) {\n            do {\n              top = previous.pop();\n            } while (top && entry.start > top.end);\n\n            if (top) {\n              previous.push(top);\n            }\n\n            top = entry;\n          }\n\n          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        }\n      }\n    }\n  }\n\n  return collector.toIndentRanges();\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/syntaxRangeProvider.js"],"names":["onUnexpectedExternalError","DisposableStore","FoldingRegions","MAX_LINE_NUMBER","foldingContext","ID_SYNTAX_PROVIDER","SyntaxRangeProvider","constructor","editorModel","providers","handleFoldingRangesChange","limit","id","provider","onDidChange","disposables","add","compute","cancellationToken","notifyTooManyRegions","collectSyntaxRanges","then","ranges","res","sanitizeRanges","dispose","_a","model","rangeData","promises","map","i","Promise","resolve","provideFoldingRanges","isCancellationRequested","Array","isArray","nLines","getLineCount","r","start","end","push","rank","kind","all","_","RangesCollector","foldingRangesLimit","_notifyTooManyRegions","_startIndexes","_endIndexes","_nestingLevels","_nestingLevelCounts","_types","_length","_foldingRangesLimit","startLineNumber","endLineNumber","type","nestingLevel","index","toIndentRanges","startIndexes","Uint32Array","endIndexes","entries","maxLevel","length","n","types","k","level","sorted","sort","d1","d2","diff","collector","top","undefined","previous","entry","value","pop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst foldingContext = {};\nexport const ID_SYNTAX_PROVIDER = 'syntax';\nexport class SyntaxRangeProvider {\n    constructor(editorModel, providers, handleFoldingRangesChange, limit) {\n        this.editorModel = editorModel;\n        this.providers = providers;\n        this.limit = limit;\n        this.id = ID_SYNTAX_PROVIDER;\n        for (const provider of providers) {\n            if (typeof provider.onDidChange === 'function') {\n                if (!this.disposables) {\n                    this.disposables = new DisposableStore();\n                }\n                this.disposables.add(provider.onDidChange(handleFoldingRangesChange));\n            }\n        }\n    }\n    compute(cancellationToken, notifyTooManyRegions) {\n        return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {\n            if (ranges) {\n                let res = sanitizeRanges(ranges, this.limit, notifyTooManyRegions);\n                return res;\n            }\n            return null;\n        });\n    }\n    dispose() {\n        var _a;\n        (_a = this.disposables) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n}\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\n    let rangeData = null;\n    let promises = providers.map((provider, i) => {\n        return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {\n            if (cancellationToken.isCancellationRequested) {\n                return;\n            }\n            if (Array.isArray(ranges)) {\n                if (!Array.isArray(rangeData)) {\n                    rangeData = [];\n                }\n                let nLines = model.getLineCount();\n                for (let r of ranges) {\n                    if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n                        rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });\n                    }\n                }\n            }\n        }, onUnexpectedExternalError);\n    });\n    return Promise.all(promises).then(_ => {\n        return rangeData;\n    });\n}\nexport class RangesCollector {\n    constructor(foldingRangesLimit, _notifyTooManyRegions) {\n        this._notifyTooManyRegions = _notifyTooManyRegions;\n        this._startIndexes = [];\n        this._endIndexes = [];\n        this._nestingLevels = [];\n        this._nestingLevelCounts = [];\n        this._types = [];\n        this._length = 0;\n        this._foldingRangesLimit = foldingRangesLimit;\n    }\n    add(startLineNumber, endLineNumber, type, nestingLevel) {\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n            return;\n        }\n        let index = this._length;\n        this._startIndexes[index] = startLineNumber;\n        this._endIndexes[index] = endLineNumber;\n        this._nestingLevels[index] = nestingLevel;\n        this._types[index] = type;\n        this._length++;\n        if (nestingLevel < 30) {\n            this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n        }\n    }\n    toIndentRanges() {\n        if (this._length <= this._foldingRangesLimit) {\n            let startIndexes = new Uint32Array(this._length);\n            let endIndexes = new Uint32Array(this._length);\n            for (let i = 0; i < this._length; i++) {\n                startIndexes[i] = this._startIndexes[i];\n                endIndexes[i] = this._endIndexes[i];\n            }\n            return new FoldingRegions(startIndexes, endIndexes, this._types);\n        }\n        else {\n            if (this._notifyTooManyRegions) {\n                this._notifyTooManyRegions(this._foldingRangesLimit);\n            }\n            let entries = 0;\n            let maxLevel = this._nestingLevelCounts.length;\n            for (let i = 0; i < this._nestingLevelCounts.length; i++) {\n                let n = this._nestingLevelCounts[i];\n                if (n) {\n                    if (n + entries > this._foldingRangesLimit) {\n                        maxLevel = i;\n                        break;\n                    }\n                    entries += n;\n                }\n            }\n            let startIndexes = new Uint32Array(this._foldingRangesLimit);\n            let endIndexes = new Uint32Array(this._foldingRangesLimit);\n            let types = [];\n            for (let i = 0, k = 0; i < this._length; i++) {\n                let level = this._nestingLevels[i];\n                if (level < maxLevel || (level === maxLevel && entries++ < this._foldingRangesLimit)) {\n                    startIndexes[k] = this._startIndexes[i];\n                    endIndexes[k] = this._endIndexes[i];\n                    types[k] = this._types[i];\n                    k++;\n                }\n            }\n            return new FoldingRegions(startIndexes, endIndexes, types);\n        }\n    }\n}\nexport function sanitizeRanges(rangeData, limit, notifyTooManyRegions) {\n    let sorted = rangeData.sort((d1, d2) => {\n        let diff = d1.start - d2.start;\n        if (diff === 0) {\n            diff = d1.rank - d2.rank;\n        }\n        return diff;\n    });\n    let collector = new RangesCollector(limit, notifyTooManyRegions);\n    let top = undefined;\n    let previous = [];\n    for (let entry of sorted) {\n        if (!top) {\n            top = entry;\n            collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        }\n        else {\n            if (entry.start > top.start) {\n                if (entry.end <= top.end) {\n                    previous.push(top);\n                    top = entry;\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                }\n                else {\n                    if (entry.start > top.end) {\n                        do {\n                            top = previous.pop();\n                        } while (top && entry.start > top.end);\n                        if (top) {\n                            previous.push(top);\n                        }\n                        top = entry;\n                    }\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n                }\n            }\n        }\n    }\n    return collector.toIndentRanges();\n}\n"]},"metadata":{},"sourceType":"module"}