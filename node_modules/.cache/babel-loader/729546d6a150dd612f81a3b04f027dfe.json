{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\n\nexport class SparseTokensStore {\n  constructor(languageIdCodec) {\n    this._pieces = [];\n    this._isComplete = false;\n    this._languageIdCodec = languageIdCodec;\n  }\n\n  flush() {\n    this._pieces = [];\n    this._isComplete = false;\n  }\n\n  isEmpty() {\n    return this._pieces.length === 0;\n  }\n\n  set(pieces, isComplete) {\n    this._pieces = pieces || [];\n    this._isComplete = isComplete;\n  }\n\n  setPartial(_range, pieces) {\n    // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n    let range = _range;\n\n    if (pieces.length > 0) {\n      const _firstRange = pieces[0].getRange();\n\n      const _lastRange = pieces[pieces.length - 1].getRange();\n\n      if (!_firstRange || !_lastRange) {\n        return _range;\n      }\n\n      range = _range.plusRange(_firstRange).plusRange(_lastRange);\n    }\n\n    let insertPosition = null;\n\n    for (let i = 0, len = this._pieces.length; i < len; i++) {\n      const piece = this._pieces[i];\n\n      if (piece.endLineNumber < range.startLineNumber) {\n        // this piece is before the range\n        continue;\n      }\n\n      if (piece.startLineNumber > range.endLineNumber) {\n        // this piece is after the range, so mark the spot before this piece\n        // as a good insertion position and stop looping\n        insertPosition = insertPosition || {\n          index: i\n        };\n        break;\n      } // this piece might intersect with the range\n\n\n      piece.removeTokens(range);\n\n      if (piece.isEmpty()) {\n        // remove the piece if it became empty\n        this._pieces.splice(i, 1);\n\n        i--;\n        len--;\n        continue;\n      }\n\n      if (piece.endLineNumber < range.startLineNumber) {\n        // after removal, this piece is before the range\n        continue;\n      }\n\n      if (piece.startLineNumber > range.endLineNumber) {\n        // after removal, this piece is after the range\n        insertPosition = insertPosition || {\n          index: i\n        };\n        continue;\n      } // after removal, this piece contains the range\n\n\n      const [a, b] = piece.split(range);\n\n      if (a.isEmpty()) {\n        // this piece is actually after the range\n        insertPosition = insertPosition || {\n          index: i\n        };\n        continue;\n      }\n\n      if (b.isEmpty()) {\n        // this piece is actually before the range\n        continue;\n      }\n\n      this._pieces.splice(i, 1, a, b);\n\n      i++;\n      len++;\n      insertPosition = insertPosition || {\n        index: i\n      };\n    }\n\n    insertPosition = insertPosition || {\n      index: this._pieces.length\n    };\n\n    if (pieces.length > 0) {\n      this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n    } // console.log(`I HAVE ${this._pieces.length} pieces`);\n    // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n\n\n    return range;\n  }\n\n  isComplete() {\n    return this._isComplete;\n  }\n\n  addSparseTokens(lineNumber, aTokens) {\n    const pieces = this._pieces;\n\n    if (pieces.length === 0) {\n      return aTokens;\n    }\n\n    const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n\n    const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n\n    if (!bTokens) {\n      return aTokens;\n    }\n\n    const aLen = aTokens.getCount();\n    const bLen = bTokens.getCount();\n    let aIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastEndOffset = 0;\n\n    const emitToken = (endOffset, metadata) => {\n      if (endOffset === lastEndOffset) {\n        return;\n      }\n\n      lastEndOffset = endOffset;\n      result[resultLen++] = endOffset;\n      result[resultLen++] = metadata;\n    };\n\n    for (let bIndex = 0; bIndex < bLen; bIndex++) {\n      const bStartCharacter = bTokens.getStartCharacter(bIndex);\n      const bEndCharacter = bTokens.getEndCharacter(bIndex);\n      const bMetadata = bTokens.getMetadata(bIndex);\n      const bMask = ((bMetadata & 1\n      /* SEMANTIC_USE_ITALIC */\n      ? 1024\n      /* ITALIC_MASK */\n      : 0) | (bMetadata & 2\n      /* SEMANTIC_USE_BOLD */\n      ? 2048\n      /* BOLD_MASK */\n      : 0) | (bMetadata & 4\n      /* SEMANTIC_USE_UNDERLINE */\n      ? 4096\n      /* UNDERLINE_MASK */\n      : 0) | (bMetadata & 8\n      /* SEMANTIC_USE_STRIKETHROUGH */\n      ? 8192\n      /* STRIKETHROUGH_MASK */\n      : 0) | (bMetadata & 16\n      /* SEMANTIC_USE_FOREGROUND */\n      ? 8372224\n      /* FOREGROUND_MASK */\n      : 0) | (bMetadata & 32\n      /* SEMANTIC_USE_BACKGROUND */\n      ? 4286578688\n      /* BACKGROUND_MASK */\n      : 0)) >>> 0;\n      const aMask = ~bMask >>> 0; // push any token from `a` that is before `b`\n\n      while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n        aIndex++;\n      } // push the token from `a` if it intersects the token from `b`\n\n\n      if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n        emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n      } // skip any tokens from `a` that are contained inside `b`\n\n\n      while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);\n        aIndex++;\n      }\n\n      if (aIndex < aLen) {\n        emitToken(bEndCharacter, aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);\n\n        if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n          // `a` ends exactly at the same spot as `b`!\n          aIndex++;\n        }\n      } else {\n        const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1); // push the token from `b`\n\n        emitToken(bEndCharacter, aTokens.getMetadata(aMergeIndex) & aMask | bMetadata & bMask);\n      }\n    } // push the remaining tokens from `a`\n\n\n    while (aIndex < aLen) {\n      emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n      aIndex++;\n    }\n\n    return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n  }\n\n  static _findFirstPieceWithLine(pieces, lineNumber) {\n    let low = 0;\n    let high = pieces.length - 1;\n\n    while (low < high) {\n      let mid = low + Math.floor((high - low) / 2);\n\n      if (pieces[mid].endLineNumber < lineNumber) {\n        low = mid + 1;\n      } else if (pieces[mid].startLineNumber > lineNumber) {\n        high = mid - 1;\n      } else {\n        while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n          mid--;\n        }\n\n        return mid;\n      }\n    }\n\n    return low;\n  }\n\n  acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    for (const piece of this._pieces) {\n      piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js"],"names":["arrays","LineTokens","SparseTokensStore","constructor","languageIdCodec","_pieces","_isComplete","_languageIdCodec","flush","isEmpty","length","set","pieces","isComplete","setPartial","_range","range","_firstRange","getRange","_lastRange","plusRange","insertPosition","i","len","piece","endLineNumber","startLineNumber","index","removeTokens","splice","a","b","split","arrayInsert","addSparseTokens","lineNumber","aTokens","pieceIndex","_findFirstPieceWithLine","bTokens","getLineTokens","aLen","getCount","bLen","aIndex","result","resultLen","lastEndOffset","emitToken","endOffset","metadata","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","getMetadata","bMask","aMask","getEndOffset","getStartOffset","aMergeIndex","Math","min","max","Uint32Array","getLineContent","low","high","mid","floor","acceptEdit","eolCount","firstLineLength","lastLineLength","firstCharCode"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* SEMANTIC_USE_ITALIC */) ? 1024 /* ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* SEMANTIC_USE_BOLD */) ? 2048 /* BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */) ? 4096 /* UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* SEMANTIC_USE_STRIKETHROUGH */) ? 8192 /* STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* SEMANTIC_USE_FOREGROUND */) ? 8372224 /* FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* SEMANTIC_USE_BACKGROUND */) ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}