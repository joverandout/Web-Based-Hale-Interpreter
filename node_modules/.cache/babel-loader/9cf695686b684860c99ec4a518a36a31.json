{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from './async.js'; // When comparing large numbers of strings it's better for performance to create an\n// Intl.Collator object and use the function provided by its compare property\n// than it is to use String.prototype.localeCompare()\n// A collator with numeric sorting enabled, and no sensitivity to case, accents or diacritics.\n\nconst intlFileNameCollatorBaseNumeric = new IdleValue(() => {\n  const collator = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: 'base'\n  });\n  return {\n    collator: collator,\n    collatorIsNumeric: collator.resolvedOptions().numeric\n  };\n}); // A collator with numeric sorting enabled.\n\nconst intlFileNameCollatorNumeric = new IdleValue(() => {\n  const collator = new Intl.Collator(undefined, {\n    numeric: true\n  });\n  return {\n    collator: collator\n  };\n}); // A collator with numeric sorting enabled, and sensitivity to accents and diacritics but not case.\n\nconst intlFileNameCollatorNumericCaseInsensitive = new IdleValue(() => {\n  const collator = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: 'accent'\n  });\n  return {\n    collator: collator\n  };\n});\n/** Compares filenames without distinguishing the name from the extension. Disambiguates by unicode comparison. */\n\nexport function compareFileNames(one, other, caseSensitive = false) {\n  const a = one || '';\n  const b = other || '';\n  const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b); // Using the numeric option will make compare(`foo1`, `foo01`) === 0. Disambiguate.\n\n  if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {\n    return a < b ? -1 : 1;\n  }\n\n  return result;\n}\nexport function compareAnything(one, other, lookFor) {\n  const elementAName = one.toLowerCase();\n  const elementBName = other.toLowerCase(); // Sort prefix matches over non prefix matches\n\n  const prefixCompare = compareByPrefix(one, other, lookFor);\n\n  if (prefixCompare) {\n    return prefixCompare;\n  } // Sort suffix matches over non suffix matches\n\n\n  const elementASuffixMatch = elementAName.endsWith(lookFor);\n  const elementBSuffixMatch = elementBName.endsWith(lookFor);\n\n  if (elementASuffixMatch !== elementBSuffixMatch) {\n    return elementASuffixMatch ? -1 : 1;\n  } // Understand file names\n\n\n  const r = compareFileNames(elementAName, elementBName);\n\n  if (r !== 0) {\n    return r;\n  } // Compare by name\n\n\n  return elementAName.localeCompare(elementBName);\n}\nexport function compareByPrefix(one, other, lookFor) {\n  const elementAName = one.toLowerCase();\n  const elementBName = other.toLowerCase(); // Sort prefix matches over non prefix matches\n\n  const elementAPrefixMatch = elementAName.startsWith(lookFor);\n  const elementBPrefixMatch = elementBName.startsWith(lookFor);\n\n  if (elementAPrefixMatch !== elementBPrefixMatch) {\n    return elementAPrefixMatch ? -1 : 1;\n  } // Same prefix: Sort shorter matches to the top to have those on top that match more precisely\n  else if (elementAPrefixMatch && elementBPrefixMatch) {\n    if (elementAName.length < elementBName.length) {\n      return -1;\n    }\n\n    if (elementAName.length > elementBName.length) {\n      return 1;\n    }\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/comparers.js"],"names":["IdleValue","intlFileNameCollatorBaseNumeric","collator","Intl","Collator","undefined","numeric","sensitivity","collatorIsNumeric","resolvedOptions","intlFileNameCollatorNumeric","intlFileNameCollatorNumericCaseInsensitive","compareFileNames","one","other","caseSensitive","a","b","result","value","compare","compareAnything","lookFor","elementAName","toLowerCase","elementBName","prefixCompare","compareByPrefix","elementASuffixMatch","endsWith","elementBSuffixMatch","r","localeCompare","elementAPrefixMatch","startsWith","elementBPrefixMatch","length"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from './async.js';\n// When comparing large numbers of strings it's better for performance to create an\n// Intl.Collator object and use the function provided by its compare property\n// than it is to use String.prototype.localeCompare()\n// A collator with numeric sorting enabled, and no sensitivity to case, accents or diacritics.\nconst intlFileNameCollatorBaseNumeric = new IdleValue(() => {\n    const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\n    return {\n        collator: collator,\n        collatorIsNumeric: collator.resolvedOptions().numeric\n    };\n});\n// A collator with numeric sorting enabled.\nconst intlFileNameCollatorNumeric = new IdleValue(() => {\n    const collator = new Intl.Collator(undefined, { numeric: true });\n    return {\n        collator: collator\n    };\n});\n// A collator with numeric sorting enabled, and sensitivity to accents and diacritics but not case.\nconst intlFileNameCollatorNumericCaseInsensitive = new IdleValue(() => {\n    const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'accent' });\n    return {\n        collator: collator\n    };\n});\n/** Compares filenames without distinguishing the name from the extension. Disambiguates by unicode comparison. */\nexport function compareFileNames(one, other, caseSensitive = false) {\n    const a = one || '';\n    const b = other || '';\n    const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);\n    // Using the numeric option will make compare(`foo1`, `foo01`) === 0. Disambiguate.\n    if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {\n        return a < b ? -1 : 1;\n    }\n    return result;\n}\nexport function compareAnything(one, other, lookFor) {\n    const elementAName = one.toLowerCase();\n    const elementBName = other.toLowerCase();\n    // Sort prefix matches over non prefix matches\n    const prefixCompare = compareByPrefix(one, other, lookFor);\n    if (prefixCompare) {\n        return prefixCompare;\n    }\n    // Sort suffix matches over non suffix matches\n    const elementASuffixMatch = elementAName.endsWith(lookFor);\n    const elementBSuffixMatch = elementBName.endsWith(lookFor);\n    if (elementASuffixMatch !== elementBSuffixMatch) {\n        return elementASuffixMatch ? -1 : 1;\n    }\n    // Understand file names\n    const r = compareFileNames(elementAName, elementBName);\n    if (r !== 0) {\n        return r;\n    }\n    // Compare by name\n    return elementAName.localeCompare(elementBName);\n}\nexport function compareByPrefix(one, other, lookFor) {\n    const elementAName = one.toLowerCase();\n    const elementBName = other.toLowerCase();\n    // Sort prefix matches over non prefix matches\n    const elementAPrefixMatch = elementAName.startsWith(lookFor);\n    const elementBPrefixMatch = elementBName.startsWith(lookFor);\n    if (elementAPrefixMatch !== elementBPrefixMatch) {\n        return elementAPrefixMatch ? -1 : 1;\n    }\n    // Same prefix: Sort shorter matches to the top to have those on top that match more precisely\n    else if (elementAPrefixMatch && elementBPrefixMatch) {\n        if (elementAName.length < elementBName.length) {\n            return -1;\n        }\n        if (elementAName.length > elementBName.length) {\n            return 1;\n        }\n    }\n    return 0;\n}\n"]},"metadata":{},"sourceType":"module"}