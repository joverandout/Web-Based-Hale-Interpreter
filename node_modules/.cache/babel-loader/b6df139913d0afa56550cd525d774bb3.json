{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\n\nfunction escapeNewLine(str) {\n  return str.replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n}\n\nexport class TextChange {\n  constructor(oldPosition, oldText, newPosition, newText) {\n    this.oldPosition = oldPosition;\n    this.oldText = oldText;\n    this.newPosition = newPosition;\n    this.newText = newText;\n  }\n\n  get oldLength() {\n    return this.oldText.length;\n  }\n\n  get oldEnd() {\n    return this.oldPosition + this.oldText.length;\n  }\n\n  get newLength() {\n    return this.newText.length;\n  }\n\n  get newEnd() {\n    return this.newPosition + this.newText.length;\n  }\n\n  toString() {\n    if (this.oldText.length === 0) {\n      return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n    }\n\n    if (this.newText.length === 0) {\n      return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n    }\n\n    return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n  }\n\n  static _writeStringSize(str) {\n    return 4 + 2 * str.length;\n  }\n\n  static _writeString(b, str, offset) {\n    const len = str.length;\n    buffer.writeUInt32BE(b, len, offset);\n    offset += 4;\n\n    for (let i = 0; i < len; i++) {\n      buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n      offset += 2;\n    }\n\n    return offset;\n  }\n\n  static _readString(b, offset) {\n    const len = buffer.readUInt32BE(b, offset);\n    offset += 4;\n    return decodeUTF16LE(b, offset, len);\n  }\n\n  writeSize() {\n    return +4 // oldPosition\n    + 4 // newPosition\n    + TextChange._writeStringSize(this.oldText) + TextChange._writeStringSize(this.newText);\n  }\n\n  write(b, offset) {\n    buffer.writeUInt32BE(b, this.oldPosition, offset);\n    offset += 4;\n    buffer.writeUInt32BE(b, this.newPosition, offset);\n    offset += 4;\n    offset = TextChange._writeString(b, this.oldText, offset);\n    offset = TextChange._writeString(b, this.newText, offset);\n    return offset;\n  }\n\n  static read(b, offset, dest) {\n    const oldPosition = buffer.readUInt32BE(b, offset);\n    offset += 4;\n    const newPosition = buffer.readUInt32BE(b, offset);\n    offset += 4;\n\n    const oldText = TextChange._readString(b, offset);\n\n    offset += TextChange._writeStringSize(oldText);\n\n    const newText = TextChange._readString(b, offset);\n\n    offset += TextChange._writeStringSize(newText);\n    dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n    return offset;\n  }\n\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n  if (prevEdits === null || prevEdits.length === 0) {\n    return currEdits;\n  }\n\n  const compressor = new TextChangeCompressor(prevEdits, currEdits);\n  return compressor.compress();\n}\n\nclass TextChangeCompressor {\n  constructor(prevEdits, currEdits) {\n    this._prevEdits = prevEdits;\n    this._currEdits = currEdits;\n    this._result = [];\n    this._resultLen = 0;\n    this._prevLen = this._prevEdits.length;\n    this._prevDeltaOffset = 0;\n    this._currLen = this._currEdits.length;\n    this._currDeltaOffset = 0;\n  }\n\n  compress() {\n    let prevIndex = 0;\n    let currIndex = 0;\n\n    let prevEdit = this._getPrev(prevIndex);\n\n    let currEdit = this._getCurr(currIndex);\n\n    while (prevIndex < this._prevLen || currIndex < this._currLen) {\n      if (prevEdit === null) {\n        this._acceptCurr(currEdit);\n\n        currEdit = this._getCurr(++currIndex);\n        continue;\n      }\n\n      if (currEdit === null) {\n        this._acceptPrev(prevEdit);\n\n        prevEdit = this._getPrev(++prevIndex);\n        continue;\n      }\n\n      if (currEdit.oldEnd <= prevEdit.newPosition) {\n        this._acceptCurr(currEdit);\n\n        currEdit = this._getCurr(++currIndex);\n        continue;\n      }\n\n      if (prevEdit.newEnd <= currEdit.oldPosition) {\n        this._acceptPrev(prevEdit);\n\n        prevEdit = this._getPrev(++prevIndex);\n        continue;\n      }\n\n      if (currEdit.oldPosition < prevEdit.newPosition) {\n        const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n\n        this._acceptCurr(e1);\n\n        currEdit = e2;\n        continue;\n      }\n\n      if (prevEdit.newPosition < currEdit.oldPosition) {\n        const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n\n        this._acceptPrev(e1);\n\n        prevEdit = e2;\n        continue;\n      } // At this point, currEdit.oldPosition === prevEdit.newPosition\n\n\n      let mergePrev;\n      let mergeCurr;\n\n      if (currEdit.oldEnd === prevEdit.newEnd) {\n        mergePrev = prevEdit;\n        mergeCurr = currEdit;\n        prevEdit = this._getPrev(++prevIndex);\n        currEdit = this._getCurr(++currIndex);\n      } else if (currEdit.oldEnd < prevEdit.newEnd) {\n        const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n\n        mergePrev = e1;\n        mergeCurr = currEdit;\n        prevEdit = e2;\n        currEdit = this._getCurr(++currIndex);\n      } else {\n        const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n\n        mergePrev = prevEdit;\n        mergeCurr = e1;\n        prevEdit = this._getPrev(++prevIndex);\n        currEdit = e2;\n      }\n\n      this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n      this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n      this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n    }\n\n    const merged = TextChangeCompressor._merge(this._result);\n\n    const cleaned = TextChangeCompressor._removeNoOps(merged);\n\n    return cleaned;\n  }\n\n  _acceptCurr(currEdit) {\n    this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n    this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n  }\n\n  _getCurr(currIndex) {\n    return currIndex < this._currLen ? this._currEdits[currIndex] : null;\n  }\n\n  _acceptPrev(prevEdit) {\n    this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n    this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n  }\n\n  _getPrev(prevIndex) {\n    return prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null;\n  }\n\n  static _rebaseCurr(prevDeltaOffset, currEdit) {\n    return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n  }\n\n  static _rebasePrev(currDeltaOffset, prevEdit) {\n    return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n  }\n\n  static _splitPrev(edit, offset) {\n    const preText = edit.newText.substr(0, offset);\n    const postText = edit.newText.substr(offset);\n    return [new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText), new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)];\n  }\n\n  static _splitCurr(edit, offset) {\n    const preText = edit.oldText.substr(0, offset);\n    const postText = edit.oldText.substr(offset);\n    return [new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText), new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')];\n  }\n\n  static _merge(edits) {\n    if (edits.length === 0) {\n      return edits;\n    }\n\n    const result = [];\n    let resultLen = 0;\n    let prev = edits[0];\n\n    for (let i = 1; i < edits.length; i++) {\n      const curr = edits[i];\n\n      if (prev.oldEnd === curr.oldPosition) {\n        // Merge into `prev`\n        prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n      } else {\n        result[resultLen++] = prev;\n        prev = curr;\n      }\n    }\n\n    result[resultLen++] = prev;\n    return result;\n  }\n\n  static _removeNoOps(edits) {\n    if (edits.length === 0) {\n      return edits;\n    }\n\n    const result = [];\n    let resultLen = 0;\n\n    for (let i = 0; i < edits.length; i++) {\n      const edit = edits[i];\n\n      if (edit.oldText === edit.newText) {\n        continue;\n      }\n\n      result[resultLen++] = edit;\n    }\n\n    return result;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js"],"names":["buffer","decodeUTF16LE","escapeNewLine","str","replace","TextChange","constructor","oldPosition","oldText","newPosition","newText","oldLength","length","oldEnd","newLength","newEnd","toString","_writeStringSize","_writeString","b","offset","len","writeUInt32BE","i","writeUInt16LE","charCodeAt","_readString","readUInt32BE","writeSize","write","read","dest","push","compressConsecutiveTextChanges","prevEdits","currEdits","compressor","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","_acceptCurr","_acceptPrev","e1","e2","_splitCurr","_splitPrev","mergePrev","mergeCurr","merged","_merge","cleaned","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","result","resultLen","prev","curr"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}