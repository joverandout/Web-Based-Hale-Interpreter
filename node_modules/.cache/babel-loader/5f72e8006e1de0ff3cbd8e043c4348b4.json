{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from './viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from './viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n  constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n    this._editorId = editorId;\n    this.model = model;\n    this._validModelVersionId = -1;\n    this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n    this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n    this.fontInfo = fontInfo;\n    this.tabSize = tabSize;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n\n    this._constructLines(\n    /*resetHiddenAreas*/\n    true, null);\n  }\n\n  dispose() {\n    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n  }\n\n  createCoordinatesConverter() {\n    return new CoordinatesConverter(this);\n  }\n\n  _constructLines(resetHiddenAreas, previousLineBreaks) {\n    this.modelLineProjections = [];\n\n    if (resetHiddenAreas) {\n      this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n\n    const linesContent = this.model.getLinesContent();\n    const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n    const lineCount = linesContent.length;\n    const lineBreaksComputer = this.createLineBreaksComputer();\n    const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n\n    for (let i = 0; i < lineCount; i++) {\n      const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n      lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n    }\n\n    const linesBreaks = lineBreaksComputer.finalize();\n    const values = [];\n    const hiddenAreas = this.hiddenAreasDecorationIds.map(areaId => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n    let hiddenAreaStart = 1,\n        hiddenAreaEnd = 0;\n    let hiddenAreaIdx = -1;\n    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n\n    for (let i = 0; i < lineCount; i++) {\n      const lineNumber = i + 1;\n\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n      }\n\n      const isInHiddenArea = lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd;\n      const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n      values[i] = line.getViewLineCount();\n      this.modelLineProjections[i] = line;\n    }\n\n    this._validModelVersionId = this.model.getVersionId();\n    this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n  }\n\n  getHiddenAreas() {\n    return this.hiddenAreasDecorationIds.map(decId => this.model.getDecorationRange(decId));\n  }\n\n  setHiddenAreas(_ranges) {\n    const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n\n    const newRanges = normalizeLineRanges(validatedRanges); // TODO@Martin: Please stop calling this method on each model change!\n    // This checks if there really was a change\n\n    const oldRanges = this.hiddenAreasDecorationIds.map(areaId => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n\n    if (newRanges.length === oldRanges.length) {\n      let hasDifference = false;\n\n      for (let i = 0; i < newRanges.length; i++) {\n        if (!newRanges[i].equalsRange(oldRanges[i])) {\n          hasDifference = true;\n          break;\n        }\n      }\n\n      if (!hasDifference) {\n        return false;\n      }\n    }\n\n    const newDecorations = newRanges.map(r => ({\n      range: r,\n      options: ModelDecorationOptions.EMPTY\n    }));\n    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n    const hiddenAreas = newRanges;\n    let hiddenAreaStart = 1,\n        hiddenAreaEnd = 0;\n    let hiddenAreaIdx = -1;\n    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n    let hasVisibleLine = false;\n\n    for (let i = 0; i < this.modelLineProjections.length; i++) {\n      const lineNumber = i + 1;\n\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n      }\n\n      let lineChanged = false;\n\n      if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n        // Line should be hidden\n        if (this.modelLineProjections[i].isVisible()) {\n          this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n          lineChanged = true;\n        }\n      } else {\n        hasVisibleLine = true; // Line should be visible\n\n        if (!this.modelLineProjections[i].isVisible()) {\n          this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n          lineChanged = true;\n        }\n      }\n\n      if (lineChanged) {\n        const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n        this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n      }\n    }\n\n    if (!hasVisibleLine) {\n      // Cannot have everything be hidden => reveal everything!\n      this.setHiddenAreas([]);\n    }\n\n    return true;\n  }\n\n  modelPositionIsVisible(modelLineNumber, _modelColumn) {\n    if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n      // invalid arguments\n      return false;\n    }\n\n    return this.modelLineProjections[modelLineNumber - 1].isVisible();\n  }\n\n  getModelLineViewLineCount(modelLineNumber) {\n    if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n      // invalid arguments\n      return 1;\n    }\n\n    return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n  }\n\n  setTabSize(newTabSize) {\n    if (this.tabSize === newTabSize) {\n      return false;\n    }\n\n    this.tabSize = newTabSize;\n\n    this._constructLines(\n    /*resetHiddenAreas*/\n    false, null);\n\n    return true;\n  }\n\n  setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n    const equalFontInfo = this.fontInfo.equals(fontInfo);\n    const equalWrappingStrategy = this.wrappingStrategy === wrappingStrategy;\n    const equalWrappingColumn = this.wrappingColumn === wrappingColumn;\n    const equalWrappingIndent = this.wrappingIndent === wrappingIndent;\n\n    if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n      return false;\n    }\n\n    const onlyWrappingColumnChanged = equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent;\n    this.fontInfo = fontInfo;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n    let previousLineBreaks = null;\n\n    if (onlyWrappingColumnChanged) {\n      previousLineBreaks = [];\n\n      for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n        previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n      }\n    }\n\n    this._constructLines(\n    /*resetHiddenAreas*/\n    false, previousLineBreaks);\n\n    return true;\n  }\n\n  createLineBreaksComputer() {\n    const lineBreaksComputerFactory = this.wrappingStrategy === 'advanced' ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory;\n    return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n  }\n\n  onModelFlushed() {\n    this._constructLines(\n    /*resetHiddenAreas*/\n    true, null);\n  }\n\n  onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n    if (!versionId || versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    }\n\n    const outputFromLineNumber = fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1;\n    const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n    this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n  }\n\n  onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n    if (!versionId || versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    } // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n\n\n    const isInHiddenArea = fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible();\n    const outputFromLineNumber = fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1;\n    let totalOutputLineCount = 0;\n    const insertLines = [];\n    const insertPrefixSumValues = [];\n\n    for (let i = 0, len = lineBreaks.length; i < len; i++) {\n      const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n      insertLines.push(line);\n      const outputLineCount = line.getViewLineCount();\n      totalOutputLineCount += outputLineCount;\n      insertPrefixSumValues[i] = outputLineCount;\n    } // TODO@Alex: use arrays.arrayInsert\n\n\n    this.modelLineProjections = this.modelLineProjections.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.modelLineProjections.slice(fromLineNumber - 1));\n    this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n    return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n  }\n\n  onModelLineChanged(versionId, lineNumber, lineBreakData) {\n    if (versionId !== null && versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return [false, null, null, null];\n    }\n\n    const lineIndex = lineNumber - 1;\n    const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n    const isVisible = this.modelLineProjections[lineIndex].isVisible();\n    const line = createModelLineProjection(lineBreakData, isVisible);\n    this.modelLineProjections[lineIndex] = line;\n    const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n    let lineMappingChanged = false;\n    let changeFrom = 0;\n    let changeTo = -1;\n    let insertFrom = 0;\n    let insertTo = -1;\n    let deleteFrom = 0;\n    let deleteTo = -1;\n\n    if (oldOutputLineCount > newOutputLineCount) {\n      changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n      deleteFrom = changeTo + 1;\n      deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else if (oldOutputLineCount < newOutputLineCount) {\n      changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n      changeTo = changeFrom + oldOutputLineCount - 1;\n      insertFrom = changeTo + 1;\n      insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else {\n      changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n    }\n\n    this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n    const viewLinesChangedEvent = changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null;\n    const viewLinesInsertedEvent = insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null;\n    const viewLinesDeletedEvent = deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null;\n    return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n  }\n\n  acceptVersionId(versionId) {\n    this._validModelVersionId = versionId;\n\n    if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n      // At least one line must be visible => reset hidden areas\n      this.setHiddenAreas([]);\n    }\n  }\n\n  getViewLineCount() {\n    return this.projectedModelLineLineCounts.getTotalSum();\n  }\n\n  _toValidViewLineNumber(viewLineNumber) {\n    if (viewLineNumber < 1) {\n      return 1;\n    }\n\n    const viewLineCount = this.getViewLineCount();\n\n    if (viewLineNumber > viewLineCount) {\n      return viewLineCount;\n    }\n\n    return viewLineNumber | 0;\n  }\n\n  getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    minLineNumber = this._toValidViewLineNumber(minLineNumber);\n    maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n    const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n    const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n    const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n    const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n    const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n    const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n    return {\n      startLineNumber: viewStartPosition.lineNumber,\n      endLineNumber: viewEndPosition.lineNumber,\n      indent: result.indent\n    };\n  } // #region ViewLineInfo\n\n\n  getViewLineInfo(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n    const lineIndex = r.index;\n    const remainder = r.remainder;\n    return new ViewLineInfo(lineIndex + 1, remainder);\n  }\n\n  getMinColumnOfViewLine(viewLineInfo) {\n    return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n  }\n\n  getModelStartPositionOfViewLine(viewLineInfo) {\n    const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n    const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n    return new Position(viewLineInfo.modelLineNumber, column);\n  }\n\n  getModelEndPositionOfViewLine(viewLineInfo) {\n    const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n    const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n    return new Position(viewLineInfo.modelLineNumber, column);\n  }\n\n  getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n    const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n    const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n    const result = new Array();\n    let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n    let viewLines = new Array();\n\n    for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n      const line = this.modelLineProjections[curModelLine - 1];\n\n      if (line.isVisible()) {\n        const startOffset = curModelLine === startViewLine.modelLineNumber ? startViewLine.modelLineWrappedLineIdx : 0;\n        const endOffset = curModelLine === endViewLine.modelLineNumber ? endViewLine.modelLineWrappedLineIdx + 1 : line.getViewLineCount();\n\n        for (let i = startOffset; i < endOffset; i++) {\n          viewLines.push(new ViewLineInfo(curModelLine, i));\n        }\n      }\n\n      if (!line.isVisible() && lastVisibleModelPos) {\n        const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n        const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n        result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        viewLines = [];\n        lastVisibleModelPos = null;\n      } else if (line.isVisible() && !lastVisibleModelPos) {\n        lastVisibleModelPos = new Position(curModelLine, 1);\n      }\n    }\n\n    if (lastVisibleModelPos) {\n      const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n      result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n    }\n\n    return result;\n  } // #endregion\n\n\n  getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n    const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n    const resultPerViewLine = [];\n\n    for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n      const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n      const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n\n      for (const viewLineInfo of group.viewLines) {\n        if (viewLineInfo.isWrappedLineContinuation && this.getMinColumnOfViewLine(viewLineInfo) === 1) {\n          // Don't add indent guides when the wrapped line continuation has no wrapping-indentation.\n          resultPerViewLine.push([]);\n        } else {\n          let bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber]; // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n          // model-columns must be converted to view-model columns.\n\n          bracketGuides = bracketGuides.map(g => g.horizontalLine ? new IndentGuide(g.visibleColumn, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn).column)) : g);\n          resultPerViewLine.push(bracketGuides);\n        }\n      }\n    }\n\n    return resultPerViewLine;\n  }\n\n  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n    // TODO: Use the same code as in `getViewLinesBracketGuides`.\n    // Future TODO: Merge with `getViewLinesBracketGuides`.\n    // However, this requires more refactoring of indent guides.\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n    const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n    let result = [];\n    const resultRepeatCount = [];\n    const resultRepeatOption = [];\n    const modelStartLineIndex = modelStart.lineNumber - 1;\n    const modelEndLineIndex = modelEnd.lineNumber - 1;\n    let reqStart = null;\n\n    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      const line = this.modelLineProjections[modelLineIndex];\n\n      if (line.isVisible()) {\n        const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n        const count = viewLineEndIndex - viewLineStartIndex + 1;\n        let option = 0\n        /* BlockNone */\n        ;\n\n        if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n          // wrapped lines should block indent guides\n          option = viewLineStartIndex === 0 ? 1\n          /* BlockSubsequent */\n          : 2\n          /* BlockAll */\n          ;\n        }\n\n        resultRepeatCount.push(count);\n        resultRepeatOption.push(option); // merge into previous request\n\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, 0);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n          reqStart = null;\n        }\n      }\n    }\n\n    if (reqStart !== null) {\n      result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n      reqStart = null;\n    }\n\n    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    const viewIndents = new Array(viewLineCount);\n    let currIndex = 0;\n\n    for (let i = 0, len = result.length; i < len; i++) {\n      let value = result[i];\n      const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n      const option = resultRepeatOption[i];\n      let blockAtIndex;\n\n      if (option === 2\n      /* BlockAll */\n      ) {\n        blockAtIndex = 0;\n      } else if (option === 1\n      /* BlockSubsequent */\n      ) {\n        blockAtIndex = 1;\n      } else {\n        blockAtIndex = count;\n      }\n\n      for (let j = 0; j < count; j++) {\n        if (j === blockAtIndex) {\n          value = 0;\n        }\n\n        viewIndents[currIndex++] = value;\n      }\n    }\n\n    return viewIndents;\n  }\n\n  getViewLineContent(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n\n  getViewLineLength(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n\n  getViewLineMinColumn(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n\n  getViewLineMaxColumn(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n\n  getViewLineData(viewLineNumber) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n  }\n\n  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n    let viewLineNumber = viewStartLineNumber;\n    const startModelLineIndex = start.index;\n    const startRemainder = start.remainder;\n    const result = [];\n\n    for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n      const line = this.modelLineProjections[modelLineIndex];\n\n      if (!line.isVisible()) {\n        continue;\n      }\n\n      const fromViewLineIndex = modelLineIndex === startModelLineIndex ? startRemainder : 0;\n      let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n      let lastLine = false;\n\n      if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n        lastLine = true;\n        remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n      }\n\n      line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n      viewLineNumber += remainingViewLineCount;\n\n      if (lastLine) {\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n    const lineIndex = r.index;\n    const remainder = r.remainder;\n    const line = this.modelLineProjections[lineIndex];\n    const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n    const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n\n    if (viewColumn < minColumn) {\n      viewColumn = minColumn;\n    }\n\n    if (viewColumn > maxColumn) {\n      viewColumn = maxColumn;\n    }\n\n    const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n    const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n\n    if (computedModelPosition.equals(expectedModelPosition)) {\n      return new Position(viewLineNumber, viewColumn);\n    }\n\n    return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n  }\n\n  validateViewRange(viewRange, expectedModelRange) {\n    const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n    const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n    return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n  }\n\n  convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n    const info = this.getViewLineInfo(viewLineNumber);\n    const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn); // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n\n    return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n  }\n\n  convertViewRangeToModelRange(viewRange) {\n    const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n    const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n\n  convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2\n  /* None */\n  ) {\n    const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n    const inputLineNumber = validPosition.lineNumber;\n    const inputColumn = validPosition.column;\n    let lineIndex = inputLineNumber - 1,\n        lineIndexChanged = false;\n\n    while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      lineIndex--;\n      lineIndexChanged = true;\n    }\n\n    if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      // Could not reach a real line\n      // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n      return new Position(1, 1);\n    }\n\n    const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n    let r;\n\n    if (lineIndexChanged) {\n      r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n    } else {\n      r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n    } // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n\n\n    return r;\n  }\n  /**\n   * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n  */\n\n\n  convertModelRangeToViewRange(modelRange, affinity = 0\n  /* Left */\n  ) {\n    if (modelRange.isEmpty()) {\n      const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n      return Range.fromPositions(start);\n    } else {\n      const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1\n      /* Right */\n      );\n      const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0\n      /* Left */\n      );\n      return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n  }\n\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    let lineIndex = modelLineNumber - 1;\n\n    if (this.modelLineProjections[lineIndex].isVisible()) {\n      // this model line is visible\n      const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n      return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n    } // this model line is not visible\n\n\n    while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      lineIndex--;\n    }\n\n    if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n      // Could not reach a real line\n      return 1;\n    }\n\n    const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n    return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n  }\n\n  getDecorationsInRange(range, ownerId, filterOutValidation) {\n    const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n    const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n\n    if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n      // most likely there are no hidden lines => fast path\n      // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n      return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n    }\n\n    let result = [];\n    const modelStartLineIndex = modelStart.lineNumber - 1;\n    const modelEndLineIndex = modelEnd.lineNumber - 1;\n    let reqStart = null;\n\n    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      const line = this.modelLineProjections[modelLineIndex];\n\n      if (line.isVisible()) {\n        // merge into previous request\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n          result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n          reqStart = null;\n        }\n      }\n    }\n\n    if (reqStart !== null) {\n      result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n      reqStart = null;\n    }\n\n    result.sort((a, b) => {\n      const res = Range.compareRangesUsingStarts(a.range, b.range);\n\n      if (res === 0) {\n        if (a.id < b.id) {\n          return -1;\n        }\n\n        if (a.id > b.id) {\n          return 1;\n        }\n\n        return 0;\n      }\n\n      return res;\n    }); // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n\n    let finalResult = [],\n        finalResultLen = 0;\n    let prevDecId = null;\n\n    for (const dec of result) {\n      const decId = dec.id;\n\n      if (prevDecId === decId) {\n        // skip\n        continue;\n      }\n\n      prevDecId = decId;\n      finalResult[finalResultLen++] = dec;\n    }\n\n    return finalResult;\n  }\n\n  getInjectedTextAt(position) {\n    const info = this.getViewLineInfo(position.lineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n  }\n\n  normalizePosition(position, affinity) {\n    const info = this.getViewLineInfo(position.lineNumber);\n    return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n  }\n\n  getLineIndentColumn(lineNumber) {\n    const info = this.getViewLineInfo(lineNumber);\n\n    if (info.modelLineWrappedLineIdx === 0) {\n      return this.model.getLineIndentColumn(info.modelLineNumber);\n    } // wrapped lines have no indentation.\n    // We deliberately don't handle the case that indentation is wrapped\n    // to avoid two view lines reporting indentation for the very same model line.\n\n\n    return 0;\n  }\n\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\n\nfunction normalizeLineRanges(ranges) {\n  if (ranges.length === 0) {\n    return [];\n  }\n\n  const sortedRanges = ranges.slice();\n  sortedRanges.sort(Range.compareRangesUsingStarts);\n  const result = [];\n  let currentRangeStart = sortedRanges[0].startLineNumber;\n  let currentRangeEnd = sortedRanges[0].endLineNumber;\n\n  for (let i = 1, len = sortedRanges.length; i < len; i++) {\n    const range = sortedRanges[i];\n\n    if (range.startLineNumber > currentRangeEnd + 1) {\n      result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n      currentRangeStart = range.startLineNumber;\n      currentRangeEnd = range.endLineNumber;\n    } else if (range.endLineNumber > currentRangeEnd) {\n      currentRangeEnd = range.endLineNumber;\n    }\n  }\n\n  result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n  return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\n\n\nclass ViewLineInfo {\n  constructor(modelLineNumber, modelLineWrappedLineIdx) {\n    this.modelLineNumber = modelLineNumber;\n    this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n  }\n\n  get isWrappedLineContinuation() {\n    return this.modelLineWrappedLineIdx > 0;\n  }\n\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\n\n\nclass ViewLineInfoGroupedByModelRange {\n  constructor(modelRange, viewLines) {\n    this.modelRange = modelRange;\n    this.viewLines = viewLines;\n  }\n\n}\n\nclass CoordinatesConverter {\n  constructor(lines) {\n    this._lines = lines;\n  } // View -> Model conversion and related methods\n\n\n  convertViewPositionToModelPosition(viewPosition) {\n    return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n  }\n\n  convertViewRangeToModelRange(viewRange) {\n    return this._lines.convertViewRangeToModelRange(viewRange);\n  }\n\n  validateViewPosition(viewPosition, expectedModelPosition) {\n    return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n  }\n\n  validateViewRange(viewRange, expectedModelRange) {\n    return this._lines.validateViewRange(viewRange, expectedModelRange);\n  } // Model -> View conversion and related methods\n\n\n  convertModelPositionToViewPosition(modelPosition, affinity) {\n    return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity);\n  }\n\n  convertModelRangeToViewRange(modelRange, affinity) {\n    return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n  }\n\n  modelPositionIsVisible(modelPosition) {\n    return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n  }\n\n  getModelLineViewLineCount(modelLineNumber) {\n    return this._lines.getModelLineViewLineCount(modelLineNumber);\n  }\n\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n  }\n\n}\n\nexport class ViewModelLinesFromModelAsIs {\n  constructor(model) {\n    this.model = model;\n  }\n\n  dispose() {}\n\n  createCoordinatesConverter() {\n    return new IdentityCoordinatesConverter(this);\n  }\n\n  getHiddenAreas() {\n    return [];\n  }\n\n  setHiddenAreas(_ranges) {\n    return false;\n  }\n\n  setTabSize(_newTabSize) {\n    return false;\n  }\n\n  setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n    return false;\n  }\n\n  createLineBreaksComputer() {\n    const result = [];\n    return {\n      addRequest: (lineText, injectedText, previousLineBreakData) => {\n        result.push(null);\n      },\n      finalize: () => {\n        return result;\n      }\n    };\n  }\n\n  onModelFlushed() {}\n\n  onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n    return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n  }\n\n  onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n    return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n  }\n\n  onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n    return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n  }\n\n  acceptVersionId(_versionId) {}\n\n  getViewLineCount() {\n    return this.model.getLineCount();\n  }\n\n  getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n    return {\n      startLineNumber: viewLineNumber,\n      endLineNumber: viewLineNumber,\n      indent: 0\n    };\n  }\n\n  getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n    return new Array(endLineNumber - startLineNumber + 1).fill([]);\n  }\n\n  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    const result = new Array(viewLineCount);\n\n    for (let i = 0; i < viewLineCount; i++) {\n      result[i] = 0;\n    }\n\n    return result;\n  }\n\n  getViewLineContent(viewLineNumber) {\n    return this.model.getLineContent(viewLineNumber);\n  }\n\n  getViewLineLength(viewLineNumber) {\n    return this.model.getLineLength(viewLineNumber);\n  }\n\n  getViewLineMinColumn(viewLineNumber) {\n    return this.model.getLineMinColumn(viewLineNumber);\n  }\n\n  getViewLineMaxColumn(viewLineNumber) {\n    return this.model.getLineMaxColumn(viewLineNumber);\n  }\n\n  getViewLineData(viewLineNumber) {\n    const lineTokens = this.model.getLineTokens(viewLineNumber);\n    const lineContent = lineTokens.getLineContent();\n    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n  }\n\n  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n    const lineCount = this.model.getLineCount();\n    viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n    viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n    const result = [];\n\n    for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n      const idx = lineNumber - viewStartLineNumber;\n      result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n    }\n\n    return result;\n  }\n\n  getDecorationsInRange(range, ownerId, filterOutValidation) {\n    return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n  }\n\n  normalizePosition(position, affinity) {\n    return this.model.normalizePosition(position, affinity);\n  }\n\n  getLineIndentColumn(lineNumber) {\n    return this.model.getLineIndentColumn(lineNumber);\n  }\n\n  getInjectedTextAt(position) {\n    // Identity lines collection does not support injected text.\n    return null;\n  }\n\n}\n\nclass IdentityCoordinatesConverter {\n  constructor(lines) {\n    this._lines = lines;\n  }\n\n  _validPosition(pos) {\n    return this._lines.model.validatePosition(pos);\n  }\n\n  _validRange(range) {\n    return this._lines.model.validateRange(range);\n  } // View -> Model conversion and related methods\n\n\n  convertViewPositionToModelPosition(viewPosition) {\n    return this._validPosition(viewPosition);\n  }\n\n  convertViewRangeToModelRange(viewRange) {\n    return this._validRange(viewRange);\n  }\n\n  validateViewPosition(_viewPosition, expectedModelPosition) {\n    return this._validPosition(expectedModelPosition);\n  }\n\n  validateViewRange(_viewRange, expectedModelRange) {\n    return this._validRange(expectedModelRange);\n  } // Model -> View conversion and related methods\n\n\n  convertModelPositionToViewPosition(modelPosition) {\n    return this._validPosition(modelPosition);\n  }\n\n  convertModelRangeToViewRange(modelRange) {\n    return this._validRange(modelRange);\n  }\n\n  modelPositionIsVisible(modelPosition) {\n    const lineCount = this._lines.model.getLineCount();\n\n    if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n      // invalid arguments\n      return false;\n    }\n\n    return true;\n  }\n\n  getModelLineViewLineCount(modelLineNumber) {\n    return 1;\n  }\n\n  getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n    return modelLineNumber;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js"],"names":["arrays","Position","Range","IndentGuide","IndentGuideHorizontalLine","ModelDecorationOptions","LineInjectedText","viewEvents","createModelLineProjection","ConstantTimePrefixSumComputer","ViewLineData","ViewModelLinesFromProjectedModel","constructor","editorId","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","fontInfo","tabSize","wrappingStrategy","wrappingColumn","wrappingIndent","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","dispose","hiddenAreasDecorationIds","deltaDecorations","createCoordinatesConverter","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","modelLineProjections","linesContent","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineCount","length","lineBreaksComputer","createLineBreaksComputer","injectedTextQueue","ArrayQueue","fromDecorations","i","lineInjectedText","takeWhile","t","lineNumber","addRequest","linesBreaks","finalize","values","hiddenAreas","map","areaId","getDecorationRange","sort","compareRangesUsingStarts","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","startLineNumber","endLineNumber","isInHiddenArea","line","getViewLineCount","getVersionId","projectedModelLineLineCounts","getHiddenAreas","decId","setHiddenAreas","_ranges","validatedRanges","r","validateRange","newRanges","normalizeLineRanges","oldRanges","hasDifference","equalsRange","newDecorations","range","options","EMPTY","hasVisibleLine","lineChanged","isVisible","setVisible","newOutputLineCount","setValue","modelPositionIsVisible","modelLineNumber","_modelColumn","getModelLineViewLineCount","setTabSize","newTabSize","setWrappingSettings","equalFontInfo","equals","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","onlyWrappingColumnChanged","len","getProjectionData","lineBreaksComputerFactory","onModelFlushed","onModelLinesDeleted","versionId","fromLineNumber","toLineNumber","outputFromLineNumber","getPrefixSum","outputToLineNumber","splice","removeValues","ViewLinesDeletedEvent","onModelLinesInserted","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","push","outputLineCount","slice","concat","insertValues","ViewLinesInsertedEvent","onModelLineChanged","lineBreakData","lineIndex","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","viewLinesChangedEvent","ViewLinesChangedEvent","viewLinesInsertedEvent","viewLinesDeletedEvent","acceptVersionId","getTotalSum","_toValidViewLineNumber","viewLineNumber","viewLineCount","getActiveIndentGuide","minLineNumber","maxLineNumber","modelPosition","convertViewPositionToModelPosition","getViewLineMinColumn","modelMinPosition","modelMaxPosition","result","guides","viewStartPosition","convertModelPositionToViewPosition","viewEndPosition","getLineMaxColumn","indent","getViewLineInfo","getIndexOf","index","remainder","ViewLineInfo","getMinColumnOfViewLine","viewLineInfo","modelLineWrappedLineIdx","getModelStartPositionOfViewLine","minViewColumn","column","getModelColumnOfViewPosition","getModelEndPositionOfViewLine","maxViewColumn","getViewLineMaxColumn","getViewLineInfosGroupedByModelRanges","viewStartLineNumber","viewEndLineNumber","startViewLine","endViewLine","Array","lastVisibleModelPos","viewLines","curModelLine","startOffset","endOffset","lastVisibleModelPos2","modelRange","fromPositions","ViewLineInfoGroupedByModelRange","getViewLinesBracketGuides","activeViewPosition","modelActivePosition","resultPerViewLine","group","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","isWrappedLineContinuation","bracketGuides","g","horizontalLine","visibleColumn","className","top","endColumn","getViewLinesIndentGuides","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","getViewLineNumberOfModelPosition","viewLineEndIndex","count","option","getLinesIndentGuides","viewIndents","currIndex","value","Math","min","blockAtIndex","j","getViewLineContent","info","getViewLineLength","getViewLineData","getViewLinesData","needed","start","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","validateViewPosition","viewColumn","expectedModelPosition","minColumn","maxColumn","computedModelColumn","computedModelPosition","validatePosition","validateViewRange","viewRange","expectedModelRange","validViewStart","startColumn","getStartPosition","validViewEnd","getEndPosition","inputColumn","convertViewRangeToModelRange","end","_modelLineNumber","affinity","validPosition","inputLineNumber","lineIndexChanged","deltaLineNumber","getViewPositionOfModelPosition","convertModelRangeToViewRange","isEmpty","modelColumn","getDecorationsInRange","ownerId","filterOutValidation","maxLineColumn","a","b","res","id","finalResult","finalResultLen","prevDecId","dec","getInjectedTextAt","position","normalizePosition","getLineIndentColumn","ranges","sortedRanges","currentRangeStart","currentRangeEnd","lines","_lines","viewPosition","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","lineText","injectedText","previousLineBreakData","_versionId","_minLineNumber","_maxLineNumber","activePosition","fill","getLineContent","getLineLength","getLineMinColumn","lineTokens","getLineTokens","lineContent","inflate","max","idx","_validPosition","pos","_validRange","_viewPosition","_viewRange"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from './viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from './viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                if (viewLineInfo.isWrappedLineContinuation && this.getMinColumnOfViewLine(viewLineInfo) === 1) {\n                    // Don't add indent guides when the wrapped line continuation has no wrapping-indentation.\n                    resultPerViewLine.push([]);\n                }\n                else {\n                    let bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                    // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                    // model-columns must be converted to view-model columns.\n                    bracketGuides = bracketGuides.map(g => g.horizontalLine ?\n                        new IndentGuide(g.visibleColumn, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn).column)) : g);\n                    resultPerViewLine.push(bracketGuides);\n                }\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* BlockSubsequent */ : 2 /* BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* None */) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n            lineIndexChanged = true;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            return new Position(1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        let finalResult = [], finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n    get isWrappedLineContinuation() {\n        return this.modelLineWrappedLineIdx > 0;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}