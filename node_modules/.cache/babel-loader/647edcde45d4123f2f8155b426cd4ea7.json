{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\n\nimport { createCancelableAsyncIterable, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class HoverResult {\n  constructor(value, isComplete, hasLoadingMessage) {\n    this.value = value;\n    this.isComplete = isComplete;\n    this.hasLoadingMessage = hasLoadingMessage;\n  }\n\n}\n/**\n * Computing the hover is very fine tuned.\n *\n * Suppose the hover delay is 300ms (the default). Then, when resting the mouse at an anchor:\n * - at 150ms, the async computation is triggered (i.e. semantic hover)\n *   - if async results already come in, they are not rendered yet.\n * - at 300ms, the sync computation is triggered (i.e. decorations, markers)\n *   - if there are sync or async results, they are rendered.\n * - at 900ms, if the async computation hasn't finished, a \"Loading...\" result is added.\n */\n\nexport class HoverOperation extends Disposable {\n  constructor(_editor, _computer) {\n    super();\n    this._editor = _editor;\n    this._computer = _computer;\n    this._onResult = this._register(new Emitter());\n    this.onResult = this._onResult.event;\n    this._firstWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerAsyncComputation(), 0));\n    this._secondWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerSyncComputation(), 0));\n    this._loadingMessageScheduler = this._register(new RunOnceScheduler(() => this._triggerLoadingMessage(), 0));\n    this._state = 0\n    /* Idle */\n    ;\n    this._asyncIterable = null;\n    this._asyncIterableDone = false;\n    this._result = [];\n  }\n\n  dispose() {\n    if (this._asyncIterable) {\n      this._asyncIterable.cancel();\n\n      this._asyncIterable = null;\n    }\n\n    super.dispose();\n  }\n\n  get _hoverTime() {\n    return this._editor.getOption(53\n    /* hover */\n    ).delay;\n  }\n\n  get _firstWaitTime() {\n    return this._hoverTime / 2;\n  }\n\n  get _secondWaitTime() {\n    return this._hoverTime - this._firstWaitTime;\n  }\n\n  get _loadingMessageTime() {\n    return 3 * this._hoverTime;\n  }\n\n  _setState(state, fireResult = true) {\n    this._state = state;\n\n    if (fireResult) {\n      this._fireResult();\n    }\n  }\n\n  _triggerAsyncComputation() {\n    this._setState(2\n    /* SecondWait */\n    );\n\n    this._secondWaitScheduler.schedule(this._secondWaitTime);\n\n    if (this._computer.computeAsync) {\n      this._asyncIterableDone = false;\n      this._asyncIterable = createCancelableAsyncIterable(token => this._computer.computeAsync(token));\n\n      (() => __awaiter(this, void 0, void 0, function* () {\n        var e_1, _a;\n\n        try {\n          try {\n            for (var _b = __asyncValues(this._asyncIterable), _c; _c = yield _b.next(), !_c.done;) {\n              const item = _c.value;\n\n              if (item) {\n                this._result.push(item);\n\n                this._fireResult();\n              }\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n\n          this._asyncIterableDone = true;\n\n          if (this._state === 3\n          /* WaitingForAsync */\n          || this._state === 4\n          /* WaitingForAsyncShowingLoading */\n          ) {\n            this._setState(0\n            /* Idle */\n            );\n          }\n        } catch (e) {\n          onUnexpectedError(e);\n        }\n      }))();\n    } else {\n      this._asyncIterableDone = true;\n    }\n  }\n\n  _triggerSyncComputation() {\n    if (this._computer.computeSync) {\n      this._result = this._result.concat(this._computer.computeSync());\n    }\n\n    this._setState(this._asyncIterableDone ? 0\n    /* Idle */\n    : 3\n    /* WaitingForAsync */\n    );\n  }\n\n  _triggerLoadingMessage() {\n    if (this._state === 3\n    /* WaitingForAsync */\n    ) {\n      this._setState(4\n      /* WaitingForAsyncShowingLoading */\n      );\n    }\n  }\n\n  _fireResult() {\n    if (this._state === 1\n    /* FirstWait */\n    || this._state === 2\n    /* SecondWait */\n    ) {\n      // Do not send out results before the hover time\n      return;\n    }\n\n    const isComplete = this._state === 0\n    /* Idle */\n    ;\n    const hasLoadingMessage = this._state === 4\n    /* WaitingForAsyncShowingLoading */\n    ;\n\n    this._onResult.fire(new HoverResult(this._result.slice(0), isComplete, hasLoadingMessage));\n  }\n\n  start(mode) {\n    if (mode === 0\n    /* Delayed */\n    ) {\n      if (this._state === 0\n      /* Idle */\n      ) {\n        this._setState(1\n        /* FirstWait */\n        );\n\n        this._firstWaitScheduler.schedule(this._firstWaitTime);\n\n        this._loadingMessageScheduler.schedule(this._loadingMessageTime);\n      }\n    } else {\n      switch (this._state) {\n        case 0\n        /* Idle */\n        :\n          this._triggerAsyncComputation();\n\n          this._secondWaitScheduler.cancel();\n\n          this._triggerSyncComputation();\n\n          break;\n\n        case 2\n        /* SecondWait */\n        :\n          this._secondWaitScheduler.cancel();\n\n          this._triggerSyncComputation();\n\n          break;\n      }\n    }\n  }\n\n  cancel() {\n    this._firstWaitScheduler.cancel();\n\n    this._secondWaitScheduler.cancel();\n\n    this._loadingMessageScheduler.cancel();\n\n    if (this._asyncIterable) {\n      this._asyncIterable.cancel();\n\n      this._asyncIterable = null;\n    }\n\n    this._result = [];\n\n    this._setState(0\n    /* Idle */\n    , false);\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverOperation.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","settle","d","createCancelableAsyncIterable","RunOnceScheduler","onUnexpectedError","Emitter","Disposable","HoverResult","constructor","isComplete","hasLoadingMessage","HoverOperation","_editor","_computer","_onResult","_register","onResult","event","_firstWaitScheduler","_triggerAsyncComputation","_secondWaitScheduler","_triggerSyncComputation","_loadingMessageScheduler","_triggerLoadingMessage","_state","_asyncIterable","_asyncIterableDone","_result","dispose","cancel","_hoverTime","getOption","delay","_firstWaitTime","_secondWaitTime","_loadingMessageTime","_setState","state","fireResult","_fireResult","schedule","computeAsync","token","e_1","_a","_b","_c","item","push","e_1_1","error","return","computeSync","concat","fire","slice","start","mode"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport { createCancelableAsyncIterable, RunOnceScheduler } from '../../../../base/common/async.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class HoverResult {\n    constructor(value, isComplete, hasLoadingMessage) {\n        this.value = value;\n        this.isComplete = isComplete;\n        this.hasLoadingMessage = hasLoadingMessage;\n    }\n}\n/**\n * Computing the hover is very fine tuned.\n *\n * Suppose the hover delay is 300ms (the default). Then, when resting the mouse at an anchor:\n * - at 150ms, the async computation is triggered (i.e. semantic hover)\n *   - if async results already come in, they are not rendered yet.\n * - at 300ms, the sync computation is triggered (i.e. decorations, markers)\n *   - if there are sync or async results, they are rendered.\n * - at 900ms, if the async computation hasn't finished, a \"Loading...\" result is added.\n */\nexport class HoverOperation extends Disposable {\n    constructor(_editor, _computer) {\n        super();\n        this._editor = _editor;\n        this._computer = _computer;\n        this._onResult = this._register(new Emitter());\n        this.onResult = this._onResult.event;\n        this._firstWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerAsyncComputation(), 0));\n        this._secondWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerSyncComputation(), 0));\n        this._loadingMessageScheduler = this._register(new RunOnceScheduler(() => this._triggerLoadingMessage(), 0));\n        this._state = 0 /* Idle */;\n        this._asyncIterable = null;\n        this._asyncIterableDone = false;\n        this._result = [];\n    }\n    dispose() {\n        if (this._asyncIterable) {\n            this._asyncIterable.cancel();\n            this._asyncIterable = null;\n        }\n        super.dispose();\n    }\n    get _hoverTime() {\n        return this._editor.getOption(53 /* hover */).delay;\n    }\n    get _firstWaitTime() {\n        return this._hoverTime / 2;\n    }\n    get _secondWaitTime() {\n        return this._hoverTime - this._firstWaitTime;\n    }\n    get _loadingMessageTime() {\n        return 3 * this._hoverTime;\n    }\n    _setState(state, fireResult = true) {\n        this._state = state;\n        if (fireResult) {\n            this._fireResult();\n        }\n    }\n    _triggerAsyncComputation() {\n        this._setState(2 /* SecondWait */);\n        this._secondWaitScheduler.schedule(this._secondWaitTime);\n        if (this._computer.computeAsync) {\n            this._asyncIterableDone = false;\n            this._asyncIterable = createCancelableAsyncIterable(token => this._computer.computeAsync(token));\n            (() => __awaiter(this, void 0, void 0, function* () {\n                var e_1, _a;\n                try {\n                    try {\n                        for (var _b = __asyncValues(this._asyncIterable), _c; _c = yield _b.next(), !_c.done;) {\n                            const item = _c.value;\n                            if (item) {\n                                this._result.push(item);\n                                this._fireResult();\n                            }\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    this._asyncIterableDone = true;\n                    if (this._state === 3 /* WaitingForAsync */ || this._state === 4 /* WaitingForAsyncShowingLoading */) {\n                        this._setState(0 /* Idle */);\n                    }\n                }\n                catch (e) {\n                    onUnexpectedError(e);\n                }\n            }))();\n        }\n        else {\n            this._asyncIterableDone = true;\n        }\n    }\n    _triggerSyncComputation() {\n        if (this._computer.computeSync) {\n            this._result = this._result.concat(this._computer.computeSync());\n        }\n        this._setState(this._asyncIterableDone ? 0 /* Idle */ : 3 /* WaitingForAsync */);\n    }\n    _triggerLoadingMessage() {\n        if (this._state === 3 /* WaitingForAsync */) {\n            this._setState(4 /* WaitingForAsyncShowingLoading */);\n        }\n    }\n    _fireResult() {\n        if (this._state === 1 /* FirstWait */ || this._state === 2 /* SecondWait */) {\n            // Do not send out results before the hover time\n            return;\n        }\n        const isComplete = (this._state === 0 /* Idle */);\n        const hasLoadingMessage = (this._state === 4 /* WaitingForAsyncShowingLoading */);\n        this._onResult.fire(new HoverResult(this._result.slice(0), isComplete, hasLoadingMessage));\n    }\n    start(mode) {\n        if (mode === 0 /* Delayed */) {\n            if (this._state === 0 /* Idle */) {\n                this._setState(1 /* FirstWait */);\n                this._firstWaitScheduler.schedule(this._firstWaitTime);\n                this._loadingMessageScheduler.schedule(this._loadingMessageTime);\n            }\n        }\n        else {\n            switch (this._state) {\n                case 0 /* Idle */:\n                    this._triggerAsyncComputation();\n                    this._secondWaitScheduler.cancel();\n                    this._triggerSyncComputation();\n                    break;\n                case 2 /* SecondWait */:\n                    this._secondWaitScheduler.cancel();\n                    this._triggerSyncComputation();\n                    break;\n            }\n        }\n    }\n    cancel() {\n        this._firstWaitScheduler.cancel();\n        this._secondWaitScheduler.cancel();\n        this._loadingMessageScheduler.cancel();\n        if (this._asyncIterable) {\n            this._asyncIterable.cancel();\n            this._asyncIterable = null;\n        }\n        this._result = [];\n        this._setState(0 /* Idle */, false);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}