{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthToObj, toLength } from './length.js';\nexport class TextEditInfo {\n  constructor(startOffset, endOffset, newLength) {\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.newLength = newLength;\n  }\n\n}\nexport class BeforeEditPositionMapper {\n  /**\n   * @param edits Must be sorted by offset in ascending order.\n  */\n  constructor(edits, documentLength) {\n    this.documentLength = documentLength;\n    this.nextEditIdx = 0;\n    this.deltaOldToNewLineCount = 0;\n    this.deltaOldToNewColumnCount = 0;\n    this.deltaLineIdxInOld = -1;\n    this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n  }\n  /**\n   * @param offset Must be equal to or greater than the last offset this method has been called with.\n  */\n\n\n  getOffsetBeforeChange(offset) {\n    this.adjustNextEdit(offset);\n    return this.translateCurToOld(offset);\n  }\n  /**\n   * @param offset Must be equal to or greater than the last offset this method has been called with.\n  */\n\n\n  getDistanceToNextChange(offset) {\n    this.adjustNextEdit(offset);\n    const nextEdit = this.edits[this.nextEditIdx];\n    const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : this.documentLength;\n    return lengthDiffNonNegative(offset, nextChangeOffset);\n  }\n\n  translateOldToCur(oldOffsetObj) {\n    if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n      return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n    } else {\n      return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n    }\n  }\n\n  translateCurToOld(newOffset) {\n    const offsetObj = lengthToObj(newOffset);\n\n    if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n      return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n    } else {\n      return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n    }\n  }\n\n  adjustNextEdit(offset) {\n    while (this.nextEditIdx < this.edits.length) {\n      const nextEdit = this.edits[this.nextEditIdx]; // After applying the edit, what is its end offset (considering all previous edits)?\n\n      const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n\n      if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n        // We are after the edit, skip it\n        this.nextEditIdx++;\n        const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur); // Before applying the edit, what is its end offset (considering all previous edits)?\n\n        const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n        const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n        this.deltaOldToNewLineCount += lineDelta;\n        const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n        const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n        this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n        this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n      } else {\n        // We are in or before the edit.\n        break;\n      }\n    }\n  }\n\n}\n\nclass TextEditInfoCache {\n  constructor(startOffset, endOffset, textLength) {\n    this.endOffsetBeforeObj = lengthToObj(endOffset);\n    this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n    this.offsetObj = lengthToObj(startOffset);\n  }\n\n  static from(edit) {\n    return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js"],"names":["lengthAdd","lengthDiffNonNegative","lengthLessThanEqual","lengthToObj","toLength","TextEditInfo","constructor","startOffset","endOffset","newLength","BeforeEditPositionMapper","edits","documentLength","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","map","edit","TextEditInfoCache","from","getOffsetBeforeChange","offset","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","oldOffsetObj","lineCount","columnCount","newOffset","length","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthToObj, toLength } from './length.js';\nexport class TextEditInfo {\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits, documentLength) {\n        this.documentLength = documentLength;\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : this.documentLength;\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}