{"ast":null,"code":"const hasBuffer = typeof Buffer !== 'undefined';\nlet textDecoder;\nexport class VSBuffer {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.byteLength = this.buffer.byteLength;\n  }\n  /**\n   * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n   * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n   * which is not transferrable.\n   */\n\n\n  static wrap(actual) {\n    if (hasBuffer && !Buffer.isBuffer(actual)) {\n      // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n      // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n      actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n    }\n\n    return new VSBuffer(actual);\n  }\n\n  toString() {\n    if (hasBuffer) {\n      return this.buffer.toString();\n    } else {\n      if (!textDecoder) {\n        textDecoder = new TextDecoder();\n      }\n\n      return textDecoder.decode(this.buffer);\n    }\n  }\n\n}\nexport function readUInt16LE(source, offset) {\n  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;\n}\nexport function writeUInt16LE(destination, value, offset) {\n  destination[offset + 0] = value & 0b11111111;\n  value = value >>> 8;\n  destination[offset + 1] = value & 0b11111111;\n}\nexport function readUInt32BE(source, offset) {\n  return source[offset] * Math.pow(2, 24) + source[offset + 1] * Math.pow(2, 16) + source[offset + 2] * Math.pow(2, 8) + source[offset + 3];\n}\nexport function writeUInt32BE(destination, value, offset) {\n  destination[offset + 3] = value;\n  value = value >>> 8;\n  destination[offset + 2] = value;\n  value = value >>> 8;\n  destination[offset + 1] = value;\n  value = value >>> 8;\n  destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n  return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n  destination[offset] = value;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/buffer.js"],"names":["hasBuffer","Buffer","textDecoder","VSBuffer","constructor","buffer","byteLength","wrap","actual","isBuffer","from","byteOffset","toString","TextDecoder","decode","readUInt16LE","source","offset","writeUInt16LE","destination","value","readUInt32BE","Math","pow","writeUInt32BE","readUInt8","writeUInt8"],"mappings":"AAAA,MAAMA,SAAS,GAAI,OAAOC,MAAP,KAAkB,WAArC;AACA,IAAIC,WAAJ;AACA,OAAO,MAAMC,QAAN,CAAe;AAClBC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKC,UAAL,GAAkB,KAAKD,MAAL,CAAYC,UAA9B;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACe,SAAJC,IAAI,CAACC,MAAD,EAAS;AAChB,QAAIR,SAAS,IAAI,CAAEC,MAAM,CAACQ,QAAP,CAAgBD,MAAhB,CAAnB,EAA6C;AACzC;AACA;AACAA,MAAAA,MAAM,GAAGP,MAAM,CAACS,IAAP,CAAYF,MAAM,CAACH,MAAnB,EAA2BG,MAAM,CAACG,UAAlC,EAA8CH,MAAM,CAACF,UAArD,CAAT;AACH;;AACD,WAAO,IAAIH,QAAJ,CAAaK,MAAb,CAAP;AACH;;AACDI,EAAAA,QAAQ,GAAG;AACP,QAAIZ,SAAJ,EAAe;AACX,aAAO,KAAKK,MAAL,CAAYO,QAAZ,EAAP;AACH,KAFD,MAGK;AACD,UAAI,CAACV,WAAL,EAAkB;AACdA,QAAAA,WAAW,GAAG,IAAIW,WAAJ,EAAd;AACH;;AACD,aAAOX,WAAW,CAACY,MAAZ,CAAmB,KAAKT,MAAxB,CAAP;AACH;AACJ;;AA5BiB;AA8BtB,OAAO,SAASU,YAAT,CAAsBC,MAAtB,EAA8BC,MAA9B,EAAsC;AACzC,SAAUD,MAAM,CAACC,MAAM,GAAG,CAAV,CAAN,IAAsB,CAAvB,KAA8B,CAA/B,GACFD,MAAM,CAACC,MAAM,GAAG,CAAV,CAAN,IAAsB,CAAvB,KAA8B,CADnC;AAEH;AACD,OAAO,SAASC,aAAT,CAAuBC,WAAvB,EAAoCC,KAApC,EAA2CH,MAA3C,EAAmD;AACtDE,EAAAA,WAAW,CAACF,MAAM,GAAG,CAAV,CAAX,GAA2BG,KAAK,GAAG,UAAnC;AACAA,EAAAA,KAAK,GAAGA,KAAK,KAAK,CAAlB;AACAD,EAAAA,WAAW,CAACF,MAAM,GAAG,CAAV,CAAX,GAA2BG,KAAK,GAAG,UAAnC;AACH;AACD,OAAO,SAASC,YAAT,CAAsBL,MAAtB,EAA8BC,MAA9B,EAAsC;AACzC,SAAQD,MAAM,CAACC,MAAD,CAAN,GAAiBK,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAjB,GACFP,MAAM,CAACC,MAAM,GAAG,CAAV,CAAN,GAAqBK,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,EAAZ,CADnB,GAEFP,MAAM,CAACC,MAAM,GAAG,CAAV,CAAN,GAAqBK,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,CAAZ,CAFnB,GAGFP,MAAM,CAACC,MAAM,GAAG,CAAV,CAHZ;AAIH;AACD,OAAO,SAASO,aAAT,CAAuBL,WAAvB,EAAoCC,KAApC,EAA2CH,MAA3C,EAAmD;AACtDE,EAAAA,WAAW,CAACF,MAAM,GAAG,CAAV,CAAX,GAA0BG,KAA1B;AACAA,EAAAA,KAAK,GAAGA,KAAK,KAAK,CAAlB;AACAD,EAAAA,WAAW,CAACF,MAAM,GAAG,CAAV,CAAX,GAA0BG,KAA1B;AACAA,EAAAA,KAAK,GAAGA,KAAK,KAAK,CAAlB;AACAD,EAAAA,WAAW,CAACF,MAAM,GAAG,CAAV,CAAX,GAA0BG,KAA1B;AACAA,EAAAA,KAAK,GAAGA,KAAK,KAAK,CAAlB;AACAD,EAAAA,WAAW,CAACF,MAAD,CAAX,GAAsBG,KAAtB;AACH;AACD,OAAO,SAASK,SAAT,CAAmBT,MAAnB,EAA2BC,MAA3B,EAAmC;AACtC,SAAOD,MAAM,CAACC,MAAD,CAAb;AACH;AACD,OAAO,SAASS,UAAT,CAAoBP,WAApB,EAAiCC,KAAjC,EAAwCH,MAAxC,EAAgD;AACnDE,EAAAA,WAAW,CAACF,MAAD,CAAX,GAAsBG,KAAtB;AACH","sourcesContent":["const hasBuffer = (typeof Buffer !== 'undefined');\nlet textDecoder;\nexport class VSBuffer {\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * Math.pow(2, 24)\n        + source[offset + 1] * Math.pow(2, 16)\n        + source[offset + 2] * Math.pow(2, 8)\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n"]},"metadata":{},"sourceType":"module"}