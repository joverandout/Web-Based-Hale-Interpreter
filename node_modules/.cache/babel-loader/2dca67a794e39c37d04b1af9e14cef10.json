{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = new Array();\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\n\nexport class SmallImmutableSet {\n  constructor(items, additionalItems) {\n    this.items = items;\n    this.additionalItems = additionalItems;\n  }\n\n  static create(items, additionalItems) {\n    if (items <= 128 && additionalItems.length === 0) {\n      // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n      let cached = SmallImmutableSet.cache[items];\n\n      if (!cached) {\n        cached = new SmallImmutableSet(items, additionalItems);\n        SmallImmutableSet.cache[items] = cached;\n      }\n\n      return cached;\n    }\n\n    return new SmallImmutableSet(items, additionalItems);\n  }\n\n  static getEmpty() {\n    return this.empty;\n  }\n\n  add(value, keyProvider) {\n    const key = keyProvider.getKey(value);\n    let idx = key >> 5; // divided by 32\n\n    if (idx === 0) {\n      // fast path\n      const newItem = 1 << key | this.items;\n\n      if (newItem === this.items) {\n        return this;\n      }\n\n      return SmallImmutableSet.create(newItem, this.additionalItems);\n    }\n\n    idx--;\n    const newItems = this.additionalItems.slice(0);\n\n    while (newItems.length < idx) {\n      newItems.push(0);\n    }\n\n    newItems[idx] |= 1 << (key & 31);\n    return SmallImmutableSet.create(this.items, newItems);\n  }\n\n  merge(other) {\n    const merged = this.items | other.items;\n\n    if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n      // fast path\n      if (merged === this.items) {\n        return this;\n      }\n\n      if (merged === other.items) {\n        return other;\n      }\n\n      return SmallImmutableSet.create(merged, emptyArr);\n    } // This can be optimized, but it's not a common case\n\n\n    const newItems = new Array();\n\n    for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n      const item1 = this.additionalItems[i] || 0;\n      const item2 = other.additionalItems[i] || 0;\n      newItems.push(item1 | item2);\n    }\n\n    return SmallImmutableSet.create(merged, newItems);\n  }\n\n  intersects(other) {\n    if ((this.items & other.items) !== 0) {\n      return true;\n    }\n\n    for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n      if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport const identityKeyProvider = {\n  getKey(value) {\n    return value;\n  }\n\n};\n/**\n * Assigns values a unique incrementing key.\n*/\n\nexport class DenseKeyProvider {\n  constructor() {\n    this.items = new Map();\n  }\n\n  getKey(value) {\n    let existing = this.items.get(value);\n\n    if (existing === undefined) {\n      existing = this.items.size;\n      this.items.set(value, existing);\n    }\n\n    return existing;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js"],"names":["emptyArr","Array","SmallImmutableSet","constructor","items","additionalItems","create","length","cached","cache","getEmpty","empty","add","value","keyProvider","key","getKey","idx","newItem","newItems","slice","push","merge","other","merged","i","Math","max","item1","item2","intersects","min","identityKeyProvider","DenseKeyProvider","Map","existing","get","undefined","size","set"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = new Array();\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static getEmpty() {\n        return this.empty;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = new Array();\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}