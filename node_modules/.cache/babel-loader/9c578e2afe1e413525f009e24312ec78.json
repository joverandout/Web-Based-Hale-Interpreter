{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeError } from './tree.js';\nimport { splice, tail2 } from '../../../common/arrays.js';\nimport { Delayer, MicrotaskDelay } from '../../../common/async.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n  return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n  switch (visibility) {\n    case true:\n      return 1\n      /* Visible */\n      ;\n\n    case false:\n      return 0\n      /* Hidden */\n      ;\n\n    default:\n      return visibility;\n  }\n}\n\nfunction isCollapsibleStateUpdate(update) {\n  return typeof update.collapsible === 'boolean';\n}\n\nexport class IndexTreeModel {\n  constructor(user, list, rootElement, options = {}) {\n    this.user = user;\n    this.list = list;\n    this.rootRef = [];\n    this.eventBufferer = new EventBufferer();\n    this._onDidChangeCollapseState = new Emitter();\n    this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n    this._onDidChangeRenderNodeCount = new Emitter();\n    this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n    this._onDidSplice = new Emitter();\n    this.onDidSplice = this._onDidSplice.event;\n    this.refilterDelayer = new Delayer(MicrotaskDelay);\n    this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n    this.filter = options.filter;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.root = {\n      parent: undefined,\n      element: rootElement,\n      children: [],\n      depth: 0,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: false,\n      collapsed: false,\n      renderNodeCount: 0,\n      visibility: 1\n      /* Visible */\n      ,\n      visible: true,\n      filterData: undefined\n    };\n  }\n\n  splice(location, deleteCount, toInsert = Iterable.empty(), options = {}) {\n    if (location.length === 0) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n\n    if (options.diffIdentityProvider) {\n      this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n    } else {\n      this.spliceSimple(location, deleteCount, toInsert, options);\n    }\n  }\n\n  spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\n    var _a;\n\n    if (toInsertIterable === void 0) {\n      toInsertIterable = Iterable.empty();\n    }\n\n    if (recurseLevels === void 0) {\n      recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0;\n    }\n\n    const {\n      parentNode\n    } = this.getParentNodeWithListIndex(location);\n\n    if (!parentNode.lastDiffIds) {\n      return this.spliceSimple(location, deleteCount, toInsertIterable, options);\n    }\n\n    const toInsert = [...toInsertIterable];\n    const index = location[location.length - 1];\n    const diff = new LcsDiff({\n      getElements: () => parentNode.lastDiffIds\n    }, {\n      getElements: () => [...parentNode.children.slice(0, index), ...toInsert, ...parentNode.children.slice(index + deleteCount)].map(e => identity.getId(e.element).toString())\n    }).ComputeDiff(false); // if we were given a 'best effort' diff, use default behavior\n\n    if (diff.quitEarly) {\n      parentNode.lastDiffIds = undefined;\n      return this.spliceSimple(location, deleteCount, toInsert, options);\n    }\n\n    const locationPrefix = location.slice(0, -1);\n\n    const recurseSplice = (fromOriginal, fromModified, count) => {\n      if (recurseLevels > 0) {\n        for (let i = 0; i < count; i++) {\n          fromOriginal--;\n          fromModified--;\n          this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\n        }\n      }\n    };\n\n    let lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n    let lastStartM = toInsert.length;\n\n    for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\n      recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n      lastStartO = change.originalStart;\n      lastStartM = change.modifiedStart - index;\n      this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\n    } // at this point, startO === startM === count since any remaining prefix should match\n\n\n    recurseSplice(lastStartO, lastStartM, lastStartO);\n  }\n\n  spliceSimple(location, deleteCount, toInsert = Iterable.empty(), {\n    onDidCreateNode,\n    onDidDeleteNode,\n    diffIdentityProvider\n  }) {\n    const {\n      parentNode,\n      listIndex,\n      revealed,\n      visible\n    } = this.getParentNodeWithListIndex(location);\n    const treeListElementsToInsert = [];\n    const nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? 1\n    /* Visible */\n    : 0\n    /* Hidden */\n    , revealed, treeListElementsToInsert, onDidCreateNode));\n    const lastIndex = location[location.length - 1];\n    const lastHadChildren = parentNode.children.length > 0; // figure out what's the visible child start index right before the\n    // splice point\n\n    let visibleChildStartIndex = 0;\n\n    for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n      const child = parentNode.children[i];\n\n      if (child.visible) {\n        visibleChildStartIndex = child.visibleChildIndex;\n        break;\n      }\n    }\n\n    const nodesToInsert = [];\n    let insertedVisibleChildrenCount = 0;\n    let renderNodeCount = 0;\n\n    for (const child of nodesToInsertIterator) {\n      nodesToInsert.push(child);\n      renderNodeCount += child.renderNodeCount;\n\n      if (child.visible) {\n        child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n      }\n    }\n\n    const deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);\n\n    if (!diffIdentityProvider) {\n      parentNode.lastDiffIds = undefined;\n    } else if (parentNode.lastDiffIds) {\n      splice(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map(n => diffIdentityProvider.getId(n.element).toString()));\n    } else {\n      parentNode.lastDiffIds = parentNode.children.map(n => diffIdentityProvider.getId(n.element).toString());\n    } // figure out what is the count of deleted visible children\n\n\n    let deletedVisibleChildrenCount = 0;\n\n    for (const child of deletedNodes) {\n      if (child.visible) {\n        deletedVisibleChildrenCount++;\n      }\n    } // and adjust for all visible children after the splice point\n\n\n    if (deletedVisibleChildrenCount !== 0) {\n      for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n        const child = parentNode.children[i];\n\n        if (child.visible) {\n          child.visibleChildIndex -= deletedVisibleChildrenCount;\n        }\n      }\n    } // update parent's visible children count\n\n\n    parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n\n    if (revealed && visible) {\n      const visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\n\n      this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n\n      this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n    }\n\n    if (deletedNodes.length > 0 && onDidDeleteNode) {\n      const visit = node => {\n        onDidDeleteNode(node);\n        node.children.forEach(visit);\n      };\n\n      deletedNodes.forEach(visit);\n    }\n\n    const currentlyHasChildren = parentNode.children.length > 0;\n\n    if (lastHadChildren !== currentlyHasChildren) {\n      this.setCollapsible(location.slice(0, -1), currentlyHasChildren);\n    }\n\n    this._onDidSplice.fire({\n      insertedNodes: nodesToInsert,\n      deletedNodes\n    });\n\n    let node = parentNode;\n\n    while (node) {\n      if (node.visibility === 2\n      /* Recurse */\n      ) {\n        // delayed to avoid excessive refiltering, see #135941\n        this.refilterDelayer.trigger(() => this.refilter());\n        break;\n      }\n\n      node = node.parent;\n    }\n  }\n\n  rerender(location) {\n    if (location.length === 0) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n\n    const {\n      node,\n      listIndex,\n      revealed\n    } = this.getTreeNodeWithListIndex(location);\n\n    if (node.visible && revealed) {\n      this.list.splice(listIndex, 1, [node]);\n    }\n  }\n\n  has(location) {\n    return this.hasTreeNode(location);\n  }\n\n  getListIndex(location) {\n    const {\n      listIndex,\n      visible,\n      revealed\n    } = this.getTreeNodeWithListIndex(location);\n    return visible && revealed ? listIndex : -1;\n  }\n\n  getListRenderCount(location) {\n    return this.getTreeNode(location).renderNodeCount;\n  }\n\n  isCollapsible(location) {\n    return this.getTreeNode(location).collapsible;\n  }\n\n  setCollapsible(location, collapsible) {\n    const node = this.getTreeNode(location);\n\n    if (typeof collapsible === 'undefined') {\n      collapsible = !node.collapsible;\n    }\n\n    const update = {\n      collapsible\n    };\n    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n  }\n\n  isCollapsed(location) {\n    return this.getTreeNode(location).collapsed;\n  }\n\n  setCollapsed(location, collapsed, recursive) {\n    const node = this.getTreeNode(location);\n\n    if (typeof collapsed === 'undefined') {\n      collapsed = !node.collapsed;\n    }\n\n    const update = {\n      collapsed,\n      recursive: recursive || false\n    };\n    return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n  }\n\n  _setCollapseState(location, update) {\n    const {\n      node,\n      listIndex,\n      revealed\n    } = this.getTreeNodeWithListIndex(location);\n\n    const result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n\n    if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n      let onlyVisibleChildIndex = -1;\n\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n\n        if (child.visible) {\n          if (onlyVisibleChildIndex > -1) {\n            onlyVisibleChildIndex = -1;\n            break;\n          } else {\n            onlyVisibleChildIndex = i;\n          }\n        }\n      }\n\n      if (onlyVisibleChildIndex > -1) {\n        this._setCollapseState([...location, onlyVisibleChildIndex], update);\n      }\n    }\n\n    return result;\n  }\n\n  _setListNodeCollapseState(node, listIndex, revealed, update) {\n    const result = this._setNodeCollapseState(node, update, false);\n\n    if (!revealed || !node.visible || !result) {\n      return result;\n    }\n\n    const previousRenderNodeCount = node.renderNodeCount;\n    const toInsert = this.updateNodeAfterCollapseChange(node);\n    const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n    this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n    return result;\n  }\n\n  _setNodeCollapseState(node, update, deep) {\n    let result;\n\n    if (node === this.root) {\n      result = false;\n    } else {\n      if (isCollapsibleStateUpdate(update)) {\n        result = node.collapsible !== update.collapsible;\n        node.collapsible = update.collapsible;\n      } else if (!node.collapsible) {\n        result = false;\n      } else {\n        result = node.collapsed !== update.collapsed;\n        node.collapsed = update.collapsed;\n      }\n\n      if (result) {\n        this._onDidChangeCollapseState.fire({\n          node,\n          deep\n        });\n      }\n    }\n\n    if (!isCollapsibleStateUpdate(update) && update.recursive) {\n      for (const child of node.children) {\n        result = this._setNodeCollapseState(child, update, true) || result;\n      }\n    }\n\n    return result;\n  }\n\n  expandTo(location) {\n    this.eventBufferer.bufferEvents(() => {\n      let node = this.getTreeNode(location);\n\n      while (node.parent) {\n        node = node.parent;\n        location = location.slice(0, location.length - 1);\n\n        if (node.collapsed) {\n          this._setCollapseState(location, {\n            collapsed: false,\n            recursive: false\n          });\n        }\n      }\n    });\n  }\n\n  refilter() {\n    const previousRenderNodeCount = this.root.renderNodeCount;\n    const toInsert = this.updateNodeAfterFilterChange(this.root);\n    this.list.splice(0, previousRenderNodeCount, toInsert);\n    this.refilterDelayer.cancel();\n  }\n\n  createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n    const node = {\n      parent,\n      element: treeElement.element,\n      children: [],\n      depth: parent.depth + 1,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : typeof treeElement.collapsed !== 'undefined',\n      collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n      renderNodeCount: 1,\n      visibility: 1\n      /* Visible */\n      ,\n      visible: true,\n      filterData: undefined\n    };\n\n    const visibility = this._filterNode(node, parentVisibility);\n\n    node.visibility = visibility;\n\n    if (revealed) {\n      treeListElements.push(node);\n    }\n\n    const childElements = treeElement.children || Iterable.empty();\n    const childRevealed = revealed && visibility !== 0\n    /* Hidden */\n    && !node.collapsed;\n    const childNodes = Iterable.map(childElements, el => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));\n    let visibleChildrenCount = 0;\n    let renderNodeCount = 1;\n\n    for (const child of childNodes) {\n      node.children.push(child);\n      renderNodeCount += child.renderNodeCount;\n\n      if (child.visible) {\n        child.visibleChildIndex = visibleChildrenCount++;\n      }\n    }\n\n    node.collapsible = node.collapsible || node.children.length > 0;\n    node.visibleChildrenCount = visibleChildrenCount;\n    node.visible = visibility === 2\n    /* Recurse */\n    ? visibleChildrenCount > 0 : visibility === 1\n    /* Visible */\n    ;\n\n    if (!node.visible) {\n      node.renderNodeCount = 0;\n\n      if (revealed) {\n        treeListElements.pop();\n      }\n    } else if (!node.collapsed) {\n      node.renderNodeCount = renderNodeCount;\n    }\n\n    if (onDidCreateNode) {\n      onDidCreateNode(node);\n    }\n\n    return node;\n  }\n\n  updateNodeAfterCollapseChange(node) {\n    const previousRenderNodeCount = node.renderNodeCount;\n    const result = [];\n\n    this._updateNodeAfterCollapseChange(node, result);\n\n    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n    return result;\n  }\n\n  _updateNodeAfterCollapseChange(node, result) {\n    if (node.visible === false) {\n      return 0;\n    }\n\n    result.push(node);\n    node.renderNodeCount = 1;\n\n    if (!node.collapsed) {\n      for (const child of node.children) {\n        node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n      }\n    }\n\n    this._onDidChangeRenderNodeCount.fire(node);\n\n    return node.renderNodeCount;\n  }\n\n  updateNodeAfterFilterChange(node) {\n    const previousRenderNodeCount = node.renderNodeCount;\n    const result = [];\n\n    this._updateNodeAfterFilterChange(node, node.visible ? 1\n    /* Visible */\n    : 0\n    /* Hidden */\n    , result);\n\n    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n    return result;\n  }\n\n  _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {\n    let visibility;\n\n    if (node !== this.root) {\n      visibility = this._filterNode(node, parentVisibility);\n\n      if (visibility === 0\n      /* Hidden */\n      ) {\n        node.visible = false;\n        node.renderNodeCount = 0;\n        return false;\n      }\n\n      if (revealed) {\n        result.push(node);\n      }\n    }\n\n    const resultStartLength = result.length;\n    node.renderNodeCount = node === this.root ? 0 : 1;\n    let hasVisibleDescendants = false;\n\n    if (!node.collapsed || visibility !== 0\n    /* Hidden */\n    ) {\n      let visibleChildIndex = 0;\n\n      for (const child of node.children) {\n        hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n\n        if (child.visible) {\n          child.visibleChildIndex = visibleChildIndex++;\n        }\n      }\n\n      node.visibleChildrenCount = visibleChildIndex;\n    } else {\n      node.visibleChildrenCount = 0;\n    }\n\n    if (node !== this.root) {\n      node.visible = visibility === 2\n      /* Recurse */\n      ? hasVisibleDescendants : visibility === 1\n      /* Visible */\n      ;\n      node.visibility = visibility;\n    }\n\n    if (!node.visible) {\n      node.renderNodeCount = 0;\n\n      if (revealed) {\n        result.pop();\n      }\n    } else if (!node.collapsed) {\n      node.renderNodeCount += result.length - resultStartLength;\n    }\n\n    this._onDidChangeRenderNodeCount.fire(node);\n\n    return node.visible;\n  }\n\n  _updateAncestorsRenderNodeCount(node, diff) {\n    if (diff === 0) {\n      return;\n    }\n\n    while (node) {\n      node.renderNodeCount += diff;\n\n      this._onDidChangeRenderNodeCount.fire(node);\n\n      node = node.parent;\n    }\n  }\n\n  _filterNode(node, parentVisibility) {\n    const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1\n    /* Visible */\n    ;\n\n    if (typeof result === 'boolean') {\n      node.filterData = undefined;\n      return result ? 1\n      /* Visible */\n      : 0\n      /* Hidden */\n      ;\n    } else if (isFilterResult(result)) {\n      node.filterData = result.data;\n      return getVisibleState(result.visibility);\n    } else {\n      node.filterData = undefined;\n      return getVisibleState(result);\n    }\n  } // cheap\n\n\n  hasTreeNode(location, node = this.root) {\n    if (!location || location.length === 0) {\n      return true;\n    }\n\n    const [index, ...rest] = location;\n\n    if (index < 0 || index > node.children.length) {\n      return false;\n    }\n\n    return this.hasTreeNode(rest, node.children[index]);\n  } // cheap\n\n\n  getTreeNode(location, node = this.root) {\n    if (!location || location.length === 0) {\n      return node;\n    }\n\n    const [index, ...rest] = location;\n\n    if (index < 0 || index > node.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n\n    return this.getTreeNode(rest, node.children[index]);\n  } // expensive\n\n\n  getTreeNodeWithListIndex(location) {\n    if (location.length === 0) {\n      return {\n        node: this.root,\n        listIndex: -1,\n        revealed: true,\n        visible: false\n      };\n    }\n\n    const {\n      parentNode,\n      listIndex,\n      revealed,\n      visible\n    } = this.getParentNodeWithListIndex(location);\n    const index = location[location.length - 1];\n\n    if (index < 0 || index > parentNode.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n\n    const node = parentNode.children[index];\n    return {\n      node,\n      listIndex,\n      revealed,\n      visible: visible && node.visible\n    };\n  }\n\n  getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {\n    const [index, ...rest] = location;\n\n    if (index < 0 || index > node.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    } // TODO@joao perf!\n\n\n    for (let i = 0; i < index; i++) {\n      listIndex += node.children[i].renderNodeCount;\n    }\n\n    revealed = revealed && !node.collapsed;\n    visible = visible && node.visible;\n\n    if (rest.length === 0) {\n      return {\n        parentNode: node,\n        listIndex,\n        revealed,\n        visible\n      };\n    }\n\n    return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n  }\n\n  getNode(location = []) {\n    return this.getTreeNode(location);\n  } // TODO@joao perf!\n\n\n  getNodeLocation(node) {\n    const location = [];\n    let indexTreeNode = node; // typing woes\n\n    while (indexTreeNode.parent) {\n      location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n      indexTreeNode = indexTreeNode.parent;\n    }\n\n    return location.reverse();\n  }\n\n  getParentNodeLocation(location) {\n    if (location.length === 0) {\n      return undefined;\n    } else if (location.length === 1) {\n      return [];\n    } else {\n      return tail2(location)[0];\n    }\n  }\n\n  getFirstElementChild(location) {\n    const node = this.getTreeNode(location);\n\n    if (node.children.length === 0) {\n      return undefined;\n    }\n\n    return node.children[0].element;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js"],"names":["TreeError","splice","tail2","Delayer","MicrotaskDelay","LcsDiff","Emitter","EventBufferer","Iterable","isFilterResult","obj","getVisibleState","visibility","isCollapsibleStateUpdate","update","collapsible","IndexTreeModel","constructor","user","list","rootElement","options","rootRef","eventBufferer","_onDidChangeCollapseState","onDidChangeCollapseState","wrapEvent","event","_onDidChangeRenderNodeCount","onDidChangeRenderNodeCount","_onDidSplice","onDidSplice","refilterDelayer","collapseByDefault","filter","autoExpandSingleChildren","root","parent","undefined","element","children","depth","visibleChildrenCount","visibleChildIndex","collapsed","renderNodeCount","visible","filterData","location","deleteCount","toInsert","empty","length","diffIdentityProvider","spliceSmart","spliceSimple","identity","toInsertIterable","recurseLevels","_a","diffDepth","parentNode","getParentNodeWithListIndex","lastDiffIds","index","diff","getElements","slice","map","e","getId","toString","ComputeDiff","quitEarly","locationPrefix","recurseSplice","fromOriginal","fromModified","count","i","Number","MAX_SAFE_INTEGER","lastStartO","Math","min","lastStartM","change","changes","sort","a","b","originalStart","originalLength","modifiedStart","modifiedLength","onDidCreateNode","onDidDeleteNode","listIndex","revealed","treeListElementsToInsert","nodesToInsertIterator","el","createTreeNode","lastIndex","lastHadChildren","visibleChildStartIndex","child","nodesToInsert","insertedVisibleChildrenCount","push","deletedNodes","n","deletedVisibleChildrenCount","visibleDeleteCount","reduce","r","node","_updateAncestorsRenderNodeCount","visit","forEach","currentlyHasChildren","setCollapsible","fire","insertedNodes","trigger","refilter","rerender","getTreeNodeWithListIndex","has","hasTreeNode","getListIndex","getListRenderCount","getTreeNode","isCollapsible","bufferEvents","_setCollapseState","isCollapsed","setCollapsed","recursive","result","_setListNodeCollapseState","onlyVisibleChildIndex","_setNodeCollapseState","previousRenderNodeCount","updateNodeAfterCollapseChange","deep","expandTo","updateNodeAfterFilterChange","cancel","treeElement","parentVisibility","treeListElements","_filterNode","childElements","childRevealed","childNodes","pop","_updateNodeAfterCollapseChange","_updateNodeAfterFilterChange","resultStartLength","hasVisibleDescendants","data","rest","getNode","getNodeLocation","indexTreeNode","indexOf","reverse","getParentNodeLocation","getFirstElementChild"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeError } from './tree.js';\nimport { splice, tail2 } from '../../../common/arrays.js';\nimport { Delayer, MicrotaskDelay } from '../../../common/async.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n    return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n    switch (visibility) {\n        case true: return 1 /* Visible */;\n        case false: return 0 /* Hidden */;\n        default: return visibility;\n    }\n}\nfunction isCollapsibleStateUpdate(update) {\n    return typeof update.collapsible === 'boolean';\n}\nexport class IndexTreeModel {\n    constructor(user, list, rootElement, options = {}) {\n        this.user = user;\n        this.list = list;\n        this.rootRef = [];\n        this.eventBufferer = new EventBufferer();\n        this._onDidChangeCollapseState = new Emitter();\n        this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n        this._onDidChangeRenderNodeCount = new Emitter();\n        this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n        this._onDidSplice = new Emitter();\n        this.onDidSplice = this._onDidSplice.event;\n        this.refilterDelayer = new Delayer(MicrotaskDelay);\n        this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n        this.filter = options.filter;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.root = {\n            parent: undefined,\n            element: rootElement,\n            children: [],\n            depth: 0,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: false,\n            collapsed: false,\n            renderNodeCount: 0,\n            visibility: 1 /* Visible */,\n            visible: true,\n            filterData: undefined\n        };\n    }\n    splice(location, deleteCount, toInsert = Iterable.empty(), options = {}) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        if (options.diffIdentityProvider) {\n            this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n        }\n        else {\n            this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n    }\n    spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\n        var _a;\n        if (toInsertIterable === void 0) { toInsertIterable = Iterable.empty(); }\n        if (recurseLevels === void 0) { recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0; }\n        const { parentNode } = this.getParentNodeWithListIndex(location);\n        if (!parentNode.lastDiffIds) {\n            return this.spliceSimple(location, deleteCount, toInsertIterable, options);\n        }\n        const toInsert = [...toInsertIterable];\n        const index = location[location.length - 1];\n        const diff = new LcsDiff({ getElements: () => parentNode.lastDiffIds }, {\n            getElements: () => [\n                ...parentNode.children.slice(0, index),\n                ...toInsert,\n                ...parentNode.children.slice(index + deleteCount),\n            ].map(e => identity.getId(e.element).toString())\n        }).ComputeDiff(false);\n        // if we were given a 'best effort' diff, use default behavior\n        if (diff.quitEarly) {\n            parentNode.lastDiffIds = undefined;\n            return this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n        const locationPrefix = location.slice(0, -1);\n        const recurseSplice = (fromOriginal, fromModified, count) => {\n            if (recurseLevels > 0) {\n                for (let i = 0; i < count; i++) {\n                    fromOriginal--;\n                    fromModified--;\n                    this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\n                }\n            }\n        };\n        let lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n        let lastStartM = toInsert.length;\n        for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\n            recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n            lastStartO = change.originalStart;\n            lastStartM = change.modifiedStart - index;\n            this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\n        }\n        // at this point, startO === startM === count since any remaining prefix should match\n        recurseSplice(lastStartO, lastStartM, lastStartO);\n    }\n    spliceSimple(location, deleteCount, toInsert = Iterable.empty(), { onDidCreateNode, onDidDeleteNode, diffIdentityProvider }) {\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const treeListElementsToInsert = [];\n        const nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* Visible */ : 0 /* Hidden */, revealed, treeListElementsToInsert, onDidCreateNode));\n        const lastIndex = location[location.length - 1];\n        const lastHadChildren = parentNode.children.length > 0;\n        // figure out what's the visible child start index right before the\n        // splice point\n        let visibleChildStartIndex = 0;\n        for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n            const child = parentNode.children[i];\n            if (child.visible) {\n                visibleChildStartIndex = child.visibleChildIndex;\n                break;\n            }\n        }\n        const nodesToInsert = [];\n        let insertedVisibleChildrenCount = 0;\n        let renderNodeCount = 0;\n        for (const child of nodesToInsertIterator) {\n            nodesToInsert.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n            }\n        }\n        const deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);\n        if (!diffIdentityProvider) {\n            parentNode.lastDiffIds = undefined;\n        }\n        else if (parentNode.lastDiffIds) {\n            splice(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map(n => diffIdentityProvider.getId(n.element).toString()));\n        }\n        else {\n            parentNode.lastDiffIds = parentNode.children.map(n => diffIdentityProvider.getId(n.element).toString());\n        }\n        // figure out what is the count of deleted visible children\n        let deletedVisibleChildrenCount = 0;\n        for (const child of deletedNodes) {\n            if (child.visible) {\n                deletedVisibleChildrenCount++;\n            }\n        }\n        // and adjust for all visible children after the splice point\n        if (deletedVisibleChildrenCount !== 0) {\n            for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n                const child = parentNode.children[i];\n                if (child.visible) {\n                    child.visibleChildIndex -= deletedVisibleChildrenCount;\n                }\n            }\n        }\n        // update parent's visible children count\n        parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n        if (revealed && visible) {\n            const visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\n            this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n            this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n        }\n        if (deletedNodes.length > 0 && onDidDeleteNode) {\n            const visit = (node) => {\n                onDidDeleteNode(node);\n                node.children.forEach(visit);\n            };\n            deletedNodes.forEach(visit);\n        }\n        const currentlyHasChildren = parentNode.children.length > 0;\n        if (lastHadChildren !== currentlyHasChildren) {\n            this.setCollapsible(location.slice(0, -1), currentlyHasChildren);\n        }\n        this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });\n        let node = parentNode;\n        while (node) {\n            if (node.visibility === 2 /* Recurse */) {\n                // delayed to avoid excessive refiltering, see #135941\n                this.refilterDelayer.trigger(() => this.refilter());\n                break;\n            }\n            node = node.parent;\n        }\n    }\n    rerender(location) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        if (node.visible && revealed) {\n            this.list.splice(listIndex, 1, [node]);\n        }\n    }\n    has(location) {\n        return this.hasTreeNode(location);\n    }\n    getListIndex(location) {\n        const { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);\n        return visible && revealed ? listIndex : -1;\n    }\n    getListRenderCount(location) {\n        return this.getTreeNode(location).renderNodeCount;\n    }\n    isCollapsible(location) {\n        return this.getTreeNode(location).collapsible;\n    }\n    setCollapsible(location, collapsible) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsible === 'undefined') {\n            collapsible = !node.collapsible;\n        }\n        const update = { collapsible };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    isCollapsed(location) {\n        return this.getTreeNode(location).collapsed;\n    }\n    setCollapsed(location, collapsed, recursive) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsed === 'undefined') {\n            collapsed = !node.collapsed;\n        }\n        const update = { collapsed, recursive: recursive || false };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    _setCollapseState(location, update) {\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        const result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n        if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n            let onlyVisibleChildIndex = -1;\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                if (child.visible) {\n                    if (onlyVisibleChildIndex > -1) {\n                        onlyVisibleChildIndex = -1;\n                        break;\n                    }\n                    else {\n                        onlyVisibleChildIndex = i;\n                    }\n                }\n            }\n            if (onlyVisibleChildIndex > -1) {\n                this._setCollapseState([...location, onlyVisibleChildIndex], update);\n            }\n        }\n        return result;\n    }\n    _setListNodeCollapseState(node, listIndex, revealed, update) {\n        const result = this._setNodeCollapseState(node, update, false);\n        if (!revealed || !node.visible || !result) {\n            return result;\n        }\n        const previousRenderNodeCount = node.renderNodeCount;\n        const toInsert = this.updateNodeAfterCollapseChange(node);\n        const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n        this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n        return result;\n    }\n    _setNodeCollapseState(node, update, deep) {\n        let result;\n        if (node === this.root) {\n            result = false;\n        }\n        else {\n            if (isCollapsibleStateUpdate(update)) {\n                result = node.collapsible !== update.collapsible;\n                node.collapsible = update.collapsible;\n            }\n            else if (!node.collapsible) {\n                result = false;\n            }\n            else {\n                result = node.collapsed !== update.collapsed;\n                node.collapsed = update.collapsed;\n            }\n            if (result) {\n                this._onDidChangeCollapseState.fire({ node, deep });\n            }\n        }\n        if (!isCollapsibleStateUpdate(update) && update.recursive) {\n            for (const child of node.children) {\n                result = this._setNodeCollapseState(child, update, true) || result;\n            }\n        }\n        return result;\n    }\n    expandTo(location) {\n        this.eventBufferer.bufferEvents(() => {\n            let node = this.getTreeNode(location);\n            while (node.parent) {\n                node = node.parent;\n                location = location.slice(0, location.length - 1);\n                if (node.collapsed) {\n                    this._setCollapseState(location, { collapsed: false, recursive: false });\n                }\n            }\n        });\n    }\n    refilter() {\n        const previousRenderNodeCount = this.root.renderNodeCount;\n        const toInsert = this.updateNodeAfterFilterChange(this.root);\n        this.list.splice(0, previousRenderNodeCount, toInsert);\n        this.refilterDelayer.cancel();\n    }\n    createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n        const node = {\n            parent,\n            element: treeElement.element,\n            children: [],\n            depth: parent.depth + 1,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\n            collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n            renderNodeCount: 1,\n            visibility: 1 /* Visible */,\n            visible: true,\n            filterData: undefined\n        };\n        const visibility = this._filterNode(node, parentVisibility);\n        node.visibility = visibility;\n        if (revealed) {\n            treeListElements.push(node);\n        }\n        const childElements = treeElement.children || Iterable.empty();\n        const childRevealed = revealed && visibility !== 0 /* Hidden */ && !node.collapsed;\n        const childNodes = Iterable.map(childElements, el => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));\n        let visibleChildrenCount = 0;\n        let renderNodeCount = 1;\n        for (const child of childNodes) {\n            node.children.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildrenCount++;\n            }\n        }\n        node.collapsible = node.collapsible || node.children.length > 0;\n        node.visibleChildrenCount = visibleChildrenCount;\n        node.visible = visibility === 2 /* Recurse */ ? visibleChildrenCount > 0 : (visibility === 1 /* Visible */);\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                treeListElements.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount = renderNodeCount;\n        }\n        if (onDidCreateNode) {\n            onDidCreateNode(node);\n        }\n        return node;\n    }\n    updateNodeAfterCollapseChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterCollapseChange(node, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterCollapseChange(node, result) {\n        if (node.visible === false) {\n            return 0;\n        }\n        result.push(node);\n        node.renderNodeCount = 1;\n        if (!node.collapsed) {\n            for (const child of node.children) {\n                node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n            }\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.renderNodeCount;\n    }\n    updateNodeAfterFilterChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterFilterChange(node, node.visible ? 1 /* Visible */ : 0 /* Hidden */, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {\n        let visibility;\n        if (node !== this.root) {\n            visibility = this._filterNode(node, parentVisibility);\n            if (visibility === 0 /* Hidden */) {\n                node.visible = false;\n                node.renderNodeCount = 0;\n                return false;\n            }\n            if (revealed) {\n                result.push(node);\n            }\n        }\n        const resultStartLength = result.length;\n        node.renderNodeCount = node === this.root ? 0 : 1;\n        let hasVisibleDescendants = false;\n        if (!node.collapsed || visibility !== 0 /* Hidden */) {\n            let visibleChildIndex = 0;\n            for (const child of node.children) {\n                hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n                if (child.visible) {\n                    child.visibleChildIndex = visibleChildIndex++;\n                }\n            }\n            node.visibleChildrenCount = visibleChildIndex;\n        }\n        else {\n            node.visibleChildrenCount = 0;\n        }\n        if (node !== this.root) {\n            node.visible = visibility === 2 /* Recurse */ ? hasVisibleDescendants : (visibility === 1 /* Visible */);\n            node.visibility = visibility;\n        }\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                result.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount += result.length - resultStartLength;\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.visible;\n    }\n    _updateAncestorsRenderNodeCount(node, diff) {\n        if (diff === 0) {\n            return;\n        }\n        while (node) {\n            node.renderNodeCount += diff;\n            this._onDidChangeRenderNodeCount.fire(node);\n            node = node.parent;\n        }\n    }\n    _filterNode(node, parentVisibility) {\n        const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* Visible */;\n        if (typeof result === 'boolean') {\n            node.filterData = undefined;\n            return result ? 1 /* Visible */ : 0 /* Hidden */;\n        }\n        else if (isFilterResult(result)) {\n            node.filterData = result.data;\n            return getVisibleState(result.visibility);\n        }\n        else {\n            node.filterData = undefined;\n            return getVisibleState(result);\n        }\n    }\n    // cheap\n    hasTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return true;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            return false;\n        }\n        return this.hasTreeNode(rest, node.children[index]);\n    }\n    // cheap\n    getTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return node;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        return this.getTreeNode(rest, node.children[index]);\n    }\n    // expensive\n    getTreeNodeWithListIndex(location) {\n        if (location.length === 0) {\n            return { node: this.root, listIndex: -1, revealed: true, visible: false };\n        }\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const index = location[location.length - 1];\n        if (index < 0 || index > parentNode.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const node = parentNode.children[index];\n        return { node, listIndex, revealed, visible: visible && node.visible };\n    }\n    getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        // TODO@joao perf!\n        for (let i = 0; i < index; i++) {\n            listIndex += node.children[i].renderNodeCount;\n        }\n        revealed = revealed && !node.collapsed;\n        visible = visible && node.visible;\n        if (rest.length === 0) {\n            return { parentNode: node, listIndex, revealed, visible };\n        }\n        return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n    }\n    getNode(location = []) {\n        return this.getTreeNode(location);\n    }\n    // TODO@joao perf!\n    getNodeLocation(node) {\n        const location = [];\n        let indexTreeNode = node; // typing woes\n        while (indexTreeNode.parent) {\n            location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n            indexTreeNode = indexTreeNode.parent;\n        }\n        return location.reverse();\n    }\n    getParentNodeLocation(location) {\n        if (location.length === 0) {\n            return undefined;\n        }\n        else if (location.length === 1) {\n            return [];\n        }\n        else {\n            return tail2(location)[0];\n        }\n    }\n    getFirstElementChild(location) {\n        const node = this.getTreeNode(location);\n        if (node.children.length === 0) {\n            return undefined;\n        }\n        return node.children[0].element;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}