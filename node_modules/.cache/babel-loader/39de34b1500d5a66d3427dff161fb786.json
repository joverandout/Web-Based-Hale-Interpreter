{"ast":null,"code":"var BIT_16 = Math.pow(2, 16);\nvar BIT_24 = Math.pow(2, 24);\nvar BUFFER_ALLOC_SIZE = Math.pow(2, 8); // The maximum precision JS Numbers can hold precisely\n// Don't panic: Good enough to represent byte values up to 8192 TB\n\nvar IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);\nvar MAX_PACKET_LENGTH = Math.pow(2, 24) - 1;\n\nvar Buffer = require('safe-buffer').Buffer;\n\nmodule.exports = PacketWriter;\n\nfunction PacketWriter() {\n  this._buffer = null;\n  this._offset = 0;\n}\n\nPacketWriter.prototype.toBuffer = function toBuffer(parser) {\n  if (!this._buffer) {\n    this._buffer = Buffer.alloc(0);\n    this._offset = 0;\n  }\n\n  var buffer = this._buffer;\n  var length = this._offset;\n  var packets = Math.floor(length / MAX_PACKET_LENGTH) + 1;\n  this._buffer = Buffer.allocUnsafe(length + packets * 4);\n  this._offset = 0;\n\n  for (var packet = 0; packet < packets; packet++) {\n    var isLast = packet + 1 === packets;\n    var packetLength = isLast ? length % MAX_PACKET_LENGTH : MAX_PACKET_LENGTH;\n    var packetNumber = parser.incrementPacketNumber();\n    this.writeUnsignedNumber(3, packetLength);\n    this.writeUnsignedNumber(1, packetNumber);\n    var start = packet * MAX_PACKET_LENGTH;\n    var end = start + packetLength;\n    this.writeBuffer(buffer.slice(start, end));\n  }\n\n  return this._buffer;\n};\n\nPacketWriter.prototype.writeUnsignedNumber = function (bytes, value) {\n  this._allocate(bytes);\n\n  for (var i = 0; i < bytes; i++) {\n    this._buffer[this._offset++] = value >> i * 8 & 0xff;\n  }\n};\n\nPacketWriter.prototype.writeFiller = function (bytes) {\n  this._allocate(bytes);\n\n  for (var i = 0; i < bytes; i++) {\n    this._buffer[this._offset++] = 0x00;\n  }\n};\n\nPacketWriter.prototype.writeNullTerminatedString = function (value, encoding) {\n  // Typecast undefined into '' and numbers into strings\n  value = value || '';\n  value = value + '';\n  var bytes = Buffer.byteLength(value, encoding || 'utf-8') + 1;\n\n  this._allocate(bytes);\n\n  this._buffer.write(value, this._offset, encoding);\n\n  this._buffer[this._offset + bytes - 1] = 0x00;\n  this._offset += bytes;\n};\n\nPacketWriter.prototype.writeString = function (value) {\n  // Typecast undefined into '' and numbers into strings\n  value = value || '';\n  value = value + '';\n  var bytes = Buffer.byteLength(value, 'utf-8');\n\n  this._allocate(bytes);\n\n  this._buffer.write(value, this._offset, 'utf-8');\n\n  this._offset += bytes;\n};\n\nPacketWriter.prototype.writeBuffer = function (value) {\n  var bytes = value.length;\n\n  this._allocate(bytes);\n\n  value.copy(this._buffer, this._offset);\n  this._offset += bytes;\n};\n\nPacketWriter.prototype.writeLengthCodedNumber = function (value) {\n  if (value === null) {\n    this._allocate(1);\n\n    this._buffer[this._offset++] = 251;\n    return;\n  }\n\n  if (value <= 250) {\n    this._allocate(1);\n\n    this._buffer[this._offset++] = value;\n    return;\n  }\n\n  if (value > IEEE_754_BINARY_64_PRECISION) {\n    throw new Error('writeLengthCodedNumber: JS precision range exceeded, your ' + 'number is > 53 bit: \"' + value + '\"');\n  }\n\n  if (value < BIT_16) {\n    this._allocate(3);\n\n    this._buffer[this._offset++] = 252;\n  } else if (value < BIT_24) {\n    this._allocate(4);\n\n    this._buffer[this._offset++] = 253;\n  } else {\n    this._allocate(9);\n\n    this._buffer[this._offset++] = 254;\n  } // 16 Bit\n\n\n  this._buffer[this._offset++] = value & 0xff;\n  this._buffer[this._offset++] = value >> 8 & 0xff;\n\n  if (value < BIT_16) {\n    return;\n  } // 24 Bit\n\n\n  this._buffer[this._offset++] = value >> 16 & 0xff;\n\n  if (value < BIT_24) {\n    return;\n  }\n\n  this._buffer[this._offset++] = value >> 24 & 0xff; // Hack: Get the most significant 32 bit (JS bitwise operators are 32 bit)\n\n  value = value.toString(2);\n  value = value.substr(0, value.length - 32);\n  value = parseInt(value, 2);\n  this._buffer[this._offset++] = value & 0xff;\n  this._buffer[this._offset++] = value >> 8 & 0xff;\n  this._buffer[this._offset++] = value >> 16 & 0xff; // Set last byte to 0, as we can only support 53 bits in JS (see above)\n\n  this._buffer[this._offset++] = 0;\n};\n\nPacketWriter.prototype.writeLengthCodedBuffer = function (value) {\n  var bytes = value.length;\n  this.writeLengthCodedNumber(bytes);\n  this.writeBuffer(value);\n};\n\nPacketWriter.prototype.writeNullTerminatedBuffer = function (value) {\n  this.writeBuffer(value);\n  this.writeFiller(1); // 0x00 terminator\n};\n\nPacketWriter.prototype.writeLengthCodedString = function (value) {\n  if (value === null) {\n    this.writeLengthCodedNumber(null);\n    return;\n  }\n\n  value = value === undefined ? '' : String(value);\n  var bytes = Buffer.byteLength(value, 'utf-8');\n  this.writeLengthCodedNumber(bytes);\n\n  if (!bytes) {\n    return;\n  }\n\n  this._allocate(bytes);\n\n  this._buffer.write(value, this._offset, 'utf-8');\n\n  this._offset += bytes;\n};\n\nPacketWriter.prototype._allocate = function _allocate(bytes) {\n  if (!this._buffer) {\n    this._buffer = Buffer.alloc(Math.max(BUFFER_ALLOC_SIZE, bytes));\n    this._offset = 0;\n    return;\n  }\n\n  var bytesRemaining = this._buffer.length - this._offset;\n\n  if (bytesRemaining >= bytes) {\n    return;\n  }\n\n  var newSize = this._buffer.length + Math.max(BUFFER_ALLOC_SIZE, bytes);\n  var oldBuffer = this._buffer;\n  this._buffer = Buffer.alloc(newSize);\n  oldBuffer.copy(this._buffer);\n};","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/mysql/lib/protocol/PacketWriter.js"],"names":["BIT_16","Math","pow","BIT_24","BUFFER_ALLOC_SIZE","IEEE_754_BINARY_64_PRECISION","MAX_PACKET_LENGTH","Buffer","require","module","exports","PacketWriter","_buffer","_offset","prototype","toBuffer","parser","alloc","buffer","length","packets","floor","allocUnsafe","packet","isLast","packetLength","packetNumber","incrementPacketNumber","writeUnsignedNumber","start","end","writeBuffer","slice","bytes","value","_allocate","i","writeFiller","writeNullTerminatedString","encoding","byteLength","write","writeString","copy","writeLengthCodedNumber","Error","toString","substr","parseInt","writeLengthCodedBuffer","writeNullTerminatedBuffer","writeLengthCodedString","undefined","String","max","bytesRemaining","newSize","oldBuffer"],"mappings":"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","sourcesContent":["var BIT_16            = Math.pow(2, 16);\nvar BIT_24            = Math.pow(2, 24);\nvar BUFFER_ALLOC_SIZE = Math.pow(2, 8);\n// The maximum precision JS Numbers can hold precisely\n// Don't panic: Good enough to represent byte values up to 8192 TB\nvar IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);\nvar MAX_PACKET_LENGTH            = Math.pow(2, 24) - 1;\nvar Buffer                       = require('safe-buffer').Buffer;\n\nmodule.exports = PacketWriter;\nfunction PacketWriter() {\n  this._buffer = null;\n  this._offset = 0;\n}\n\nPacketWriter.prototype.toBuffer = function toBuffer(parser) {\n  if (!this._buffer) {\n    this._buffer = Buffer.alloc(0);\n    this._offset = 0;\n  }\n\n  var buffer  = this._buffer;\n  var length  = this._offset;\n  var packets = Math.floor(length / MAX_PACKET_LENGTH) + 1;\n\n  this._buffer = Buffer.allocUnsafe(length + packets * 4);\n  this._offset = 0;\n\n  for (var packet = 0; packet < packets; packet++) {\n    var isLast = (packet + 1 === packets);\n    var packetLength = (isLast)\n      ? length % MAX_PACKET_LENGTH\n      : MAX_PACKET_LENGTH;\n\n    var packetNumber = parser.incrementPacketNumber();\n\n    this.writeUnsignedNumber(3, packetLength);\n    this.writeUnsignedNumber(1, packetNumber);\n\n    var start = packet * MAX_PACKET_LENGTH;\n    var end   = start + packetLength;\n\n    this.writeBuffer(buffer.slice(start, end));\n  }\n\n  return this._buffer;\n};\n\nPacketWriter.prototype.writeUnsignedNumber = function(bytes, value) {\n  this._allocate(bytes);\n\n  for (var i = 0; i < bytes; i++) {\n    this._buffer[this._offset++] = (value >> (i * 8)) & 0xff;\n  }\n};\n\nPacketWriter.prototype.writeFiller = function(bytes) {\n  this._allocate(bytes);\n\n  for (var i = 0; i < bytes; i++) {\n    this._buffer[this._offset++] = 0x00;\n  }\n};\n\nPacketWriter.prototype.writeNullTerminatedString = function(value, encoding) {\n  // Typecast undefined into '' and numbers into strings\n  value = value || '';\n  value = value + '';\n\n  var bytes = Buffer.byteLength(value, encoding || 'utf-8') + 1;\n  this._allocate(bytes);\n\n  this._buffer.write(value, this._offset, encoding);\n  this._buffer[this._offset + bytes - 1] = 0x00;\n\n  this._offset += bytes;\n};\n\nPacketWriter.prototype.writeString = function(value) {\n  // Typecast undefined into '' and numbers into strings\n  value = value || '';\n  value = value + '';\n\n  var bytes = Buffer.byteLength(value, 'utf-8');\n  this._allocate(bytes);\n\n  this._buffer.write(value, this._offset, 'utf-8');\n\n  this._offset += bytes;\n};\n\nPacketWriter.prototype.writeBuffer = function(value) {\n  var bytes = value.length;\n\n  this._allocate(bytes);\n  value.copy(this._buffer, this._offset);\n  this._offset += bytes;\n};\n\nPacketWriter.prototype.writeLengthCodedNumber = function(value) {\n  if (value === null) {\n    this._allocate(1);\n    this._buffer[this._offset++] = 251;\n    return;\n  }\n\n  if (value <= 250) {\n    this._allocate(1);\n    this._buffer[this._offset++] = value;\n    return;\n  }\n\n  if (value > IEEE_754_BINARY_64_PRECISION) {\n    throw new Error(\n      'writeLengthCodedNumber: JS precision range exceeded, your ' +\n      'number is > 53 bit: \"' + value + '\"'\n    );\n  }\n\n  if (value < BIT_16) {\n    this._allocate(3);\n    this._buffer[this._offset++] = 252;\n  } else if (value < BIT_24) {\n    this._allocate(4);\n    this._buffer[this._offset++] = 253;\n  } else {\n    this._allocate(9);\n    this._buffer[this._offset++] = 254;\n  }\n\n  // 16 Bit\n  this._buffer[this._offset++] = value & 0xff;\n  this._buffer[this._offset++] = (value >> 8) & 0xff;\n\n  if (value < BIT_16) {\n    return;\n  }\n\n  // 24 Bit\n  this._buffer[this._offset++] = (value >> 16) & 0xff;\n\n  if (value < BIT_24) {\n    return;\n  }\n\n  this._buffer[this._offset++] = (value >> 24) & 0xff;\n\n  // Hack: Get the most significant 32 bit (JS bitwise operators are 32 bit)\n  value = value.toString(2);\n  value = value.substr(0, value.length - 32);\n  value = parseInt(value, 2);\n\n  this._buffer[this._offset++] = value & 0xff;\n  this._buffer[this._offset++] = (value >> 8) & 0xff;\n  this._buffer[this._offset++] = (value >> 16) & 0xff;\n\n  // Set last byte to 0, as we can only support 53 bits in JS (see above)\n  this._buffer[this._offset++] = 0;\n};\n\nPacketWriter.prototype.writeLengthCodedBuffer = function(value) {\n  var bytes = value.length;\n  this.writeLengthCodedNumber(bytes);\n  this.writeBuffer(value);\n};\n\nPacketWriter.prototype.writeNullTerminatedBuffer = function(value) {\n  this.writeBuffer(value);\n  this.writeFiller(1); // 0x00 terminator\n};\n\nPacketWriter.prototype.writeLengthCodedString = function(value) {\n  if (value === null) {\n    this.writeLengthCodedNumber(null);\n    return;\n  }\n\n  value = (value === undefined)\n    ? ''\n    : String(value);\n\n  var bytes = Buffer.byteLength(value, 'utf-8');\n  this.writeLengthCodedNumber(bytes);\n\n  if (!bytes) {\n    return;\n  }\n\n  this._allocate(bytes);\n  this._buffer.write(value, this._offset, 'utf-8');\n  this._offset += bytes;\n};\n\nPacketWriter.prototype._allocate = function _allocate(bytes) {\n  if (!this._buffer) {\n    this._buffer = Buffer.alloc(Math.max(BUFFER_ALLOC_SIZE, bytes));\n    this._offset = 0;\n    return;\n  }\n\n  var bytesRemaining = this._buffer.length - this._offset;\n  if (bytesRemaining >= bytes) {\n    return;\n  }\n\n  var newSize   = this._buffer.length + Math.max(BUFFER_ALLOC_SIZE, bytes);\n  var oldBuffer = this._buffer;\n\n  this._buffer = Buffer.alloc(newSize);\n  oldBuffer.copy(this._buffer);\n};\n"]},"metadata":{},"sourceType":"script"}