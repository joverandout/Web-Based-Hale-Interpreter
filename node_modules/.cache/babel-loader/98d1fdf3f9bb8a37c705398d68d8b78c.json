{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\nexport class MirrorTextModel {\n  constructor(uri, lines, eol, versionId) {\n    this._uri = uri;\n    this._lines = lines;\n    this._eol = eol;\n    this._versionId = versionId;\n    this._lineStarts = null;\n    this._cachedTextValue = null;\n  }\n\n  dispose() {\n    this._lines.length = 0;\n  }\n\n  get version() {\n    return this._versionId;\n  }\n\n  getText() {\n    if (this._cachedTextValue === null) {\n      this._cachedTextValue = this._lines.join(this._eol);\n    }\n\n    return this._cachedTextValue;\n  }\n\n  onEvents(e) {\n    if (e.eol && e.eol !== this._eol) {\n      this._eol = e.eol;\n      this._lineStarts = null;\n    } // Update my lines\n\n\n    const changes = e.changes;\n\n    for (const change of changes) {\n      this._acceptDeleteRange(change.range);\n\n      this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n    }\n\n    this._versionId = e.versionId;\n    this._cachedTextValue = null;\n  }\n\n  _ensureLineStarts() {\n    if (!this._lineStarts) {\n      const eolLength = this._eol.length;\n      const linesLength = this._lines.length;\n      const lineStartValues = new Uint32Array(linesLength);\n\n      for (let i = 0; i < linesLength; i++) {\n        lineStartValues[i] = this._lines[i].length + eolLength;\n      }\n\n      this._lineStarts = new PrefixSumComputer(lineStartValues);\n    }\n  }\n  /**\n   * All changes to a line's text go through this method\n   */\n\n\n  _setLineText(lineIndex, newValue) {\n    this._lines[lineIndex] = newValue;\n\n    if (this._lineStarts) {\n      // update prefix sum\n      this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n    }\n  }\n\n  _acceptDeleteRange(range) {\n    if (range.startLineNumber === range.endLineNumber) {\n      if (range.startColumn === range.endColumn) {\n        // Nothing to delete\n        return;\n      } // Delete text on the affected line\n\n\n      this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n\n      return;\n    } // Take remaining text on last line and append it to remaining text on first line\n\n\n    this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1)); // Delete middle lines\n\n\n    this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\n    if (this._lineStarts) {\n      // update prefix sum\n      this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n  }\n\n  _acceptInsertText(position, insertText) {\n    if (insertText.length === 0) {\n      // Nothing to insert\n      return;\n    }\n\n    const insertLines = splitLines(insertText);\n\n    if (insertLines.length === 1) {\n      // Inserting text on one line\n      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));\n\n      return;\n    } // Append overflowing text from first line to the end of text to insert\n\n\n    insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1); // Delete overflowing text from first line and insert text on first line\n\n    this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]); // Insert new lines & store lengths\n\n\n    const newLengths = new Uint32Array(insertLines.length - 1);\n\n    for (let i = 1; i < insertLines.length; i++) {\n      this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n\n      newLengths[i - 1] = insertLines[i].length + this._eol.length;\n    }\n\n    if (this._lineStarts) {\n      // update prefix sum\n      this._lineStarts.insertValues(position.lineNumber, newLengths);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js"],"names":["splitLines","Position","PrefixSumComputer","MirrorTextModel","constructor","uri","lines","eol","versionId","_uri","_lines","_eol","_versionId","_lineStarts","_cachedTextValue","dispose","length","version","getText","join","onEvents","e","changes","change","_acceptDeleteRange","range","_acceptInsertText","startLineNumber","startColumn","text","_ensureLineStarts","eolLength","linesLength","lineStartValues","Uint32Array","i","_setLineText","lineIndex","newValue","setValue","endLineNumber","endColumn","substring","splice","removeValues","position","insertText","insertLines","lineNumber","column","newLengths","insertValues"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\nexport class MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    get version() {\n        return this._versionId;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        const insertLines = splitLines(insertText);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        const newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}