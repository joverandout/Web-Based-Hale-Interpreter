{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n  constructor(piece, color) {\n    this.piece = piece;\n    this.color = color;\n    this.size_left = 0;\n    this.lf_left = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n  }\n\n  next() {\n    if (this.right !== SENTINEL) {\n      return leftest(this.right);\n    }\n\n    let node = this;\n\n    while (node.parent !== SENTINEL) {\n      if (node.parent.left === node) {\n        break;\n      }\n\n      node = node.parent;\n    }\n\n    if (node.parent === SENTINEL) {\n      return SENTINEL;\n    } else {\n      return node.parent;\n    }\n  }\n\n  prev() {\n    if (this.left !== SENTINEL) {\n      return righttest(this.left);\n    }\n\n    let node = this;\n\n    while (node.parent !== SENTINEL) {\n      if (node.parent.right === node) {\n        break;\n      }\n\n      node = node.parent;\n    }\n\n    if (node.parent === SENTINEL) {\n      return SENTINEL;\n    } else {\n      return node.parent;\n    }\n  }\n\n  detach() {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  }\n\n}\nexport const SENTINEL = new TreeNode(null, 0\n/* Black */\n);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0\n/* Black */\n;\nexport function leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n\n  return node;\n}\nexport function righttest(node) {\n  while (node.right !== SENTINEL) {\n    node = node.right;\n  }\n\n  return node;\n}\nexport function calculateSize(node) {\n  if (node === SENTINEL) {\n    return 0;\n  }\n\n  return node.size_left + node.piece.length + calculateSize(node.right);\n}\nexport function calculateLF(node) {\n  if (node === SENTINEL) {\n    return 0;\n  }\n\n  return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nexport function resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n  const y = x.right; // fix size_left\n\n  y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n  y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n  x.right = y.left;\n\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n\n  y.parent = x.parent;\n\n  if (x.parent === SENTINEL) {\n    tree.root = y;\n  } else if (x.parent.left === x) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n\n  y.left = x;\n  x.parent = y;\n}\nexport function rightRotate(tree, y) {\n  const x = y.left;\n  y.left = x.right;\n\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n\n  x.parent = y.parent; // fix size_left\n\n  y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n  y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n\n  if (y.parent === SENTINEL) {\n    tree.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n\n  x.right = y;\n  y.parent = x;\n}\nexport function rbDelete(tree, z) {\n  let x;\n  let y;\n\n  if (z.left === SENTINEL) {\n    y = z;\n    x = y.right;\n  } else if (z.right === SENTINEL) {\n    y = z;\n    x = y.left;\n  } else {\n    y = leftest(z.right);\n    x = y.right;\n  }\n\n  if (y === tree.root) {\n    tree.root = x; // if x is null, we are removing the only node\n\n    x.color = 0\n    /* Black */\n    ;\n    z.detach();\n    resetSentinel();\n    tree.root.parent = SENTINEL;\n    return;\n  }\n\n  const yWasRed = y.color === 1\n  /* Red */\n  ;\n\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n\n  if (y === z) {\n    x.parent = y.parent;\n    recomputeTreeMetadata(tree, x);\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    } // as we make changes to x's hierarchy, update size_left of subtree first\n\n\n    recomputeTreeMetadata(tree, x);\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    y.color = z.color;\n\n    if (z === tree.root) {\n      tree.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    } // update metadata\n    // we replace z with y, so in this sub tree, the length change is z.item.length\n\n\n    y.size_left = z.size_left;\n    y.lf_left = z.lf_left;\n    recomputeTreeMetadata(tree, y);\n  }\n\n  z.detach();\n\n  if (x.parent.left === x) {\n    const newSizeLeft = calculateSize(x);\n    const newLFLeft = calculateLF(x);\n\n    if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n      const delta = newSizeLeft - x.parent.size_left;\n      const lf_delta = newLFLeft - x.parent.lf_left;\n      x.parent.size_left = newSizeLeft;\n      x.parent.lf_left = newLFLeft;\n      updateTreeMetadata(tree, x.parent, delta, lf_delta);\n    }\n  }\n\n  recomputeTreeMetadata(tree, x.parent);\n\n  if (yWasRed) {\n    resetSentinel();\n    return;\n  } // RB-DELETE-FIXUP\n\n\n  let w;\n\n  while (x !== tree.root && x.color === 0\n  /* Black */\n  ) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n\n      if (w.color === 1\n      /* Red */\n      ) {\n        w.color = 0\n        /* Black */\n        ;\n        x.parent.color = 1\n        /* Red */\n        ;\n        leftRotate(tree, x.parent);\n        w = x.parent.right;\n      }\n\n      if (w.left.color === 0\n      /* Black */\n      && w.right.color === 0\n      /* Black */\n      ) {\n        w.color = 1\n        /* Red */\n        ;\n        x = x.parent;\n      } else {\n        if (w.right.color === 0\n        /* Black */\n        ) {\n          w.left.color = 0\n          /* Black */\n          ;\n          w.color = 1\n          /* Red */\n          ;\n          rightRotate(tree, w);\n          w = x.parent.right;\n        }\n\n        w.color = x.parent.color;\n        x.parent.color = 0\n        /* Black */\n        ;\n        w.right.color = 0\n        /* Black */\n        ;\n        leftRotate(tree, x.parent);\n        x = tree.root;\n      }\n    } else {\n      w = x.parent.left;\n\n      if (w.color === 1\n      /* Red */\n      ) {\n        w.color = 0\n        /* Black */\n        ;\n        x.parent.color = 1\n        /* Red */\n        ;\n        rightRotate(tree, x.parent);\n        w = x.parent.left;\n      }\n\n      if (w.left.color === 0\n      /* Black */\n      && w.right.color === 0\n      /* Black */\n      ) {\n        w.color = 1\n        /* Red */\n        ;\n        x = x.parent;\n      } else {\n        if (w.left.color === 0\n        /* Black */\n        ) {\n          w.right.color = 0\n          /* Black */\n          ;\n          w.color = 1\n          /* Red */\n          ;\n          leftRotate(tree, w);\n          w = x.parent.left;\n        }\n\n        w.color = x.parent.color;\n        x.parent.color = 0\n        /* Black */\n        ;\n        w.left.color = 0\n        /* Black */\n        ;\n        rightRotate(tree, x.parent);\n        x = tree.root;\n      }\n    }\n  }\n\n  x.color = 0\n  /* Black */\n  ;\n  resetSentinel();\n}\nexport function fixInsert(tree, x) {\n  recomputeTreeMetadata(tree, x);\n\n  while (x !== tree.root && x.parent.color === 1\n  /* Red */\n  ) {\n    if (x.parent === x.parent.parent.left) {\n      const y = x.parent.parent.right;\n\n      if (y.color === 1\n      /* Red */\n      ) {\n        x.parent.color = 0\n        /* Black */\n        ;\n        y.color = 0\n        /* Black */\n        ;\n        x.parent.parent.color = 1\n        /* Red */\n        ;\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(tree, x);\n        }\n\n        x.parent.color = 0\n        /* Black */\n        ;\n        x.parent.parent.color = 1\n        /* Red */\n        ;\n        rightRotate(tree, x.parent.parent);\n      }\n    } else {\n      const y = x.parent.parent.left;\n\n      if (y.color === 1\n      /* Red */\n      ) {\n        x.parent.color = 0\n        /* Black */\n        ;\n        y.color = 0\n        /* Black */\n        ;\n        x.parent.parent.color = 1\n        /* Red */\n        ;\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(tree, x);\n        }\n\n        x.parent.color = 0\n        /* Black */\n        ;\n        x.parent.parent.color = 1\n        /* Red */\n        ;\n        leftRotate(tree, x.parent.parent);\n      }\n    }\n  }\n\n  tree.root.color = 0\n  /* Black */\n  ;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n  // node length change or line feed count change\n  while (x !== tree.root && x !== SENTINEL) {\n    if (x.parent.left === x) {\n      x.parent.size_left += delta;\n      x.parent.lf_left += lineFeedCntDelta;\n    }\n\n    x = x.parent;\n  }\n}\nexport function recomputeTreeMetadata(tree, x) {\n  let delta = 0;\n  let lf_delta = 0;\n\n  if (x === tree.root) {\n    return;\n  } // go upwards till the node whose left subtree is changed.\n\n\n  while (x !== tree.root && x === x.parent.right) {\n    x = x.parent;\n  }\n\n  if (x === tree.root) {\n    // well, it means we add a node to the end (inorder)\n    return;\n  } // x is the node whose right subtree is changed.\n\n\n  x = x.parent;\n  delta = calculateSize(x.left) - x.size_left;\n  lf_delta = calculateLF(x.left) - x.lf_left;\n  x.size_left += delta;\n  x.lf_left += lf_delta; // go upwards till root. O(logN)\n\n  while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n    if (x.parent.left === x) {\n      x.parent.size_left += delta;\n      x.parent.lf_left += lf_delta;\n    }\n\n    x = x.parent;\n  }\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js"],"names":["TreeNode","constructor","piece","color","size_left","lf_left","parent","left","right","next","SENTINEL","leftest","node","prev","righttest","detach","calculateSize","length","calculateLF","lineFeedCnt","resetSentinel","leftRotate","tree","x","y","root","rightRotate","rbDelete","z","yWasRed","recomputeTreeMetadata","newSizeLeft","newLFLeft","delta","lf_delta","updateTreeMetadata","w","fixInsert","lineFeedCntDelta"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nexport function calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nexport function calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nexport function resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* Red */) {\n                w.color = 0 /* Black */;\n                x.parent.color = 1 /* Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {\n                w.color = 1 /* Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* Black */) {\n                    w.left.color = 0 /* Black */;\n                    w.color = 1 /* Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* Black */;\n                w.right.color = 0 /* Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* Red */) {\n                w.color = 0 /* Black */;\n                x.parent.color = 1 /* Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* Black */ && w.right.color === 0 /* Black */) {\n                w.color = 1 /* Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* Black */) {\n                    w.right.color = 0 /* Black */;\n                    w.color = 1 /* Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* Black */;\n                w.left.color = 0 /* Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* Red */) {\n                x.parent.color = 0 /* Black */;\n                y.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* Red */) {\n                x.parent.color = 0 /* Black */;\n                y.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* Black */;\n                x.parent.parent.color = 1 /* Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}