{"ast":null,"code":"var Types = require('../constants/types');\n\nvar Charsets = require('../constants/charsets');\n\nvar Field = require('./Field');\n\nvar IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);\nmodule.exports = RowDataPacket;\n\nfunction RowDataPacket() {}\n\nObject.defineProperty(RowDataPacket.prototype, 'parse', {\n  configurable: true,\n  enumerable: false,\n  value: parse\n});\nObject.defineProperty(RowDataPacket.prototype, '_typeCast', {\n  configurable: true,\n  enumerable: false,\n  value: typeCast\n});\n\nfunction parse(parser, fieldPackets, typeCast, nestTables, connection) {\n  var self = this;\n\n  var next = function () {\n    return self._typeCast(fieldPacket, parser, connection.config.timezone, connection.config.supportBigNumbers, connection.config.bigNumberStrings, connection.config.dateStrings);\n  };\n\n  for (var i = 0; i < fieldPackets.length; i++) {\n    var fieldPacket = fieldPackets[i];\n    var value;\n\n    if (typeof typeCast === 'function') {\n      value = typeCast.apply(connection, [new Field({\n        packet: fieldPacket,\n        parser: parser\n      }), next]);\n    } else {\n      value = typeCast ? this._typeCast(fieldPacket, parser, connection.config.timezone, connection.config.supportBigNumbers, connection.config.bigNumberStrings, connection.config.dateStrings) : fieldPacket.charsetNr === Charsets.BINARY ? parser.parseLengthCodedBuffer() : parser.parseLengthCodedString();\n    }\n\n    if (typeof nestTables === 'string' && nestTables.length) {\n      this[fieldPacket.table + nestTables + fieldPacket.name] = value;\n    } else if (nestTables) {\n      this[fieldPacket.table] = this[fieldPacket.table] || {};\n      this[fieldPacket.table][fieldPacket.name] = value;\n    } else {\n      this[fieldPacket.name] = value;\n    }\n  }\n}\n\nfunction typeCast(field, parser, timeZone, supportBigNumbers, bigNumberStrings, dateStrings) {\n  var numberString;\n\n  switch (field.type) {\n    case Types.TIMESTAMP:\n    case Types.TIMESTAMP2:\n    case Types.DATE:\n    case Types.DATETIME:\n    case Types.DATETIME2:\n    case Types.NEWDATE:\n      var dateString = parser.parseLengthCodedString();\n\n      if (typeMatch(field.type, dateStrings)) {\n        return dateString;\n      }\n\n      if (dateString === null) {\n        return null;\n      }\n\n      var originalString = dateString;\n\n      if (field.type === Types.DATE) {\n        dateString += ' 00:00:00';\n      }\n\n      if (timeZone !== 'local') {\n        dateString += ' ' + timeZone;\n      }\n\n      var dt = new Date(dateString);\n\n      if (isNaN(dt.getTime())) {\n        return originalString;\n      }\n\n      return dt;\n\n    case Types.TINY:\n    case Types.SHORT:\n    case Types.LONG:\n    case Types.INT24:\n    case Types.YEAR:\n    case Types.FLOAT:\n    case Types.DOUBLE:\n      numberString = parser.parseLengthCodedString();\n      return numberString === null || field.zeroFill && numberString[0] === '0' ? numberString : Number(numberString);\n\n    case Types.NEWDECIMAL:\n    case Types.LONGLONG:\n      numberString = parser.parseLengthCodedString();\n      return numberString === null || field.zeroFill && numberString[0] === '0' ? numberString : supportBigNumbers && (bigNumberStrings || Number(numberString) >= IEEE_754_BINARY_64_PRECISION || Number(numberString) <= -IEEE_754_BINARY_64_PRECISION) ? numberString : Number(numberString);\n\n    case Types.BIT:\n      return parser.parseLengthCodedBuffer();\n\n    case Types.STRING:\n    case Types.VAR_STRING:\n    case Types.TINY_BLOB:\n    case Types.MEDIUM_BLOB:\n    case Types.LONG_BLOB:\n    case Types.BLOB:\n      return field.charsetNr === Charsets.BINARY ? parser.parseLengthCodedBuffer() : parser.parseLengthCodedString();\n\n    case Types.GEOMETRY:\n      return parser.parseGeometryValue();\n\n    default:\n      return parser.parseLengthCodedString();\n  }\n}\n\nfunction typeMatch(type, list) {\n  if (Array.isArray(list)) {\n    return list.indexOf(Types[type]) !== -1;\n  } else {\n    return Boolean(list);\n  }\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/mysql/lib/protocol/packets/RowDataPacket.js"],"names":["Types","require","Charsets","Field","IEEE_754_BINARY_64_PRECISION","Math","pow","module","exports","RowDataPacket","Object","defineProperty","prototype","configurable","enumerable","value","parse","typeCast","parser","fieldPackets","nestTables","connection","self","next","_typeCast","fieldPacket","config","timezone","supportBigNumbers","bigNumberStrings","dateStrings","i","length","apply","packet","charsetNr","BINARY","parseLengthCodedBuffer","parseLengthCodedString","table","name","field","timeZone","numberString","type","TIMESTAMP","TIMESTAMP2","DATE","DATETIME","DATETIME2","NEWDATE","dateString","typeMatch","originalString","dt","Date","isNaN","getTime","TINY","SHORT","LONG","INT24","YEAR","FLOAT","DOUBLE","zeroFill","Number","NEWDECIMAL","LONGLONG","BIT","STRING","VAR_STRING","TINY_BLOB","MEDIUM_BLOB","LONG_BLOB","BLOB","GEOMETRY","parseGeometryValue","list","Array","isArray","indexOf","Boolean"],"mappings":"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","sourcesContent":["var Types                        = require('../constants/types');\nvar Charsets                     = require('../constants/charsets');\nvar Field                        = require('./Field');\nvar IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);\n\nmodule.exports = RowDataPacket;\nfunction RowDataPacket() {\n}\n\nObject.defineProperty(RowDataPacket.prototype, 'parse', {\n  configurable : true,\n  enumerable   : false,\n  value        : parse\n});\n\nObject.defineProperty(RowDataPacket.prototype, '_typeCast', {\n  configurable : true,\n  enumerable   : false,\n  value        : typeCast\n});\n\nfunction parse(parser, fieldPackets, typeCast, nestTables, connection) {\n  var self = this;\n  var next = function () {\n    return self._typeCast(fieldPacket, parser, connection.config.timezone, connection.config.supportBigNumbers, connection.config.bigNumberStrings, connection.config.dateStrings);\n  };\n\n  for (var i = 0; i < fieldPackets.length; i++) {\n    var fieldPacket = fieldPackets[i];\n    var value;\n\n    if (typeof typeCast === 'function') {\n      value = typeCast.apply(connection, [ new Field({ packet: fieldPacket, parser: parser }), next ]);\n    } else {\n      value = (typeCast)\n        ? this._typeCast(fieldPacket, parser, connection.config.timezone, connection.config.supportBigNumbers, connection.config.bigNumberStrings, connection.config.dateStrings)\n        : ( (fieldPacket.charsetNr === Charsets.BINARY)\n          ? parser.parseLengthCodedBuffer()\n          : parser.parseLengthCodedString() );\n    }\n\n    if (typeof nestTables === 'string' && nestTables.length) {\n      this[fieldPacket.table + nestTables + fieldPacket.name] = value;\n    } else if (nestTables) {\n      this[fieldPacket.table] = this[fieldPacket.table] || {};\n      this[fieldPacket.table][fieldPacket.name] = value;\n    } else {\n      this[fieldPacket.name] = value;\n    }\n  }\n}\n\nfunction typeCast(field, parser, timeZone, supportBigNumbers, bigNumberStrings, dateStrings) {\n  var numberString;\n\n  switch (field.type) {\n    case Types.TIMESTAMP:\n    case Types.TIMESTAMP2:\n    case Types.DATE:\n    case Types.DATETIME:\n    case Types.DATETIME2:\n    case Types.NEWDATE:\n      var dateString = parser.parseLengthCodedString();\n\n      if (typeMatch(field.type, dateStrings)) {\n        return dateString;\n      }\n\n      if (dateString === null) {\n        return null;\n      }\n\n      var originalString = dateString;\n      if (field.type === Types.DATE) {\n        dateString += ' 00:00:00';\n      }\n\n      if (timeZone !== 'local') {\n        dateString += ' ' + timeZone;\n      }\n\n      var dt = new Date(dateString);\n      if (isNaN(dt.getTime())) {\n        return originalString;\n      }\n\n      return dt;\n    case Types.TINY:\n    case Types.SHORT:\n    case Types.LONG:\n    case Types.INT24:\n    case Types.YEAR:\n    case Types.FLOAT:\n    case Types.DOUBLE:\n      numberString = parser.parseLengthCodedString();\n      return (numberString === null || (field.zeroFill && numberString[0] === '0'))\n        ? numberString : Number(numberString);\n    case Types.NEWDECIMAL:\n    case Types.LONGLONG:\n      numberString = parser.parseLengthCodedString();\n      return (numberString === null || (field.zeroFill && numberString[0] === '0'))\n        ? numberString\n        : ((supportBigNumbers && (bigNumberStrings || (Number(numberString) >= IEEE_754_BINARY_64_PRECISION) || Number(numberString) <= -IEEE_754_BINARY_64_PRECISION))\n          ? numberString\n          : Number(numberString));\n    case Types.BIT:\n      return parser.parseLengthCodedBuffer();\n    case Types.STRING:\n    case Types.VAR_STRING:\n    case Types.TINY_BLOB:\n    case Types.MEDIUM_BLOB:\n    case Types.LONG_BLOB:\n    case Types.BLOB:\n      return (field.charsetNr === Charsets.BINARY)\n        ? parser.parseLengthCodedBuffer()\n        : parser.parseLengthCodedString();\n    case Types.GEOMETRY:\n      return parser.parseGeometryValue();\n    default:\n      return parser.parseLengthCodedString();\n  }\n}\n\nfunction typeMatch(type, list) {\n  if (Array.isArray(list)) {\n    return list.indexOf(Types[type]) !== -1;\n  } else {\n    return Boolean(list);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}