{"ast":null,"code":"/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail(array, n = 0) {\n  return array[array.length - (1 + n)];\n}\nexport function tail2(arr) {\n  if (arr.length === 0) {\n    throw new Error('Invalid tail call');\n  }\n\n  return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\nexport function equals(one, other, itemEquals = (a, b) => a === b) {\n  if (one === other) {\n    return true;\n  }\n\n  if (!one || !other) {\n    return false;\n  }\n\n  if (one.length !== other.length) {\n    return false;\n  }\n\n  for (let i = 0, len = one.length; i < len; i++) {\n    if (!itemEquals(one[i], other[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function binarySearch(array, key, comparator) {\n  let low = 0,\n      high = array.length - 1;\n\n  while (low <= high) {\n    const mid = (low + high) / 2 | 0;\n    const comp = comparator(array[mid], key);\n\n    if (comp < 0) {\n      low = mid + 1;\n    } else if (comp > 0) {\n      high = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -(low + 1);\n}\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\n\nexport function findFirstInSorted(array, p) {\n  let low = 0,\n      high = array.length;\n\n  if (high === 0) {\n    return 0; // no children\n  }\n\n  while (low < high) {\n    const mid = Math.floor((low + high) / 2);\n\n    if (p(array[mid])) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n\n  return low;\n}\nexport function quickSelect(nth, data, compare) {\n  nth = nth | 0;\n\n  if (nth >= data.length) {\n    throw new TypeError('invalid index');\n  }\n\n  let pivotValue = data[Math.floor(data.length * Math.random())];\n  let lower = [];\n  let higher = [];\n  let pivots = [];\n\n  for (let value of data) {\n    const val = compare(value, pivotValue);\n\n    if (val < 0) {\n      lower.push(value);\n    } else if (val > 0) {\n      higher.push(value);\n    } else {\n      pivots.push(value);\n    }\n  }\n\n  if (nth < lower.length) {\n    return quickSelect(nth, lower, compare);\n  } else if (nth < lower.length + pivots.length) {\n    return pivots[0];\n  } else {\n    return quickSelect(nth - (lower.length + pivots.length), higher, compare);\n  }\n}\nexport function groupBy(data, compare) {\n  const result = [];\n  let currentGroup = undefined;\n\n  for (const element of data.slice(0).sort(compare)) {\n    if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n      currentGroup = [element];\n      result.push(currentGroup);\n    } else {\n      currentGroup.push(element);\n    }\n  }\n\n  return result;\n}\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\n\nexport function coalesce(array) {\n  return array.filter(e => !!e);\n}\n/**\n * @returns false if the provided object is an array and not empty.\n */\n\nexport function isFalsyOrEmpty(obj) {\n  return !Array.isArray(obj) || obj.length === 0;\n}\nexport function isNonEmptyArray(obj) {\n  return Array.isArray(obj) && obj.length > 0;\n}\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\n\nexport function distinct(array, keyFn = value => value) {\n  const seen = new Set();\n  return array.filter(element => {\n    const key = keyFn(element);\n\n    if (seen.has(key)) {\n      return false;\n    }\n\n    seen.add(key);\n    return true;\n  });\n}\nexport function findLast(arr, predicate) {\n  const idx = lastIndex(arr, predicate);\n\n  if (idx === -1) {\n    return undefined;\n  }\n\n  return arr[idx];\n}\nexport function lastIndex(array, fn) {\n  for (let i = array.length - 1; i >= 0; i--) {\n    const element = array[i];\n\n    if (fn(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\nexport function firstOrDefault(array, notFoundValue) {\n  return array.length > 0 ? array[0] : notFoundValue;\n}\nexport function flatten(arr) {\n  return [].concat(...arr);\n}\nexport function range(arg, to) {\n  let from = typeof to === 'number' ? arg : 0;\n\n  if (typeof to === 'number') {\n    from = arg;\n  } else {\n    from = 0;\n    to = arg;\n  }\n\n  const result = [];\n\n  if (from <= to) {\n    for (let i = from; i < to; i++) {\n      result.push(i);\n    }\n  } else {\n    for (let i = from; i > to; i--) {\n      result.push(i);\n    }\n  }\n\n  return result;\n}\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\n\nexport function arrayInsert(target, insertIndex, insertArr) {\n  const before = target.slice(0, insertIndex);\n  const after = target.slice(insertIndex);\n  return before.concat(insertArr, after);\n}\n/**\n * Pushes an element to the start of the array, if found.\n */\n\nexport function pushToStart(arr, value) {\n  const index = arr.indexOf(value);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n    arr.unshift(value);\n  }\n}\n/**\n * Pushes an element to the end of the array, if found.\n */\n\nexport function pushToEnd(arr, value) {\n  const index = arr.indexOf(value);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n    arr.push(value);\n  }\n}\nexport function asArray(x) {\n  return Array.isArray(x) ? x : [x];\n}\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\n\nexport function insertInto(array, start, newItems) {\n  const startIdx = getActualStartIndex(array, start);\n  const originalLength = array.length;\n  const newItemsLength = newItems.length;\n  array.length = originalLength + newItemsLength; // Move the items after the start index, start from the end so that we don't overwrite any value.\n\n  for (let i = originalLength - 1; i >= startIdx; i--) {\n    array[i + newItemsLength] = array[i];\n  }\n\n  for (let i = 0; i < newItemsLength; i++) {\n    array[i + startIdx] = newItems[i];\n  }\n}\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\n\nexport function splice(array, start, deleteCount, newItems) {\n  const index = getActualStartIndex(array, start);\n  const result = array.splice(index, deleteCount);\n  insertInto(array, index, newItems);\n  return result;\n}\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\n\nfunction getActualStartIndex(array, start) {\n  return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\n\nexport function compareBy(selector, comparator) {\n  return (a, b) => comparator(selector(a), selector(b));\n}\n/**\n * The natural order on numbers.\n*/\n\nexport const numberComparator = (a, b) => a - b;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\n\nexport function findMaxBy(items, comparator) {\n  if (items.length === 0) {\n    return undefined;\n  }\n\n  let max = items[0];\n\n  for (let i = 1; i < items.length; i++) {\n    const item = items[i];\n\n    if (comparator(item, max) > 0) {\n      max = item;\n    }\n  }\n\n  return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\n\nexport function findLastMaxBy(items, comparator) {\n  if (items.length === 0) {\n    return undefined;\n  }\n\n  let max = items[0];\n\n  for (let i = 1; i < items.length; i++) {\n    const item = items[i];\n\n    if (comparator(item, max) >= 0) {\n      max = item;\n    }\n  }\n\n  return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\n\nexport function findMinBy(items, comparator) {\n  return findMaxBy(items, (a, b) => -comparator(a, b));\n}\nexport class ArrayQueue {\n  /**\n   * Constructs a queue that is backed by the given array. Runtime is O(1).\n  */\n  constructor(items) {\n    this.items = items;\n    this.firstIdx = 0;\n    this.lastIdx = this.items.length - 1;\n  }\n  /**\n   * Consumes elements from the beginning of the queue as long as the predicate returns true.\n   * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n  */\n\n\n  takeWhile(predicate) {\n    // P(k) := k <= this.lastIdx && predicate(this.items[k])\n    // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n    let startIdx = this.firstIdx;\n\n    while (startIdx < this.items.length && predicate(this.items[startIdx])) {\n      startIdx++;\n    }\n\n    const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n    this.firstIdx = startIdx;\n    return result;\n  }\n  /**\n   * Consumes elements from the end of the queue as long as the predicate returns true.\n   * If no elements were consumed, `null` is returned.\n   * The result has the same order as the underlying array!\n  */\n\n\n  takeFromEndWhile(predicate) {\n    // P(k) := this.firstIdx >= k && predicate(this.items[k])\n    // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n    let endIdx = this.lastIdx;\n\n    while (endIdx >= 0 && predicate(this.items[endIdx])) {\n      endIdx--;\n    }\n\n    const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n    this.lastIdx = endIdx;\n    return result;\n  }\n\n  peek() {\n    return this.items[this.firstIdx];\n  }\n\n  dequeue() {\n    const result = this.items[this.firstIdx];\n    this.firstIdx++;\n    return result;\n  }\n\n  takeCount(count) {\n    const result = this.items.slice(this.firstIdx, this.firstIdx + count);\n    this.firstIdx += count;\n    return result;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/arrays.js"],"names":["tail","array","n","length","tail2","arr","Error","slice","equals","one","other","itemEquals","a","b","i","len","binarySearch","key","comparator","low","high","mid","comp","findFirstInSorted","p","Math","floor","quickSelect","nth","data","compare","TypeError","pivotValue","random","lower","higher","pivots","value","val","push","groupBy","result","currentGroup","undefined","element","sort","coalesce","filter","e","isFalsyOrEmpty","obj","Array","isArray","isNonEmptyArray","distinct","keyFn","seen","Set","has","add","findLast","predicate","idx","lastIndex","fn","firstOrDefault","notFoundValue","flatten","concat","range","arg","to","from","arrayInsert","target","insertIndex","insertArr","before","after","pushToStart","index","indexOf","splice","unshift","pushToEnd","asArray","x","insertInto","start","newItems","startIdx","getActualStartIndex","originalLength","newItemsLength","deleteCount","max","min","compareBy","selector","numberComparator","findMaxBy","items","item","findLastMaxBy","findMinBy","ArrayQueue","constructor","firstIdx","lastIdx","takeWhile","takeFromEndWhile","endIdx","peek","dequeue","takeCount","count"],"mappings":"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","sourcesContent":["/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail(array, n = 0) {\n    return array[array.length - (1 + n)];\n}\nexport function tail2(arr) {\n    if (arr.length === 0) {\n        throw new Error('Invalid tail call');\n    }\n    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\nexport function equals(one, other, itemEquals = (a, b) => a === b) {\n    if (one === other) {\n        return true;\n    }\n    if (!one || !other) {\n        return false;\n    }\n    if (one.length !== other.length) {\n        return false;\n    }\n    for (let i = 0, len = one.length; i < len; i++) {\n        if (!itemEquals(one[i], other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function binarySearch(array, key, comparator) {\n    let low = 0, high = array.length - 1;\n    while (low <= high) {\n        const mid = ((low + high) / 2) | 0;\n        const comp = comparator(array[mid], key);\n        if (comp < 0) {\n            low = mid + 1;\n        }\n        else if (comp > 0) {\n            high = mid - 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -(low + 1);\n}\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\nexport function findFirstInSorted(array, p) {\n    let low = 0, high = array.length;\n    if (high === 0) {\n        return 0; // no children\n    }\n    while (low < high) {\n        const mid = Math.floor((low + high) / 2);\n        if (p(array[mid])) {\n            high = mid;\n        }\n        else {\n            low = mid + 1;\n        }\n    }\n    return low;\n}\nexport function quickSelect(nth, data, compare) {\n    nth = nth | 0;\n    if (nth >= data.length) {\n        throw new TypeError('invalid index');\n    }\n    let pivotValue = data[Math.floor(data.length * Math.random())];\n    let lower = [];\n    let higher = [];\n    let pivots = [];\n    for (let value of data) {\n        const val = compare(value, pivotValue);\n        if (val < 0) {\n            lower.push(value);\n        }\n        else if (val > 0) {\n            higher.push(value);\n        }\n        else {\n            pivots.push(value);\n        }\n    }\n    if (nth < lower.length) {\n        return quickSelect(nth, lower, compare);\n    }\n    else if (nth < lower.length + pivots.length) {\n        return pivots[0];\n    }\n    else {\n        return quickSelect(nth - (lower.length + pivots.length), higher, compare);\n    }\n}\nexport function groupBy(data, compare) {\n    const result = [];\n    let currentGroup = undefined;\n    for (const element of data.slice(0).sort(compare)) {\n        if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n            currentGroup = [element];\n            result.push(currentGroup);\n        }\n        else {\n            currentGroup.push(element);\n        }\n    }\n    return result;\n}\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce(array) {\n    return array.filter(e => !!e);\n}\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj) {\n    return !Array.isArray(obj) || obj.length === 0;\n}\nexport function isNonEmptyArray(obj) {\n    return Array.isArray(obj) && obj.length > 0;\n}\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nexport function distinct(array, keyFn = value => value) {\n    const seen = new Set();\n    return array.filter(element => {\n        const key = keyFn(element);\n        if (seen.has(key)) {\n            return false;\n        }\n        seen.add(key);\n        return true;\n    });\n}\nexport function findLast(arr, predicate) {\n    const idx = lastIndex(arr, predicate);\n    if (idx === -1) {\n        return undefined;\n    }\n    return arr[idx];\n}\nexport function lastIndex(array, fn) {\n    for (let i = array.length - 1; i >= 0; i--) {\n        const element = array[i];\n        if (fn(element)) {\n            return i;\n        }\n    }\n    return -1;\n}\nexport function firstOrDefault(array, notFoundValue) {\n    return array.length > 0 ? array[0] : notFoundValue;\n}\nexport function flatten(arr) {\n    return [].concat(...arr);\n}\nexport function range(arg, to) {\n    let from = typeof to === 'number' ? arg : 0;\n    if (typeof to === 'number') {\n        from = arg;\n    }\n    else {\n        from = 0;\n        to = arg;\n    }\n    const result = [];\n    if (from <= to) {\n        for (let i = from; i < to; i++) {\n            result.push(i);\n        }\n    }\n    else {\n        for (let i = from; i > to; i--) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert(target, insertIndex, insertArr) {\n    const before = target.slice(0, insertIndex);\n    const after = target.slice(insertIndex);\n    return before.concat(insertArr, after);\n}\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.unshift(value);\n    }\n}\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.push(value);\n    }\n}\nexport function asArray(x) {\n    return Array.isArray(x) ? x : [x];\n}\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nexport function insertInto(array, start, newItems) {\n    const startIdx = getActualStartIndex(array, start);\n    const originalLength = array.length;\n    const newItemsLength = newItems.length;\n    array.length = originalLength + newItemsLength;\n    // Move the items after the start index, start from the end so that we don't overwrite any value.\n    for (let i = originalLength - 1; i >= startIdx; i--) {\n        array[i + newItemsLength] = array[i];\n    }\n    for (let i = 0; i < newItemsLength; i++) {\n        array[i + startIdx] = newItems[i];\n    }\n}\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nexport function splice(array, start, deleteCount, newItems) {\n    const index = getActualStartIndex(array, start);\n    const result = array.splice(index, deleteCount);\n    insertInto(array, index, newItems);\n    return result;\n}\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex(array, start) {\n    return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\nexport function compareBy(selector, comparator) {\n    return (a, b) => comparator(selector(a), selector(b));\n}\n/**\n * The natural order on numbers.\n*/\nexport const numberComparator = (a, b) => a - b;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findMaxBy(items, comparator) {\n    if (items.length === 0) {\n        return undefined;\n    }\n    let max = items[0];\n    for (let i = 1; i < items.length; i++) {\n        const item = items[i];\n        if (comparator(item, max) > 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMaxBy(items, comparator) {\n    if (items.length === 0) {\n        return undefined;\n    }\n    let max = items[0];\n    for (let i = 1; i < items.length; i++) {\n        const item = items[i];\n        if (comparator(item, max) >= 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findMinBy(items, comparator) {\n    return findMaxBy(items, (a, b) => -comparator(a, b));\n}\nexport class ArrayQueue {\n    /**\n     * Constructs a queue that is backed by the given array. Runtime is O(1).\n    */\n    constructor(items) {\n        this.items = items;\n        this.firstIdx = 0;\n        this.lastIdx = this.items.length - 1;\n    }\n    /**\n     * Consumes elements from the beginning of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n    */\n    takeWhile(predicate) {\n        // P(k) := k <= this.lastIdx && predicate(this.items[k])\n        // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n        let startIdx = this.firstIdx;\n        while (startIdx < this.items.length && predicate(this.items[startIdx])) {\n            startIdx++;\n        }\n        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n        this.firstIdx = startIdx;\n        return result;\n    }\n    /**\n     * Consumes elements from the end of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned.\n     * The result has the same order as the underlying array!\n    */\n    takeFromEndWhile(predicate) {\n        // P(k) := this.firstIdx >= k && predicate(this.items[k])\n        // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n        let endIdx = this.lastIdx;\n        while (endIdx >= 0 && predicate(this.items[endIdx])) {\n            endIdx--;\n        }\n        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n        this.lastIdx = endIdx;\n        return result;\n    }\n    peek() {\n        return this.items[this.firstIdx];\n    }\n    dequeue() {\n        const result = this.items[this.firstIdx];\n        this.firstIdx++;\n        return result;\n    }\n    takeCount(count) {\n        const result = this.items.slice(this.firstIdx, this.firstIdx + count);\n        this.firstIdx += count;\n        return result;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}