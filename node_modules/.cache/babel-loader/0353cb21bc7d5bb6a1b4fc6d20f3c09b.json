{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport * as strings from './strings.js'; // Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\n\nexport function or(...filter) {\n  return function (word, wordToMatchAgainst) {\n    for (let i = 0, len = filter.length; i < len; i++) {\n      const match = filter[i](word, wordToMatchAgainst);\n\n      if (match) {\n        return match;\n      }\n    }\n\n    return null;\n  };\n} // Prefix\n\nexport const matchesStrictPrefix = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n    return null;\n  }\n\n  let matches;\n\n  if (ignoreCase) {\n    matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n  } else {\n    matches = wordToMatchAgainst.indexOf(word) === 0;\n  }\n\n  if (!matches) {\n    return null;\n  }\n\n  return word.length > 0 ? [{\n    start: 0,\n    end: word.length\n  }] : [];\n} // Contiguous Substring\n\n\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n  const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\n  if (index === -1) {\n    return null;\n  }\n\n  return [{\n    start: index,\n    end: index + word.length\n  }];\n} // Substring\n\nexport function matchesSubString(word, wordToMatchAgainst) {\n  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === wordToMatchAgainst.length) {\n    return null;\n  } else {\n    if (word[i] === wordToMatchAgainst[j]) {\n      let result = null;\n\n      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n        return join({\n          start: j,\n          end: j + 1\n        }, result);\n      }\n\n      return null;\n    }\n\n    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n  }\n} // CamelCase\n\n\nfunction isLower(code) {\n  return 97\n  /* a */\n  <= code && code <= 122\n  /* z */\n  ;\n}\n\nexport function isUpper(code) {\n  return 65\n  /* A */\n  <= code && code <= 90\n  /* Z */\n  ;\n}\n\nfunction isNumber(code) {\n  return 48\n  /* Digit0 */\n  <= code && code <= 57\n  /* Digit9 */\n  ;\n}\n\nfunction isWhitespace(code) {\n  return code === 32\n  /* Space */\n  || code === 9\n  /* Tab */\n  || code === 10\n  /* LineFeed */\n  || code === 13\n  /* CarriageReturn */\n  ;\n}\n\nconst wordSeparators = new Set(); // These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n\n'()[]{}<>`\\'\"-/;:,.?!'.split('').forEach(s => wordSeparators.add(s.charCodeAt(0)));\n\nfunction isWordSeparator(code) {\n  return isWhitespace(code) || wordSeparators.has(code);\n}\n\nfunction charactersMatch(codeA, codeB) {\n  return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);\n}\n\nfunction isAlphanumeric(code) {\n  return isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head, tail) {\n  if (tail.length === 0) {\n    tail = [head];\n  } else if (head.end === tail[0].start) {\n    tail[0].start = head.start;\n  } else {\n    tail.unshift(head);\n  }\n\n  return tail;\n}\n\nfunction nextAnchor(camelCaseWord, start) {\n  for (let i = start; i < camelCaseWord.length; i++) {\n    const c = camelCaseWord.charCodeAt(i);\n\n    if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n\n  return camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === camelCaseWord.length) {\n    return null;\n  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n    return null;\n  } else {\n    let result = null;\n    let nextUpperIndex = j + 1;\n    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\n    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n      nextUpperIndex++;\n    }\n\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n} // Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\n\n\nfunction analyzeCamelCaseWord(word) {\n  let upper = 0,\n      lower = 0,\n      alpha = 0,\n      numeric = 0,\n      code = 0;\n\n  for (let i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n\n    if (isUpper(code)) {\n      upper++;\n    }\n\n    if (isLower(code)) {\n      lower++;\n    }\n\n    if (isAlphanumeric(code)) {\n      alpha++;\n    }\n\n    if (isNumber(code)) {\n      numeric++;\n    }\n  }\n\n  const upperPercent = upper / word.length;\n  const lowerPercent = lower / word.length;\n  const alphaPercent = alpha / word.length;\n  const numericPercent = numeric / word.length;\n  return {\n    upperPercent,\n    lowerPercent,\n    alphaPercent,\n    numericPercent\n  };\n}\n\nfunction isUpperCaseWord(analysis) {\n  const {\n    upperPercent,\n    lowerPercent\n  } = analysis;\n  return lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis) {\n  const {\n    upperPercent,\n    lowerPercent,\n    alphaPercent,\n    numericPercent\n  } = analysis;\n  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n} // Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\n\n\nfunction isCamelCasePattern(word) {\n  let upper = 0,\n      lower = 0,\n      code = 0,\n      whitespace = 0;\n\n  for (let i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n\n    if (isUpper(code)) {\n      upper++;\n    }\n\n    if (isLower(code)) {\n      lower++;\n    }\n\n    if (isWhitespace(code)) {\n      whitespace++;\n    }\n  }\n\n  if ((upper === 0 || lower === 0) && whitespace === 0) {\n    return word.length <= 30;\n  } else {\n    return upper <= 5;\n  }\n}\n\nexport function matchesCamelCase(word, camelCaseWord) {\n  if (!camelCaseWord) {\n    return null;\n  }\n\n  camelCaseWord = camelCaseWord.trim();\n\n  if (camelCaseWord.length === 0) {\n    return null;\n  }\n\n  if (!isCamelCasePattern(word)) {\n    return null;\n  }\n\n  if (camelCaseWord.length > 60) {\n    return null;\n  }\n\n  const analysis = analyzeCamelCaseWord(camelCaseWord);\n\n  if (!isCamelCaseWord(analysis)) {\n    if (!isUpperCaseWord(analysis)) {\n      return null;\n    }\n\n    camelCaseWord = camelCaseWord.toLowerCase();\n  }\n\n  let result = null;\n  let i = 0;\n  word = word.toLowerCase();\n\n  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n    i = nextAnchor(camelCaseWord, i + 1);\n  }\n\n  return result;\n} // Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(word, target, contiguous = false) {\n  if (!target || target.length === 0) {\n    return null;\n  }\n\n  let result = null;\n  let i = 0;\n  word = word.toLowerCase();\n  target = target.toLowerCase();\n\n  while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n    i = nextWord(target, i + 1);\n  }\n\n  return result;\n}\n\nfunction _matchesWords(word, target, i, j, contiguous) {\n  if (i === word.length) {\n    return [];\n  } else if (j === target.length) {\n    return null;\n  } else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\n    return null;\n  } else {\n    let result = null;\n    let nextWordIndex = j + 1;\n    result = _matchesWords(word, target, i + 1, j + 1, contiguous);\n\n    if (!contiguous) {\n      while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n        result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n        nextWordIndex++;\n      }\n    }\n\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n}\n\nfunction nextWord(word, start) {\n  for (let i = start; i < word.length; i++) {\n    if (isWordSeparator(word.charCodeAt(i)) || i > 0 && isWordSeparator(word.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n\n  return word.length;\n} // Fuzzy\n\n\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n  if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n    return null; // return early for invalid input\n  } // Form RegExp for wildcard matches\n\n\n  let regexp = fuzzyRegExpCache.get(word);\n\n  if (!regexp) {\n    regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n    fuzzyRegExpCache.set(word, regexp);\n  } // RegExp Filter\n\n\n  const match = regexp.exec(wordToMatchAgainst);\n\n  if (match) {\n    return [{\n      start: match.index,\n      end: match.index + match[0].length\n    }];\n  } // Default Filter\n\n\n  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nexport function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n  const max = Math.min(13, pattern.length);\n\n  for (; patternPos < max; patternPos++) {\n    const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, false);\n\n    if (result) {\n      return result;\n    }\n  }\n\n  return [0, wordPos];\n} //#region --- fuzzyScore ---\n\nexport function createMatches(score) {\n  if (typeof score === 'undefined') {\n    return [];\n  }\n\n  const res = [];\n  const wordPos = score[1];\n\n  for (let i = score.length - 1; i > 1; i--) {\n    const pos = score[i] + wordPos;\n    const last = res[res.length - 1];\n\n    if (last && last.end === pos) {\n      last.end = pos + 1;\n    } else {\n      res.push({\n        start: pos,\n        end: pos + 1\n      });\n    }\n  }\n\n  return res;\n}\nconst _maxLen = 128;\n\nfunction initTable() {\n  const table = [];\n  const row = [];\n\n  for (let i = 0; i <= _maxLen; i++) {\n    row[i] = 0;\n  }\n\n  for (let i = 0; i <= _maxLen; i++) {\n    table.push(row.slice(0));\n  }\n\n  return table;\n}\n\nfunction initArr(maxLen) {\n  const row = [];\n\n  for (let i = 0; i <= maxLen; i++) {\n    row[i] = 0;\n  }\n\n  return row;\n}\n\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\n\n\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\n\n\nconst _diag = initTable(); // the length of a contiguous diagonal match\n\n\nconst _table = initTable();\n\nconst _arrows = initTable();\n\nconst _debug = false;\n\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n  function pad(s, n, pad = ' ') {\n    while (s.length < n) {\n      s = pad + s;\n    }\n\n    return s;\n  }\n\n  let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n\n  for (let i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += ' |';\n    } else {\n      ret += `${pattern[i - 1]}|`;\n    }\n\n    ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n  }\n\n  return ret;\n}\n\nfunction printTables(pattern, patternStart, word, wordStart) {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\n\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n\n  const code = value.codePointAt(index);\n\n  switch (code) {\n    case 95\n    /* Underline */\n    :\n    case 45\n    /* Dash */\n    :\n    case 46\n    /* Period */\n    :\n    case 32\n    /* Space */\n    :\n    case 47\n    /* Slash */\n    :\n    case 92\n    /* Backslash */\n    :\n    case 39\n    /* SingleQuote */\n    :\n    case 34\n    /* DoubleQuote */\n    :\n    case 58\n    /* Colon */\n    :\n    case 36\n    /* DollarSign */\n    :\n    case 60\n    /* LessThan */\n    :\n    case 40\n    /* OpenParen */\n    :\n    case 91\n    /* OpenSquareBracket */\n    :\n      return true;\n\n    case undefined:\n      return false;\n\n    default:\n      if (strings.isEmojiImprecise(code)) {\n        return true;\n      }\n\n      return false;\n  }\n}\n\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n\n  const code = value.charCodeAt(index);\n\n  switch (code) {\n    case 32\n    /* Space */\n    :\n    case 9\n    /* Tab */\n    :\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\n\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      if (fillMinWordPosArr) {\n        // Remember the min word position for each pattern position\n        _minWordMatchPos[patternPos] = wordPos;\n      }\n\n      patternPos += 1;\n    }\n\n    wordPos += 1;\n  }\n\n  return patternPos === patternLen; // pattern must be exhausted\n}\nexport var FuzzyScore;\n\n(function (FuzzyScore) {\n  /**\n   * No matches and value `-100`\n   */\n  FuzzyScore.Default = [-100, 0];\n\n  function isDefault(score) {\n    return !score || score.length === 2 && score[0] === -100 && score[1] === 0;\n  }\n\n  FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\n\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  const wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {\n    return undefined;\n  } // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n\n\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n    return undefined;\n  } // Find the max matching word position for each pattern position\n  // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n\n\n  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n\n  let row = 1;\n  let column = 1;\n  let patternPos = patternStart;\n  let wordPos = wordStart;\n  const hasStrongFirstMatch = [false]; // There will be a match, fill in tables\n\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    // Reduce search space to possible matching word positions and to possible access from next row\n    const minWordMatchPos = _minWordMatchPos[patternPos];\n    const maxWordMatchPos = _maxWordMatchPos[patternPos];\n    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;\n\n    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n      let score = Number.MIN_SAFE_INTEGER;\n      let canComeDiag = false;\n\n      if (wordPos <= maxWordMatchPos) {\n        score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n      }\n\n      let diagScore = 0;\n\n      if (score !== Number.MAX_SAFE_INTEGER) {\n        canComeDiag = true;\n        diagScore = score + _table[row - 1][column - 1];\n      }\n\n      const canComeLeft = wordPos > minWordMatchPos;\n      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n        // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n        _table[row][column] = leftLeftScore;\n        _arrows[row][column] = 3\n        /* LeftLeft */\n        ;\n        _diag[row][column] = 0;\n      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n        // always prefer choosing left since that means a match is earlier in the word\n        _table[row][column] = leftScore;\n        _arrows[row][column] = 2\n        /* Left */\n        ;\n        _diag[row][column] = 0;\n      } else if (canComeDiag) {\n        _table[row][column] = diagScore;\n        _arrows[row][column] = 1\n        /* Diag */\n        ;\n        _diag[row][column] = _diag[row - 1][column - 1] + 1;\n      } else {\n        throw new Error(`not possible`);\n      }\n    }\n  }\n\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n\n  if (!hasStrongFirstMatch[0] && !firstMatchCanBeWeak) {\n    return undefined;\n  }\n\n  row--;\n  column--;\n  const result = [_table[row][column], wordStart];\n  let backwardsDiagLength = 0;\n  let maxMatchColumn = 0;\n\n  while (row >= 1) {\n    // Find the column where we go diagonally up\n    let diagColumn = column;\n\n    do {\n      const arrow = _arrows[row][diagColumn];\n\n      if (arrow === 3\n      /* LeftLeft */\n      ) {\n        diagColumn = diagColumn - 2;\n      } else if (arrow === 2\n      /* Left */\n      ) {\n        diagColumn = diagColumn - 1;\n      } else {\n        // found the diagonal\n        break;\n      }\n    } while (diagColumn >= 1); // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n\n\n    if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n    && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n    && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n    && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n    ) {\n      diagColumn = column;\n    }\n\n    if (diagColumn === column) {\n      // this is a contiguous match\n      backwardsDiagLength++;\n    } else {\n      backwardsDiagLength = 1;\n    }\n\n    if (!maxMatchColumn) {\n      // remember the last matched column\n      maxMatchColumn = diagColumn;\n    }\n\n    row--;\n    column = diagColumn - 1;\n    result.push(column);\n  }\n\n  if (wordLen === patternLen) {\n    // the word matches the pattern with all characters!\n    // giving the score a total match boost (to come up ahead other words)\n    result[0] += 2;\n  } // Add 1 penalty for each skipped character in the word\n\n\n  const skippedCharsCount = maxMatchColumn - patternLen;\n  result[0] -= skippedCharsCount;\n  return result;\n}\n\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n  let patternPos = patternLen - 1;\n  let wordPos = wordLen - 1;\n\n  while (patternPos >= patternStart && wordPos >= wordStart) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      _maxWordMatchPos[patternPos] = wordPos;\n      patternPos--;\n    }\n\n    wordPos--;\n  }\n}\n\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n\n  let score = 1;\n  let isGapLocation = false;\n\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    isGapLocation = true;\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    score = 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    score = 5;\n    isGapLocation = true;\n  }\n\n  if (score > 1 && patternPos === patternStart) {\n    outFirstMatchStrong[0] = true;\n  }\n\n  if (!isGapLocation) {\n    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n  } //\n\n\n  if (patternPos === patternStart) {\n    // first character in pattern\n    if (wordPos > wordStart) {\n      // the first pattern character would match a word character that is not at the word start\n      // so introduce a penalty to account for the gap preceding this match\n      score -= isGapLocation ? 3 : 5;\n    }\n  } else {\n    if (newMatchStart) {\n      // this would be the beginning of a new match (i.e. there would be a gap before this location)\n      score += isGapLocation ? 2 : 0;\n    } else {\n      // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n      score += isGapLocation ? 0 : 1;\n    }\n  }\n\n  if (wordPos + 1 === wordLen) {\n    // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n    // so pretend there is a gap after the last character in the word to normalize things\n    score -= isGapLocation ? 3 : 5;\n  }\n\n  return score;\n} //#endregion\n//#region --- graceful ---\n\n\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\n\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n  let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\n  if (top && !aggressive) {\n    // when using the original pattern yield a result we`\n    // return it unless we are aggressive and try to find\n    // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n    return top;\n  }\n\n  if (pattern.length >= 3) {\n    // When the pattern is long enough then try a few (max 7)\n    // permutations of the pattern to find a better match. The\n    // permutations only swap neighbouring characters, e.g\n    // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n    const tries = Math.min(7, pattern.length - 1);\n\n    for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n      const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\n      if (newPattern) {\n        const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\n        if (candidate) {\n          candidate[0] -= 3; // permutation penalty\n\n          if (!top || candidate[0] > top[0]) {\n            top = candidate;\n          }\n        }\n      }\n    }\n  }\n\n  return top;\n}\n\nfunction nextTypoPermutation(pattern, patternPos) {\n  if (patternPos + 1 >= pattern.length) {\n    return undefined;\n  }\n\n  const swap1 = pattern[patternPos];\n  const swap2 = pattern[patternPos + 1];\n\n  if (swap1 === swap2) {\n    return undefined;\n  }\n\n  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);\n} //#endregion","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/filters.js"],"names":["LRUCache","strings","or","filter","word","wordToMatchAgainst","i","len","length","match","matchesStrictPrefix","_matchesPrefix","bind","undefined","matchesPrefix","ignoreCase","matches","startsWithIgnoreCase","indexOf","start","end","matchesContiguousSubString","index","toLowerCase","matchesSubString","_matchesSubString","j","result","join","isLower","code","isUpper","isNumber","isWhitespace","wordSeparators","Set","split","forEach","s","add","charCodeAt","isWordSeparator","has","charactersMatch","codeA","codeB","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","_matchesCamelCase","nextUpperIndex","analyzeCamelCaseWord","upper","lower","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isUpperCaseWord","analysis","isCamelCaseWord","isCamelCasePattern","whitespace","matchesCamelCase","trim","matchesWords","target","contiguous","_matchesWords","nextWord","nextWordIndex","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","matchesFuzzy","enableSeparateSubstringMatching","regexp","get","RegExp","convertSimple2RegExpPattern","set","exec","anyScore","pattern","lowPattern","patternPos","lowWord","wordPos","max","Math","min","fuzzyScore","createMatches","score","res","pos","last","push","_maxLen","initTable","table","row","slice","initArr","maxLen","_minWordMatchPos","_maxWordMatchPos","_diag","_table","_arrows","_debug","printTable","patternLen","wordLen","pad","n","ret","map","toString","printTables","patternStart","wordStart","substr","console","log","isSeparatorAtPos","value","codePointAt","isEmojiImprecise","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","isPatternInWord","patternLow","fillMinWordPosArr","FuzzyScore","Default","isDefault","firstMatchCanBeWeak","_fillInMaxWordMatchPos","column","hasStrongFirstMatch","minWordMatchPos","maxWordMatchPos","nextMaxWordMatchPos","Number","MIN_SAFE_INTEGER","canComeDiag","_doScore","diagScore","MAX_SAFE_INTEGER","canComeLeft","leftScore","canComeLeftLeft","leftLeftScore","Error","backwardsDiagLength","maxMatchColumn","diagColumn","arrow","skippedCharsCount","newMatchStart","outFirstMatchStrong","isGapLocation","fuzzyScoreGracefulAggressive","fuzzyScoreWithPermutations","aggressive","top","tries","movingPatternPos","newPattern","nextTypoPermutation","candidate","swap1","swap2"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport * as strings from './strings.js';\n// Combined filters\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter) {\n    return function (word, wordToMatchAgainst) {\n        for (let i = 0, len = filter.length; i < len; i++) {\n            const match = filter[i](word, wordToMatchAgainst);\n            if (match) {\n                return match;\n            }\n        }\n        return null;\n    };\n}\n// Prefix\nexport const matchesStrictPrefix = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n        return null;\n    }\n    let matches;\n    if (ignoreCase) {\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n    }\n    else {\n        matches = wordToMatchAgainst.indexOf(word) === 0;\n    }\n    if (!matches) {\n        return null;\n    }\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n// Contiguous Substring\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n    if (index === -1) {\n        return null;\n    }\n    return [{ start: index, end: index + word.length }];\n}\n// Substring\nexport function matchesSubString(word, wordToMatchAgainst) {\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === wordToMatchAgainst.length) {\n        return null;\n    }\n    else {\n        if (word[i] === wordToMatchAgainst[j]) {\n            let result = null;\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n                return join({ start: j, end: j + 1 }, result);\n            }\n            return null;\n        }\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n    }\n}\n// CamelCase\nfunction isLower(code) {\n    return 97 /* a */ <= code && code <= 122 /* z */;\n}\nexport function isUpper(code) {\n    return 65 /* A */ <= code && code <= 90 /* Z */;\n}\nfunction isNumber(code) {\n    return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;\n}\nfunction isWhitespace(code) {\n    return (code === 32 /* Space */\n        || code === 9 /* Tab */\n        || code === 10 /* LineFeed */\n        || code === 13 /* CarriageReturn */);\n}\nconst wordSeparators = new Set();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n'()[]{}<>`\\'\"-/;:,.?!'\n    .split('')\n    .forEach(s => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n    return isWhitespace(code) || wordSeparators.has(code);\n}\nfunction charactersMatch(codeA, codeB) {\n    return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\nfunction isAlphanumeric(code) {\n    return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n    if (tail.length === 0) {\n        tail = [head];\n    }\n    else if (head.end === tail[0].start) {\n        tail[0].start = head.start;\n    }\n    else {\n        tail.unshift(head);\n    }\n    return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n    for (let i = start; i < camelCaseWord.length; i++) {\n        const c = camelCaseWord.charCodeAt(i);\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === camelCaseWord.length) {\n        return null;\n    }\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextUpperIndex = j + 1;\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n            nextUpperIndex++;\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isAlphanumeric(code)) {\n            alpha++;\n        }\n        if (isNumber(code)) {\n            numeric++;\n        }\n    }\n    const upperPercent = upper / word.length;\n    const lowerPercent = lower / word.length;\n    const alphaPercent = alpha / word.length;\n    const numericPercent = numeric / word.length;\n    return { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\nfunction isUpperCaseWord(analysis) {\n    const { upperPercent, lowerPercent } = analysis;\n    return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n    let upper = 0, lower = 0, code = 0, whitespace = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isWhitespace(code)) {\n            whitespace++;\n        }\n    }\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\n        return word.length <= 30;\n    }\n    else {\n        return upper <= 5;\n    }\n}\nexport function matchesCamelCase(word, camelCaseWord) {\n    if (!camelCaseWord) {\n        return null;\n    }\n    camelCaseWord = camelCaseWord.trim();\n    if (camelCaseWord.length === 0) {\n        return null;\n    }\n    if (!isCamelCasePattern(word)) {\n        return null;\n    }\n    if (camelCaseWord.length > 60) {\n        return null;\n    }\n    const analysis = analyzeCamelCaseWord(camelCaseWord);\n    if (!isCamelCaseWord(analysis)) {\n        if (!isUpperCaseWord(analysis)) {\n            return null;\n        }\n        camelCaseWord = camelCaseWord.toLowerCase();\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n        i = nextAnchor(camelCaseWord, i + 1);\n    }\n    return result;\n}\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\nexport function matchesWords(word, target, contiguous = false) {\n    if (!target || target.length === 0) {\n        return null;\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    target = target.toLowerCase();\n    while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n        i = nextWord(target, i + 1);\n    }\n    return result;\n}\nfunction _matchesWords(word, target, i, j, contiguous) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === target.length) {\n        return null;\n    }\n    else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextWordIndex = j + 1;\n        result = _matchesWords(word, target, i + 1, j + 1, contiguous);\n        if (!contiguous) {\n            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n                result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n                nextWordIndex++;\n            }\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\nfunction nextWord(word, start) {\n    for (let i = start; i < word.length; i++) {\n        if (isWordSeparator(word.charCodeAt(i)) ||\n            (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return word.length;\n}\n// Fuzzy\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n        return null; // return early for invalid input\n    }\n    // Form RegExp for wildcard matches\n    let regexp = fuzzyRegExpCache.get(word);\n    if (!regexp) {\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n        fuzzyRegExpCache.set(word, regexp);\n    }\n    // RegExp Filter\n    const match = regexp.exec(wordToMatchAgainst);\n    if (match) {\n        return [{ start: match.index, end: match.index + match[0].length }];\n    }\n    // Default Filter\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nexport function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n    const max = Math.min(13, pattern.length);\n    for (; patternPos < max; patternPos++) {\n        const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, false);\n        if (result) {\n            return result;\n        }\n    }\n    return [0, wordPos];\n}\n//#region --- fuzzyScore ---\nexport function createMatches(score) {\n    if (typeof score === 'undefined') {\n        return [];\n    }\n    const res = [];\n    const wordPos = score[1];\n    for (let i = score.length - 1; i > 1; i--) {\n        const pos = score[i] + wordPos;\n        const last = res[res.length - 1];\n        if (last && last.end === pos) {\n            last.end = pos + 1;\n        }\n        else {\n            res.push({ start: pos, end: pos + 1 });\n        }\n    }\n    return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n    const table = [];\n    const row = [];\n    for (let i = 0; i <= _maxLen; i++) {\n        row[i] = 0;\n    }\n    for (let i = 0; i <= _maxLen; i++) {\n        table.push(row.slice(0));\n    }\n    return table;\n}\nfunction initArr(maxLen) {\n    const row = [];\n    for (let i = 0; i <= maxLen; i++) {\n        row[i] = 0;\n    }\n    return row;\n}\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = initTable();\nconst _debug = false;\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n    function pad(s, n, pad = ' ') {\n        while (s.length < n) {\n            s = pad + s;\n        }\n        return s;\n    }\n    let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n    for (let i = 0; i <= patternLen; i++) {\n        if (i === 0) {\n            ret += ' |';\n        }\n        else {\n            ret += `${pattern[i - 1]}|`;\n        }\n        ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n    }\n    return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n    pattern = pattern.substr(patternStart);\n    word = word.substr(wordStart);\n    console.log(printTable(_table, pattern, pattern.length, word, word.length));\n    console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n    console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\nfunction isSeparatorAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.codePointAt(index);\n    switch (code) {\n        case 95 /* Underline */:\n        case 45 /* Dash */:\n        case 46 /* Period */:\n        case 32 /* Space */:\n        case 47 /* Slash */:\n        case 92 /* Backslash */:\n        case 39 /* SingleQuote */:\n        case 34 /* DoubleQuote */:\n        case 58 /* Colon */:\n        case 36 /* DollarSign */:\n        case 60 /* LessThan */:\n        case 40 /* OpenParen */:\n        case 91 /* OpenSquareBracket */:\n            return true;\n        case undefined:\n            return false;\n        default:\n            if (strings.isEmojiImprecise(code)) {\n                return true;\n            }\n            return false;\n    }\n}\nfunction isWhitespaceAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.charCodeAt(index);\n    switch (code) {\n        case 32 /* Space */:\n        case 9 /* Tab */:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n    return word[pos] !== wordLow[pos];\n}\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n    while (patternPos < patternLen && wordPos < wordLen) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            if (fillMinWordPosArr) {\n                // Remember the min word position for each pattern position\n                _minWordMatchPos[patternPos] = wordPos;\n            }\n            patternPos += 1;\n        }\n        wordPos += 1;\n    }\n    return patternPos === patternLen; // pattern must be exhausted\n}\nexport var FuzzyScore;\n(function (FuzzyScore) {\n    /**\n     * No matches and value `-100`\n     */\n    FuzzyScore.Default = ([-100, 0]);\n    function isDefault(score) {\n        return !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n    }\n    FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n    const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n    const wordLen = word.length > _maxLen ? _maxLen : word.length;\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n        return undefined;\n    }\n    // Run a simple check if the characters of pattern occur\n    // (in order) at all in word. If that isn't the case we\n    // stop because no match will be possible\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n        return undefined;\n    }\n    // Find the max matching word position for each pattern position\n    // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n    _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n    let row = 1;\n    let column = 1;\n    let patternPos = patternStart;\n    let wordPos = wordStart;\n    const hasStrongFirstMatch = [false];\n    // There will be a match, fill in tables\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n        // Reduce search space to possible matching word positions and to possible access from next row\n        const minWordMatchPos = _minWordMatchPos[patternPos];\n        const maxWordMatchPos = _maxWordMatchPos[patternPos];\n        const nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n        for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n            let score = Number.MIN_SAFE_INTEGER;\n            let canComeDiag = false;\n            if (wordPos <= maxWordMatchPos) {\n                score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n            }\n            let diagScore = 0;\n            if (score !== Number.MAX_SAFE_INTEGER) {\n                canComeDiag = true;\n                diagScore = score + _table[row - 1][column - 1];\n            }\n            const canComeLeft = wordPos > minWordMatchPos;\n            const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n            const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n            const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n            if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n                // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n                _table[row][column] = leftLeftScore;\n                _arrows[row][column] = 3 /* LeftLeft */;\n                _diag[row][column] = 0;\n            }\n            else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n                // always prefer choosing left since that means a match is earlier in the word\n                _table[row][column] = leftScore;\n                _arrows[row][column] = 2 /* Left */;\n                _diag[row][column] = 0;\n            }\n            else if (canComeDiag) {\n                _table[row][column] = diagScore;\n                _arrows[row][column] = 1 /* Diag */;\n                _diag[row][column] = _diag[row - 1][column - 1] + 1;\n            }\n            else {\n                throw new Error(`not possible`);\n            }\n        }\n    }\n    if (_debug) {\n        printTables(pattern, patternStart, word, wordStart);\n    }\n    if (!hasStrongFirstMatch[0] && !firstMatchCanBeWeak) {\n        return undefined;\n    }\n    row--;\n    column--;\n    const result = [_table[row][column], wordStart];\n    let backwardsDiagLength = 0;\n    let maxMatchColumn = 0;\n    while (row >= 1) {\n        // Find the column where we go diagonally up\n        let diagColumn = column;\n        do {\n            const arrow = _arrows[row][diagColumn];\n            if (arrow === 3 /* LeftLeft */) {\n                diagColumn = diagColumn - 2;\n            }\n            else if (arrow === 2 /* Left */) {\n                diagColumn = diagColumn - 1;\n            }\n            else {\n                // found the diagonal\n                break;\n            }\n        } while (diagColumn >= 1);\n        // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n        if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n            && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n            && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n            && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n        ) {\n            diagColumn = column;\n        }\n        if (diagColumn === column) {\n            // this is a contiguous match\n            backwardsDiagLength++;\n        }\n        else {\n            backwardsDiagLength = 1;\n        }\n        if (!maxMatchColumn) {\n            // remember the last matched column\n            maxMatchColumn = diagColumn;\n        }\n        row--;\n        column = diagColumn - 1;\n        result.push(column);\n    }\n    if (wordLen === patternLen) {\n        // the word matches the pattern with all characters!\n        // giving the score a total match boost (to come up ahead other words)\n        result[0] += 2;\n    }\n    // Add 1 penalty for each skipped character in the word\n    const skippedCharsCount = maxMatchColumn - patternLen;\n    result[0] -= skippedCharsCount;\n    return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n    let patternPos = patternLen - 1;\n    let wordPos = wordLen - 1;\n    while (patternPos >= patternStart && wordPos >= wordStart) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            _maxWordMatchPos[patternPos] = wordPos;\n            patternPos--;\n        }\n        wordPos--;\n    }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\n        return Number.MIN_SAFE_INTEGER;\n    }\n    let score = 1;\n    let isGapLocation = false;\n    if (wordPos === (patternPos - patternStart)) {\n        // common prefix: `foobar <-> foobaz`\n        //                            ^^^^^\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    }\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n        // hitting upper-case: `foo <-> forOthers`\n        //                              ^^ ^\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n        isGapLocation = true;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n        // hitting a separator: `. <-> foo.bar`\n        //                                ^\n        score = 5;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n        // post separator: `foo <-> bar_foo`\n        //                              ^^^\n        score = 5;\n        isGapLocation = true;\n    }\n    if (score > 1 && patternPos === patternStart) {\n        outFirstMatchStrong[0] = true;\n    }\n    if (!isGapLocation) {\n        isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n    }\n    //\n    if (patternPos === patternStart) { // first character in pattern\n        if (wordPos > wordStart) {\n            // the first pattern character would match a word character that is not at the word start\n            // so introduce a penalty to account for the gap preceding this match\n            score -= isGapLocation ? 3 : 5;\n        }\n    }\n    else {\n        if (newMatchStart) {\n            // this would be the beginning of a new match (i.e. there would be a gap before this location)\n            score += isGapLocation ? 2 : 0;\n        }\n        else {\n            // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n            score += isGapLocation ? 0 : 1;\n        }\n    }\n    if (wordPos + 1 === wordLen) {\n        // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n        // so pretend there is a gap after the last character in the word to normalize things\n        score -= isGapLocation ? 3 : 5;\n    }\n    return score;\n}\n//#endregion\n//#region --- graceful ---\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n    let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n    if (top && !aggressive) {\n        // when using the original pattern yield a result we`\n        // return it unless we are aggressive and try to find\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n        return top;\n    }\n    if (pattern.length >= 3) {\n        // When the pattern is long enough then try a few (max 7)\n        // permutations of the pattern to find a better match. The\n        // permutations only swap neighbouring characters, e.g\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n        const tries = Math.min(7, pattern.length - 1);\n        for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n            const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n            if (newPattern) {\n                const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n                if (candidate) {\n                    candidate[0] -= 3; // permutation penalty\n                    if (!top || candidate[0] > top[0]) {\n                        top = candidate;\n                    }\n                }\n            }\n        }\n    }\n    return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n    if (patternPos + 1 >= pattern.length) {\n        return undefined;\n    }\n    const swap1 = pattern[patternPos];\n    const swap2 = pattern[patternPos + 1];\n    if (swap1 === swap2) {\n        return undefined;\n    }\n    return pattern.slice(0, patternPos)\n        + swap2\n        + swap1\n        + pattern.slice(patternPos + 2);\n}\n//#endregion\n"]},"metadata":{},"sourceType":"module"}