{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js'; // TRACING\n\nconst _enableTracing = false;\n\nclass CyclicDependencyError extends Error {\n  constructor(graph) {\n    var _a;\n\n    super('cyclic dependency between services');\n    this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n  }\n\n}\n\nexport class InstantiationService {\n  constructor(services = new ServiceCollection(), strict = false, parent) {\n    this._activeInstantiations = new Set();\n    this._services = services;\n    this._strict = strict;\n    this._parent = parent;\n\n    this._services.set(IInstantiationService, this);\n  }\n\n  createChild(services) {\n    return new InstantiationService(services, this._strict, this);\n  }\n\n  invokeFunction(fn, ...args) {\n    let _trace = Trace.traceInvocation(fn);\n\n    let _done = false;\n\n    try {\n      const accessor = {\n        get: id => {\n          if (_done) {\n            throw illegalState('service accessor is only valid during the invocation of its target method');\n          }\n\n          const result = this._getOrCreateServiceInstance(id, _trace);\n\n          if (!result) {\n            throw new Error(`[invokeFunction] unknown service '${id}'`);\n          }\n\n          return result;\n        }\n      };\n      return fn(accessor, ...args);\n    } finally {\n      _done = true;\n\n      _trace.stop();\n    }\n  }\n\n  createInstance(ctorOrDescriptor, ...rest) {\n    let _trace;\n\n    let result;\n\n    if (ctorOrDescriptor instanceof SyncDescriptor) {\n      _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n    } else {\n      _trace = Trace.traceCreation(ctorOrDescriptor);\n      result = this._createInstance(ctorOrDescriptor, rest, _trace);\n    }\n\n    _trace.stop();\n\n    return result;\n  }\n\n  _createInstance(ctor, args = [], _trace) {\n    // arguments defined by service decorators\n    let serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n\n    let serviceArgs = [];\n\n    for (const dependency of serviceDependencies) {\n      let service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\n      if (!service && this._strict && !dependency.optional) {\n        throw new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);\n      }\n\n      serviceArgs.push(service);\n    }\n\n    let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length; // check for argument mismatches, adjust static args if needed\n\n    if (args.length !== firstServiceArgPos) {\n      console.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n      let delta = firstServiceArgPos - args.length;\n\n      if (delta > 0) {\n        args = args.concat(new Array(delta));\n      } else {\n        args = args.slice(0, firstServiceArgPos);\n      }\n    } // now create the instance\n\n\n    return new ctor(...[...args, ...serviceArgs]);\n  }\n\n  _setServiceInstance(id, instance) {\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      this._services.set(id, instance);\n    } else if (this._parent) {\n      this._parent._setServiceInstance(id, instance);\n    } else {\n      throw new Error('illegalState - setting UNKNOWN service instance');\n    }\n  }\n\n  _getServiceInstanceOrDescriptor(id) {\n    let instanceOrDesc = this._services.get(id);\n\n    if (!instanceOrDesc && this._parent) {\n      return this._parent._getServiceInstanceOrDescriptor(id);\n    } else {\n      return instanceOrDesc;\n    }\n  }\n\n  _getOrCreateServiceInstance(id, _trace) {\n    let thing = this._getServiceInstanceOrDescriptor(id);\n\n    if (thing instanceof SyncDescriptor) {\n      return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n    } else {\n      _trace.branch(id, false);\n\n      return thing;\n    }\n  }\n\n  _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n    if (this._activeInstantiations.has(id)) {\n      throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n    }\n\n    this._activeInstantiations.add(id);\n\n    try {\n      return this._createAndCacheServiceInstance(id, desc, _trace);\n    } finally {\n      this._activeInstantiations.delete(id);\n    }\n  }\n\n  _createAndCacheServiceInstance(id, desc, _trace) {\n    const graph = new Graph(data => data.id.toString());\n    let cycleCount = 0;\n    const stack = [{\n      id,\n      desc,\n      _trace\n    }];\n\n    while (stack.length) {\n      const item = stack.pop();\n      graph.lookupOrInsertNode(item); // a weak but working heuristic for cycle checks\n\n      if (cycleCount++ > 1000) {\n        throw new CyclicDependencyError(graph);\n      } // check all dependencies for existence and if they need to be created first\n\n\n      for (let dependency of _util.getServiceDependencies(item.desc.ctor)) {\n        let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\n        if (!instanceOrDesc && !dependency.optional) {\n          console.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);\n        }\n\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          const d = {\n            id: dependency.id,\n            desc: instanceOrDesc,\n            _trace: item._trace.branch(dependency.id, true)\n          };\n          graph.insertEdge(item, d);\n          stack.push(d);\n        }\n      }\n    }\n\n    while (true) {\n      const roots = graph.roots(); // if there is no more roots but still\n      // nodes in the graph we have a cycle\n\n      if (roots.length === 0) {\n        if (!graph.isEmpty()) {\n          throw new CyclicDependencyError(graph);\n        }\n\n        break;\n      }\n\n      for (const {\n        data\n      } of roots) {\n        // Repeat the check for this still being a service sync descriptor. That's because\n        // instantiating a dependency might have side-effect and recursively trigger instantiation\n        // so that some dependencies are now fullfilled already.\n        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          // create instance and overwrite the service collections\n          const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\n          this._setServiceInstance(data.id, instance);\n        }\n\n        graph.removeNode(data);\n      }\n    }\n\n    return this._getServiceInstanceOrDescriptor(id);\n  }\n\n  _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n    } else if (this._parent) {\n      return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n    } else {\n      throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n    }\n  }\n\n  _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {\n    if (!_supportsDelayedInstantiation) {\n      // eager instantiation\n      return this._createInstance(ctor, args, _trace);\n    } else {\n      // Return a proxy object that's backed by an idle value. That\n      // strategy is to instantiate services in our idle time or when actually\n      // needed but not when injected into a consumer\n      const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\n      return new Proxy(Object.create(null), {\n        get(target, key) {\n          if (key in target) {\n            return target[key];\n          }\n\n          let obj = idle.value;\n          let prop = obj[key];\n\n          if (typeof prop !== 'function') {\n            return prop;\n          }\n\n          prop = prop.bind(obj);\n          target[key] = prop;\n          return prop;\n        },\n\n        set(_target, p, value) {\n          idle.value[p] = value;\n          return true;\n        }\n\n      });\n    }\n  }\n\n}\nexport class Trace {\n  constructor(type, name) {\n    this.type = type;\n    this.name = name;\n    this._start = Date.now();\n    this._dep = [];\n  }\n\n  static traceInvocation(ctor) {\n    return !_enableTracing ? Trace._None : new Trace(1\n    /* Invocation */\n    , ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n  }\n\n  static traceCreation(ctor) {\n    return !_enableTracing ? Trace._None : new Trace(0\n    /* Creation */\n    , ctor.name);\n  }\n\n  branch(id, first) {\n    let child = new Trace(2\n    /* Branch */\n    , id.toString());\n\n    this._dep.push([id, first, child]);\n\n    return child;\n  }\n\n  stop() {\n    let dur = Date.now() - this._start;\n\n    Trace._totals += dur;\n    let causedCreation = false;\n\n    function printChild(n, trace) {\n      let res = [];\n      let prefix = new Array(n + 1).join('\\t');\n\n      for (const [id, first, child] of trace._dep) {\n        if (first && child) {\n          causedCreation = true;\n          res.push(`${prefix}CREATES -> ${id}`);\n          let nested = printChild(n + 1, child);\n\n          if (nested) {\n            res.push(nested);\n          }\n        } else {\n          res.push(`${prefix}uses -> ${id}`);\n        }\n      }\n\n      return res.join('\\n');\n    }\n\n    let lines = [`${this.type === 0\n    /* Creation */\n    ? 'CREATE' : 'CALL'} ${this.name}`, `${printChild(1, this)}`, `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`];\n\n    if (dur > 2 || causedCreation) {\n      console.log(lines.join('\\n'));\n    }\n  }\n\n}\nTrace._None = new class extends Trace {\n  constructor() {\n    super(-1, null);\n  }\n\n  stop() {}\n\n  branch() {\n    return this;\n  }\n\n}();\nTrace._totals = 0; //#endregion","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js"],"names":["IdleValue","illegalState","SyncDescriptor","Graph","IInstantiationService","_util","ServiceCollection","_enableTracing","CyclicDependencyError","Error","constructor","graph","_a","message","findCycleSlow","toString","InstantiationService","services","strict","parent","_activeInstantiations","Set","_services","_strict","_parent","set","createChild","invokeFunction","fn","args","_trace","Trace","traceInvocation","_done","accessor","get","id","result","_getOrCreateServiceInstance","stop","createInstance","ctorOrDescriptor","rest","traceCreation","ctor","_createInstance","staticArguments","concat","serviceDependencies","getServiceDependencies","sort","a","b","index","serviceArgs","dependency","service","optional","name","push","firstServiceArgPos","length","console","warn","delta","Array","slice","_setServiceInstance","instance","_getServiceInstanceOrDescriptor","instanceOrDesc","thing","_safeCreateAndCacheServiceInstance","branch","desc","has","add","_createAndCacheServiceInstance","delete","data","cycleCount","stack","item","pop","lookupOrInsertNode","d","insertEdge","roots","isEmpty","_createServiceInstanceWithOwner","supportsDelayedInstantiation","removeNode","_createServiceInstance","_supportsDelayedInstantiation","idle","Proxy","Object","create","target","key","obj","value","prop","bind","_target","p","type","_start","Date","now","_dep","_None","substring","replace","first","child","dur","_totals","causedCreation","printChild","n","trace","res","prefix","join","nested","lines","toFixed","log"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\n// TRACING\nconst _enableTracing = false;\nclass CyclicDependencyError extends Error {\n    constructor(graph) {\n        var _a;\n        super('cyclic dependency between services');\n        this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n    }\n}\nexport class InstantiationService {\n    constructor(services = new ServiceCollection(), strict = false, parent) {\n        this._activeInstantiations = new Set();\n        this._services = services;\n        this._strict = strict;\n        this._parent = parent;\n        this._services.set(IInstantiationService, this);\n    }\n    createChild(services) {\n        return new InstantiationService(services, this._strict, this);\n    }\n    invokeFunction(fn, ...args) {\n        let _trace = Trace.traceInvocation(fn);\n        let _done = false;\n        try {\n            const accessor = {\n                get: (id) => {\n                    if (_done) {\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\n                    }\n                    const result = this._getOrCreateServiceInstance(id, _trace);\n                    if (!result) {\n                        throw new Error(`[invokeFunction] unknown service '${id}'`);\n                    }\n                    return result;\n                }\n            };\n            return fn(accessor, ...args);\n        }\n        finally {\n            _done = true;\n            _trace.stop();\n        }\n    }\n    createInstance(ctorOrDescriptor, ...rest) {\n        let _trace;\n        let result;\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\n            _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n        }\n        else {\n            _trace = Trace.traceCreation(ctorOrDescriptor);\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\n        }\n        _trace.stop();\n        return result;\n    }\n    _createInstance(ctor, args = [], _trace) {\n        // arguments defined by service decorators\n        let serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n        let serviceArgs = [];\n        for (const dependency of serviceDependencies) {\n            let service = this._getOrCreateServiceInstance(dependency.id, _trace);\n            if (!service && this._strict && !dependency.optional) {\n                throw new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);\n            }\n            serviceArgs.push(service);\n        }\n        let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n        // check for argument mismatches, adjust static args if needed\n        if (args.length !== firstServiceArgPos) {\n            console.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n            let delta = firstServiceArgPos - args.length;\n            if (delta > 0) {\n                args = args.concat(new Array(delta));\n            }\n            else {\n                args = args.slice(0, firstServiceArgPos);\n            }\n        }\n        // now create the instance\n        return new ctor(...[...args, ...serviceArgs]);\n    }\n    _setServiceInstance(id, instance) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            this._services.set(id, instance);\n        }\n        else if (this._parent) {\n            this._parent._setServiceInstance(id, instance);\n        }\n        else {\n            throw new Error('illegalState - setting UNKNOWN service instance');\n        }\n    }\n    _getServiceInstanceOrDescriptor(id) {\n        let instanceOrDesc = this._services.get(id);\n        if (!instanceOrDesc && this._parent) {\n            return this._parent._getServiceInstanceOrDescriptor(id);\n        }\n        else {\n            return instanceOrDesc;\n        }\n    }\n    _getOrCreateServiceInstance(id, _trace) {\n        let thing = this._getServiceInstanceOrDescriptor(id);\n        if (thing instanceof SyncDescriptor) {\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n        }\n        else {\n            _trace.branch(id, false);\n            return thing;\n        }\n    }\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n        if (this._activeInstantiations.has(id)) {\n            throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n        }\n        this._activeInstantiations.add(id);\n        try {\n            return this._createAndCacheServiceInstance(id, desc, _trace);\n        }\n        finally {\n            this._activeInstantiations.delete(id);\n        }\n    }\n    _createAndCacheServiceInstance(id, desc, _trace) {\n        const graph = new Graph(data => data.id.toString());\n        let cycleCount = 0;\n        const stack = [{ id, desc, _trace }];\n        while (stack.length) {\n            const item = stack.pop();\n            graph.lookupOrInsertNode(item);\n            // a weak but working heuristic for cycle checks\n            if (cycleCount++ > 1000) {\n                throw new CyclicDependencyError(graph);\n            }\n            // check all dependencies for existence and if they need to be created first\n            for (let dependency of _util.getServiceDependencies(item.desc.ctor)) {\n                let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                if (!instanceOrDesc && !dependency.optional) {\n                    console.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);\n                }\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                    graph.insertEdge(item, d);\n                    stack.push(d);\n                }\n            }\n        }\n        while (true) {\n            const roots = graph.roots();\n            // if there is no more roots but still\n            // nodes in the graph we have a cycle\n            if (roots.length === 0) {\n                if (!graph.isEmpty()) {\n                    throw new CyclicDependencyError(graph);\n                }\n                break;\n            }\n            for (const { data } of roots) {\n                // Repeat the check for this still being a service sync descriptor. That's because\n                // instantiating a dependency might have side-effect and recursively trigger instantiation\n                // so that some dependencies are now fullfilled already.\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    // create instance and overwrite the service collections\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                    this._setServiceInstance(data.id, instance);\n                }\n                graph.removeNode(data);\n            }\n        }\n        return this._getServiceInstanceOrDescriptor(id);\n    }\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else if (this._parent) {\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else {\n            throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n        }\n    }\n    _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {\n        if (!_supportsDelayedInstantiation) {\n            // eager instantiation\n            return this._createInstance(ctor, args, _trace);\n        }\n        else {\n            // Return a proxy object that's backed by an idle value. That\n            // strategy is to instantiate services in our idle time or when actually\n            // needed but not when injected into a consumer\n            const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\n            return new Proxy(Object.create(null), {\n                get(target, key) {\n                    if (key in target) {\n                        return target[key];\n                    }\n                    let obj = idle.value;\n                    let prop = obj[key];\n                    if (typeof prop !== 'function') {\n                        return prop;\n                    }\n                    prop = prop.bind(obj);\n                    target[key] = prop;\n                    return prop;\n                },\n                set(_target, p, value) {\n                    idle.value[p] = value;\n                    return true;\n                }\n            });\n        }\n    }\n}\nexport class Trace {\n    constructor(type, name) {\n        this.type = type;\n        this.name = name;\n        this._start = Date.now();\n        this._dep = [];\n    }\n    static traceInvocation(ctor) {\n        return !_enableTracing ? Trace._None : new Trace(1 /* Invocation */, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n    }\n    static traceCreation(ctor) {\n        return !_enableTracing ? Trace._None : new Trace(0 /* Creation */, ctor.name);\n    }\n    branch(id, first) {\n        let child = new Trace(2 /* Branch */, id.toString());\n        this._dep.push([id, first, child]);\n        return child;\n    }\n    stop() {\n        let dur = Date.now() - this._start;\n        Trace._totals += dur;\n        let causedCreation = false;\n        function printChild(n, trace) {\n            let res = [];\n            let prefix = new Array(n + 1).join('\\t');\n            for (const [id, first, child] of trace._dep) {\n                if (first && child) {\n                    causedCreation = true;\n                    res.push(`${prefix}CREATES -> ${id}`);\n                    let nested = printChild(n + 1, child);\n                    if (nested) {\n                        res.push(nested);\n                    }\n                }\n                else {\n                    res.push(`${prefix}uses -> ${id}`);\n                }\n            }\n            return res.join('\\n');\n        }\n        let lines = [\n            `${this.type === 0 /* Creation */ ? 'CREATE' : 'CALL'} ${this.name}`,\n            `${printChild(1, this)}`,\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n        ];\n        if (dur > 2 || causedCreation) {\n            console.log(lines.join('\\n'));\n        }\n    }\n}\nTrace._None = new class extends Trace {\n    constructor() { super(-1, null); }\n    stop() { }\n    branch() { return this; }\n};\nTrace._totals = 0;\n//#endregion\n"]},"metadata":{},"sourceType":"module"}