{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findFirstInSorted } from '../../../../base/common/arrays.js';\nimport { RunOnceScheduler, TimeoutTimer } from '../../../../base/common/async.js';\nimport { DisposableStore, dispose } from '../../../../base/common/lifecycle.js';\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection } from '../../../common/commands/replaceCommand.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { SearchParams } from '../../../common/model/textModelSearch.js';\nimport { FindDecorations } from './findDecorations.js';\nimport { ReplaceAllCommand } from './replaceAllCommand.js';\nimport { parseReplaceString, ReplacePattern } from './replacePattern.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nexport const CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey('findWidgetVisible', false);\nexport const CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated(); // Keep ContextKey use of 'Focussed' to not break when clauses\n\nexport const CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey('findInputFocussed', false);\nexport const CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey('replaceInputFocussed', false);\nexport const ToggleCaseSensitiveKeybinding = {\n  primary: 512\n  /* Alt */\n  | 33\n  /* KeyC */\n  ,\n  mac: {\n    primary: 2048\n    /* CtrlCmd */\n    | 512\n    /* Alt */\n    | 33\n    /* KeyC */\n\n  }\n};\nexport const ToggleWholeWordKeybinding = {\n  primary: 512\n  /* Alt */\n  | 53\n  /* KeyW */\n  ,\n  mac: {\n    primary: 2048\n    /* CtrlCmd */\n    | 512\n    /* Alt */\n    | 53\n    /* KeyW */\n\n  }\n};\nexport const ToggleRegexKeybinding = {\n  primary: 512\n  /* Alt */\n  | 48\n  /* KeyR */\n  ,\n  mac: {\n    primary: 2048\n    /* CtrlCmd */\n    | 512\n    /* Alt */\n    | 48\n    /* KeyR */\n\n  }\n};\nexport const ToggleSearchScopeKeybinding = {\n  primary: 512\n  /* Alt */\n  | 42\n  /* KeyL */\n  ,\n  mac: {\n    primary: 2048\n    /* CtrlCmd */\n    | 512\n    /* Alt */\n    | 42\n    /* KeyL */\n\n  }\n};\nexport const TogglePreserveCaseKeybinding = {\n  primary: 512\n  /* Alt */\n  | 46\n  /* KeyP */\n  ,\n  mac: {\n    primary: 2048\n    /* CtrlCmd */\n    | 512\n    /* Alt */\n    | 46\n    /* KeyP */\n\n  }\n};\nexport const FIND_IDS = {\n  StartFindAction: 'actions.find',\n  StartFindWithSelection: 'actions.findWithSelection',\n  StartFindWithArgs: 'editor.actions.findWithArgs',\n  NextMatchFindAction: 'editor.action.nextMatchFindAction',\n  PreviousMatchFindAction: 'editor.action.previousMatchFindAction',\n  NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',\n  PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',\n  StartFindReplaceAction: 'editor.action.startFindReplaceAction',\n  CloseFindWidgetCommand: 'closeFindWidget',\n  ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',\n  ToggleWholeWordCommand: 'toggleFindWholeWord',\n  ToggleRegexCommand: 'toggleFindRegex',\n  ToggleSearchScopeCommand: 'toggleFindInSelection',\n  TogglePreserveCaseCommand: 'togglePreserveCase',\n  ReplaceOneAction: 'editor.action.replaceOne',\n  ReplaceAllAction: 'editor.action.replaceAll',\n  SelectAllMatchesAction: 'editor.action.selectAllMatches'\n};\nexport const MATCHES_LIMIT = 19999;\nconst RESEARCH_DELAY = 240;\nexport class FindModelBoundToEditorModel {\n  constructor(editor, state) {\n    this._toDispose = new DisposableStore();\n    this._editor = editor;\n    this._state = state;\n    this._isDisposed = false;\n    this._startSearchingTimer = new TimeoutTimer();\n    this._decorations = new FindDecorations(editor);\n\n    this._toDispose.add(this._decorations);\n\n    this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);\n\n    this._toDispose.add(this._updateDecorationsScheduler);\n\n    this._toDispose.add(this._editor.onDidChangeCursorPosition(e => {\n      if (e.reason === 3\n      /* Explicit */\n      || e.reason === 5\n      /* Undo */\n      || e.reason === 6\n      /* Redo */\n      ) {\n        this._decorations.setStartPosition(this._editor.getPosition());\n      }\n    }));\n\n    this._ignoreModelContentChanged = false;\n\n    this._toDispose.add(this._editor.onDidChangeModelContent(e => {\n      if (this._ignoreModelContentChanged) {\n        return;\n      }\n\n      if (e.isFlush) {\n        // a model.setValue() was called\n        this._decorations.reset();\n      }\n\n      this._decorations.setStartPosition(this._editor.getPosition());\n\n      this._updateDecorationsScheduler.schedule();\n    }));\n\n    this._toDispose.add(this._state.onFindReplaceStateChange(e => this._onStateChanged(e)));\n\n    this.research(false, this._state.searchScope);\n  }\n\n  dispose() {\n    this._isDisposed = true;\n    dispose(this._startSearchingTimer);\n\n    this._toDispose.dispose();\n  }\n\n  _onStateChanged(e) {\n    if (this._isDisposed) {\n      // The find model is disposed during a find state changed event\n      return;\n    }\n\n    if (!this._editor.hasModel()) {\n      // The find model will be disposed momentarily\n      return;\n    }\n\n    if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {\n      let model = this._editor.getModel();\n\n      if (model.isTooLargeForSyncing()) {\n        this._startSearchingTimer.cancel();\n\n        this._startSearchingTimer.setIfNotSet(() => {\n          if (e.searchScope) {\n            this.research(e.moveCursor, this._state.searchScope);\n          } else {\n            this.research(e.moveCursor);\n          }\n        }, RESEARCH_DELAY);\n      } else {\n        if (e.searchScope) {\n          this.research(e.moveCursor, this._state.searchScope);\n        } else {\n          this.research(e.moveCursor);\n        }\n      }\n    }\n  }\n\n  static _getSearchRange(model, findScope) {\n    // If we have set now or before a find scope, use it for computing the search range\n    if (findScope) {\n      return findScope;\n    }\n\n    return model.getFullModelRange();\n  }\n\n  research(moveCursor, newFindScope) {\n    let findScopes = null;\n\n    if (typeof newFindScope !== 'undefined') {\n      if (newFindScope !== null) {\n        if (!Array.isArray(newFindScope)) {\n          findScopes = [newFindScope];\n        } else {\n          findScopes = newFindScope;\n        }\n      }\n    } else {\n      findScopes = this._decorations.getFindScopes();\n    }\n\n    if (findScopes !== null) {\n      findScopes = findScopes.map(findScope => {\n        if (findScope.startLineNumber !== findScope.endLineNumber) {\n          let endLineNumber = findScope.endLineNumber;\n\n          if (findScope.endColumn === 1) {\n            endLineNumber = endLineNumber - 1;\n          }\n\n          return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));\n        }\n\n        return findScope;\n      });\n    }\n\n    let findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);\n\n    this._decorations.set(findMatches, findScopes);\n\n    const editorSelection = this._editor.getSelection();\n\n    let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);\n\n    if (currentMatchesPosition === 0 && findMatches.length > 0) {\n      // current selection is not on top of a match\n      // try to find its nearest result from the top of the document\n      const matchAfterSelection = findFirstInSorted(findMatches.map(match => match.range), range => Range.compareRangesUsingStarts(range, editorSelection) >= 0);\n      currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1\n      /** match position is one based */\n      : currentMatchesPosition;\n    }\n\n    this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), undefined);\n\n    if (moveCursor && this._editor.getOption(35\n    /* find */\n    ).cursorMoveOnType) {\n      this._moveToNextMatch(this._decorations.getStartPosition());\n    }\n  }\n\n  _hasMatches() {\n    return this._state.matchesCount > 0;\n  }\n\n  _cannotFind() {\n    if (!this._hasMatches()) {\n      let findScope = this._decorations.getFindScope();\n\n      if (findScope) {\n        // Reveal the selection so user is reminded that 'selection find' is on.\n        this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0\n        /* Smooth */\n        );\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _setCurrentFindMatch(match) {\n    let matchesPosition = this._decorations.setCurrentFindMatch(match);\n\n    this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);\n\n    this._editor.setSelection(match);\n\n    this._editor.revealRangeInCenterIfOutsideViewport(match, 0\n    /* Smooth */\n    );\n  }\n\n  _prevSearchPosition(before) {\n    let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0 || this._state.searchString.indexOf('$') >= 0);\n    let {\n      lineNumber,\n      column\n    } = before;\n\n    let model = this._editor.getModel();\n\n    if (isUsingLineStops || column === 1) {\n      if (lineNumber === 1) {\n        lineNumber = model.getLineCount();\n      } else {\n        lineNumber--;\n      }\n\n      column = model.getLineMaxColumn(lineNumber);\n    } else {\n      column--;\n    }\n\n    return new Position(lineNumber, column);\n  }\n\n  _moveToPrevMatch(before, isRecursed = false) {\n    if (!this._state.canNavigateBack()) {\n      // we are beyond the first matched find result\n      // instead of doing nothing, we should refocus the first item\n      const nextMatchRange = this._decorations.matchAfterPosition(before);\n\n      if (nextMatchRange) {\n        this._setCurrentFindMatch(nextMatchRange);\n      }\n\n      return;\n    }\n\n    if (this._decorations.getCount() < MATCHES_LIMIT) {\n      let prevMatchRange = this._decorations.matchBeforePosition(before);\n\n      if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {\n        before = this._prevSearchPosition(before);\n        prevMatchRange = this._decorations.matchBeforePosition(before);\n      }\n\n      if (prevMatchRange) {\n        this._setCurrentFindMatch(prevMatchRange);\n      }\n\n      return;\n    }\n\n    if (this._cannotFind()) {\n      return;\n    }\n\n    let findScope = this._decorations.getFindScope();\n\n    let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope); // ...(----)...|...\n\n\n    if (searchRange.getEndPosition().isBefore(before)) {\n      before = searchRange.getEndPosition();\n    } // ...|...(----)...\n\n\n    if (before.isBefore(searchRange.getStartPosition())) {\n      before = searchRange.getEndPosition();\n    }\n\n    let {\n      lineNumber,\n      column\n    } = before;\n\n    let model = this._editor.getModel();\n\n    let position = new Position(lineNumber, column);\n    let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117\n    /* wordSeparators */\n    ) : null, false);\n\n    if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {\n      // Looks like we're stuck at this position, unacceptable!\n      position = this._prevSearchPosition(position);\n      prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117\n      /* wordSeparators */\n      ) : null, false);\n    }\n\n    if (!prevMatch) {\n      // there is precisely one match and selection is on top of it\n      return;\n    }\n\n    if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {\n      return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);\n    }\n\n    this._setCurrentFindMatch(prevMatch.range);\n  }\n\n  moveToPrevMatch() {\n    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());\n  }\n\n  _nextSearchPosition(after) {\n    let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0 || this._state.searchString.indexOf('$') >= 0);\n    let {\n      lineNumber,\n      column\n    } = after;\n\n    let model = this._editor.getModel();\n\n    if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {\n      if (lineNumber === model.getLineCount()) {\n        lineNumber = 1;\n      } else {\n        lineNumber++;\n      }\n\n      column = 1;\n    } else {\n      column++;\n    }\n\n    return new Position(lineNumber, column);\n  }\n\n  _moveToNextMatch(after) {\n    if (!this._state.canNavigateForward()) {\n      // we are beyond the last matched find result\n      // instead of doing nothing, we should refocus the last item\n      const prevMatchRange = this._decorations.matchBeforePosition(after);\n\n      if (prevMatchRange) {\n        this._setCurrentFindMatch(prevMatchRange);\n      }\n\n      return;\n    }\n\n    if (this._decorations.getCount() < MATCHES_LIMIT) {\n      let nextMatchRange = this._decorations.matchAfterPosition(after);\n\n      if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {\n        // Looks like we're stuck at this position, unacceptable!\n        after = this._nextSearchPosition(after);\n        nextMatchRange = this._decorations.matchAfterPosition(after);\n      }\n\n      if (nextMatchRange) {\n        this._setCurrentFindMatch(nextMatchRange);\n      }\n\n      return;\n    }\n\n    let nextMatch = this._getNextMatch(after, false, true);\n\n    if (nextMatch) {\n      this._setCurrentFindMatch(nextMatch.range);\n    }\n  }\n\n  _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {\n    if (this._cannotFind()) {\n      return null;\n    }\n\n    let findScope = this._decorations.getFindScope();\n\n    let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope); // ...(----)...|...\n\n\n    if (searchRange.getEndPosition().isBefore(after)) {\n      after = searchRange.getStartPosition();\n    } // ...|...(----)...\n\n\n    if (after.isBefore(searchRange.getStartPosition())) {\n      after = searchRange.getStartPosition();\n    }\n\n    let {\n      lineNumber,\n      column\n    } = after;\n\n    let model = this._editor.getModel();\n\n    let position = new Position(lineNumber, column);\n    let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117\n    /* wordSeparators */\n    ) : null, captureMatches);\n\n    if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {\n      // Looks like we're stuck at this position, unacceptable!\n      position = this._nextSearchPosition(position);\n      nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117\n      /* wordSeparators */\n      ) : null, captureMatches);\n    }\n\n    if (!nextMatch) {\n      // there is precisely one match and selection is on top of it\n      return null;\n    }\n\n    if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {\n      return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);\n    }\n\n    return nextMatch;\n  }\n\n  moveToNextMatch() {\n    this._moveToNextMatch(this._editor.getSelection().getEndPosition());\n  }\n\n  _getReplacePattern() {\n    if (this._state.isRegex) {\n      return parseReplaceString(this._state.replaceString);\n    }\n\n    return ReplacePattern.fromStaticValue(this._state.replaceString);\n  }\n\n  replace() {\n    if (!this._hasMatches()) {\n      return;\n    }\n\n    let replacePattern = this._getReplacePattern();\n\n    let selection = this._editor.getSelection();\n\n    let nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);\n\n    if (nextMatch) {\n      if (selection.equalsRange(nextMatch.range)) {\n        // selection sits on a find match => replace it!\n        let replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);\n        let command = new ReplaceCommand(selection, replaceString);\n\n        this._executeEditorCommand('replace', command);\n\n        this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));\n\n        this.research(true);\n      } else {\n        this._decorations.setStartPosition(this._editor.getPosition());\n\n        this._setCurrentFindMatch(nextMatch.range);\n      }\n    }\n  }\n\n  _findMatches(findScopes, captureMatches, limitResultCount) {\n    const searchRanges = (findScopes || [null]).map(scope => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));\n    return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117\n    /* wordSeparators */\n    ) : null, captureMatches, limitResultCount);\n  }\n\n  replaceAll() {\n    if (!this._hasMatches()) {\n      return;\n    }\n\n    const findScopes = this._decorations.getFindScopes();\n\n    if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {\n      // Doing a replace on the entire file that is over ${MATCHES_LIMIT} matches\n      this._largeReplaceAll();\n    } else {\n      this._regularReplaceAll(findScopes);\n    }\n\n    this.research(false);\n  }\n\n  _largeReplaceAll() {\n    const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117\n    /* wordSeparators */\n    ) : null);\n    const searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return;\n    }\n\n    let searchRegex = searchData.regex;\n\n    if (!searchRegex.multiline) {\n      let mod = 'mu';\n\n      if (searchRegex.ignoreCase) {\n        mod += 'i';\n      }\n\n      if (searchRegex.global) {\n        mod += 'g';\n      }\n\n      searchRegex = new RegExp(searchRegex.source, mod);\n    }\n\n    const model = this._editor.getModel();\n\n    const modelText = model.getValue(1\n    /* LF */\n    );\n    const fullModelRange = model.getFullModelRange();\n\n    const replacePattern = this._getReplacePattern();\n\n    let resultText;\n    const preserveCase = this._state.preserveCase;\n\n    if (replacePattern.hasReplacementPatterns || preserveCase) {\n      resultText = modelText.replace(searchRegex, function () {\n        return replacePattern.buildReplaceString(arguments, preserveCase);\n      });\n    } else {\n      resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));\n    }\n\n    let command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());\n\n    this._executeEditorCommand('replaceAll', command);\n  }\n\n  _regularReplaceAll(findScopes) {\n    const replacePattern = this._getReplacePattern(); // Get all the ranges (even more than the highlighted ones)\n\n\n    let matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    );\n\n    let replaceStrings = [];\n\n    for (let i = 0, len = matches.length; i < len; i++) {\n      replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);\n    }\n\n    let command = new ReplaceAllCommand(this._editor.getSelection(), matches.map(m => m.range), replaceStrings);\n\n    this._executeEditorCommand('replaceAll', command);\n  }\n\n  selectAllMatches() {\n    if (!this._hasMatches()) {\n      return;\n    }\n\n    let findScopes = this._decorations.getFindScopes(); // Get all the ranges (even more than the highlighted ones)\n\n\n    let matches = this._findMatches(findScopes, false, 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    );\n\n    let selections = matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)); // If one of the ranges is the editor selection, then maintain it as primary\n\n    let editorSelection = this._editor.getSelection();\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      let sel = selections[i];\n\n      if (sel.equalsRange(editorSelection)) {\n        selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));\n        break;\n      }\n    }\n\n    this._editor.setSelections(selections);\n  }\n\n  _executeEditorCommand(source, command) {\n    try {\n      this._ignoreModelContentChanged = true;\n\n      this._editor.pushUndoStop();\n\n      this._editor.executeCommand(source, command);\n\n      this._editor.pushUndoStop();\n    } finally {\n      this._ignoreModelContentChanged = false;\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findModel.js"],"names":["findFirstInSorted","RunOnceScheduler","TimeoutTimer","DisposableStore","dispose","ReplaceCommand","ReplaceCommandThatPreservesSelection","Position","Range","Selection","SearchParams","FindDecorations","ReplaceAllCommand","parseReplaceString","ReplacePattern","RawContextKey","CONTEXT_FIND_WIDGET_VISIBLE","CONTEXT_FIND_WIDGET_NOT_VISIBLE","toNegated","CONTEXT_FIND_INPUT_FOCUSED","CONTEXT_REPLACE_INPUT_FOCUSED","ToggleCaseSensitiveKeybinding","primary","mac","ToggleWholeWordKeybinding","ToggleRegexKeybinding","ToggleSearchScopeKeybinding","TogglePreserveCaseKeybinding","FIND_IDS","StartFindAction","StartFindWithSelection","StartFindWithArgs","NextMatchFindAction","PreviousMatchFindAction","NextSelectionMatchFindAction","PreviousSelectionMatchFindAction","StartFindReplaceAction","CloseFindWidgetCommand","ToggleCaseSensitiveCommand","ToggleWholeWordCommand","ToggleRegexCommand","ToggleSearchScopeCommand","TogglePreserveCaseCommand","ReplaceOneAction","ReplaceAllAction","SelectAllMatchesAction","MATCHES_LIMIT","RESEARCH_DELAY","FindModelBoundToEditorModel","constructor","editor","state","_toDispose","_editor","_state","_isDisposed","_startSearchingTimer","_decorations","add","_updateDecorationsScheduler","research","onDidChangeCursorPosition","e","reason","setStartPosition","getPosition","_ignoreModelContentChanged","onDidChangeModelContent","isFlush","reset","schedule","onFindReplaceStateChange","_onStateChanged","searchScope","hasModel","searchString","isReplaceRevealed","isRegex","wholeWord","matchCase","model","getModel","isTooLargeForSyncing","cancel","setIfNotSet","moveCursor","_getSearchRange","findScope","getFullModelRange","newFindScope","findScopes","Array","isArray","getFindScopes","map","startLineNumber","endLineNumber","endColumn","getLineMaxColumn","findMatches","_findMatches","set","editorSelection","getSelection","currentMatchesPosition","getCurrentMatchesPosition","length","matchAfterSelection","match","range","compareRangesUsingStarts","changeMatchInfo","getCount","undefined","getOption","cursorMoveOnType","_moveToNextMatch","getStartPosition","_hasMatches","matchesCount","_cannotFind","getFindScope","revealRangeInCenterIfOutsideViewport","_setCurrentFindMatch","matchesPosition","setCurrentFindMatch","setSelection","_prevSearchPosition","before","isUsingLineStops","indexOf","lineNumber","column","getLineCount","_moveToPrevMatch","isRecursed","canNavigateBack","nextMatchRange","matchAfterPosition","prevMatchRange","matchBeforePosition","isEmpty","equals","searchRange","getEndPosition","isBefore","position","prevMatch","findPreviousMatch","containsRange","moveToPrevMatch","_nextSearchPosition","after","canNavigateForward","nextMatch","_getNextMatch","captureMatches","forceMove","findNextMatch","moveToNextMatch","_getReplacePattern","replaceString","fromStaticValue","replace","replacePattern","selection","equalsRange","buildReplaceString","matches","preserveCase","command","_executeEditorCommand","startColumn","limitResultCount","searchRanges","scope","replaceAll","_largeReplaceAll","_regularReplaceAll","searchParams","searchData","parseSearchRequest","searchRegex","regex","multiline","mod","ignoreCase","global","RegExp","source","modelText","getValue","fullModelRange","resultText","hasReplacementPatterns","arguments","replaceStrings","i","len","m","selectAllMatches","selections","sel","concat","slice","setSelections","pushUndoStop","executeCommand"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findFirstInSorted } from '../../../../base/common/arrays.js';\nimport { RunOnceScheduler, TimeoutTimer } from '../../../../base/common/async.js';\nimport { DisposableStore, dispose } from '../../../../base/common/lifecycle.js';\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection } from '../../../common/commands/replaceCommand.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { SearchParams } from '../../../common/model/textModelSearch.js';\nimport { FindDecorations } from './findDecorations.js';\nimport { ReplaceAllCommand } from './replaceAllCommand.js';\nimport { parseReplaceString, ReplacePattern } from './replacePattern.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nexport const CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey('findWidgetVisible', false);\nexport const CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();\n// Keep ContextKey use of 'Focussed' to not break when clauses\nexport const CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey('findInputFocussed', false);\nexport const CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey('replaceInputFocussed', false);\nexport const ToggleCaseSensitiveKeybinding = {\n    primary: 512 /* Alt */ | 33 /* KeyC */,\n    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 33 /* KeyC */ }\n};\nexport const ToggleWholeWordKeybinding = {\n    primary: 512 /* Alt */ | 53 /* KeyW */,\n    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 53 /* KeyW */ }\n};\nexport const ToggleRegexKeybinding = {\n    primary: 512 /* Alt */ | 48 /* KeyR */,\n    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 48 /* KeyR */ }\n};\nexport const ToggleSearchScopeKeybinding = {\n    primary: 512 /* Alt */ | 42 /* KeyL */,\n    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 42 /* KeyL */ }\n};\nexport const TogglePreserveCaseKeybinding = {\n    primary: 512 /* Alt */ | 46 /* KeyP */,\n    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 46 /* KeyP */ }\n};\nexport const FIND_IDS = {\n    StartFindAction: 'actions.find',\n    StartFindWithSelection: 'actions.findWithSelection',\n    StartFindWithArgs: 'editor.actions.findWithArgs',\n    NextMatchFindAction: 'editor.action.nextMatchFindAction',\n    PreviousMatchFindAction: 'editor.action.previousMatchFindAction',\n    NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',\n    PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',\n    StartFindReplaceAction: 'editor.action.startFindReplaceAction',\n    CloseFindWidgetCommand: 'closeFindWidget',\n    ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',\n    ToggleWholeWordCommand: 'toggleFindWholeWord',\n    ToggleRegexCommand: 'toggleFindRegex',\n    ToggleSearchScopeCommand: 'toggleFindInSelection',\n    TogglePreserveCaseCommand: 'togglePreserveCase',\n    ReplaceOneAction: 'editor.action.replaceOne',\n    ReplaceAllAction: 'editor.action.replaceAll',\n    SelectAllMatchesAction: 'editor.action.selectAllMatches'\n};\nexport const MATCHES_LIMIT = 19999;\nconst RESEARCH_DELAY = 240;\nexport class FindModelBoundToEditorModel {\n    constructor(editor, state) {\n        this._toDispose = new DisposableStore();\n        this._editor = editor;\n        this._state = state;\n        this._isDisposed = false;\n        this._startSearchingTimer = new TimeoutTimer();\n        this._decorations = new FindDecorations(editor);\n        this._toDispose.add(this._decorations);\n        this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);\n        this._toDispose.add(this._updateDecorationsScheduler);\n        this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {\n            if (e.reason === 3 /* Explicit */\n                || e.reason === 5 /* Undo */\n                || e.reason === 6 /* Redo */) {\n                this._decorations.setStartPosition(this._editor.getPosition());\n            }\n        }));\n        this._ignoreModelContentChanged = false;\n        this._toDispose.add(this._editor.onDidChangeModelContent((e) => {\n            if (this._ignoreModelContentChanged) {\n                return;\n            }\n            if (e.isFlush) {\n                // a model.setValue() was called\n                this._decorations.reset();\n            }\n            this._decorations.setStartPosition(this._editor.getPosition());\n            this._updateDecorationsScheduler.schedule();\n        }));\n        this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));\n        this.research(false, this._state.searchScope);\n    }\n    dispose() {\n        this._isDisposed = true;\n        dispose(this._startSearchingTimer);\n        this._toDispose.dispose();\n    }\n    _onStateChanged(e) {\n        if (this._isDisposed) {\n            // The find model is disposed during a find state changed event\n            return;\n        }\n        if (!this._editor.hasModel()) {\n            // The find model will be disposed momentarily\n            return;\n        }\n        if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {\n            let model = this._editor.getModel();\n            if (model.isTooLargeForSyncing()) {\n                this._startSearchingTimer.cancel();\n                this._startSearchingTimer.setIfNotSet(() => {\n                    if (e.searchScope) {\n                        this.research(e.moveCursor, this._state.searchScope);\n                    }\n                    else {\n                        this.research(e.moveCursor);\n                    }\n                }, RESEARCH_DELAY);\n            }\n            else {\n                if (e.searchScope) {\n                    this.research(e.moveCursor, this._state.searchScope);\n                }\n                else {\n                    this.research(e.moveCursor);\n                }\n            }\n        }\n    }\n    static _getSearchRange(model, findScope) {\n        // If we have set now or before a find scope, use it for computing the search range\n        if (findScope) {\n            return findScope;\n        }\n        return model.getFullModelRange();\n    }\n    research(moveCursor, newFindScope) {\n        let findScopes = null;\n        if (typeof newFindScope !== 'undefined') {\n            if (newFindScope !== null) {\n                if (!Array.isArray(newFindScope)) {\n                    findScopes = [newFindScope];\n                }\n                else {\n                    findScopes = newFindScope;\n                }\n            }\n        }\n        else {\n            findScopes = this._decorations.getFindScopes();\n        }\n        if (findScopes !== null) {\n            findScopes = findScopes.map(findScope => {\n                if (findScope.startLineNumber !== findScope.endLineNumber) {\n                    let endLineNumber = findScope.endLineNumber;\n                    if (findScope.endColumn === 1) {\n                        endLineNumber = endLineNumber - 1;\n                    }\n                    return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));\n                }\n                return findScope;\n            });\n        }\n        let findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);\n        this._decorations.set(findMatches, findScopes);\n        const editorSelection = this._editor.getSelection();\n        let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);\n        if (currentMatchesPosition === 0 && findMatches.length > 0) {\n            // current selection is not on top of a match\n            // try to find its nearest result from the top of the document\n            const matchAfterSelection = findFirstInSorted(findMatches.map(match => match.range), range => Range.compareRangesUsingStarts(range, editorSelection) >= 0);\n            currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 /** match position is one based */ : currentMatchesPosition;\n        }\n        this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), undefined);\n        if (moveCursor && this._editor.getOption(35 /* find */).cursorMoveOnType) {\n            this._moveToNextMatch(this._decorations.getStartPosition());\n        }\n    }\n    _hasMatches() {\n        return (this._state.matchesCount > 0);\n    }\n    _cannotFind() {\n        if (!this._hasMatches()) {\n            let findScope = this._decorations.getFindScope();\n            if (findScope) {\n                // Reveal the selection so user is reminded that 'selection find' is on.\n                this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0 /* Smooth */);\n            }\n            return true;\n        }\n        return false;\n    }\n    _setCurrentFindMatch(match) {\n        let matchesPosition = this._decorations.setCurrentFindMatch(match);\n        this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);\n        this._editor.setSelection(match);\n        this._editor.revealRangeInCenterIfOutsideViewport(match, 0 /* Smooth */);\n    }\n    _prevSearchPosition(before) {\n        let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0\n            || this._state.searchString.indexOf('$') >= 0);\n        let { lineNumber, column } = before;\n        let model = this._editor.getModel();\n        if (isUsingLineStops || column === 1) {\n            if (lineNumber === 1) {\n                lineNumber = model.getLineCount();\n            }\n            else {\n                lineNumber--;\n            }\n            column = model.getLineMaxColumn(lineNumber);\n        }\n        else {\n            column--;\n        }\n        return new Position(lineNumber, column);\n    }\n    _moveToPrevMatch(before, isRecursed = false) {\n        if (!this._state.canNavigateBack()) {\n            // we are beyond the first matched find result\n            // instead of doing nothing, we should refocus the first item\n            const nextMatchRange = this._decorations.matchAfterPosition(before);\n            if (nextMatchRange) {\n                this._setCurrentFindMatch(nextMatchRange);\n            }\n            return;\n        }\n        if (this._decorations.getCount() < MATCHES_LIMIT) {\n            let prevMatchRange = this._decorations.matchBeforePosition(before);\n            if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {\n                before = this._prevSearchPosition(before);\n                prevMatchRange = this._decorations.matchBeforePosition(before);\n            }\n            if (prevMatchRange) {\n                this._setCurrentFindMatch(prevMatchRange);\n            }\n            return;\n        }\n        if (this._cannotFind()) {\n            return;\n        }\n        let findScope = this._decorations.getFindScope();\n        let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n        // ...(----)...|...\n        if (searchRange.getEndPosition().isBefore(before)) {\n            before = searchRange.getEndPosition();\n        }\n        // ...|...(----)...\n        if (before.isBefore(searchRange.getStartPosition())) {\n            before = searchRange.getEndPosition();\n        }\n        let { lineNumber, column } = before;\n        let model = this._editor.getModel();\n        let position = new Position(lineNumber, column);\n        let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117 /* wordSeparators */) : null, false);\n        if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {\n            // Looks like we're stuck at this position, unacceptable!\n            position = this._prevSearchPosition(position);\n            prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117 /* wordSeparators */) : null, false);\n        }\n        if (!prevMatch) {\n            // there is precisely one match and selection is on top of it\n            return;\n        }\n        if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {\n            return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);\n        }\n        this._setCurrentFindMatch(prevMatch.range);\n    }\n    moveToPrevMatch() {\n        this._moveToPrevMatch(this._editor.getSelection().getStartPosition());\n    }\n    _nextSearchPosition(after) {\n        let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0\n            || this._state.searchString.indexOf('$') >= 0);\n        let { lineNumber, column } = after;\n        let model = this._editor.getModel();\n        if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber === model.getLineCount()) {\n                lineNumber = 1;\n            }\n            else {\n                lineNumber++;\n            }\n            column = 1;\n        }\n        else {\n            column++;\n        }\n        return new Position(lineNumber, column);\n    }\n    _moveToNextMatch(after) {\n        if (!this._state.canNavigateForward()) {\n            // we are beyond the last matched find result\n            // instead of doing nothing, we should refocus the last item\n            const prevMatchRange = this._decorations.matchBeforePosition(after);\n            if (prevMatchRange) {\n                this._setCurrentFindMatch(prevMatchRange);\n            }\n            return;\n        }\n        if (this._decorations.getCount() < MATCHES_LIMIT) {\n            let nextMatchRange = this._decorations.matchAfterPosition(after);\n            if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {\n                // Looks like we're stuck at this position, unacceptable!\n                after = this._nextSearchPosition(after);\n                nextMatchRange = this._decorations.matchAfterPosition(after);\n            }\n            if (nextMatchRange) {\n                this._setCurrentFindMatch(nextMatchRange);\n            }\n            return;\n        }\n        let nextMatch = this._getNextMatch(after, false, true);\n        if (nextMatch) {\n            this._setCurrentFindMatch(nextMatch.range);\n        }\n    }\n    _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {\n        if (this._cannotFind()) {\n            return null;\n        }\n        let findScope = this._decorations.getFindScope();\n        let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n        // ...(----)...|...\n        if (searchRange.getEndPosition().isBefore(after)) {\n            after = searchRange.getStartPosition();\n        }\n        // ...|...(----)...\n        if (after.isBefore(searchRange.getStartPosition())) {\n            after = searchRange.getStartPosition();\n        }\n        let { lineNumber, column } = after;\n        let model = this._editor.getModel();\n        let position = new Position(lineNumber, column);\n        let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117 /* wordSeparators */) : null, captureMatches);\n        if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {\n            // Looks like we're stuck at this position, unacceptable!\n            position = this._nextSearchPosition(position);\n            nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117 /* wordSeparators */) : null, captureMatches);\n        }\n        if (!nextMatch) {\n            // there is precisely one match and selection is on top of it\n            return null;\n        }\n        if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {\n            return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);\n        }\n        return nextMatch;\n    }\n    moveToNextMatch() {\n        this._moveToNextMatch(this._editor.getSelection().getEndPosition());\n    }\n    _getReplacePattern() {\n        if (this._state.isRegex) {\n            return parseReplaceString(this._state.replaceString);\n        }\n        return ReplacePattern.fromStaticValue(this._state.replaceString);\n    }\n    replace() {\n        if (!this._hasMatches()) {\n            return;\n        }\n        let replacePattern = this._getReplacePattern();\n        let selection = this._editor.getSelection();\n        let nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);\n        if (nextMatch) {\n            if (selection.equalsRange(nextMatch.range)) {\n                // selection sits on a find match => replace it!\n                let replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);\n                let command = new ReplaceCommand(selection, replaceString);\n                this._executeEditorCommand('replace', command);\n                this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));\n                this.research(true);\n            }\n            else {\n                this._decorations.setStartPosition(this._editor.getPosition());\n                this._setCurrentFindMatch(nextMatch.range);\n            }\n        }\n    }\n    _findMatches(findScopes, captureMatches, limitResultCount) {\n        const searchRanges = (findScopes || [null]).map((scope) => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));\n        return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117 /* wordSeparators */) : null, captureMatches, limitResultCount);\n    }\n    replaceAll() {\n        if (!this._hasMatches()) {\n            return;\n        }\n        const findScopes = this._decorations.getFindScopes();\n        if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {\n            // Doing a replace on the entire file that is over ${MATCHES_LIMIT} matches\n            this._largeReplaceAll();\n        }\n        else {\n            this._regularReplaceAll(findScopes);\n        }\n        this.research(false);\n    }\n    _largeReplaceAll() {\n        const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(117 /* wordSeparators */) : null);\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return;\n        }\n        let searchRegex = searchData.regex;\n        if (!searchRegex.multiline) {\n            let mod = 'mu';\n            if (searchRegex.ignoreCase) {\n                mod += 'i';\n            }\n            if (searchRegex.global) {\n                mod += 'g';\n            }\n            searchRegex = new RegExp(searchRegex.source, mod);\n        }\n        const model = this._editor.getModel();\n        const modelText = model.getValue(1 /* LF */);\n        const fullModelRange = model.getFullModelRange();\n        const replacePattern = this._getReplacePattern();\n        let resultText;\n        const preserveCase = this._state.preserveCase;\n        if (replacePattern.hasReplacementPatterns || preserveCase) {\n            resultText = modelText.replace(searchRegex, function () {\n                return replacePattern.buildReplaceString(arguments, preserveCase);\n            });\n        }\n        else {\n            resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));\n        }\n        let command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());\n        this._executeEditorCommand('replaceAll', command);\n    }\n    _regularReplaceAll(findScopes) {\n        const replacePattern = this._getReplacePattern();\n        // Get all the ranges (even more than the highlighted ones)\n        let matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n        let replaceStrings = [];\n        for (let i = 0, len = matches.length; i < len; i++) {\n            replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);\n        }\n        let command = new ReplaceAllCommand(this._editor.getSelection(), matches.map(m => m.range), replaceStrings);\n        this._executeEditorCommand('replaceAll', command);\n    }\n    selectAllMatches() {\n        if (!this._hasMatches()) {\n            return;\n        }\n        let findScopes = this._decorations.getFindScopes();\n        // Get all the ranges (even more than the highlighted ones)\n        let matches = this._findMatches(findScopes, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n        let selections = matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));\n        // If one of the ranges is the editor selection, then maintain it as primary\n        let editorSelection = this._editor.getSelection();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let sel = selections[i];\n            if (sel.equalsRange(editorSelection)) {\n                selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));\n                break;\n            }\n        }\n        this._editor.setSelections(selections);\n    }\n    _executeEditorCommand(source, command) {\n        try {\n            this._ignoreModelContentChanged = true;\n            this._editor.pushUndoStop();\n            this._editor.executeCommand(source, command);\n            this._editor.pushUndoStop();\n        }\n        finally {\n            this._ignoreModelContentChanged = false;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}