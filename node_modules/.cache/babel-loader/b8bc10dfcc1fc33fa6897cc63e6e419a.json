{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\n\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { LineInjectedText } from '../../common/textModelEvents.js';\nimport { ModelLineProjectionData } from '../../common/viewModel/modelLineProjectionData.js';\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('domLineBreaksComputer', {\n  createHTML: value => value\n});\nexport class DOMLineBreaksComputerFactory {\n  static create() {\n    return new DOMLineBreaksComputerFactory();\n  }\n\n  constructor() {}\n\n  createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n    const requests = [];\n    const injectedTexts = [];\n    return {\n      addRequest: (lineText, injectedText, previousLineBreakData) => {\n        requests.push(lineText);\n        injectedTexts.push(injectedText);\n      },\n      finalize: () => {\n        return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent, injectedTexts);\n      }\n    };\n  }\n\n}\n\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent, injectedTextsPerLine) {\n  var _a;\n\n  function createEmptyLineBreakWithPossiblyInjectedText(requestIdx) {\n    const injectedTexts = injectedTextsPerLine[requestIdx];\n\n    if (injectedTexts) {\n      const lineText = LineInjectedText.applyInjectedText(requests[requestIdx], injectedTexts);\n      const injectionOptions = injectedTexts.map(t => t.options);\n      const injectionOffsets = injectedTexts.map(text => text.column - 1); // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n      // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n\n      return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    } else {\n      return null;\n    }\n  }\n\n  if (firstLineBreakColumn === -1) {\n    const result = [];\n\n    for (let i = 0, len = requests.length; i < len; i++) {\n      result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n    }\n\n    return result;\n  }\n\n  const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n  const additionalIndent = wrappingIndent === 3\n  /* DeepIndent */\n  ? 2 : wrappingIndent === 2\n  /* Indent */\n  ? 1 : 0;\n  const additionalIndentSize = Math.round(tabSize * additionalIndent);\n  const additionalIndentLength = Math.ceil(fontInfo.spaceWidth * additionalIndentSize);\n  const containerDomNode = document.createElement('div');\n  applyFontInfo(containerDomNode, fontInfo);\n  const sb = createStringBuilder(10000);\n  const firstNonWhitespaceIndices = [];\n  const wrappedTextIndentLengths = [];\n  const renderLineContents = [];\n  const allCharOffsets = [];\n  const allVisibleColumns = [];\n\n  for (let i = 0; i < requests.length; i++) {\n    const lineContent = LineInjectedText.applyInjectedText(requests[i], injectedTextsPerLine[i]);\n    let firstNonWhitespaceIndex = 0;\n    let wrappedTextIndentLength = 0;\n    let width = overallWidth;\n\n    if (wrappingIndent !== 0\n    /* None */\n    ) {\n      firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\n      if (firstNonWhitespaceIndex === -1) {\n        // all whitespace line\n        firstNonWhitespaceIndex = 0;\n      } else {\n        // Track existing indent\n        for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n          const charWidth = lineContent.charCodeAt(i) === 9\n          /* Tab */\n          ? tabSize - wrappedTextIndentLength % tabSize : 1;\n          wrappedTextIndentLength += charWidth;\n        }\n\n        const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength); // Force sticking to beginning of line if no character would fit except for the indentation\n\n        if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n          firstNonWhitespaceIndex = 0;\n          wrappedTextIndentLength = 0;\n        } else {\n          width = overallWidth - indentWidth;\n        }\n      }\n    }\n\n    const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n    const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb, additionalIndentLength);\n    firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n    wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n    renderLineContents[i] = renderLineContent;\n    allCharOffsets[i] = tmp[0];\n    allVisibleColumns[i] = tmp[1];\n  }\n\n  const html = sb.build();\n  const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n  containerDomNode.innerHTML = trustedhtml;\n  containerDomNode.style.position = 'absolute';\n  containerDomNode.style.top = '10000';\n  containerDomNode.style.wordWrap = 'break-word';\n  document.body.appendChild(containerDomNode);\n  const range = document.createRange();\n  const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n  const result = [];\n\n  for (let i = 0; i < requests.length; i++) {\n    const lineDomNode = lineDomNodes[i];\n    const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n\n    if (breakOffsets === null) {\n      result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n      continue;\n    }\n\n    const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n    const wrappedTextIndentLength = wrappedTextIndentLengths[i] + additionalIndentSize;\n    const visibleColumns = allVisibleColumns[i];\n    const breakOffsetsVisibleColumn = [];\n\n    for (let j = 0, len = breakOffsets.length; j < len; j++) {\n      breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n    }\n\n    if (firstNonWhitespaceIndex !== 0) {\n      // All break offsets are relative to the renderLineContent, make them absolute again\n      for (let j = 0, len = breakOffsets.length; j < len; j++) {\n        breakOffsets[j] += firstNonWhitespaceIndex;\n      }\n    }\n\n    let injectionOptions;\n    let injectionOffsets;\n    const curInjectedTexts = injectedTextsPerLine[i];\n\n    if (curInjectedTexts) {\n      injectionOptions = curInjectedTexts.map(t => t.options);\n      injectionOffsets = curInjectedTexts.map(text => text.column - 1);\n    } else {\n      injectionOptions = null;\n      injectionOffsets = null;\n    }\n\n    result[i] = new ModelLineProjectionData(injectionOffsets, injectionOptions, breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\n  }\n\n  document.body.removeChild(containerDomNode);\n  return result;\n}\n\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb, wrappingIndentLength) {\n  if (wrappingIndentLength !== 0) {\n    const hangingOffset = String(wrappingIndentLength);\n    sb.appendASCIIString('<div style=\"text-indent: -');\n    sb.appendASCIIString(hangingOffset);\n    sb.appendASCIIString('px; padding-left: ');\n    sb.appendASCIIString(hangingOffset);\n    sb.appendASCIIString('px; box-sizing: border-box; width:');\n  } else {\n    sb.appendASCIIString('<div style=\"width:');\n  }\n\n  sb.appendASCIIString(String(width));\n  sb.appendASCIIString('px;\">'); // if (containsRTL) {\n  // \tsb.appendASCIIString('\" dir=\"ltr');\n  // }\n\n  const len = lineContent.length;\n  let visibleColumn = initialVisibleColumn;\n  let charOffset = 0;\n  const charOffsets = [];\n  const visibleColumns = [];\n  let nextCharCode = 0 < len ? lineContent.charCodeAt(0) : 0\n  /* Null */\n  ;\n  sb.appendASCIIString('<span>');\n\n  for (let charIndex = 0; charIndex < len; charIndex++) {\n    if (charIndex !== 0 && charIndex % 16384\n    /* SPAN_MODULO_LIMIT */\n    === 0) {\n      sb.appendASCIIString('</span><span>');\n    }\n\n    charOffsets[charIndex] = charOffset;\n    visibleColumns[charIndex] = visibleColumn;\n    const charCode = nextCharCode;\n    nextCharCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0\n    /* Null */\n    ;\n    let producedCharacters = 1;\n    let charWidth = 1;\n\n    switch (charCode) {\n      case 9\n      /* Tab */\n      :\n        producedCharacters = tabSize - visibleColumn % tabSize;\n        charWidth = producedCharacters;\n\n        for (let space = 1; space <= producedCharacters; space++) {\n          if (space < producedCharacters) {\n            sb.write1(0xA0); // &nbsp;\n          } else {\n            sb.appendASCII(32\n            /* Space */\n            );\n          }\n        }\n\n        break;\n\n      case 32\n      /* Space */\n      :\n        if (nextCharCode === 32\n        /* Space */\n        ) {\n          sb.write1(0xA0); // &nbsp;\n        } else {\n          sb.appendASCII(32\n          /* Space */\n          );\n        }\n\n        break;\n\n      case 60\n      /* LessThan */\n      :\n        sb.appendASCIIString('&lt;');\n        break;\n\n      case 62\n      /* GreaterThan */\n      :\n        sb.appendASCIIString('&gt;');\n        break;\n\n      case 38\n      /* Ampersand */\n      :\n        sb.appendASCIIString('&amp;');\n        break;\n\n      case 0\n      /* Null */\n      :\n        sb.appendASCIIString('&#00;');\n        break;\n\n      case 65279\n      /* UTF8_BOM */\n      :\n      case 8232\n      /* LINE_SEPARATOR */\n      :\n      case 8233\n      /* PARAGRAPH_SEPARATOR */\n      :\n      case 133\n      /* NEXT_LINE */\n      :\n        sb.write1(0xFFFD);\n        break;\n\n      default:\n        if (strings.isFullWidthCharacter(charCode)) {\n          charWidth++;\n        }\n\n        if (charCode < 32) {\n          sb.write1(9216 + charCode);\n        } else {\n          sb.write1(charCode);\n        }\n\n    }\n\n    charOffset += producedCharacters;\n    visibleColumn += charWidth;\n  }\n\n  sb.appendASCIIString('</span>');\n  charOffsets[lineContent.length] = charOffset;\n  visibleColumns[lineContent.length] = visibleColumn;\n  sb.appendASCIIString('</div>');\n  return [charOffsets, visibleColumns];\n}\n\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n  if (lineContent.length <= 1) {\n    return null;\n  }\n\n  const spans = Array.prototype.slice.call(lineDomNode.children, 0);\n  const breakOffsets = [];\n\n  try {\n    discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n  } catch (err) {\n    console.log(err);\n    return null;\n  }\n\n  if (breakOffsets.length === 0) {\n    return null;\n  }\n\n  breakOffsets.push(lineContent.length);\n  return breakOffsets;\n}\n\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n  if (low === high) {\n    return;\n  }\n\n  lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n  highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n\n  if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n    // same line\n    return;\n  } // there is at least one line break between these two offsets\n\n\n  if (low + 1 === high) {\n    // the two characters are adjacent, so the line break must be exactly between them\n    result.push(high);\n    return;\n  }\n\n  const mid = low + (high - low) / 2 | 0;\n  const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n  discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n  discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\n\nfunction readClientRect(range, spans, startOffset, endOffset) {\n  range.setStart(spans[startOffset / 16384\n  /* SPAN_MODULO_LIMIT */\n  | 0].firstChild, startOffset % 16384\n  /* SPAN_MODULO_LIMIT */\n  );\n  range.setEnd(spans[endOffset / 16384\n  /* SPAN_MODULO_LIMIT */\n  | 0].firstChild, endOffset % 16384\n  /* SPAN_MODULO_LIMIT */\n  );\n  return range.getClientRects();\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/browser/view/domLineBreaksComputer.js"],"names":["_a","createStringBuilder","strings","applyFontInfo","LineInjectedText","ModelLineProjectionData","ttPolicy","window","trustedTypes","createPolicy","createHTML","value","DOMLineBreaksComputerFactory","create","constructor","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","requests","injectedTexts","addRequest","lineText","injectedText","previousLineBreakData","push","finalize","createLineBreaks","firstLineBreakColumn","injectedTextsPerLine","createEmptyLineBreakWithPossiblyInjectedText","requestIdx","applyInjectedText","injectionOptions","map","t","options","injectionOffsets","text","column","length","result","i","len","overallWidth","Math","round","typicalHalfwidthCharacterWidth","additionalIndent","additionalIndentSize","additionalIndentLength","ceil","spaceWidth","containerDomNode","document","createElement","sb","firstNonWhitespaceIndices","wrappedTextIndentLengths","renderLineContents","allCharOffsets","allVisibleColumns","lineContent","firstNonWhitespaceIndex","wrappedTextIndentLength","width","charWidth","charCodeAt","indentWidth","typicalFullwidthCharacterWidth","renderLineContent","substr","tmp","renderLine","html","build","trustedhtml","innerHTML","style","position","top","wordWrap","body","appendChild","range","createRange","lineDomNodes","Array","prototype","slice","call","children","lineDomNode","breakOffsets","readLineBreaks","visibleColumns","breakOffsetsVisibleColumn","j","curInjectedTexts","removeChild","initialVisibleColumn","wrappingIndentLength","hangingOffset","String","appendASCIIString","visibleColumn","charOffset","charOffsets","nextCharCode","charIndex","charCode","producedCharacters","space","write1","appendASCII","isFullWidthCharacter","spans","discoverBreaks","err","console","log","low","lowRects","high","highRects","readClientRect","abs","mid","midRects","startOffset","endOffset","setStart","firstChild","setEnd","getClientRects"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { LineInjectedText } from '../../common/textModelEvents.js';\nimport { ModelLineProjectionData } from '../../common/viewModel/modelLineProjectionData.js';\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('domLineBreaksComputer', { createHTML: value => value });\nexport class DOMLineBreaksComputerFactory {\n    static create() {\n        return new DOMLineBreaksComputerFactory();\n    }\n    constructor() {\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n        const requests = [];\n        const injectedTexts = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n            },\n            finalize: () => {\n                return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent, injectedTexts);\n            }\n        };\n    }\n}\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent, injectedTextsPerLine) {\n    var _a;\n    function createEmptyLineBreakWithPossiblyInjectedText(requestIdx) {\n        const injectedTexts = injectedTextsPerLine[requestIdx];\n        if (injectedTexts) {\n            const lineText = LineInjectedText.applyInjectedText(requests[requestIdx], injectedTexts);\n            const injectionOptions = injectedTexts.map(t => t.options);\n            const injectionOffsets = injectedTexts.map(text => text.column - 1);\n            // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n            // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n            return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n        }\n        else {\n            return null;\n        }\n    }\n    if (firstLineBreakColumn === -1) {\n        const result = [];\n        for (let i = 0, len = requests.length; i < len; i++) {\n            result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n        }\n        return result;\n    }\n    const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n    const additionalIndent = (wrappingIndent === 3 /* DeepIndent */ ? 2 : wrappingIndent === 2 /* Indent */ ? 1 : 0);\n    const additionalIndentSize = Math.round(tabSize * additionalIndent);\n    const additionalIndentLength = Math.ceil(fontInfo.spaceWidth * additionalIndentSize);\n    const containerDomNode = document.createElement('div');\n    applyFontInfo(containerDomNode, fontInfo);\n    const sb = createStringBuilder(10000);\n    const firstNonWhitespaceIndices = [];\n    const wrappedTextIndentLengths = [];\n    const renderLineContents = [];\n    const allCharOffsets = [];\n    const allVisibleColumns = [];\n    for (let i = 0; i < requests.length; i++) {\n        const lineContent = LineInjectedText.applyInjectedText(requests[i], injectedTextsPerLine[i]);\n        let firstNonWhitespaceIndex = 0;\n        let wrappedTextIndentLength = 0;\n        let width = overallWidth;\n        if (wrappingIndent !== 0 /* None */) {\n            firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            if (firstNonWhitespaceIndex === -1) {\n                // all whitespace line\n                firstNonWhitespaceIndex = 0;\n            }\n            else {\n                // Track existing indent\n                for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                    const charWidth = (lineContent.charCodeAt(i) === 9 /* Tab */\n                        ? (tabSize - (wrappedTextIndentLength % tabSize))\n                        : 1);\n                    wrappedTextIndentLength += charWidth;\n                }\n                const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\n                // Force sticking to beginning of line if no character would fit except for the indentation\n                if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n                    firstNonWhitespaceIndex = 0;\n                    wrappedTextIndentLength = 0;\n                }\n                else {\n                    width = overallWidth - indentWidth;\n                }\n            }\n        }\n        const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n        const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb, additionalIndentLength);\n        firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n        wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n        renderLineContents[i] = renderLineContent;\n        allCharOffsets[i] = tmp[0];\n        allVisibleColumns[i] = tmp[1];\n    }\n    const html = sb.build();\n    const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n    containerDomNode.innerHTML = trustedhtml;\n    containerDomNode.style.position = 'absolute';\n    containerDomNode.style.top = '10000';\n    containerDomNode.style.wordWrap = 'break-word';\n    document.body.appendChild(containerDomNode);\n    const range = document.createRange();\n    const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n    const result = [];\n    for (let i = 0; i < requests.length; i++) {\n        const lineDomNode = lineDomNodes[i];\n        const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n        if (breakOffsets === null) {\n            result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n            continue;\n        }\n        const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n        const wrappedTextIndentLength = wrappedTextIndentLengths[i] + additionalIndentSize;\n        const visibleColumns = allVisibleColumns[i];\n        const breakOffsetsVisibleColumn = [];\n        for (let j = 0, len = breakOffsets.length; j < len; j++) {\n            breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n        }\n        if (firstNonWhitespaceIndex !== 0) {\n            // All break offsets are relative to the renderLineContent, make them absolute again\n            for (let j = 0, len = breakOffsets.length; j < len; j++) {\n                breakOffsets[j] += firstNonWhitespaceIndex;\n            }\n        }\n        let injectionOptions;\n        let injectionOffsets;\n        const curInjectedTexts = injectedTextsPerLine[i];\n        if (curInjectedTexts) {\n            injectionOptions = curInjectedTexts.map(t => t.options);\n            injectionOffsets = curInjectedTexts.map(text => text.column - 1);\n        }\n        else {\n            injectionOptions = null;\n            injectionOffsets = null;\n        }\n        result[i] = new ModelLineProjectionData(injectionOffsets, injectionOptions, breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\n    }\n    document.body.removeChild(containerDomNode);\n    return result;\n}\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb, wrappingIndentLength) {\n    if (wrappingIndentLength !== 0) {\n        const hangingOffset = String(wrappingIndentLength);\n        sb.appendASCIIString('<div style=\"text-indent: -');\n        sb.appendASCIIString(hangingOffset);\n        sb.appendASCIIString('px; padding-left: ');\n        sb.appendASCIIString(hangingOffset);\n        sb.appendASCIIString('px; box-sizing: border-box; width:');\n    }\n    else {\n        sb.appendASCIIString('<div style=\"width:');\n    }\n    sb.appendASCIIString(String(width));\n    sb.appendASCIIString('px;\">');\n    // if (containsRTL) {\n    // \tsb.appendASCIIString('\" dir=\"ltr');\n    // }\n    const len = lineContent.length;\n    let visibleColumn = initialVisibleColumn;\n    let charOffset = 0;\n    const charOffsets = [];\n    const visibleColumns = [];\n    let nextCharCode = (0 < len ? lineContent.charCodeAt(0) : 0 /* Null */);\n    sb.appendASCIIString('<span>');\n    for (let charIndex = 0; charIndex < len; charIndex++) {\n        if (charIndex !== 0 && charIndex % 16384 /* SPAN_MODULO_LIMIT */ === 0) {\n            sb.appendASCIIString('</span><span>');\n        }\n        charOffsets[charIndex] = charOffset;\n        visibleColumns[charIndex] = visibleColumn;\n        const charCode = nextCharCode;\n        nextCharCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\n        let producedCharacters = 1;\n        let charWidth = 1;\n        switch (charCode) {\n            case 9 /* Tab */:\n                producedCharacters = (tabSize - (visibleColumn % tabSize));\n                charWidth = producedCharacters;\n                for (let space = 1; space <= producedCharacters; space++) {\n                    if (space < producedCharacters) {\n                        sb.write1(0xA0); // &nbsp;\n                    }\n                    else {\n                        sb.appendASCII(32 /* Space */);\n                    }\n                }\n                break;\n            case 32 /* Space */:\n                if (nextCharCode === 32 /* Space */) {\n                    sb.write1(0xA0); // &nbsp;\n                }\n                else {\n                    sb.appendASCII(32 /* Space */);\n                }\n                break;\n            case 60 /* LessThan */:\n                sb.appendASCIIString('&lt;');\n                break;\n            case 62 /* GreaterThan */:\n                sb.appendASCIIString('&gt;');\n                break;\n            case 38 /* Ampersand */:\n                sb.appendASCIIString('&amp;');\n                break;\n            case 0 /* Null */:\n                sb.appendASCIIString('&#00;');\n                break;\n            case 65279 /* UTF8_BOM */:\n            case 8232 /* LINE_SEPARATOR */:\n            case 8233 /* PARAGRAPH_SEPARATOR */:\n            case 133 /* NEXT_LINE */:\n                sb.write1(0xFFFD);\n                break;\n            default:\n                if (strings.isFullWidthCharacter(charCode)) {\n                    charWidth++;\n                }\n                if (charCode < 32) {\n                    sb.write1(9216 + charCode);\n                }\n                else {\n                    sb.write1(charCode);\n                }\n        }\n        charOffset += producedCharacters;\n        visibleColumn += charWidth;\n    }\n    sb.appendASCIIString('</span>');\n    charOffsets[lineContent.length] = charOffset;\n    visibleColumns[lineContent.length] = visibleColumn;\n    sb.appendASCIIString('</div>');\n    return [charOffsets, visibleColumns];\n}\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n    if (lineContent.length <= 1) {\n        return null;\n    }\n    const spans = Array.prototype.slice.call(lineDomNode.children, 0);\n    const breakOffsets = [];\n    try {\n        discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n    }\n    catch (err) {\n        console.log(err);\n        return null;\n    }\n    if (breakOffsets.length === 0) {\n        return null;\n    }\n    breakOffsets.push(lineContent.length);\n    return breakOffsets;\n}\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n    if (low === high) {\n        return;\n    }\n    lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n    highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n    if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n        // same line\n        return;\n    }\n    // there is at least one line break between these two offsets\n    if (low + 1 === high) {\n        // the two characters are adjacent, so the line break must be exactly between them\n        result.push(high);\n        return;\n    }\n    const mid = low + ((high - low) / 2) | 0;\n    const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n    discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n    discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\nfunction readClientRect(range, spans, startOffset, endOffset) {\n    range.setStart(spans[(startOffset / 16384 /* SPAN_MODULO_LIMIT */) | 0].firstChild, startOffset % 16384 /* SPAN_MODULO_LIMIT */);\n    range.setEnd(spans[(endOffset / 16384 /* SPAN_MODULO_LIMIT */) | 0].firstChild, endOffset % 16384 /* SPAN_MODULO_LIMIT */);\n    return range.getClientRects();\n}\n"]},"metadata":{},"sourceType":"module"}