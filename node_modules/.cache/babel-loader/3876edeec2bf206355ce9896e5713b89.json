{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nexport class PieceTreeTextBufferFactory {\n  constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n    this._chunks = _chunks;\n    this._bom = _bom;\n    this._cr = _cr;\n    this._lf = _lf;\n    this._crlf = _crlf;\n    this._containsRTL = _containsRTL;\n    this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n    this._isBasicASCII = _isBasicASCII;\n    this._normalizeEOL = _normalizeEOL;\n  }\n\n  _getEOL(defaultEOL) {\n    const totalEOLCount = this._cr + this._lf + this._crlf;\n    const totalCRCount = this._cr + this._crlf;\n\n    if (totalEOLCount === 0) {\n      // This is an empty file or a file with precisely one line\n      return defaultEOL === 1\n      /* LF */\n      ? '\\n' : '\\r\\n';\n    }\n\n    if (totalCRCount > totalEOLCount / 2) {\n      // More than half of the file contains \\r\\n ending lines\n      return '\\r\\n';\n    } // At least one line more ends in \\n\n\n\n    return '\\n';\n  }\n\n  create(defaultEOL) {\n    const eol = this._getEOL(defaultEOL);\n\n    const chunks = this._chunks;\n\n    if (this._normalizeEOL && (eol === '\\r\\n' && (this._cr > 0 || this._lf > 0) || eol === '\\n' && (this._cr > 0 || this._crlf > 0))) {\n      // Normalize pieces\n      for (let i = 0, len = chunks.length; i < len; i++) {\n        const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n        const newLineStart = createLineStartsFast(str);\n        chunks[i] = new StringBuffer(str, newLineStart);\n      }\n    }\n\n    const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n    return {\n      textBuffer: textBuffer,\n      disposable: textBuffer\n    };\n  }\n\n}\nexport class PieceTreeTextBufferBuilder {\n  constructor() {\n    this.chunks = [];\n    this.BOM = '';\n    this._hasPreviousChar = false;\n    this._previousChar = 0;\n    this._tmpLineStarts = [];\n    this.cr = 0;\n    this.lf = 0;\n    this.crlf = 0;\n    this.containsRTL = false;\n    this.containsUnusualLineTerminators = false;\n    this.isBasicASCII = true;\n  }\n\n  acceptChunk(chunk) {\n    if (chunk.length === 0) {\n      return;\n    }\n\n    if (this.chunks.length === 0) {\n      if (strings.startsWithUTF8BOM(chunk)) {\n        this.BOM = strings.UTF8_BOM_CHARACTER;\n        chunk = chunk.substr(1);\n      }\n    }\n\n    const lastChar = chunk.charCodeAt(chunk.length - 1);\n\n    if (lastChar === 13\n    /* CarriageReturn */\n    || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n      // last character is \\r or a high surrogate => keep it back\n      this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n\n      this._hasPreviousChar = true;\n      this._previousChar = lastChar;\n    } else {\n      this._acceptChunk1(chunk, false);\n\n      this._hasPreviousChar = false;\n      this._previousChar = lastChar;\n    }\n  }\n\n  _acceptChunk1(chunk, allowEmptyStrings) {\n    if (!allowEmptyStrings && chunk.length === 0) {\n      // Nothing to do\n      return;\n    }\n\n    if (this._hasPreviousChar) {\n      this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n    } else {\n      this._acceptChunk2(chunk);\n    }\n  }\n\n  _acceptChunk2(chunk) {\n    const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n    this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n    this.cr += lineStarts.cr;\n    this.lf += lineStarts.lf;\n    this.crlf += lineStarts.crlf;\n\n    if (this.isBasicASCII) {\n      this.isBasicASCII = lineStarts.isBasicASCII;\n    }\n\n    if (!this.isBasicASCII && !this.containsRTL) {\n      // No need to check if it is basic ASCII\n      this.containsRTL = strings.containsRTL(chunk);\n    }\n\n    if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\n      // No need to check if it is basic ASCII\n      this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n    }\n  }\n\n  finish(normalizeEOL = true) {\n    this._finish();\n\n    return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n  }\n\n  _finish() {\n    if (this.chunks.length === 0) {\n      this._acceptChunk1('', true);\n    }\n\n    if (this._hasPreviousChar) {\n      this._hasPreviousChar = false; // recreate last chunk\n\n      const lastChunk = this.chunks[this.chunks.length - 1];\n      lastChunk.buffer += String.fromCharCode(this._previousChar);\n      const newLineStarts = createLineStartsFast(lastChunk.buffer);\n      lastChunk.lineStarts = newLineStarts;\n\n      if (this._previousChar === 13\n      /* CarriageReturn */\n      ) {\n        this.cr++;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js"],"names":["strings","StringBuffer","createLineStarts","createLineStartsFast","PieceTreeTextBuffer","PieceTreeTextBufferFactory","constructor","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","_getEOL","defaultEOL","totalEOLCount","totalCRCount","create","eol","chunks","i","len","length","str","buffer","replace","newLineStart","textBuffer","disposable","PieceTreeTextBufferBuilder","BOM","_hasPreviousChar","_previousChar","_tmpLineStarts","cr","lf","crlf","containsRTL","containsUnusualLineTerminators","isBasicASCII","acceptChunk","chunk","startsWithUTF8BOM","UTF8_BOM_CHARACTER","substr","lastChar","charCodeAt","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","lineStarts","push","finish","normalizeEOL","_finish","lastChunk","newLineStarts"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nexport class PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (this.isBasicASCII) {\n            this.isBasicASCII = lineStarts.isBasicASCII;\n        }\n        if (!this.isBasicASCII && !this.containsRTL) {\n            // No need to check if it is basic ASCII\n            this.containsRTL = strings.containsRTL(chunk);\n        }\n        if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\n            // No need to check if it is basic ASCII\n            this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}