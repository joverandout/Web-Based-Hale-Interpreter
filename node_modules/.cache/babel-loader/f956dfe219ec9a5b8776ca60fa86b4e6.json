{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\n\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n  const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n  return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\n\nclass Parser {\n  constructor(tokenizer, edits, oldNode, createImmutableLists) {\n    this.tokenizer = tokenizer;\n    this.createImmutableLists = createImmutableLists;\n    this._itemsConstructed = 0;\n    this._itemsFromCache = 0;\n\n    if (oldNode && createImmutableLists) {\n      throw new Error('Not supported');\n    }\n\n    this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n    this.positionMapper = new BeforeEditPositionMapper(edits, tokenizer.length);\n  }\n\n  parseDocument() {\n    this._itemsConstructed = 0;\n    this._itemsFromCache = 0;\n    let result = this.parseList(SmallImmutableSet.getEmpty());\n\n    if (!result) {\n      result = ListAstNode.getEmpty();\n    }\n\n    return result;\n  }\n\n  parseList(openedBracketIds) {\n    const items = new Array();\n\n    while (true) {\n      const token = this.tokenizer.peek();\n\n      if (!token || token.kind === 2\n      /* ClosingBracket */\n      && token.bracketIds.intersects(openedBracketIds)) {\n        break;\n      }\n\n      const child = this.parseChild(openedBracketIds);\n\n      if (child.kind === 4\n      /* List */\n      && child.childrenLength === 0) {\n        continue;\n      }\n\n      items.push(child);\n    } // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n\n\n    const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n    return result;\n  }\n\n  parseChild(openedBracketIds) {\n    if (this.oldNodeReader) {\n      const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n\n      if (!lengthIsZero(maxCacheableLength)) {\n        const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n          if (!lengthLessThan(curNode.length, maxCacheableLength)) {\n            // Either the node contains edited text or touches edited text.\n            // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n            return false;\n          }\n\n          const canBeReused = curNode.canBeReused(openedBracketIds);\n          return canBeReused;\n        });\n\n        if (cachedNode) {\n          this._itemsFromCache++;\n          this.tokenizer.skip(cachedNode.length);\n          return cachedNode;\n        }\n      }\n    }\n\n    this._itemsConstructed++;\n    const token = this.tokenizer.read();\n\n    switch (token.kind) {\n      case 2\n      /* ClosingBracket */\n      :\n        return new InvalidBracketAstNode(token.bracketIds, token.length);\n\n      case 0\n      /* Text */\n      :\n        return token.astNode;\n\n      case 1\n      /* OpeningBracket */\n      :\n        {\n          const set = openedBracketIds.merge(token.bracketIds);\n          const child = this.parseList(set);\n          const nextToken = this.tokenizer.peek();\n\n          if (nextToken && nextToken.kind === 2\n          /* ClosingBracket */\n          && (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n            this.tokenizer.read();\n            return PairAstNode.create(token.astNode, child, nextToken.astNode);\n          } else {\n            return PairAstNode.create(token.astNode, child, null);\n          }\n        }\n\n      default:\n        throw new Error('unexpected');\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js"],"names":["InvalidBracketAstNode","ListAstNode","PairAstNode","BeforeEditPositionMapper","SmallImmutableSet","lengthIsZero","lengthLessThan","concat23Trees","concat23TreesOfSameHeight","NodeReader","parseDocument","tokenizer","edits","oldNode","createImmutableLists","parser","Parser","constructor","_itemsConstructed","_itemsFromCache","Error","oldNodeReader","undefined","positionMapper","length","result","parseList","getEmpty","openedBracketIds","items","Array","token","peek","kind","bracketIds","intersects","child","parseChild","childrenLength","push","maxCacheableLength","getDistanceToNextChange","offset","cachedNode","readLongestNodeAt","getOffsetBeforeChange","curNode","canBeReused","skip","read","astNode","set","merge","nextToken","bracketId","create"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits, tokenizer.length);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty());\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds) {\n        const items = new Array();\n        while (true) {\n            const token = this.tokenizer.peek();\n            if (!token ||\n                (token.kind === 2 /* ClosingBracket */ &&\n                    token.bracketIds.intersects(openedBracketIds))) {\n                break;\n            }\n            const child = this.parseChild(openedBracketIds);\n            if (child.kind === 4 /* List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    parseChild(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (!lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    if (!lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* Text */:\n                return token.astNode;\n            case 1 /* OpeningBracket */: {\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}