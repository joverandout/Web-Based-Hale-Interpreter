{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullMode.js';\nconst fallback = {\n  getInitialState: () => NullState,\n  tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0\n  /* Null */\n  , state)\n};\nexport function tokenizeToString(languageService, text, languageId) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!languageId) {\n      return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n    }\n\n    const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);\n    return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n  });\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n  let result = `<div>`;\n  let charIndex = startOffset;\n  let tabsCharDelta = 0;\n  let prevIsSpace = true;\n\n  for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n    const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n\n    if (tokenEndIndex <= startOffset) {\n      continue;\n    }\n\n    let partContent = '';\n\n    for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n      const charCode = text.charCodeAt(charIndex);\n\n      switch (charCode) {\n        case 9\n        /* Tab */\n        :\n          {\n            let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n            tabsCharDelta += insertSpacesCount - 1;\n\n            while (insertSpacesCount > 0) {\n              if (useNbsp && prevIsSpace) {\n                partContent += '&#160;';\n                prevIsSpace = false;\n              } else {\n                partContent += ' ';\n                prevIsSpace = true;\n              }\n\n              insertSpacesCount--;\n            }\n\n            break;\n          }\n\n        case 60\n        /* LessThan */\n        :\n          partContent += '&lt;';\n          prevIsSpace = false;\n          break;\n\n        case 62\n        /* GreaterThan */\n        :\n          partContent += '&gt;';\n          prevIsSpace = false;\n          break;\n\n        case 38\n        /* Ampersand */\n        :\n          partContent += '&amp;';\n          prevIsSpace = false;\n          break;\n\n        case 0\n        /* Null */\n        :\n          partContent += '&#00;';\n          prevIsSpace = false;\n          break;\n\n        case 65279\n        /* UTF8_BOM */\n        :\n        case 8232\n        /* LINE_SEPARATOR */\n        :\n        case 8233\n        /* PARAGRAPH_SEPARATOR */\n        :\n        case 133\n        /* NEXT_LINE */\n        :\n          partContent += '\\ufffd';\n          prevIsSpace = false;\n          break;\n\n        case 13\n        /* CarriageReturn */\n        :\n          // zero width space, because carriage return would introduce a line break\n          partContent += '&#8203';\n          prevIsSpace = false;\n          break;\n\n        case 32\n        /* Space */\n        :\n          if (useNbsp && prevIsSpace) {\n            partContent += '&#160;';\n            prevIsSpace = false;\n          } else {\n            partContent += ' ';\n            prevIsSpace = true;\n          }\n\n          break;\n\n        default:\n          partContent += String.fromCharCode(charCode);\n          prevIsSpace = false;\n      }\n    }\n\n    result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n\n    if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n      break;\n    }\n  }\n\n  result += `</div>`;\n  return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n  let result = `<div class=\"monaco-tokenized-source\">`;\n  const lines = strings.splitLines(text);\n  let currentState = tokenizationSupport.getInitialState();\n\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const line = lines[i];\n\n    if (i > 0) {\n      result += `<br/>`;\n    }\n\n    const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n    LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n    const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n    const viewLineTokens = lineTokens.inflate();\n    let startOffset = 0;\n\n    for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n      const type = viewLineTokens.getClassName(j);\n      const endIndex = viewLineTokens.getEndOffset(j);\n      result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n      startOffset = endIndex;\n    }\n\n    currentState = tokenizationResult.endState;\n  }\n\n  result += `</div>`;\n  return result;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/languages/textToHtmlTokenizer.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","strings","LineTokens","TokenizationRegistry","NullState","nullTokenizeEncoded","fallback","getInitialState","tokenizeEncoded","buffer","hasEOL","state","tokenizeToString","languageService","text","languageId","_tokenizeToString","languageIdCodec","tokenizationSupport","getOrCreate","tokenizeLineToHTML","viewLineTokens","colorMap","startOffset","endOffset","tabSize","useNbsp","charIndex","tabsCharDelta","prevIsSpace","tokenIndex","tokenCount","getCount","tokenEndIndex","getEndOffset","partContent","charCode","charCodeAt","insertSpacesCount","String","fromCharCode","getInlineStyle","lines","splitLines","currentState","i","len","length","line","tokenizationResult","convertToEndOffset","tokens","lineTokens","inflate","j","lenJ","type","getClassName","endIndex","escape","substring","endState"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullMode.js';\nconst fallback = {\n    getInitialState: () => NullState,\n    tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* Null */, state)\n};\nexport function tokenizeToString(languageService, text, languageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!languageId) {\n            return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n        }\n        const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);\n        return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n    });\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    let prevIsSpace = true;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* Tab */: {\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        if (useNbsp && prevIsSpace) {\n                            partContent += '&#160;';\n                            prevIsSpace = false;\n                        }\n                        else {\n                            partContent += ' ';\n                            prevIsSpace = true;\n                        }\n                        insertSpacesCount--;\n                    }\n                    break;\n                }\n                case 60 /* LessThan */:\n                    partContent += '&lt;';\n                    prevIsSpace = false;\n                    break;\n                case 62 /* GreaterThan */:\n                    partContent += '&gt;';\n                    prevIsSpace = false;\n                    break;\n                case 38 /* Ampersand */:\n                    partContent += '&amp;';\n                    prevIsSpace = false;\n                    break;\n                case 0 /* Null */:\n                    partContent += '&#00;';\n                    prevIsSpace = false;\n                    break;\n                case 65279 /* UTF8_BOM */:\n                case 8232 /* LINE_SEPARATOR */:\n                case 8233 /* PARAGRAPH_SEPARATOR */:\n                case 133 /* NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    prevIsSpace = false;\n                    break;\n                case 13 /* CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    prevIsSpace = false;\n                    break;\n                case 32 /* Space */:\n                    if (useNbsp && prevIsSpace) {\n                        partContent += '&#160;';\n                        prevIsSpace = false;\n                    }\n                    else {\n                        partContent += ' ';\n                        prevIsSpace = true;\n                    }\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n                    prevIsSpace = false;\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    const lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n        const viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}