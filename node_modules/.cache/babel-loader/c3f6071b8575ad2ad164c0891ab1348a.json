{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { once } from './functional.js';\nimport { Iterable } from './iterator.js';\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\n\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nexport function setDisposableTracker(tracker) {\n  disposableTracker = tracker;\n}\n\nif (TRACK_DISPOSABLES) {\n  const __is_disposable_tracked__ = '__is_disposable_tracked__';\n  setDisposableTracker(new class {\n    trackDisposable(x) {\n      const stack = new Error('Potentially leaked disposable').stack;\n      setTimeout(() => {\n        if (!x[__is_disposable_tracked__]) {\n          console.log(stack);\n        }\n      }, 3000);\n    }\n\n    setParent(child, parent) {\n      if (child && child !== Disposable.None) {\n        try {\n          child[__is_disposable_tracked__] = true;\n        } catch (_a) {// noop\n        }\n      }\n    }\n\n    markAsDisposed(disposable) {\n      if (disposable && disposable !== Disposable.None) {\n        try {\n          disposable[__is_disposable_tracked__] = true;\n        } catch (_a) {// noop\n        }\n      }\n    }\n\n    markAsSingleton(disposable) {}\n\n  }());\n}\n\nfunction trackDisposable(x) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\n  return x;\n}\n\nfunction markAsDisposed(disposable) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\n}\n\nfunction setParentOfDisposable(child, parent) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\n}\n\nfunction setParentOfDisposables(children, parent) {\n  if (!disposableTracker) {\n    return;\n  }\n\n  for (const child of children) {\n    disposableTracker.setParent(child, parent);\n  }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\n\n\nexport function markAsSingleton(singleton) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);\n  return singleton;\n}\nexport class MultiDisposeError extends Error {\n  constructor(errors) {\n    super(`Encountered errors while disposing of store. Errors: [${errors.join(', ')}]`);\n    this.errors = errors;\n  }\n\n}\nexport function isDisposable(thing) {\n  return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n  if (Iterable.is(arg)) {\n    let errors = [];\n\n    for (const d of arg) {\n      if (d) {\n        try {\n          d.dispose();\n        } catch (e) {\n          errors.push(e);\n        }\n      }\n    }\n\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      throw new MultiDisposeError(errors);\n    }\n\n    return Array.isArray(arg) ? [] : arg;\n  } else if (arg) {\n    arg.dispose();\n    return arg;\n  }\n}\nexport function combinedDisposable(...disposables) {\n  const parent = toDisposable(() => dispose(disposables));\n  setParentOfDisposables(disposables, parent);\n  return parent;\n}\nexport function toDisposable(fn) {\n  const self = trackDisposable({\n    dispose: once(() => {\n      markAsDisposed(self);\n      fn();\n    })\n  });\n  return self;\n}\nexport class DisposableStore {\n  constructor() {\n    this._toDispose = new Set();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  /**\n   * Dispose of all registered disposables and mark this object as disposed.\n   *\n   * Any future disposables added to this object will be disposed of on `add`.\n   */\n\n\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n\n    markAsDisposed(this);\n    this._isDisposed = true;\n    this.clear();\n  }\n  /**\n   * Returns `true` if this object has been disposed\n   */\n\n\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Dispose of all registered disposables but do not mark this object as disposed.\n   */\n\n\n  clear() {\n    try {\n      dispose(this._toDispose.values());\n    } finally {\n      this._toDispose.clear();\n    }\n  }\n\n  add(o) {\n    if (!o) {\n      return o;\n    }\n\n    if (o === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n\n    setParentOfDisposable(o, this);\n\n    if (this._isDisposed) {\n      if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n        console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n      }\n    } else {\n      this._toDispose.add(o);\n    }\n\n    return o;\n  }\n\n}\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\nexport class Disposable {\n  constructor() {\n    this._store = new DisposableStore();\n    trackDisposable(this);\n    setParentOfDisposable(this._store, this);\n  }\n\n  dispose() {\n    markAsDisposed(this);\n\n    this._store.dispose();\n  }\n\n  _register(o) {\n    if (o === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n\n    return this._store.add(o);\n  }\n\n}\nDisposable.None = Object.freeze({\n  dispose() {}\n\n});\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\n\nexport class MutableDisposable {\n  constructor() {\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n\n  get value() {\n    return this._isDisposed ? undefined : this._value;\n  }\n\n  set value(value) {\n    var _a;\n\n    if (this._isDisposed || value === this._value) {\n      return;\n    }\n\n    (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n\n    if (value) {\n      setParentOfDisposable(value, this);\n    }\n\n    this._value = value;\n  }\n\n  clear() {\n    this.value = undefined;\n  }\n\n  dispose() {\n    var _a;\n\n    this._isDisposed = true;\n    markAsDisposed(this);\n    (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._value = undefined;\n  }\n  /**\n   * Clears the value, but does not dispose it.\n   * The old value is returned.\n  */\n\n\n  clearAndLeak() {\n    const oldValue = this._value;\n    this._value = undefined;\n\n    if (oldValue) {\n      setParentOfDisposable(oldValue, null);\n    }\n\n    return oldValue;\n  }\n\n}\nexport class ImmortalReference {\n  constructor(object) {\n    this.object = object;\n  }\n\n  dispose() {}\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"],"names":["once","Iterable","TRACK_DISPOSABLES","disposableTracker","setDisposableTracker","tracker","__is_disposable_tracked__","trackDisposable","x","stack","Error","setTimeout","console","log","setParent","child","parent","Disposable","None","_a","markAsDisposed","disposable","markAsSingleton","setParentOfDisposable","setParentOfDisposables","children","singleton","MultiDisposeError","constructor","errors","join","isDisposable","thing","dispose","length","arg","is","d","e","push","Array","isArray","combinedDisposable","disposables","toDisposable","fn","self","DisposableStore","_toDispose","Set","_isDisposed","clear","isDisposed","values","add","o","DISABLE_DISPOSED_WARNING","warn","_store","_register","Object","freeze","MutableDisposable","value","undefined","_value","clearAndLeak","oldValue","ImmortalReference","object"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { once } from './functional.js';\nimport { Iterable } from './iterator.js';\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nexport function setDisposableTracker(tracker) {\n    disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\n    setDisposableTracker(new class {\n        trackDisposable(x) {\n            const stack = new Error('Potentially leaked disposable').stack;\n            setTimeout(() => {\n                if (!x[__is_disposable_tracked__]) {\n                    console.log(stack);\n                }\n            }, 3000);\n        }\n        setParent(child, parent) {\n            if (child && child !== Disposable.None) {\n                try {\n                    child[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n        markAsDisposed(disposable) {\n            if (disposable && disposable !== Disposable.None) {\n                try {\n                    disposable[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n        markAsSingleton(disposable) { }\n    });\n}\nfunction trackDisposable(x) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\n    return x;\n}\nfunction markAsDisposed(disposable) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n    if (!disposableTracker) {\n        return;\n    }\n    for (const child of children) {\n        disposableTracker.setParent(child, parent);\n    }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton(singleton) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);\n    return singleton;\n}\nexport class MultiDisposeError extends Error {\n    constructor(errors) {\n        super(`Encountered errors while disposing of store. Errors: [${errors.join(', ')}]`);\n        this.errors = errors;\n    }\n}\nexport function isDisposable(thing) {\n    return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n    if (Iterable.is(arg)) {\n        let errors = [];\n        for (const d of arg) {\n            if (d) {\n                try {\n                    d.dispose();\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        else if (errors.length > 1) {\n            throw new MultiDisposeError(errors);\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        arg.dispose();\n        return arg;\n    }\n}\nexport function combinedDisposable(...disposables) {\n    const parent = toDisposable(() => dispose(disposables));\n    setParentOfDisposables(disposables, parent);\n    return parent;\n}\nexport function toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: once(() => {\n            markAsDisposed(self);\n            fn();\n        })\n    });\n    return self;\n}\nexport class DisposableStore {\n    constructor() {\n        this._toDispose = new Set();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Dispose of all registered disposables and mark this object as disposed.\n     *\n     * Any future disposables added to this object will be disposed of on `add`.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clear();\n    }\n    /**\n     * Returns `true` if this object has been disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n    clear() {\n        try {\n            dispose(this._toDispose.values());\n        }\n        finally {\n            this._toDispose.clear();\n        }\n    }\n    add(o) {\n        if (!o) {\n            return o;\n        }\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        setParentOfDisposable(o, this);\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n            }\n        }\n        else {\n            this._toDispose.add(o);\n        }\n        return o;\n    }\n}\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\nexport class Disposable {\n    constructor() {\n        this._store = new DisposableStore();\n        trackDisposable(this);\n        setParentOfDisposable(this._store, this);\n    }\n    dispose() {\n        markAsDisposed(this);\n        this._store.dispose();\n    }\n    _register(o) {\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        return this._store.add(o);\n    }\n}\nDisposable.None = Object.freeze({ dispose() { } });\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        var _a;\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        if (value) {\n            setParentOfDisposable(value, this);\n        }\n        this._value = value;\n    }\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        var _a;\n        this._isDisposed = true;\n        markAsDisposed(this);\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._value = undefined;\n    }\n    /**\n     * Clears the value, but does not dispose it.\n     * The old value is returned.\n    */\n    clearAndLeak() {\n        const oldValue = this._value;\n        this._value = undefined;\n        if (oldValue) {\n            setParentOfDisposable(oldValue, null);\n        }\n        return oldValue;\n    }\n}\nexport class ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\n"]},"metadata":{},"sourceType":"module"}