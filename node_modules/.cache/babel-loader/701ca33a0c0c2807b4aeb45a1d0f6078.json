{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n  return (node.metadata & 1\n  /* ColorMask */\n  ) >>> 0\n  /* ColorOffset */\n  ;\n}\n\nfunction setNodeColor(node, color) {\n  node.metadata = node.metadata & 254\n  /* ColorMaskInverse */\n  | color << 0\n  /* ColorOffset */\n  ;\n}\n\nfunction getNodeIsVisited(node) {\n  return (node.metadata & 2\n  /* IsVisitedMask */\n  ) >>> 1\n  /* IsVisitedOffset */\n  === 1;\n}\n\nfunction setNodeIsVisited(node, value) {\n  node.metadata = node.metadata & 253\n  /* IsVisitedMaskInverse */\n  | (value ? 1 : 0) << 1\n  /* IsVisitedOffset */\n  ;\n}\n\nfunction getNodeIsForValidation(node) {\n  return (node.metadata & 4\n  /* IsForValidationMask */\n  ) >>> 2\n  /* IsForValidationOffset */\n  === 1;\n}\n\nfunction setNodeIsForValidation(node, value) {\n  node.metadata = node.metadata & 251\n  /* IsForValidationMaskInverse */\n  | (value ? 1 : 0) << 2\n  /* IsForValidationOffset */\n  ;\n}\n\nfunction getNodeStickiness(node) {\n  return (node.metadata & 24\n  /* StickinessMask */\n  ) >>> 3\n  /* StickinessOffset */\n  ;\n}\n\nfunction _setNodeStickiness(node, stickiness) {\n  node.metadata = node.metadata & 231\n  /* StickinessMaskInverse */\n  | stickiness << 3\n  /* StickinessOffset */\n  ;\n}\n\nfunction getCollapseOnReplaceEdit(node) {\n  return (node.metadata & 32\n  /* CollapseOnReplaceEditMask */\n  ) >>> 5\n  /* CollapseOnReplaceEditOffset */\n  === 1;\n}\n\nfunction setCollapseOnReplaceEdit(node, value) {\n  node.metadata = node.metadata & 223\n  /* CollapseOnReplaceEditMaskInverse */\n  | (value ? 1 : 0) << 5\n  /* CollapseOnReplaceEditOffset */\n  ;\n}\n\nexport class IntervalNode {\n  constructor(id, start, end) {\n    this.metadata = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n    setNodeColor(this, 1\n    /* Red */\n    );\n    this.start = start;\n    this.end = end; // FORCE_OVERFLOWING_TEST: this.delta = start;\n\n    this.delta = 0;\n    this.maxEnd = end;\n    this.id = id;\n    this.ownerId = 0;\n    this.options = null;\n    setNodeIsForValidation(this, false);\n\n    _setNodeStickiness(this, 1\n    /* NeverGrowsWhenTypingAtEdges */\n    );\n\n    setCollapseOnReplaceEdit(this, false);\n    this.cachedVersionId = 0;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = null;\n    setNodeIsVisited(this, false);\n  }\n\n  reset(versionId, start, end, range) {\n    this.start = start;\n    this.end = end;\n    this.maxEnd = end;\n    this.cachedVersionId = versionId;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = range;\n  }\n\n  setOptions(options) {\n    this.options = options;\n    const className = this.options.className;\n    setNodeIsForValidation(this, className === \"squiggly-error\"\n    /* EditorErrorDecoration */\n    || className === \"squiggly-warning\"\n    /* EditorWarningDecoration */\n    || className === \"squiggly-info\"\n    /* EditorInfoDecoration */\n    );\n\n    _setNodeStickiness(this, this.options.stickiness);\n\n    setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n  }\n\n  setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n    if (this.cachedVersionId !== cachedVersionId) {\n      this.range = null;\n    }\n\n    this.cachedVersionId = cachedVersionId;\n    this.cachedAbsoluteStart = absoluteStart;\n    this.cachedAbsoluteEnd = absoluteEnd;\n  }\n\n  detach() {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  }\n\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0\n/* Black */\n);\nexport class IntervalTree {\n  constructor() {\n    this.root = SENTINEL;\n    this.requestNormalizeDelta = false;\n  }\n\n  intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n\n    return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n  }\n\n  search(filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n\n    return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n  }\n  /**\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n   */\n\n\n  collectNodesFromOwner(ownerId) {\n    return collectNodesFromOwner(this, ownerId);\n  }\n  /**\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n   */\n\n\n  collectNodesPostOrder() {\n    return collectNodesPostOrder(this);\n  }\n\n  insert(node) {\n    rbTreeInsert(this, node);\n\n    this._normalizeDeltaIfNecessary();\n  }\n\n  delete(node) {\n    rbTreeDelete(this, node);\n\n    this._normalizeDeltaIfNecessary();\n  }\n\n  resolveNode(node, cachedVersionId) {\n    const initialNode = node;\n    let delta = 0;\n\n    while (node !== this.root) {\n      if (node === node.parent.right) {\n        delta += node.parent.delta;\n      }\n\n      node = node.parent;\n    }\n\n    const nodeStart = initialNode.start + delta;\n    const nodeEnd = initialNode.end + delta;\n    initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n  }\n\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n    // (1) collect all nodes that are intersecting this edit as nodes of interest\n    const nodesOfInterest = searchForEditing(this, offset, offset + length); // (2) remove all nodes that are intersecting this edit\n\n    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n      const node = nodesOfInterest[i];\n      rbTreeDelete(this, node);\n    }\n\n    this._normalizeDeltaIfNecessary(); // (3) edit all tree nodes except the nodes of interest\n\n\n    noOverlapReplace(this, offset, offset + length, textLength);\n\n    this._normalizeDeltaIfNecessary(); // (4) edit the nodes of interest and insert them back in the tree\n\n\n    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n      const node = nodesOfInterest[i];\n      node.start = node.cachedAbsoluteStart;\n      node.end = node.cachedAbsoluteEnd;\n      nodeAcceptEdit(node, offset, offset + length, textLength, forceMoveMarkers);\n      node.maxEnd = node.end;\n      rbTreeInsert(this, node);\n    }\n\n    this._normalizeDeltaIfNecessary();\n  }\n\n  _normalizeDeltaIfNecessary() {\n    if (!this.requestNormalizeDelta) {\n      return;\n    }\n\n    this.requestNormalizeDelta = false;\n    normalizeDelta(this);\n  }\n\n} //#region Delta Normalization\n\nfunction normalizeDelta(T) {\n  let node = T.root;\n  let delta = 0;\n\n  while (node !== SENTINEL) {\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    } // handle current node\n\n\n    node.start = delta + node.start;\n    node.end = delta + node.end;\n    node.delta = 0;\n    recomputeMaxEnd(node);\n    setNodeIsVisited(node, true); // going up from this node\n\n    setNodeIsVisited(node.left, false);\n    setNodeIsVisited(node.right, false);\n\n    if (node === node.parent.right) {\n      delta -= node.parent.delta;\n    }\n\n    node = node.parent;\n  }\n\n  setNodeIsVisited(T.root, false);\n}\n\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n  if (markerOffset < checkOffset) {\n    return true;\n  }\n\n  if (markerOffset > checkOffset) {\n    return false;\n  }\n\n  if (moveSemantics === 1\n  /* ForceMove */\n  ) {\n    return false;\n  }\n\n  if (moveSemantics === 2\n  /* ForceStay */\n  ) {\n    return true;\n  }\n\n  return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\n\n\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n  const nodeStickiness = getNodeStickiness(node);\n  const startStickToPreviousCharacter = nodeStickiness === 0\n  /* AlwaysGrowsWhenTypingAtEdges */\n  || nodeStickiness === 2\n  /* GrowsOnlyWhenTypingBefore */\n  ;\n  const endStickToPreviousCharacter = nodeStickiness === 1\n  /* NeverGrowsWhenTypingAtEdges */\n  || nodeStickiness === 2\n  /* GrowsOnlyWhenTypingBefore */\n  ;\n  const deletingCnt = end - start;\n  const insertingCnt = textLength;\n  const commonLength = Math.min(deletingCnt, insertingCnt);\n  const nodeStart = node.start;\n  let startDone = false;\n  const nodeEnd = node.end;\n  let endDone = false;\n\n  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n    // This edit encompasses the entire decoration range\n    // and the decoration has asked to become collapsed\n    node.start = start;\n    startDone = true;\n    node.end = start;\n    endDone = true;\n  }\n\n  {\n    const moveSemantics = forceMoveMarkers ? 1\n    /* ForceMove */\n    : deletingCnt > 0 ? 2\n    /* ForceStay */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n      endDone = true;\n    }\n  }\n\n  if (commonLength > 0 && !forceMoveMarkers) {\n    const moveSemantics = deletingCnt > insertingCnt ? 2\n    /* ForceStay */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      endDone = true;\n    }\n  }\n\n  {\n    const moveSemantics = forceMoveMarkers ? 1\n    /* ForceMove */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n      node.start = start + insertingCnt;\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n      node.end = start + insertingCnt;\n      endDone = true;\n    }\n  } // Finish\n\n  const deltaColumn = insertingCnt - deletingCnt;\n\n  if (!startDone) {\n    node.start = Math.max(0, nodeStart + deltaColumn);\n  }\n\n  if (!endDone) {\n    node.end = Math.max(0, nodeEnd + deltaColumn);\n  }\n\n  if (node.start > node.end) {\n    node.end = node.start;\n  }\n}\n\nfunction searchForEditing(T, start, end) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  const result = [];\n  let resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > end) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    nodeEnd = delta + node.end;\n\n    if (nodeEnd >= start) {\n      node.setCachedOffsets(nodeStart, nodeEnd, 0);\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction noOverlapReplace(T, start, end, textLength) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  const editDelta = textLength - (end - start);\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      recomputeMaxEnd(node);\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > end) {\n      node.start += editDelta;\n      node.end += editDelta;\n      node.delta += editDelta;\n\n      if (node.delta < -1073741824\n      /* MIN_SAFE_DELTA */\n      || node.delta > 1073741824\n      /* MAX_SAFE_DELTA */\n      ) {\n        T.requestNormalizeDelta = true;\n      } // cover case a) from above\n      // there is no need to search this node or its right subtree\n\n\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n} //#endregion\n//#region Searching\n\n\nfunction collectNodesFromOwner(T, ownerId) {\n  let node = T.root;\n  const result = [];\n  let resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    } // handle current node\n\n\n    if (node.ownerId === ownerId) {\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction collectNodesPostOrder(T) {\n  let node = T.root;\n  const result = [];\n  let resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    } // handle current node\n\n\n    result[resultLen++] = node;\n    setNodeIsVisited(node, true);\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n  let node = T.root;\n  let delta = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  const result = [];\n  let resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n    nodeEnd = delta + node.end;\n    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    let include = true;\n\n    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n      include = false;\n    }\n\n    if (filterOutValidation && getNodeIsForValidation(node)) {\n      include = false;\n    }\n\n    if (include) {\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  const result = [];\n  let resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < intervalStart) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > intervalEnd) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    nodeEnd = delta + node.end;\n\n    if (nodeEnd >= intervalStart) {\n      // There is overlap\n      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n      let include = true;\n\n      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n        include = false;\n      }\n\n      if (filterOutValidation && getNodeIsForValidation(node)) {\n        include = false;\n      }\n\n      if (include) {\n        result[resultLen++] = node;\n      }\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n} //#endregion\n//#region Insertion\n\n\nfunction rbTreeInsert(T, newNode) {\n  if (T.root === SENTINEL) {\n    newNode.parent = SENTINEL;\n    newNode.left = SENTINEL;\n    newNode.right = SENTINEL;\n    setNodeColor(newNode, 0\n    /* Black */\n    );\n    T.root = newNode;\n    return T.root;\n  }\n\n  treeInsert(T, newNode);\n  recomputeMaxEndWalkToRoot(newNode.parent); // repair tree\n\n  let x = newNode;\n\n  while (x !== T.root && getNodeColor(x.parent) === 1\n  /* Red */\n  ) {\n    if (x.parent === x.parent.parent.left) {\n      const y = x.parent.parent.right;\n\n      if (getNodeColor(y) === 1\n      /* Red */\n      ) {\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(y, 0\n        /* Black */\n        );\n        setNodeColor(x.parent.parent, 1\n        /* Red */\n        );\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(T, x);\n        }\n\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(x.parent.parent, 1\n        /* Red */\n        );\n        rightRotate(T, x.parent.parent);\n      }\n    } else {\n      const y = x.parent.parent.left;\n\n      if (getNodeColor(y) === 1\n      /* Red */\n      ) {\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(y, 0\n        /* Black */\n        );\n        setNodeColor(x.parent.parent, 1\n        /* Red */\n        );\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(T, x);\n        }\n\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(x.parent.parent, 1\n        /* Red */\n        );\n        leftRotate(T, x.parent.parent);\n      }\n    }\n  }\n\n  setNodeColor(T.root, 0\n  /* Black */\n  );\n  return newNode;\n}\n\nfunction treeInsert(T, z) {\n  let delta = 0;\n  let x = T.root;\n  const zAbsoluteStart = z.start;\n  const zAbsoluteEnd = z.end;\n\n  while (true) {\n    const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n\n    if (cmp < 0) {\n      // this node should be inserted to the left\n      // => it is not affected by the node's delta\n      if (x.left === SENTINEL) {\n        z.start -= delta;\n        z.end -= delta;\n        z.maxEnd -= delta;\n        x.left = z;\n        break;\n      } else {\n        x = x.left;\n      }\n    } else {\n      // this node should be inserted to the right\n      // => it is not affected by the node's delta\n      if (x.right === SENTINEL) {\n        z.start -= delta + x.delta;\n        z.end -= delta + x.delta;\n        z.maxEnd -= delta + x.delta;\n        x.right = z;\n        break;\n      } else {\n        delta += x.delta;\n        x = x.right;\n      }\n    }\n  }\n\n  z.parent = x;\n  z.left = SENTINEL;\n  z.right = SENTINEL;\n  setNodeColor(z, 1\n  /* Red */\n  );\n} //#endregion\n//#region Deletion\n\n\nfunction rbTreeDelete(T, z) {\n  let x;\n  let y; // RB-DELETE except we don't swap z and y in case c)\n  // i.e. we always delete what's pointed at by z.\n\n  if (z.left === SENTINEL) {\n    x = z.right;\n    y = z; // x's delta is no longer influenced by z's delta\n\n    x.delta += z.delta;\n\n    if (x.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || x.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n      T.requestNormalizeDelta = true;\n    }\n\n    x.start += z.delta;\n    x.end += z.delta;\n  } else if (z.right === SENTINEL) {\n    x = z.left;\n    y = z;\n  } else {\n    y = leftest(z.right);\n    x = y.right; // y's delta is no longer influenced by z's delta,\n    // but we don't want to walk the entire right-hand-side subtree of x.\n    // we therefore maintain z's delta in y, and adjust only x\n\n    x.start += y.delta;\n    x.end += y.delta;\n    x.delta += y.delta;\n\n    if (x.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || x.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n      T.requestNormalizeDelta = true;\n    }\n\n    y.start += z.delta;\n    y.end += z.delta;\n    y.delta = z.delta;\n\n    if (y.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || y.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n      T.requestNormalizeDelta = true;\n    }\n  }\n\n  if (y === T.root) {\n    T.root = x;\n    setNodeColor(x, 0\n    /* Black */\n    );\n    z.detach();\n    resetSentinel();\n    recomputeMaxEnd(x);\n    T.root.parent = SENTINEL;\n    return;\n  }\n\n  const yWasRed = getNodeColor(y) === 1\n  /* Red */\n  ;\n\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n\n  if (y === z) {\n    x.parent = y.parent;\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    }\n\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    setNodeColor(y, getNodeColor(z));\n\n    if (z === T.root) {\n      T.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    }\n  }\n\n  z.detach();\n\n  if (yWasRed) {\n    recomputeMaxEndWalkToRoot(x.parent);\n\n    if (y !== z) {\n      recomputeMaxEndWalkToRoot(y);\n      recomputeMaxEndWalkToRoot(y.parent);\n    }\n\n    resetSentinel();\n    return;\n  }\n\n  recomputeMaxEndWalkToRoot(x);\n  recomputeMaxEndWalkToRoot(x.parent);\n\n  if (y !== z) {\n    recomputeMaxEndWalkToRoot(y);\n    recomputeMaxEndWalkToRoot(y.parent);\n  } // RB-DELETE-FIXUP\n\n\n  let w;\n\n  while (x !== T.root && getNodeColor(x) === 0\n  /* Black */\n  ) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n\n      if (getNodeColor(w) === 1\n      /* Red */\n      ) {\n        setNodeColor(w, 0\n        /* Black */\n        );\n        setNodeColor(x.parent, 1\n        /* Red */\n        );\n        leftRotate(T, x.parent);\n        w = x.parent.right;\n      }\n\n      if (getNodeColor(w.left) === 0\n      /* Black */\n      && getNodeColor(w.right) === 0\n      /* Black */\n      ) {\n        setNodeColor(w, 1\n        /* Red */\n        );\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.right) === 0\n        /* Black */\n        ) {\n          setNodeColor(w.left, 0\n          /* Black */\n          );\n          setNodeColor(w, 1\n          /* Red */\n          );\n          rightRotate(T, w);\n          w = x.parent.right;\n        }\n\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(w.right, 0\n        /* Black */\n        );\n        leftRotate(T, x.parent);\n        x = T.root;\n      }\n    } else {\n      w = x.parent.left;\n\n      if (getNodeColor(w) === 1\n      /* Red */\n      ) {\n        setNodeColor(w, 0\n        /* Black */\n        );\n        setNodeColor(x.parent, 1\n        /* Red */\n        );\n        rightRotate(T, x.parent);\n        w = x.parent.left;\n      }\n\n      if (getNodeColor(w.left) === 0\n      /* Black */\n      && getNodeColor(w.right) === 0\n      /* Black */\n      ) {\n        setNodeColor(w, 1\n        /* Red */\n        );\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.left) === 0\n        /* Black */\n        ) {\n          setNodeColor(w.right, 0\n          /* Black */\n          );\n          setNodeColor(w, 1\n          /* Red */\n          );\n          leftRotate(T, w);\n          w = x.parent.left;\n        }\n\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(w.left, 0\n        /* Black */\n        );\n        rightRotate(T, x.parent);\n        x = T.root;\n      }\n    }\n  }\n\n  setNodeColor(x, 0\n  /* Black */\n  );\n  resetSentinel();\n}\n\nfunction leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n\n  return node;\n}\n\nfunction resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n  SENTINEL.delta = 0; // optional\n\n  SENTINEL.start = 0; // optional\n\n  SENTINEL.end = 0; // optional\n} //#endregion\n//#region Rotations\n\n\nfunction leftRotate(T, x) {\n  const y = x.right; // set y.\n\n  y.delta += x.delta; // y's delta is no longer influenced by x's delta\n\n  if (y.delta < -1073741824\n  /* MIN_SAFE_DELTA */\n  || y.delta > 1073741824\n  /* MAX_SAFE_DELTA */\n  ) {\n    T.requestNormalizeDelta = true;\n  }\n\n  y.start += x.delta;\n  y.end += x.delta;\n  x.right = y.left; // turn y's left subtree into x's right subtree.\n\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n\n  y.parent = x.parent; // link x's parent to y.\n\n  if (x.parent === SENTINEL) {\n    T.root = y;\n  } else if (x === x.parent.left) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n\n  y.left = x; // put x on y's left.\n\n  x.parent = y;\n  recomputeMaxEnd(x);\n  recomputeMaxEnd(y);\n}\n\nfunction rightRotate(T, y) {\n  const x = y.left;\n  y.delta -= x.delta;\n\n  if (y.delta < -1073741824\n  /* MIN_SAFE_DELTA */\n  || y.delta > 1073741824\n  /* MAX_SAFE_DELTA */\n  ) {\n    T.requestNormalizeDelta = true;\n  }\n\n  y.start -= x.delta;\n  y.end -= x.delta;\n  y.left = x.right;\n\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n\n  x.parent = y.parent;\n\n  if (y.parent === SENTINEL) {\n    T.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n\n  x.right = y;\n  y.parent = x;\n  recomputeMaxEnd(y);\n  recomputeMaxEnd(x);\n} //#endregion\n//#region max end computation\n\n\nfunction computeMaxEnd(node) {\n  let maxEnd = node.end;\n\n  if (node.left !== SENTINEL) {\n    const leftMaxEnd = node.left.maxEnd;\n\n    if (leftMaxEnd > maxEnd) {\n      maxEnd = leftMaxEnd;\n    }\n  }\n\n  if (node.right !== SENTINEL) {\n    const rightMaxEnd = node.right.maxEnd + node.delta;\n\n    if (rightMaxEnd > maxEnd) {\n      maxEnd = rightMaxEnd;\n    }\n  }\n\n  return maxEnd;\n}\n\nexport function recomputeMaxEnd(node) {\n  node.maxEnd = computeMaxEnd(node);\n}\n\nfunction recomputeMaxEndWalkToRoot(node) {\n  while (node !== SENTINEL) {\n    const maxEnd = computeMaxEnd(node);\n\n    if (node.maxEnd === maxEnd) {\n      // no need to go further\n      return;\n    }\n\n    node.maxEnd = maxEnd;\n    node = node.parent;\n  }\n} //#endregion\n//#region utils\n\n\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n  if (aStart === bStart) {\n    return aEnd - bEnd;\n  }\n\n  return aStart - bStart;\n} //#endregion","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"names":["getNodeColor","node","metadata","setNodeColor","color","getNodeIsVisited","setNodeIsVisited","value","getNodeIsForValidation","setNodeIsForValidation","getNodeStickiness","_setNodeStickiness","stickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","constructor","id","start","end","parent","left","right","delta","maxEnd","ownerId","options","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","range","reset","versionId","setOptions","className","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","filterOutValidation","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","delete","rbTreeDelete","resolveNode","initialNode","nodeStart","nodeEnd","acceptReplace","offset","length","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","i","len","noOverlapReplace","nodeAcceptEdit","normalizeDelta","T","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","Math","min","startDone","endDone","deltaColumn","max","nodeMaxEnd","result","resultLen","editDelta","include","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","x","y","leftRotate","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","cmp","intervalCompare","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* ColorMaskInverse */) | (color << 0 /* ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* IsForValidationOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* StickinessMask */) >>> 3 /* StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* StickinessMaskInverse */) | (stickiness << 3 /* StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* CollapseOnReplaceEditMask */) >>> 5 /* CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        _setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* EditorWarningDecoration */\n            || className === \"squiggly-info\" /* EditorInfoDecoration */));\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* Red */) {\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(y, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* Red */) {\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(y, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(x.parent.parent, 1 /* Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* Red */) {\n                setNodeColor(w, 0 /* Black */);\n                setNodeColor(x.parent, 1 /* Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\n                setNodeColor(w, 1 /* Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* Black */) {\n                    setNodeColor(w.left, 0 /* Black */);\n                    setNodeColor(w, 1 /* Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(w.right, 0 /* Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* Red */) {\n                setNodeColor(w, 0 /* Black */);\n                setNodeColor(x.parent, 1 /* Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\n                setNodeColor(w, 1 /* Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* Black */) {\n                    setNodeColor(w.right, 0 /* Black */);\n                    setNodeColor(w, 1 /* Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* Black */);\n                setNodeColor(w.left, 0 /* Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n"]},"metadata":{},"sourceType":"module"}