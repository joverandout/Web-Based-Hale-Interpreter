{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n  constructor(searchString, isRegex, matchCase, wordSeparators) {\n    this.searchString = searchString;\n    this.isRegex = isRegex;\n    this.matchCase = matchCase;\n    this.wordSeparators = wordSeparators;\n  }\n\n  parseSearchRequest() {\n    if (this.searchString === '') {\n      return null;\n    } // Try to create a RegExp out of the params\n\n\n    let multiline;\n\n    if (this.isRegex) {\n      multiline = isMultilineRegexSource(this.searchString);\n    } else {\n      multiline = this.searchString.indexOf('\\n') >= 0;\n    }\n\n    let regex = null;\n\n    try {\n      regex = strings.createRegExp(this.searchString, this.isRegex, {\n        matchCase: this.matchCase,\n        wholeWord: false,\n        multiline: multiline,\n        global: true,\n        unicode: true\n      });\n    } catch (err) {\n      return null;\n    }\n\n    if (!regex) {\n      return null;\n    }\n\n    let canUseSimpleSearch = !this.isRegex && !multiline;\n\n    if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n      // casing might make a difference\n      canUseSimpleSearch = this.matchCase;\n    }\n\n    return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n  }\n\n}\nexport function isMultilineRegexSource(searchString) {\n  if (!searchString || searchString.length === 0) {\n    return false;\n  }\n\n  for (let i = 0, len = searchString.length; i < len; i++) {\n    const chCode = searchString.charCodeAt(i);\n\n    if (chCode === 92\n    /* Backslash */\n    ) {\n      // move to next char\n      i++;\n\n      if (i >= len) {\n        // string ends with a \\\n        break;\n      }\n\n      const nextChCode = searchString.charCodeAt(i);\n\n      if (nextChCode === 110\n      /* n */\n      || nextChCode === 114\n      /* r */\n      || nextChCode === 87\n      /* W */\n      ) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n  if (!captureMatches) {\n    return new FindMatch(range, null);\n  }\n\n  const matches = [];\n\n  for (let i = 0, len = rawMatches.length; i < len; i++) {\n    matches[i] = rawMatches[i];\n  }\n\n  return new FindMatch(range, matches);\n}\n\nclass LineFeedCounter {\n  constructor(text) {\n    const lineFeedsOffsets = [];\n    let lineFeedsOffsetsLen = 0;\n\n    for (let i = 0, textLen = text.length; i < textLen; i++) {\n      if (text.charCodeAt(i) === 10\n      /* LineFeed */\n      ) {\n        lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n      }\n    }\n\n    this._lineFeedsOffsets = lineFeedsOffsets;\n  }\n\n  findLineFeedCountBeforeOffset(offset) {\n    const lineFeedsOffsets = this._lineFeedsOffsets;\n    let min = 0;\n    let max = lineFeedsOffsets.length - 1;\n\n    if (max === -1) {\n      // no line feeds\n      return 0;\n    }\n\n    if (offset <= lineFeedsOffsets[0]) {\n      // before first line feed\n      return 0;\n    }\n\n    while (min < max) {\n      const mid = min + ((max - min) / 2 >> 0);\n\n      if (lineFeedsOffsets[mid] >= offset) {\n        max = mid - 1;\n      } else {\n        if (lineFeedsOffsets[mid + 1] >= offset) {\n          // bingo!\n          min = mid;\n          max = mid;\n        } else {\n          min = mid + 1;\n        }\n      }\n    }\n\n    return min + 1;\n  }\n\n}\n\nexport class TextModelSearch {\n  static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n    const searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return [];\n    }\n\n    if (searchData.regex.multiline) {\n      return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n    }\n\n    return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n  }\n  /**\n   * Multiline search always executes on the lines concatenated with \\n.\n   * We must therefore compensate for the count of \\n in case the model is CRLF\n   */\n\n\n  static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n    let startOffset;\n    let lineFeedCountBeforeMatch = 0;\n\n    if (lfCounter) {\n      lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n      startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch\n      /* add as many \\r as there were \\n */\n      ;\n    } else {\n      startOffset = deltaOffset + matchIndex;\n    }\n\n    let endOffset;\n\n    if (lfCounter) {\n      const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n      const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n      endOffset = startOffset + match0.length + lineFeedCountInMatch\n      /* add as many \\r as there were \\n */\n      ;\n    } else {\n      endOffset = startOffset + match0.length;\n    }\n\n    const startPosition = model.getPositionAt(startOffset);\n    const endPosition = model.getPositionAt(endOffset);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  }\n\n  static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n    const deltaOffset = model.getOffsetAt(searchRange.getStartPosition()); // We always execute multiline search over the lines joined with \\n\n    // This makes it that \\n will match the EOL for both CRLF and LF models\n    // We compensate for offset errors in `_getMultilineMatchRange`\n\n    const text = model.getValueInRange(searchRange, 1\n    /* LF */\n    );\n    const lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n    const result = [];\n    let counter = 0;\n    let m;\n    searcher.reset(0);\n\n    while (m = searcher.next(text)) {\n      result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\n      if (counter >= limitResultCount) {\n        return result;\n      }\n    }\n\n    return result;\n  }\n\n  static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n    const result = [];\n    let resultLen = 0; // Early case for a search range that starts & stops on the same line number\n\n    if (searchRange.startLineNumber === searchRange.endLineNumber) {\n      const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n      return result;\n    } // Collect results from first line\n\n\n    const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n    resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount); // Collect results from middle lines\n\n    for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n      resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n    } // Collect results from last line\n\n\n    if (resultLen < limitResultCount) {\n      const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n    }\n\n    return result;\n  }\n\n  static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n    const wordSeparators = searchData.wordSeparators;\n\n    if (!captureMatches && searchData.simpleSearch) {\n      const searchString = searchData.simpleSearch;\n      const searchStringLen = searchString.length;\n      const textLength = text.length;\n      let lastMatchIndex = -searchStringLen;\n\n      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      }\n\n      return resultLen;\n    }\n\n    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n    let m; // Reset regex to search from the beginning\n\n    searcher.reset(0);\n\n    do {\n      m = searcher.next(text);\n\n      if (m) {\n        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n\n    return resultLen;\n  }\n\n  static findNextMatch(model, searchParams, searchStart, captureMatches) {\n    const searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return null;\n    }\n\n    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n    if (searchData.regex.multiline) {\n      return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n    }\n\n    return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n  }\n\n  static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n    const searchTextStart = new Position(searchStart.lineNumber, 1);\n    const deltaOffset = model.getOffsetAt(searchTextStart);\n    const lineCount = model.getLineCount(); // We always execute multiline search over the lines joined with \\n\n    // This makes it that \\n will match the EOL for both CRLF and LF models\n    // We compensate for offset errors in `_getMultilineMatchRange`\n\n    const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1\n    /* LF */\n    );\n    const lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n    searcher.reset(searchStart.column - 1);\n    let m = searcher.next(text);\n\n    if (m) {\n      return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n    }\n\n    if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n      // Try again from the top\n      return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n    }\n\n    return null;\n  }\n\n  static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n    const lineCount = model.getLineCount();\n    const startLineNumber = searchStart.lineNumber; // Look in first line\n\n    const text = model.getLineContent(startLineNumber);\n\n    const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\n    if (r) {\n      return r;\n    }\n\n    for (let i = 1; i <= lineCount; i++) {\n      const lineIndex = (startLineNumber + i - 1) % lineCount;\n      const text = model.getLineContent(lineIndex + 1);\n\n      const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n\n      if (r) {\n        return r;\n      }\n    }\n\n    return null;\n  }\n\n  static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n    // Set regex to search from column\n    searcher.reset(fromColumn - 1);\n    const m = searcher.next(text);\n\n    if (m) {\n      return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n    }\n\n    return null;\n  }\n\n  static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n    const searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return null;\n    }\n\n    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n    if (searchData.regex.multiline) {\n      return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n    }\n\n    return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n  }\n\n  static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n    const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\n    if (matches.length > 0) {\n      return matches[matches.length - 1];\n    }\n\n    const lineCount = model.getLineCount();\n\n    if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n      // Try again with all content\n      return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n    }\n\n    return null;\n  }\n\n  static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n    const lineCount = model.getLineCount();\n    const startLineNumber = searchStart.lineNumber; // Look in first line\n\n    const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\n    const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\n    if (r) {\n      return r;\n    }\n\n    for (let i = 1; i <= lineCount; i++) {\n      const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n      const text = model.getLineContent(lineIndex + 1);\n\n      const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n\n      if (r) {\n        return r;\n      }\n    }\n\n    return null;\n  }\n\n  static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n    let bestResult = null;\n    let m;\n    searcher.reset(0);\n\n    while (m = searcher.next(text)) {\n      bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n    }\n\n    return bestResult;\n  }\n\n}\n\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex === 0) {\n    // Match starts at start of string\n    return true;\n  }\n\n  const charBefore = text.charCodeAt(matchStartIndex - 1);\n\n  if (wordSeparators.get(charBefore) !== 0\n  /* Regular */\n  ) {\n    // The character before the match is a word separator\n    return true;\n  }\n\n  if (charBefore === 13\n  /* CarriageReturn */\n  || charBefore === 10\n  /* LineFeed */\n  ) {\n    // The character before the match is line break or carriage return.\n    return true;\n  }\n\n  if (matchLength > 0) {\n    const firstCharInMatch = text.charCodeAt(matchStartIndex);\n\n    if (wordSeparators.get(firstCharInMatch) !== 0\n    /* Regular */\n    ) {\n      // The first character inside the match is a word separator\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex + matchLength === textLength) {\n    // Match ends at end of string\n    return true;\n  }\n\n  const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\n  if (wordSeparators.get(charAfter) !== 0\n  /* Regular */\n  ) {\n    // The character after the match is a word separator\n    return true;\n  }\n\n  if (charAfter === 13\n  /* CarriageReturn */\n  || charAfter === 10\n  /* LineFeed */\n  ) {\n    // The character after the match is line break or carriage return.\n    return true;\n  }\n\n  if (matchLength > 0) {\n    const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\n    if (wordSeparators.get(lastCharInMatch) !== 0\n    /* Regular */\n    ) {\n      // The last character in the match is a word separator\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);\n}\nexport class Searcher {\n  constructor(wordSeparators, searchRegex) {\n    this._wordSeparators = wordSeparators;\n    this._searchRegex = searchRegex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n\n  reset(lastIndex) {\n    this._searchRegex.lastIndex = lastIndex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n\n  next(text) {\n    const textLength = text.length;\n    let m;\n\n    do {\n      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n        // Reached the end of the line\n        return null;\n      }\n\n      m = this._searchRegex.exec(text);\n\n      if (!m) {\n        return null;\n      }\n\n      const matchStartIndex = m.index;\n      const matchLength = m[0].length;\n\n      if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n        if (matchLength === 0) {\n          // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n          // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n          if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n            this._searchRegex.lastIndex += 2;\n          } else {\n            this._searchRegex.lastIndex += 1;\n          }\n\n          continue;\n        } // Exit early if the regex matches the same range twice\n\n\n        return null;\n      }\n\n      this._prevMatchStartIndex = matchStartIndex;\n      this._prevMatchLength = matchLength;\n\n      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n        return m;\n      }\n    } while (m);\n\n    return null;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"],"names":["strings","getMapForWordSeparators","Position","Range","FindMatch","SearchData","LIMIT_FIND_COUNT","SearchParams","constructor","searchString","isRegex","matchCase","wordSeparators","parseSearchRequest","multiline","isMultilineRegexSource","indexOf","regex","createRegExp","wholeWord","global","unicode","err","canUseSimpleSearch","toLowerCase","toUpperCase","length","i","len","chCode","charCodeAt","nextChCode","createFindMatch","range","rawMatches","captureMatches","matches","LineFeedCounter","text","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","findLineFeedCountBeforeOffset","offset","min","max","mid","TextModelSearch","findMatches","model","searchParams","searchRange","limitResultCount","searchData","_doFindMatchesMultiline","Searcher","_doFindMatchesLineByLine","_getMultilineMatchRange","deltaOffset","lfCounter","matchIndex","match0","startOffset","lineFeedCountBeforeMatch","endOffset","lineFeedCountBeforeEndOfMatch","lineFeedCountInMatch","startPosition","getPositionAt","endPosition","lineNumber","column","searcher","getOffsetAt","getStartPosition","getValueInRange","getEOL","result","counter","m","reset","next","index","resultLen","startLineNumber","endLineNumber","getLineContent","substring","startColumn","endColumn","_findMatchesInLine","simpleSearch","searchStringLen","textLength","lastMatchIndex","isValidMatch","findNextMatch","searchStart","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","lineCount","getLineCount","getLineMaxColumn","r","_findFirstMatchInLine","lineIndex","fromColumn","findPreviousMatch","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","bestResult","leftIsWordBounday","matchStartIndex","matchLength","charBefore","get","firstCharInMatch","rightIsWordBounday","charAfter","lastCharInMatch","searchRegex","_wordSeparators","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec","getNextCodePoint"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 92 /* Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */ || nextChCode === 87 /* W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        let m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}