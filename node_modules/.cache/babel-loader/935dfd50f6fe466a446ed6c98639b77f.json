{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\n\nexport class CursorColumns {\n  static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n    if (codePoint === 9\n    /* Tab */\n    ) {\n      return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n    }\n\n    if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n      return visibleColumn + 2;\n    }\n\n    return visibleColumn + 1;\n  }\n  /**\n   * Returns a visible column from a column.\n   * @see {@link CursorColumns}\n   */\n\n\n  static visibleColumnFromColumn(lineContent, column, tabSize) {\n    const textLen = Math.min(column - 1, lineContent.length);\n    const text = lineContent.substring(0, textLen);\n    const iterator = new strings.GraphemeIterator(text);\n    let result = 0;\n\n    while (!iterator.eol()) {\n      const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n      iterator.nextGraphemeLength();\n      result = this._nextVisibleColumn(codePoint, result, tabSize);\n    }\n\n    return result;\n  }\n  /**\n   * Returns a column from a visible column.\n   * @see {@link CursorColumns}\n   */\n\n\n  static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n    if (visibleColumn <= 0) {\n      return 1;\n    }\n\n    const lineContentLength = lineContent.length;\n    const iterator = new strings.GraphemeIterator(lineContent);\n    let beforeVisibleColumn = 0;\n    let beforeColumn = 1;\n\n    while (!iterator.eol()) {\n      const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n      iterator.nextGraphemeLength();\n\n      const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n\n      const afterColumn = iterator.offset + 1;\n\n      if (afterVisibleColumn >= visibleColumn) {\n        const beforeDelta = visibleColumn - beforeVisibleColumn;\n        const afterDelta = afterVisibleColumn - visibleColumn;\n\n        if (afterDelta < beforeDelta) {\n          return afterColumn;\n        } else {\n          return beforeColumn;\n        }\n      }\n\n      beforeVisibleColumn = afterVisibleColumn;\n      beforeColumn = afterColumn;\n    } // walked the entire string\n\n\n    return lineContentLength + 1;\n  }\n  /**\n   * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n   * @see {@link CursorColumns}\n   */\n\n\n  static nextRenderTabStop(visibleColumn, tabSize) {\n    return visibleColumn + tabSize - visibleColumn % tabSize;\n  }\n  /**\n   * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n   * @see {@link CursorColumns}\n   */\n\n\n  static nextIndentTabStop(visibleColumn, indentSize) {\n    return visibleColumn + indentSize - visibleColumn % indentSize;\n  }\n  /**\n   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n   * @see {@link CursorColumns}\n   */\n\n\n  static prevRenderTabStop(column, tabSize) {\n    return Math.max(0, column - 1 - (column - 1) % tabSize);\n  }\n  /**\n   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n   * @see {@link CursorColumns}\n   */\n\n\n  static prevIndentTabStop(column, indentSize) {\n    return Math.max(0, column - 1 - (column - 1) % indentSize);\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js"],"names":["strings","CursorColumns","_nextVisibleColumn","codePoint","visibleColumn","tabSize","nextRenderTabStop","isFullWidthCharacter","isEmojiImprecise","visibleColumnFromColumn","lineContent","column","textLen","Math","min","length","text","substring","iterator","GraphemeIterator","result","eol","getNextCodePoint","offset","nextGraphemeLength","columnFromVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","beforeDelta","afterDelta","nextIndentTabStop","indentSize","prevRenderTabStop","max","prevIndentTabStop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}