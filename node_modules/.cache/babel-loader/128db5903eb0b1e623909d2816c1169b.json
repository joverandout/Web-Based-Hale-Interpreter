{"ast":null,"code":"import { createMatches as createFuzzyMatches, fuzzyScore } from './filters.js';\nimport { sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { stripWildcards } from './strings.js';\nconst NO_SCORE2 = [undefined, []];\nexport function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {\n  // Score: multiple inputs\n  const preparedQuery = query;\n\n  if (preparedQuery.values && preparedQuery.values.length > 1) {\n    return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n  } // Score: single input\n\n\n  return doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\n\nfunction doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {\n  let totalScore = 0;\n  const totalMatches = [];\n\n  for (const queryPiece of query) {\n    const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n\n    if (typeof score !== 'number') {\n      // if a single query value does not match, return with\n      // no score entirely, we require all queries to match\n      return NO_SCORE2;\n    }\n\n    totalScore += score;\n    totalMatches.push(...matches);\n  } // if we have a score, ensure that the positions are\n  // sorted in ascending order and distinct\n\n\n  return [totalScore, normalizeMatches(totalMatches)];\n}\n\nfunction doScoreFuzzy2Single(target, query, patternStart, wordStart) {\n  const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, true);\n\n  if (!score) {\n    return NO_SCORE2;\n  }\n\n  return [score[0], createFuzzyMatches(score)];\n}\n\nconst NO_ITEM_SCORE = Object.freeze({\n  score: 0\n});\n\nfunction normalizeMatches(matches) {\n  // sort matches by start to be able to normalize\n  const sortedMatches = matches.sort((matchA, matchB) => {\n    return matchA.start - matchB.start;\n  }); // merge matches that overlap\n\n  const normalizedMatches = [];\n  let currentMatch = undefined;\n\n  for (const match of sortedMatches) {\n    // if we have no current match or the matches\n    // do not overlap, we take it as is and remember\n    // it for future merging\n    if (!currentMatch || !matchOverlaps(currentMatch, match)) {\n      currentMatch = match;\n      normalizedMatches.push(match);\n    } // otherwise we merge the matches\n    else {\n      currentMatch.start = Math.min(currentMatch.start, match.start);\n      currentMatch.end = Math.max(currentMatch.end, match.end);\n    }\n  }\n\n  return normalizedMatches;\n}\n\nfunction matchOverlaps(matchA, matchB) {\n  if (matchA.end < matchB.start) {\n    return false; // A ends before B starts\n  }\n\n  if (matchB.end < matchA.start) {\n    return false; // B ends before A starts\n  }\n\n  return true;\n}\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\n\n\nfunction queryExpectsExactMatch(query) {\n  return query.startsWith('\"') && query.endsWith('\"');\n}\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\n\n\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original) {\n  if (typeof original !== 'string') {\n    original = '';\n  }\n\n  const originalLowercase = original.toLowerCase();\n  const {\n    pathNormalized,\n    normalized,\n    normalizedLowercase\n  } = normalizeQuery(original);\n  const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n  const expectExactMatch = queryExpectsExactMatch(original);\n  let values = undefined;\n  const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n\n  if (originalSplit.length > 1) {\n    for (const originalPiece of originalSplit) {\n      const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n      const {\n        pathNormalized: pathNormalizedPiece,\n        normalized: normalizedPiece,\n        normalizedLowercase: normalizedLowercasePiece\n      } = normalizeQuery(originalPiece);\n\n      if (normalizedPiece) {\n        if (!values) {\n          values = [];\n        }\n\n        values.push({\n          original: originalPiece,\n          originalLowercase: originalPiece.toLowerCase(),\n          pathNormalized: pathNormalizedPiece,\n          normalized: normalizedPiece,\n          normalizedLowercase: normalizedLowercasePiece,\n          expectContiguousMatch: expectExactMatchPiece\n        });\n      }\n    }\n  }\n\n  return {\n    original,\n    originalLowercase,\n    pathNormalized,\n    normalized,\n    normalizedLowercase,\n    values,\n    containsPathSeparator,\n    expectContiguousMatch: expectExactMatch\n  };\n}\n\nfunction normalizeQuery(original) {\n  let pathNormalized;\n\n  if (isWindows) {\n    pathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n  } else {\n    pathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n  } // we remove quotes here because quotes are used for exact match search\n\n\n  const normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, '');\n  return {\n    pathNormalized,\n    normalized,\n    normalizedLowercase: normalized.toLowerCase()\n  };\n}\n\nexport function pieceToQuery(arg1) {\n  if (Array.isArray(arg1)) {\n    return prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n  }\n\n  return prepareQuery(arg1.original);\n} //#endregion","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js"],"names":["createMatches","createFuzzyMatches","fuzzyScore","sep","isWindows","stripWildcards","NO_SCORE2","undefined","scoreFuzzy2","target","query","patternStart","wordStart","preparedQuery","values","length","doScoreFuzzy2Multiple","doScoreFuzzy2Single","totalScore","totalMatches","queryPiece","score","matches","push","normalizeMatches","original","originalLowercase","toLowerCase","NO_ITEM_SCORE","Object","freeze","sortedMatches","sort","matchA","matchB","start","normalizedMatches","currentMatch","match","matchOverlaps","Math","min","end","max","queryExpectsExactMatch","startsWith","endsWith","MULTIPLE_QUERY_VALUES_SEPARATOR","prepareQuery","pathNormalized","normalized","normalizedLowercase","normalizeQuery","containsPathSeparator","indexOf","expectExactMatch","originalSplit","split","originalPiece","expectExactMatchPiece","pathNormalizedPiece","normalizedPiece","normalizedLowercasePiece","expectContiguousMatch","replace","pieceToQuery","arg1","Array","isArray","map","piece","join"],"mappings":"AAAA,SAASA,aAAa,IAAIC,kBAA1B,EAA8CC,UAA9C,QAAgE,cAAhE;AACA,SAASC,GAAT,QAAoB,WAApB;AACA,SAASC,SAAT,QAA0B,eAA1B;AACA,SAASC,cAAT,QAA+B,cAA/B;AACA,MAAMC,SAAS,GAAG,CAACC,SAAD,EAAY,EAAZ,CAAlB;AACA,OAAO,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,KAA7B,EAAoCC,YAAY,GAAG,CAAnD,EAAsDC,SAAS,GAAG,CAAlE,EAAqE;AACxE;AACA,QAAMC,aAAa,GAAGH,KAAtB;;AACA,MAAIG,aAAa,CAACC,MAAd,IAAwBD,aAAa,CAACC,MAAd,CAAqBC,MAArB,GAA8B,CAA1D,EAA6D;AACzD,WAAOC,qBAAqB,CAACP,MAAD,EAASI,aAAa,CAACC,MAAvB,EAA+BH,YAA/B,EAA6CC,SAA7C,CAA5B;AACH,GALuE,CAMxE;;;AACA,SAAOK,mBAAmB,CAACR,MAAD,EAASC,KAAT,EAAgBC,YAAhB,EAA8BC,SAA9B,CAA1B;AACH;;AACD,SAASI,qBAAT,CAA+BP,MAA/B,EAAuCC,KAAvC,EAA8CC,YAA9C,EAA4DC,SAA5D,EAAuE;AACnE,MAAIM,UAAU,GAAG,CAAjB;AACA,QAAMC,YAAY,GAAG,EAArB;;AACA,OAAK,MAAMC,UAAX,IAAyBV,KAAzB,EAAgC;AAC5B,UAAM,CAACW,KAAD,EAAQC,OAAR,IAAmBL,mBAAmB,CAACR,MAAD,EAASW,UAAT,EAAqBT,YAArB,EAAmCC,SAAnC,CAA5C;;AACA,QAAI,OAAOS,KAAP,KAAiB,QAArB,EAA+B;AAC3B;AACA;AACA,aAAOf,SAAP;AACH;;AACDY,IAAAA,UAAU,IAAIG,KAAd;AACAF,IAAAA,YAAY,CAACI,IAAb,CAAkB,GAAGD,OAArB;AACH,GAZkE,CAanE;AACA;;;AACA,SAAO,CAACJ,UAAD,EAAaM,gBAAgB,CAACL,YAAD,CAA7B,CAAP;AACH;;AACD,SAASF,mBAAT,CAA6BR,MAA7B,EAAqCC,KAArC,EAA4CC,YAA5C,EAA0DC,SAA1D,EAAqE;AACjE,QAAMS,KAAK,GAAGnB,UAAU,CAACQ,KAAK,CAACe,QAAP,EAAiBf,KAAK,CAACgB,iBAAvB,EAA0Cf,YAA1C,EAAwDF,MAAxD,EAAgEA,MAAM,CAACkB,WAAP,EAAhE,EAAsFf,SAAtF,EAAiG,IAAjG,CAAxB;;AACA,MAAI,CAACS,KAAL,EAAY;AACR,WAAOf,SAAP;AACH;;AACD,SAAO,CAACe,KAAK,CAAC,CAAD,CAAN,EAAWpB,kBAAkB,CAACoB,KAAD,CAA7B,CAAP;AACH;;AACD,MAAMO,aAAa,GAAGC,MAAM,CAACC,MAAP,CAAc;AAAET,EAAAA,KAAK,EAAE;AAAT,CAAd,CAAtB;;AACA,SAASG,gBAAT,CAA0BF,OAA1B,EAAmC;AAC/B;AACA,QAAMS,aAAa,GAAGT,OAAO,CAACU,IAAR,CAAa,CAACC,MAAD,EAASC,MAAT,KAAoB;AACnD,WAAOD,MAAM,CAACE,KAAP,GAAeD,MAAM,CAACC,KAA7B;AACH,GAFqB,CAAtB,CAF+B,CAK/B;;AACA,QAAMC,iBAAiB,GAAG,EAA1B;AACA,MAAIC,YAAY,GAAG9B,SAAnB;;AACA,OAAK,MAAM+B,KAAX,IAAoBP,aAApB,EAAmC;AAC/B;AACA;AACA;AACA,QAAI,CAACM,YAAD,IAAiB,CAACE,aAAa,CAACF,YAAD,EAAeC,KAAf,CAAnC,EAA0D;AACtDD,MAAAA,YAAY,GAAGC,KAAf;AACAF,MAAAA,iBAAiB,CAACb,IAAlB,CAAuBe,KAAvB;AACH,KAHD,CAIA;AAJA,SAKK;AACDD,MAAAA,YAAY,CAACF,KAAb,GAAqBK,IAAI,CAACC,GAAL,CAASJ,YAAY,CAACF,KAAtB,EAA6BG,KAAK,CAACH,KAAnC,CAArB;AACAE,MAAAA,YAAY,CAACK,GAAb,GAAmBF,IAAI,CAACG,GAAL,CAASN,YAAY,CAACK,GAAtB,EAA2BJ,KAAK,CAACI,GAAjC,CAAnB;AACH;AACJ;;AACD,SAAON,iBAAP;AACH;;AACD,SAASG,aAAT,CAAuBN,MAAvB,EAA+BC,MAA/B,EAAuC;AACnC,MAAID,MAAM,CAACS,GAAP,GAAaR,MAAM,CAACC,KAAxB,EAA+B;AAC3B,WAAO,KAAP,CAD2B,CACb;AACjB;;AACD,MAAID,MAAM,CAACQ,GAAP,GAAaT,MAAM,CAACE,KAAxB,EAA+B;AAC3B,WAAO,KAAP,CAD2B,CACb;AACjB;;AACD,SAAO,IAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASS,sBAAT,CAAgClC,KAAhC,EAAuC;AACnC,SAAOA,KAAK,CAACmC,UAAN,CAAiB,GAAjB,KAAyBnC,KAAK,CAACoC,QAAN,CAAe,GAAf,CAAhC;AACH;AACD;AACA;AACA;AACA;;;AACA,MAAMC,+BAA+B,GAAG,GAAxC;AACA,OAAO,SAASC,YAAT,CAAsBvB,QAAtB,EAAgC;AACnC,MAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AAC9BA,IAAAA,QAAQ,GAAG,EAAX;AACH;;AACD,QAAMC,iBAAiB,GAAGD,QAAQ,CAACE,WAAT,EAA1B;AACA,QAAM;AAAEsB,IAAAA,cAAF;AAAkBC,IAAAA,UAAlB;AAA8BC,IAAAA;AAA9B,MAAsDC,cAAc,CAAC3B,QAAD,CAA1E;AACA,QAAM4B,qBAAqB,GAAGJ,cAAc,CAACK,OAAf,CAAuBnD,GAAvB,KAA+B,CAA7D;AACA,QAAMoD,gBAAgB,GAAGX,sBAAsB,CAACnB,QAAD,CAA/C;AACA,MAAIX,MAAM,GAAGP,SAAb;AACA,QAAMiD,aAAa,GAAG/B,QAAQ,CAACgC,KAAT,CAAeV,+BAAf,CAAtB;;AACA,MAAIS,aAAa,CAACzC,MAAd,GAAuB,CAA3B,EAA8B;AAC1B,SAAK,MAAM2C,aAAX,IAA4BF,aAA5B,EAA2C;AACvC,YAAMG,qBAAqB,GAAGf,sBAAsB,CAACc,aAAD,CAApD;AACA,YAAM;AAAET,QAAAA,cAAc,EAAEW,mBAAlB;AAAuCV,QAAAA,UAAU,EAAEW,eAAnD;AAAoEV,QAAAA,mBAAmB,EAAEW;AAAzF,UAAsHV,cAAc,CAACM,aAAD,CAA1I;;AACA,UAAIG,eAAJ,EAAqB;AACjB,YAAI,CAAC/C,MAAL,EAAa;AACTA,UAAAA,MAAM,GAAG,EAAT;AACH;;AACDA,QAAAA,MAAM,CAACS,IAAP,CAAY;AACRE,UAAAA,QAAQ,EAAEiC,aADF;AAERhC,UAAAA,iBAAiB,EAAEgC,aAAa,CAAC/B,WAAd,EAFX;AAGRsB,UAAAA,cAAc,EAAEW,mBAHR;AAIRV,UAAAA,UAAU,EAAEW,eAJJ;AAKRV,UAAAA,mBAAmB,EAAEW,wBALb;AAMRC,UAAAA,qBAAqB,EAAEJ;AANf,SAAZ;AAQH;AACJ;AACJ;;AACD,SAAO;AAAElC,IAAAA,QAAF;AAAYC,IAAAA,iBAAZ;AAA+BuB,IAAAA,cAA/B;AAA+CC,IAAAA,UAA/C;AAA2DC,IAAAA,mBAA3D;AAAgFrC,IAAAA,MAAhF;AAAwFuC,IAAAA,qBAAxF;AAA+GU,IAAAA,qBAAqB,EAAER;AAAtI,GAAP;AACH;;AACD,SAASH,cAAT,CAAwB3B,QAAxB,EAAkC;AAC9B,MAAIwB,cAAJ;;AACA,MAAI7C,SAAJ,EAAe;AACX6C,IAAAA,cAAc,GAAGxB,QAAQ,CAACuC,OAAT,CAAiB,KAAjB,EAAwB7D,GAAxB,CAAjB,CADW,CACoC;AAClD,GAFD,MAGK;AACD8C,IAAAA,cAAc,GAAGxB,QAAQ,CAACuC,OAAT,CAAiB,KAAjB,EAAwB7D,GAAxB,CAAjB,CADC,CAC8C;AAClD,GAP6B,CAQ9B;;;AACA,QAAM+C,UAAU,GAAG7C,cAAc,CAAC4C,cAAD,CAAd,CAA+Be,OAA/B,CAAuC,OAAvC,EAAgD,EAAhD,CAAnB;AACA,SAAO;AACHf,IAAAA,cADG;AAEHC,IAAAA,UAFG;AAGHC,IAAAA,mBAAmB,EAAED,UAAU,CAACvB,WAAX;AAHlB,GAAP;AAKH;;AACD,OAAO,SAASsC,YAAT,CAAsBC,IAAtB,EAA4B;AAC/B,MAAIC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyB;AACrB,WAAOlB,YAAY,CAACkB,IAAI,CAACG,GAAL,CAASC,KAAK,IAAIA,KAAK,CAAC7C,QAAxB,EAAkC8C,IAAlC,CAAuCxB,+BAAvC,CAAD,CAAnB;AACH;;AACD,SAAOC,YAAY,CAACkB,IAAI,CAACzC,QAAN,CAAnB;AACH,C,CACD","sourcesContent":["import { createMatches as createFuzzyMatches, fuzzyScore } from './filters.js';\nimport { sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { stripWildcards } from './strings.js';\nconst NO_SCORE2 = [undefined, []];\nexport function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {\n    // Score: multiple inputs\n    const preparedQuery = query;\n    if (preparedQuery.values && preparedQuery.values.length > 1) {\n        return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n    }\n    // Score: single input\n    return doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\nfunction doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {\n    let totalScore = 0;\n    const totalMatches = [];\n    for (const queryPiece of query) {\n        const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n        if (typeof score !== 'number') {\n            // if a single query value does not match, return with\n            // no score entirely, we require all queries to match\n            return NO_SCORE2;\n        }\n        totalScore += score;\n        totalMatches.push(...matches);\n    }\n    // if we have a score, ensure that the positions are\n    // sorted in ascending order and distinct\n    return [totalScore, normalizeMatches(totalMatches)];\n}\nfunction doScoreFuzzy2Single(target, query, patternStart, wordStart) {\n    const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, true);\n    if (!score) {\n        return NO_SCORE2;\n    }\n    return [score[0], createFuzzyMatches(score)];\n}\nconst NO_ITEM_SCORE = Object.freeze({ score: 0 });\nfunction normalizeMatches(matches) {\n    // sort matches by start to be able to normalize\n    const sortedMatches = matches.sort((matchA, matchB) => {\n        return matchA.start - matchB.start;\n    });\n    // merge matches that overlap\n    const normalizedMatches = [];\n    let currentMatch = undefined;\n    for (const match of sortedMatches) {\n        // if we have no current match or the matches\n        // do not overlap, we take it as is and remember\n        // it for future merging\n        if (!currentMatch || !matchOverlaps(currentMatch, match)) {\n            currentMatch = match;\n            normalizedMatches.push(match);\n        }\n        // otherwise we merge the matches\n        else {\n            currentMatch.start = Math.min(currentMatch.start, match.start);\n            currentMatch.end = Math.max(currentMatch.end, match.end);\n        }\n    }\n    return normalizedMatches;\n}\nfunction matchOverlaps(matchA, matchB) {\n    if (matchA.end < matchB.start) {\n        return false; // A ends before B starts\n    }\n    if (matchB.end < matchA.start) {\n        return false; // B ends before A starts\n    }\n    return true;\n}\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query) {\n    return query.startsWith('\"') && query.endsWith('\"');\n}\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original) {\n    if (typeof original !== 'string') {\n        original = '';\n    }\n    const originalLowercase = original.toLowerCase();\n    const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\n    const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n    const expectExactMatch = queryExpectsExactMatch(original);\n    let values = undefined;\n    const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n    if (originalSplit.length > 1) {\n        for (const originalPiece of originalSplit) {\n            const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n            const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);\n            if (normalizedPiece) {\n                if (!values) {\n                    values = [];\n                }\n                values.push({\n                    original: originalPiece,\n                    originalLowercase: originalPiece.toLowerCase(),\n                    pathNormalized: pathNormalizedPiece,\n                    normalized: normalizedPiece,\n                    normalizedLowercase: normalizedLowercasePiece,\n                    expectContiguousMatch: expectExactMatchPiece\n                });\n            }\n        }\n    }\n    return { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };\n}\nfunction normalizeQuery(original) {\n    let pathNormalized;\n    if (isWindows) {\n        pathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n    }\n    else {\n        pathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n    }\n    // we remove quotes here because quotes are used for exact match search\n    const normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, '');\n    return {\n        pathNormalized,\n        normalized,\n        normalizedLowercase: normalized.toLowerCase()\n    };\n}\nexport function pieceToQuery(arg1) {\n    if (Array.isArray(arg1)) {\n        return prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n    }\n    return prepareQuery(arg1.original);\n}\n//#endregion\n"]},"metadata":{},"sourceType":"module"}