{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\n */\nconst MINIMUM_SLIDER_SIZE = 20;\nexport class ScrollbarState {\n  constructor(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {\n    this._scrollbarSize = Math.round(scrollbarSize);\n    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n    this._arrowSize = Math.round(arrowSize);\n    this._visibleSize = visibleSize;\n    this._scrollSize = scrollSize;\n    this._scrollPosition = scrollPosition;\n    this._computedAvailableSize = 0;\n    this._computedIsNeeded = false;\n    this._computedSliderSize = 0;\n    this._computedSliderRatio = 0;\n    this._computedSliderPosition = 0;\n\n    this._refreshComputedValues();\n  }\n\n  clone() {\n    return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n  }\n\n  setVisibleSize(visibleSize) {\n    const iVisibleSize = Math.round(visibleSize);\n\n    if (this._visibleSize !== iVisibleSize) {\n      this._visibleSize = iVisibleSize;\n\n      this._refreshComputedValues();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  setScrollSize(scrollSize) {\n    const iScrollSize = Math.round(scrollSize);\n\n    if (this._scrollSize !== iScrollSize) {\n      this._scrollSize = iScrollSize;\n\n      this._refreshComputedValues();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  setScrollPosition(scrollPosition) {\n    const iScrollPosition = Math.round(scrollPosition);\n\n    if (this._scrollPosition !== iScrollPosition) {\n      this._scrollPosition = iScrollPosition;\n\n      this._refreshComputedValues();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  setScrollbarSize(scrollbarSize) {\n    this._scrollbarSize = Math.round(scrollbarSize);\n  }\n\n  setOppositeScrollbarSize(oppositeScrollbarSize) {\n    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n  }\n\n  static _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {\n    const computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n    const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n    const computedIsNeeded = scrollSize > 0 && scrollSize > visibleSize;\n\n    if (!computedIsNeeded) {\n      // There is no need for a slider\n      return {\n        computedAvailableSize: Math.round(computedAvailableSize),\n        computedIsNeeded: computedIsNeeded,\n        computedSliderSize: Math.round(computedRepresentableSize),\n        computedSliderRatio: 0,\n        computedSliderPosition: 0\n      };\n    } // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n\n\n    const computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize))); // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n    // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n\n    const computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n    const computedSliderPosition = scrollPosition * computedSliderRatio;\n    return {\n      computedAvailableSize: Math.round(computedAvailableSize),\n      computedIsNeeded: computedIsNeeded,\n      computedSliderSize: Math.round(computedSliderSize),\n      computedSliderRatio: computedSliderRatio,\n      computedSliderPosition: Math.round(computedSliderPosition)\n    };\n  }\n\n  _refreshComputedValues() {\n    const r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n\n    this._computedAvailableSize = r.computedAvailableSize;\n    this._computedIsNeeded = r.computedIsNeeded;\n    this._computedSliderSize = r.computedSliderSize;\n    this._computedSliderRatio = r.computedSliderRatio;\n    this._computedSliderPosition = r.computedSliderPosition;\n  }\n\n  getArrowSize() {\n    return this._arrowSize;\n  }\n\n  getScrollPosition() {\n    return this._scrollPosition;\n  }\n\n  getRectangleLargeSize() {\n    return this._computedAvailableSize;\n  }\n\n  getRectangleSmallSize() {\n    return this._scrollbarSize;\n  }\n\n  isNeeded() {\n    return this._computedIsNeeded;\n  }\n\n  getSliderSize() {\n    return this._computedSliderSize;\n  }\n\n  getSliderPosition() {\n    return this._computedSliderPosition;\n  }\n  /**\n   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\n   * `offset` is based on the same coordinate system as the `sliderPosition`.\n   */\n\n\n  getDesiredScrollPositionFromOffset(offset) {\n    if (!this._computedIsNeeded) {\n      // no need for a slider\n      return 0;\n    }\n\n    const desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n    return Math.round(desiredSliderPosition / this._computedSliderRatio);\n  }\n  /**\n   * Compute a desired `scrollPosition` from if offset is before or after the slider position.\n   * If offset is before slider, treat as a page up (or left).  If after, page down (or right).\n   * `offset` and `_computedSliderPosition` are based on the same coordinate system.\n   * `_visibleSize` corresponds to a \"page\" of lines in the returned coordinate system.\n   */\n\n\n  getDesiredScrollPositionFromOffsetPaged(offset) {\n    if (!this._computedIsNeeded) {\n      // no need for a slider\n      return 0;\n    }\n\n    const correctedOffset = offset - this._arrowSize; // compensate if has arrows\n\n    let desiredScrollPosition = this._scrollPosition;\n\n    if (correctedOffset < this._computedSliderPosition) {\n      desiredScrollPosition -= this._visibleSize; // page up/left\n    } else {\n      desiredScrollPosition += this._visibleSize; // page down/right\n    }\n\n    return desiredScrollPosition;\n  }\n  /**\n   * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n   */\n\n\n  getDesiredScrollPositionFromDelta(delta) {\n    if (!this._computedIsNeeded) {\n      // no need for a slider\n      return 0;\n    }\n\n    const desiredSliderPosition = this._computedSliderPosition + delta;\n    return Math.round(desiredSliderPosition / this._computedSliderRatio);\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarState.js"],"names":["MINIMUM_SLIDER_SIZE","ScrollbarState","constructor","arrowSize","scrollbarSize","oppositeScrollbarSize","visibleSize","scrollSize","scrollPosition","_scrollbarSize","Math","round","_oppositeScrollbarSize","_arrowSize","_visibleSize","_scrollSize","_scrollPosition","_computedAvailableSize","_computedIsNeeded","_computedSliderSize","_computedSliderRatio","_computedSliderPosition","_refreshComputedValues","clone","setVisibleSize","iVisibleSize","setScrollSize","iScrollSize","setScrollPosition","iScrollPosition","setScrollbarSize","setOppositeScrollbarSize","_computeValues","computedAvailableSize","max","computedRepresentableSize","computedIsNeeded","computedSliderSize","computedSliderRatio","computedSliderPosition","floor","r","getArrowSize","getScrollPosition","getRectangleLargeSize","getRectangleSmallSize","isNeeded","getSliderSize","getSliderPosition","getDesiredScrollPositionFromOffset","offset","desiredSliderPosition","getDesiredScrollPositionFromOffsetPaged","correctedOffset","desiredScrollPosition","getDesiredScrollPositionFromDelta","delta"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\n */\nconst MINIMUM_SLIDER_SIZE = 20;\nexport class ScrollbarState {\n    constructor(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {\n        this._scrollbarSize = Math.round(scrollbarSize);\n        this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n        this._arrowSize = Math.round(arrowSize);\n        this._visibleSize = visibleSize;\n        this._scrollSize = scrollSize;\n        this._scrollPosition = scrollPosition;\n        this._computedAvailableSize = 0;\n        this._computedIsNeeded = false;\n        this._computedSliderSize = 0;\n        this._computedSliderRatio = 0;\n        this._computedSliderPosition = 0;\n        this._refreshComputedValues();\n    }\n    clone() {\n        return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n    }\n    setVisibleSize(visibleSize) {\n        const iVisibleSize = Math.round(visibleSize);\n        if (this._visibleSize !== iVisibleSize) {\n            this._visibleSize = iVisibleSize;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    }\n    setScrollSize(scrollSize) {\n        const iScrollSize = Math.round(scrollSize);\n        if (this._scrollSize !== iScrollSize) {\n            this._scrollSize = iScrollSize;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    }\n    setScrollPosition(scrollPosition) {\n        const iScrollPosition = Math.round(scrollPosition);\n        if (this._scrollPosition !== iScrollPosition) {\n            this._scrollPosition = iScrollPosition;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    }\n    setScrollbarSize(scrollbarSize) {\n        this._scrollbarSize = Math.round(scrollbarSize);\n    }\n    setOppositeScrollbarSize(oppositeScrollbarSize) {\n        this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n    }\n    static _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {\n        const computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n        const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n        const computedIsNeeded = (scrollSize > 0 && scrollSize > visibleSize);\n        if (!computedIsNeeded) {\n            // There is no need for a slider\n            return {\n                computedAvailableSize: Math.round(computedAvailableSize),\n                computedIsNeeded: computedIsNeeded,\n                computedSliderSize: Math.round(computedRepresentableSize),\n                computedSliderRatio: 0,\n                computedSliderPosition: 0,\n            };\n        }\n        // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n        const computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));\n        // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n        // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n        const computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n        const computedSliderPosition = (scrollPosition * computedSliderRatio);\n        return {\n            computedAvailableSize: Math.round(computedAvailableSize),\n            computedIsNeeded: computedIsNeeded,\n            computedSliderSize: Math.round(computedSliderSize),\n            computedSliderRatio: computedSliderRatio,\n            computedSliderPosition: Math.round(computedSliderPosition),\n        };\n    }\n    _refreshComputedValues() {\n        const r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n        this._computedAvailableSize = r.computedAvailableSize;\n        this._computedIsNeeded = r.computedIsNeeded;\n        this._computedSliderSize = r.computedSliderSize;\n        this._computedSliderRatio = r.computedSliderRatio;\n        this._computedSliderPosition = r.computedSliderPosition;\n    }\n    getArrowSize() {\n        return this._arrowSize;\n    }\n    getScrollPosition() {\n        return this._scrollPosition;\n    }\n    getRectangleLargeSize() {\n        return this._computedAvailableSize;\n    }\n    getRectangleSmallSize() {\n        return this._scrollbarSize;\n    }\n    isNeeded() {\n        return this._computedIsNeeded;\n    }\n    getSliderSize() {\n        return this._computedSliderSize;\n    }\n    getSliderPosition() {\n        return this._computedSliderPosition;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\n     * `offset` is based on the same coordinate system as the `sliderPosition`.\n     */\n    getDesiredScrollPositionFromOffset(offset) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        const desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    }\n    /**\n     * Compute a desired `scrollPosition` from if offset is before or after the slider position.\n     * If offset is before slider, treat as a page up (or left).  If after, page down (or right).\n     * `offset` and `_computedSliderPosition` are based on the same coordinate system.\n     * `_visibleSize` corresponds to a \"page\" of lines in the returned coordinate system.\n     */\n    getDesiredScrollPositionFromOffsetPaged(offset) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        const correctedOffset = offset - this._arrowSize; // compensate if has arrows\n        let desiredScrollPosition = this._scrollPosition;\n        if (correctedOffset < this._computedSliderPosition) {\n            desiredScrollPosition -= this._visibleSize; // page up/left\n        }\n        else {\n            desiredScrollPosition += this._visibleSize; // page down/right\n        }\n        return desiredScrollPosition;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n    getDesiredScrollPositionFromDelta(delta) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        const desiredSliderPosition = this._computedSliderPosition + delta;\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}