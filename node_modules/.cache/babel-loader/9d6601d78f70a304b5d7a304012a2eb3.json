{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = new Uint32Array(0).buffer;\nexport class ContiguousTokensEditing {\n  static deleteBeginning(lineTokens, toChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n\n    return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n  }\n\n  static deleteEnding(lineTokens, fromChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n\n    const tokens = toUint32Array(lineTokens);\n    const lineTextLength = tokens[tokens.length - 2];\n    return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n  }\n\n  static delete(lineTokens, fromChIndex, toChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n      return lineTokens;\n    }\n\n    const tokens = toUint32Array(lineTokens);\n    const tokensCount = tokens.length >>> 1; // special case: deleting everything\n\n    if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n      return EMPTY_LINE_TOKENS;\n    }\n\n    const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n    const fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;\n    const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n\n    if (toChIndex < fromTokenEndOffset) {\n      // the delete range is inside a single token\n      const delta = toChIndex - fromChIndex;\n\n      for (let i = fromTokenIndex; i < tokensCount; i++) {\n        tokens[i << 1] -= delta;\n      }\n\n      return lineTokens;\n    }\n\n    let dest;\n    let lastEnd;\n\n    if (fromTokenStartOffset !== fromChIndex) {\n      tokens[fromTokenIndex << 1] = fromChIndex;\n      dest = fromTokenIndex + 1 << 1;\n      lastEnd = fromChIndex;\n    } else {\n      dest = fromTokenIndex << 1;\n      lastEnd = fromTokenStartOffset;\n    }\n\n    const delta = toChIndex - fromChIndex;\n\n    for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n      const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n\n      if (tokenEndOffset > lastEnd) {\n        tokens[dest++] = tokenEndOffset;\n        tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n        lastEnd = tokenEndOffset;\n      }\n    }\n\n    if (dest === tokens.length) {\n      // nothing to trim\n      return lineTokens;\n    }\n\n    const tmp = new Uint32Array(dest);\n    tmp.set(tokens.subarray(0, dest), 0);\n    return tmp.buffer;\n  }\n\n  static append(lineTokens, _otherTokens) {\n    if (_otherTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n\n    if (lineTokens === EMPTY_LINE_TOKENS) {\n      return _otherTokens;\n    }\n\n    if (lineTokens === null) {\n      return lineTokens;\n    }\n\n    if (_otherTokens === null) {\n      // cannot determine combined line length...\n      return null;\n    }\n\n    const myTokens = toUint32Array(lineTokens);\n    const otherTokens = toUint32Array(_otherTokens);\n    const otherTokensCount = otherTokens.length >>> 1;\n    const result = new Uint32Array(myTokens.length + otherTokens.length);\n    result.set(myTokens, 0);\n    let dest = myTokens.length;\n    const delta = myTokens[myTokens.length - 2];\n\n    for (let i = 0; i < otherTokensCount; i++) {\n      result[dest++] = otherTokens[i << 1] + delta;\n      result[dest++] = otherTokens[(i << 1) + 1];\n    }\n\n    return result.buffer;\n  }\n\n  static insert(lineTokens, chIndex, textLength) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      // nothing to do\n      return lineTokens;\n    }\n\n    const tokens = toUint32Array(lineTokens);\n    const tokensCount = tokens.length >>> 1;\n    let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n\n    if (fromTokenIndex > 0) {\n      const fromTokenStartOffset = tokens[fromTokenIndex - 1 << 1];\n\n      if (fromTokenStartOffset === chIndex) {\n        fromTokenIndex--;\n      }\n    }\n\n    for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n      tokens[tokenIndex << 1] += textLength;\n    }\n\n    return lineTokens;\n  }\n\n}\nexport function toUint32Array(arr) {\n  if (arr instanceof Uint32Array) {\n    return arr;\n  } else {\n    return new Uint32Array(arr);\n  }\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js"],"names":["LineTokens","EMPTY_LINE_TOKENS","Uint32Array","buffer","ContiguousTokensEditing","deleteBeginning","lineTokens","toChIndex","delete","deleteEnding","fromChIndex","tokens","toUint32Array","lineTextLength","length","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","fromTokenEndOffset","delta","i","dest","lastEnd","tokenIndex","tokenEndOffset","tmp","set","subarray","append","_otherTokens","myTokens","otherTokens","otherTokensCount","result","insert","chIndex","textLength","arr"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}