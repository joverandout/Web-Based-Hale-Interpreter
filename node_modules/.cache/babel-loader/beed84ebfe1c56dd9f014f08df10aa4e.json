{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { createCancelablePromise, first, timeout } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution, registerModelAndPositionCommand } from '../../../browser/editorExtensions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { MinimapPosition, OverviewRulerLane } from '../../../common/model.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { DocumentHighlightKind, DocumentHighlightProviderRegistry } from '../../../common/languages.js';\nimport * as nls from '../../../../nls.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { activeContrastBorder, editorSelectionHighlight, editorSelectionHighlightBorder, minimapSelectionOccurrenceHighlight, overviewRulerSelectionHighlightForeground, registerColor } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant, themeColorFromId } from '../../../../platform/theme/common/themeService.js';\nconst editorWordHighlight = registerColor('editor.wordHighlightBackground', {\n  dark: '#575757B8',\n  light: '#57575740',\n  hc: null\n}, nls.localize('wordHighlight', 'Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations.'), true);\nconst editorWordHighlightStrong = registerColor('editor.wordHighlightStrongBackground', {\n  dark: '#004972B8',\n  light: '#0e639c40',\n  hc: null\n}, nls.localize('wordHighlightStrong', 'Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations.'), true);\nconst editorWordHighlightBorder = registerColor('editor.wordHighlightBorder', {\n  light: null,\n  dark: null,\n  hc: activeContrastBorder\n}, nls.localize('wordHighlightBorder', 'Border color of a symbol during read-access, like reading a variable.'));\nconst editorWordHighlightStrongBorder = registerColor('editor.wordHighlightStrongBorder', {\n  light: null,\n  dark: null,\n  hc: activeContrastBorder\n}, nls.localize('wordHighlightStrongBorder', 'Border color of a symbol during write-access, like writing to a variable.'));\nconst overviewRulerWordHighlightForeground = registerColor('editorOverviewRuler.wordHighlightForeground', {\n  dark: '#A0A0A0CC',\n  light: '#A0A0A0CC',\n  hc: '#A0A0A0CC'\n}, nls.localize('overviewRulerWordHighlightForeground', 'Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nconst overviewRulerWordHighlightStrongForeground = registerColor('editorOverviewRuler.wordHighlightStrongForeground', {\n  dark: '#C0A0C0CC',\n  light: '#C0A0C0CC',\n  hc: '#C0A0C0CC'\n}, nls.localize('overviewRulerWordHighlightStrongForeground', 'Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nconst ctxHasWordHighlights = new RawContextKey('hasWordHighlights', false);\nexport function getOccurrencesAtPosition(model, position, token) {\n  const orderedByScore = DocumentHighlightProviderRegistry.ordered(model); // in order of score ask the occurrences provider\n  // until someone response with a good result\n  // (good = none empty array)\n\n  return first(orderedByScore.map(provider => () => {\n    return Promise.resolve(provider.provideDocumentHighlights(model, position, token)).then(undefined, onUnexpectedExternalError);\n  }), arrays.isNonEmptyArray);\n}\n\nclass OccurenceAtPositionRequest {\n  constructor(model, selection, wordSeparators) {\n    this._wordRange = this._getCurrentWordRange(model, selection);\n    this.result = createCancelablePromise(token => this._compute(model, selection, wordSeparators, token));\n  }\n\n  _getCurrentWordRange(model, selection) {\n    const word = model.getWordAtPosition(selection.getPosition());\n\n    if (word) {\n      return new Range(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);\n    }\n\n    return null;\n  }\n\n  isValid(model, selection, decorationIds) {\n    const lineNumber = selection.startLineNumber;\n    const startColumn = selection.startColumn;\n    const endColumn = selection.endColumn;\n\n    const currentWordRange = this._getCurrentWordRange(model, selection);\n\n    let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange)); // Even if we are on a different word, if that word is in the decorations ranges, the request is still valid\n    // (Same symbol)\n\n    for (let i = 0, len = decorationIds.length; !requestIsValid && i < len; i++) {\n      let range = model.getDecorationRange(decorationIds[i]);\n\n      if (range && range.startLineNumber === lineNumber) {\n        if (range.startColumn <= startColumn && range.endColumn >= endColumn) {\n          requestIsValid = true;\n        }\n      }\n    }\n\n    return requestIsValid;\n  }\n\n  cancel() {\n    this.result.cancel();\n  }\n\n}\n\nclass SemanticOccurenceAtPositionRequest extends OccurenceAtPositionRequest {\n  _compute(model, selection, wordSeparators, token) {\n    return getOccurrencesAtPosition(model, selection.getPosition(), token).then(value => value || []);\n  }\n\n}\n\nclass TextualOccurenceAtPositionRequest extends OccurenceAtPositionRequest {\n  constructor(model, selection, wordSeparators) {\n    super(model, selection, wordSeparators);\n    this._selectionIsEmpty = selection.isEmpty();\n  }\n\n  _compute(model, selection, wordSeparators, token) {\n    return timeout(250, token).then(() => {\n      if (!selection.isEmpty()) {\n        return [];\n      }\n\n      const word = model.getWordAtPosition(selection.getPosition());\n\n      if (!word || word.word.length > 1000) {\n        return [];\n      }\n\n      const matches = model.findMatches(word.word, true, false, true, wordSeparators, false);\n      return matches.map(m => {\n        return {\n          range: m.range,\n          kind: DocumentHighlightKind.Text\n        };\n      });\n    });\n  }\n\n  isValid(model, selection, decorationIds) {\n    const currentSelectionIsEmpty = selection.isEmpty();\n\n    if (this._selectionIsEmpty !== currentSelectionIsEmpty) {\n      return false;\n    }\n\n    return super.isValid(model, selection, decorationIds);\n  }\n\n}\n\nfunction computeOccurencesAtPosition(model, selection, wordSeparators) {\n  if (DocumentHighlightProviderRegistry.has(model)) {\n    return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators);\n  }\n\n  return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators);\n}\n\nregisterModelAndPositionCommand('_executeDocumentHighlights', (model, position) => getOccurrencesAtPosition(model, position, CancellationToken.None));\n\nclass WordHighlighter {\n  constructor(editor, contextKeyService) {\n    this.toUnhook = new DisposableStore();\n    this.workerRequestTokenId = 0;\n    this.workerRequestCompleted = false;\n    this.workerRequestValue = [];\n    this.lastCursorPositionChangeTime = 0;\n    this.renderDecorationsTimer = -1;\n    this.editor = editor;\n    this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);\n    this._ignorePositionChangeEvent = false;\n    this.occurrencesHighlight = this.editor.getOption(72\n    /* occurrencesHighlight */\n    );\n    this.model = this.editor.getModel();\n    this.toUnhook.add(editor.onDidChangeCursorPosition(e => {\n      if (this._ignorePositionChangeEvent) {\n        // We are changing the position => ignore this event\n        return;\n      }\n\n      if (!this.occurrencesHighlight) {\n        // Early exit if nothing needs to be done!\n        // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n        return;\n      }\n\n      this._onPositionChanged(e);\n    }));\n    this.toUnhook.add(editor.onDidChangeModelContent(e => {\n      this._stopAll();\n    }));\n    this.toUnhook.add(editor.onDidChangeConfiguration(e => {\n      let newValue = this.editor.getOption(72\n      /* occurrencesHighlight */\n      );\n\n      if (this.occurrencesHighlight !== newValue) {\n        this.occurrencesHighlight = newValue;\n\n        this._stopAll();\n      }\n    }));\n    this._decorationIds = [];\n    this.workerRequestTokenId = 0;\n    this.workerRequest = null;\n    this.workerRequestCompleted = false;\n    this.lastCursorPositionChangeTime = 0;\n    this.renderDecorationsTimer = -1;\n  }\n\n  hasDecorations() {\n    return this._decorationIds.length > 0;\n  }\n\n  restore() {\n    if (!this.occurrencesHighlight) {\n      return;\n    }\n\n    this._run();\n  }\n\n  _getSortedHighlights() {\n    return arrays.coalesce(this._decorationIds.map(id => this.model.getDecorationRange(id)).sort(Range.compareRangesUsingStarts));\n  }\n\n  moveNext() {\n    let highlights = this._getSortedHighlights();\n\n    let index = highlights.findIndex(range => range.containsPosition(this.editor.getPosition()));\n    let newIndex = (index + 1) % highlights.length;\n    let dest = highlights[newIndex];\n\n    try {\n      this._ignorePositionChangeEvent = true;\n      this.editor.setPosition(dest.getStartPosition());\n      this.editor.revealRangeInCenterIfOutsideViewport(dest);\n\n      const word = this._getWord();\n\n      if (word) {\n        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);\n        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);\n      }\n    } finally {\n      this._ignorePositionChangeEvent = false;\n    }\n  }\n\n  moveBack() {\n    let highlights = this._getSortedHighlights();\n\n    let index = highlights.findIndex(range => range.containsPosition(this.editor.getPosition()));\n    let newIndex = (index - 1 + highlights.length) % highlights.length;\n    let dest = highlights[newIndex];\n\n    try {\n      this._ignorePositionChangeEvent = true;\n      this.editor.setPosition(dest.getStartPosition());\n      this.editor.revealRangeInCenterIfOutsideViewport(dest);\n\n      const word = this._getWord();\n\n      if (word) {\n        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);\n        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);\n      }\n    } finally {\n      this._ignorePositionChangeEvent = false;\n    }\n  }\n\n  _removeDecorations() {\n    if (this._decorationIds.length > 0) {\n      // remove decorations\n      this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);\n\n      this._hasWordHighlights.set(false);\n    }\n  }\n\n  _stopAll() {\n    // Remove any existing decorations\n    this._removeDecorations(); // Cancel any renderDecorationsTimer\n\n\n    if (this.renderDecorationsTimer !== -1) {\n      clearTimeout(this.renderDecorationsTimer);\n      this.renderDecorationsTimer = -1;\n    } // Cancel any worker request\n\n\n    if (this.workerRequest !== null) {\n      this.workerRequest.cancel();\n      this.workerRequest = null;\n    } // Invalidate any worker request callback\n\n\n    if (!this.workerRequestCompleted) {\n      this.workerRequestTokenId++;\n      this.workerRequestCompleted = true;\n    }\n  }\n\n  _onPositionChanged(e) {\n    // disabled\n    if (!this.occurrencesHighlight) {\n      this._stopAll();\n\n      return;\n    } // ignore typing & other\n\n\n    if (e.reason !== 3\n    /* Explicit */\n    ) {\n      this._stopAll();\n\n      return;\n    }\n\n    this._run();\n  }\n\n  _getWord() {\n    let editorSelection = this.editor.getSelection();\n    let lineNumber = editorSelection.startLineNumber;\n    let startColumn = editorSelection.startColumn;\n    return this.model.getWordAtPosition({\n      lineNumber: lineNumber,\n      column: startColumn\n    });\n  }\n\n  _run() {\n    let editorSelection = this.editor.getSelection(); // ignore multiline selection\n\n    if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {\n      this._stopAll();\n\n      return;\n    }\n\n    let startColumn = editorSelection.startColumn;\n    let endColumn = editorSelection.endColumn;\n\n    const word = this._getWord(); // The selection must be inside a word or surround one word at most\n\n\n    if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {\n      this._stopAll();\n\n      return;\n    } // All the effort below is trying to achieve this:\n    // - when cursor is moved to a word, trigger immediately a findOccurrences request\n    // - 250ms later after the last cursor move event, render the occurrences\n    // - no flickering!\n\n\n    const workerRequestIsValid = this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this._decorationIds); // There are 4 cases:\n    // a) old workerRequest is valid & completed, renderDecorationsTimer fired\n    // b) old workerRequest is valid & completed, renderDecorationsTimer not fired\n    // c) old workerRequest is valid, but not completed\n    // d) old workerRequest is not valid\n    // For a) no action is needed\n    // For c), member 'lastCursorPositionChangeTime' will be used when installing the timer so no action is needed\n\n    this.lastCursorPositionChangeTime = new Date().getTime();\n\n    if (workerRequestIsValid) {\n      if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {\n        // case b)\n        // Delay the firing of renderDecorationsTimer by an extra 250 ms\n        clearTimeout(this.renderDecorationsTimer);\n        this.renderDecorationsTimer = -1;\n\n        this._beginRenderDecorations();\n      }\n    } else {\n      // case d)\n      // Stop all previous actions and start fresh\n      this._stopAll();\n\n      let myRequestId = ++this.workerRequestTokenId;\n      this.workerRequestCompleted = false;\n      this.workerRequest = computeOccurencesAtPosition(this.model, this.editor.getSelection(), this.editor.getOption(117\n      /* wordSeparators */\n      ));\n      this.workerRequest.result.then(data => {\n        if (myRequestId === this.workerRequestTokenId) {\n          this.workerRequestCompleted = true;\n          this.workerRequestValue = data || [];\n\n          this._beginRenderDecorations();\n        }\n      }, onUnexpectedError);\n    }\n  }\n\n  _beginRenderDecorations() {\n    let currentTime = new Date().getTime();\n    let minimumRenderTime = this.lastCursorPositionChangeTime + 250;\n\n    if (currentTime >= minimumRenderTime) {\n      // Synchronous\n      this.renderDecorationsTimer = -1;\n      this.renderDecorations();\n    } else {\n      // Asynchronous\n      this.renderDecorationsTimer = setTimeout(() => {\n        this.renderDecorations();\n      }, minimumRenderTime - currentTime);\n    }\n  }\n\n  renderDecorations() {\n    this.renderDecorationsTimer = -1;\n    let decorations = [];\n\n    for (const info of this.workerRequestValue) {\n      if (info.range) {\n        decorations.push({\n          range: info.range,\n          options: WordHighlighter._getDecorationOptions(info.kind)\n        });\n      }\n    }\n\n    this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);\n\n    this._hasWordHighlights.set(this.hasDecorations());\n  }\n\n  static _getDecorationOptions(kind) {\n    if (kind === DocumentHighlightKind.Write) {\n      return this._WRITE_OPTIONS;\n    } else if (kind === DocumentHighlightKind.Text) {\n      return this._TEXT_OPTIONS;\n    } else {\n      return this._REGULAR_OPTIONS;\n    }\n  }\n\n  dispose() {\n    this._stopAll();\n\n    this.toUnhook.dispose();\n  }\n\n}\n\nWordHighlighter._WRITE_OPTIONS = ModelDecorationOptions.register({\n  description: 'word-highlight-strong',\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n  ,\n  className: 'wordHighlightStrong',\n  overviewRuler: {\n    color: themeColorFromId(overviewRulerWordHighlightStrongForeground),\n    position: OverviewRulerLane.Center\n  },\n  minimap: {\n    color: themeColorFromId(minimapSelectionOccurrenceHighlight),\n    position: MinimapPosition.Inline\n  }\n});\nWordHighlighter._TEXT_OPTIONS = ModelDecorationOptions.register({\n  description: 'selection-highlight',\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n  ,\n  className: 'selectionHighlight',\n  overviewRuler: {\n    color: themeColorFromId(overviewRulerSelectionHighlightForeground),\n    position: OverviewRulerLane.Center\n  },\n  minimap: {\n    color: themeColorFromId(minimapSelectionOccurrenceHighlight),\n    position: MinimapPosition.Inline\n  }\n});\nWordHighlighter._REGULAR_OPTIONS = ModelDecorationOptions.register({\n  description: 'word-highlight',\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n  ,\n  className: 'wordHighlight',\n  overviewRuler: {\n    color: themeColorFromId(overviewRulerWordHighlightForeground),\n    position: OverviewRulerLane.Center\n  },\n  minimap: {\n    color: themeColorFromId(minimapSelectionOccurrenceHighlight),\n    position: MinimapPosition.Inline\n  }\n});\nlet WordHighlighterContribution = class WordHighlighterContribution extends Disposable {\n  constructor(editor, contextKeyService) {\n    super();\n    this.wordHighlighter = null;\n\n    const createWordHighlighterIfPossible = () => {\n      if (editor.hasModel()) {\n        this.wordHighlighter = new WordHighlighter(editor, contextKeyService);\n      }\n    };\n\n    this._register(editor.onDidChangeModel(e => {\n      if (this.wordHighlighter) {\n        this.wordHighlighter.dispose();\n        this.wordHighlighter = null;\n      }\n\n      createWordHighlighterIfPossible();\n    }));\n\n    createWordHighlighterIfPossible();\n  }\n\n  static get(editor) {\n    return editor.getContribution(WordHighlighterContribution.ID);\n  }\n\n  saveViewState() {\n    if (this.wordHighlighter && this.wordHighlighter.hasDecorations()) {\n      return true;\n    }\n\n    return false;\n  }\n\n  moveNext() {\n    if (this.wordHighlighter) {\n      this.wordHighlighter.moveNext();\n    }\n  }\n\n  moveBack() {\n    if (this.wordHighlighter) {\n      this.wordHighlighter.moveBack();\n    }\n  }\n\n  restoreViewState(state) {\n    if (this.wordHighlighter && state) {\n      this.wordHighlighter.restore();\n    }\n  }\n\n  dispose() {\n    if (this.wordHighlighter) {\n      this.wordHighlighter.dispose();\n      this.wordHighlighter = null;\n    }\n\n    super.dispose();\n  }\n\n};\nWordHighlighterContribution.ID = 'editor.contrib.wordHighlighter';\nWordHighlighterContribution = __decorate([__param(1, IContextKeyService)], WordHighlighterContribution);\n\nclass WordHighlightNavigationAction extends EditorAction {\n  constructor(next, opts) {\n    super(opts);\n    this._isNext = next;\n  }\n\n  run(accessor, editor) {\n    const controller = WordHighlighterContribution.get(editor);\n\n    if (!controller) {\n      return;\n    }\n\n    if (this._isNext) {\n      controller.moveNext();\n    } else {\n      controller.moveBack();\n    }\n  }\n\n}\n\nclass NextWordHighlightAction extends WordHighlightNavigationAction {\n  constructor() {\n    super(true, {\n      id: 'editor.action.wordHighlight.next',\n      label: nls.localize('wordHighlight.next.label', \"Go to Next Symbol Highlight\"),\n      alias: 'Go to Next Symbol Highlight',\n      precondition: ctxHasWordHighlights,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 65\n        /* F7 */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    });\n  }\n\n}\n\nclass PrevWordHighlightAction extends WordHighlightNavigationAction {\n  constructor() {\n    super(false, {\n      id: 'editor.action.wordHighlight.prev',\n      label: nls.localize('wordHighlight.previous.label', \"Go to Previous Symbol Highlight\"),\n      alias: 'Go to Previous Symbol Highlight',\n      precondition: ctxHasWordHighlights,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 1024\n        /* Shift */\n        | 65\n        /* F7 */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    });\n  }\n\n}\n\nclass TriggerWordHighlightAction extends EditorAction {\n  constructor() {\n    super({\n      id: 'editor.action.wordHighlight.trigger',\n      label: nls.localize('wordHighlight.trigger.label', \"Trigger Symbol Highlight\"),\n      alias: 'Trigger Symbol Highlight',\n      precondition: ctxHasWordHighlights.toNegated(),\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 0,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    });\n  }\n\n  run(accessor, editor, args) {\n    const controller = WordHighlighterContribution.get(editor);\n\n    if (!controller) {\n      return;\n    }\n\n    controller.restoreViewState(true);\n  }\n\n}\n\nregisterEditorContribution(WordHighlighterContribution.ID, WordHighlighterContribution);\nregisterEditorAction(NextWordHighlightAction);\nregisterEditorAction(PrevWordHighlightAction);\nregisterEditorAction(TriggerWordHighlightAction);\nregisterThemingParticipant((theme, collector) => {\n  const selectionHighlight = theme.getColor(editorSelectionHighlight);\n\n  if (selectionHighlight) {\n    collector.addRule(`.monaco-editor .focused .selectionHighlight { background-color: ${selectionHighlight}; }`);\n    collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);\n  }\n\n  const wordHighlight = theme.getColor(editorWordHighlight);\n\n  if (wordHighlight) {\n    collector.addRule(`.monaco-editor .wordHighlight { background-color: ${wordHighlight}; }`);\n  }\n\n  const wordHighlightStrong = theme.getColor(editorWordHighlightStrong);\n\n  if (wordHighlightStrong) {\n    collector.addRule(`.monaco-editor .wordHighlightStrong { background-color: ${wordHighlightStrong}; }`);\n  }\n\n  const selectionHighlightBorder = theme.getColor(editorSelectionHighlightBorder);\n\n  if (selectionHighlightBorder) {\n    collector.addRule(`.monaco-editor .selectionHighlight { border: 1px ${theme.type === 'hc' ? 'dotted' : 'solid'} ${selectionHighlightBorder}; box-sizing: border-box; }`);\n  }\n\n  const wordHighlightBorder = theme.getColor(editorWordHighlightBorder);\n\n  if (wordHighlightBorder) {\n    collector.addRule(`.monaco-editor .wordHighlight { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${wordHighlightBorder}; box-sizing: border-box; }`);\n  }\n\n  const wordHighlightStrongBorder = theme.getColor(editorWordHighlightStrongBorder);\n\n  if (wordHighlightStrongBorder) {\n    collector.addRule(`.monaco-editor .wordHighlightStrong { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${wordHighlightStrongBorder}; box-sizing: border-box; }`);\n  }\n});","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","alert","arrays","createCancelablePromise","first","timeout","CancellationToken","onUnexpectedError","onUnexpectedExternalError","Disposable","DisposableStore","EditorAction","registerEditorAction","registerEditorContribution","registerModelAndPositionCommand","Range","EditorContextKeys","MinimapPosition","OverviewRulerLane","ModelDecorationOptions","DocumentHighlightKind","DocumentHighlightProviderRegistry","nls","IContextKeyService","RawContextKey","activeContrastBorder","editorSelectionHighlight","editorSelectionHighlightBorder","minimapSelectionOccurrenceHighlight","overviewRulerSelectionHighlightForeground","registerColor","registerThemingParticipant","themeColorFromId","editorWordHighlight","dark","light","hc","localize","editorWordHighlightStrong","editorWordHighlightBorder","editorWordHighlightStrongBorder","overviewRulerWordHighlightForeground","overviewRulerWordHighlightStrongForeground","ctxHasWordHighlights","getOccurrencesAtPosition","model","position","token","orderedByScore","ordered","map","provider","Promise","resolve","provideDocumentHighlights","then","undefined","isNonEmptyArray","OccurenceAtPositionRequest","constructor","selection","wordSeparators","_wordRange","_getCurrentWordRange","result","_compute","word","getWordAtPosition","getPosition","startLineNumber","startColumn","endColumn","isValid","decorationIds","lineNumber","currentWordRange","requestIsValid","Boolean","equalsRange","len","range","getDecorationRange","cancel","SemanticOccurenceAtPositionRequest","value","TextualOccurenceAtPositionRequest","_selectionIsEmpty","isEmpty","matches","findMatches","m","kind","Text","currentSelectionIsEmpty","computeOccurencesAtPosition","has","None","WordHighlighter","editor","contextKeyService","toUnhook","workerRequestTokenId","workerRequestCompleted","workerRequestValue","lastCursorPositionChangeTime","renderDecorationsTimer","_hasWordHighlights","bindTo","_ignorePositionChangeEvent","occurrencesHighlight","getOption","getModel","add","onDidChangeCursorPosition","e","_onPositionChanged","onDidChangeModelContent","_stopAll","onDidChangeConfiguration","newValue","_decorationIds","workerRequest","hasDecorations","restore","_run","_getSortedHighlights","coalesce","id","sort","compareRangesUsingStarts","moveNext","highlights","index","findIndex","containsPosition","newIndex","dest","setPosition","getStartPosition","revealRangeInCenterIfOutsideViewport","_getWord","lineContent","getLineContent","moveBack","_removeDecorations","deltaDecorations","set","clearTimeout","reason","editorSelection","getSelection","column","endLineNumber","workerRequestIsValid","Date","getTime","_beginRenderDecorations","myRequestId","data","currentTime","minimumRenderTime","renderDecorations","setTimeout","decorations","info","push","options","_getDecorationOptions","Write","_WRITE_OPTIONS","_TEXT_OPTIONS","_REGULAR_OPTIONS","dispose","register","description","stickiness","className","overviewRuler","color","Center","minimap","Inline","WordHighlighterContribution","wordHighlighter","createWordHighlighterIfPossible","hasModel","_register","onDidChangeModel","get","getContribution","ID","saveViewState","restoreViewState","state","WordHighlightNavigationAction","next","opts","_isNext","run","accessor","controller","NextWordHighlightAction","label","alias","precondition","kbOpts","kbExpr","editorTextFocus","primary","weight","PrevWordHighlightAction","TriggerWordHighlightAction","toNegated","args","theme","collector","selectionHighlight","getColor","addRule","transparent","wordHighlight","wordHighlightStrong","selectionHighlightBorder","type","wordHighlightBorder","wordHighlightStrongBorder"],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAIA,UAAU,GAAI,QAAQ,KAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGK,MAAM,CAACC,wBAAP,CAAgCR,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HO,CAA3H;AACA,MAAI,OAAOC,OAAP,KAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EL,CAAC,GAAGI,OAAO,CAACC,QAAR,CAAiBZ,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCO,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD,IAAIH,CAAC,GAAGV,UAAU,CAACa,CAAD,CAAlB,EAAuBN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACH,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACT,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BG,CAAC,CAACT,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAC7E,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAcC,MAAM,CAACM,cAAP,CAAsBb,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMA,IAAIQ,OAAO,GAAI,QAAQ,KAAKA,OAAd,IAA0B,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AACrE,SAAO,UAAUhB,MAAV,EAAkBC,GAAlB,EAAuB;AAAEe,IAAAA,SAAS,CAAChB,MAAD,EAASC,GAAT,EAAcc,UAAd,CAAT;AAAqC,GAArE;AACH,CAFD;;AAGA,SAASE,KAAT,QAAsB,0CAAtB;AACA,OAAO,KAAKC,MAAZ,MAAwB,mCAAxB;AACA,SAASC,uBAAT,EAAkCC,KAAlC,EAAyCC,OAAzC,QAAwD,kCAAxD;AACA,SAASC,iBAAT,QAAkC,yCAAlC;AACA,SAASC,iBAAT,EAA4BC,yBAA5B,QAA6D,mCAA7D;AACA,SAASC,UAAT,EAAqBC,eAArB,QAA4C,sCAA5C;AACA,SAASC,YAAT,EAAuBC,oBAAvB,EAA6CC,0BAA7C,EAAyEC,+BAAzE,QAAgH,sCAAhH;AACA,SAASC,KAAT,QAAsB,+BAAtB;AACA,SAASC,iBAAT,QAAkC,sCAAlC;AACA,SAASC,eAAT,EAA0BC,iBAA1B,QAAmD,0BAAnD;AACA,SAASC,sBAAT,QAAuC,oCAAvC;AACA,SAASC,qBAAT,EAAgCC,iCAAhC,QAAyE,8BAAzE;AACA,OAAO,KAAKC,GAAZ,MAAqB,oBAArB;AACA,SAASC,kBAAT,EAA6BC,aAA7B,QAAkD,sDAAlD;AACA,SAASC,oBAAT,EAA+BC,wBAA/B,EAAyDC,8BAAzD,EAAyFC,mCAAzF,EAA8HC,yCAA9H,EAAyKC,aAAzK,QAA8L,oDAA9L;AACA,SAASC,0BAAT,EAAqCC,gBAArC,QAA6D,mDAA7D;AACA,MAAMC,mBAAmB,GAAGH,aAAa,CAAC,gCAAD,EAAmC;AAAEI,EAAAA,IAAI,EAAE,WAAR;AAAqBC,EAAAA,KAAK,EAAE,WAA5B;AAAyCC,EAAAA,EAAE,EAAE;AAA7C,CAAnC,EAAwFd,GAAG,CAACe,QAAJ,CAAa,eAAb,EAA8B,kJAA9B,CAAxF,EAA2Q,IAA3Q,CAAzC;AACA,MAAMC,yBAAyB,GAAGR,aAAa,CAAC,sCAAD,EAAyC;AAAEI,EAAAA,IAAI,EAAE,WAAR;AAAqBC,EAAAA,KAAK,EAAE,WAA5B;AAAyCC,EAAAA,EAAE,EAAE;AAA7C,CAAzC,EAA8Fd,GAAG,CAACe,QAAJ,CAAa,qBAAb,EAAoC,sJAApC,CAA9F,EAA2R,IAA3R,CAA/C;AACA,MAAME,yBAAyB,GAAGT,aAAa,CAAC,4BAAD,EAA+B;AAAEK,EAAAA,KAAK,EAAE,IAAT;AAAeD,EAAAA,IAAI,EAAE,IAArB;AAA2BE,EAAAA,EAAE,EAAEX;AAA/B,CAA/B,EAAsFH,GAAG,CAACe,QAAJ,CAAa,qBAAb,EAAoC,uEAApC,CAAtF,CAA/C;AACA,MAAMG,+BAA+B,GAAGV,aAAa,CAAC,kCAAD,EAAqC;AAAEK,EAAAA,KAAK,EAAE,IAAT;AAAeD,EAAAA,IAAI,EAAE,IAArB;AAA2BE,EAAAA,EAAE,EAAEX;AAA/B,CAArC,EAA4FH,GAAG,CAACe,QAAJ,CAAa,2BAAb,EAA0C,2EAA1C,CAA5F,CAArD;AACA,MAAMI,oCAAoC,GAAGX,aAAa,CAAC,6CAAD,EAAgD;AAAEI,EAAAA,IAAI,EAAE,WAAR;AAAqBC,EAAAA,KAAK,EAAE,WAA5B;AAAyCC,EAAAA,EAAE,EAAE;AAA7C,CAAhD,EAA4Gd,GAAG,CAACe,QAAJ,CAAa,sCAAb,EAAqD,2HAArD,CAA5G,EAA+R,IAA/R,CAA1D;AACA,MAAMK,0CAA0C,GAAGZ,aAAa,CAAC,mDAAD,EAAsD;AAAEI,EAAAA,IAAI,EAAE,WAAR;AAAqBC,EAAAA,KAAK,EAAE,WAA5B;AAAyCC,EAAAA,EAAE,EAAE;AAA7C,CAAtD,EAAkHd,GAAG,CAACe,QAAJ,CAAa,4CAAb,EAA2D,wIAA3D,CAAlH,EAAwT,IAAxT,CAAhE;AACA,MAAMM,oBAAoB,GAAG,IAAInB,aAAJ,CAAkB,mBAAlB,EAAuC,KAAvC,CAA7B;AACA,OAAO,SAASoB,wBAAT,CAAkCC,KAAlC,EAAyCC,QAAzC,EAAmDC,KAAnD,EAA0D;AAC7D,QAAMC,cAAc,GAAG3B,iCAAiC,CAAC4B,OAAlC,CAA0CJ,KAA1C,CAAvB,CAD6D,CAE7D;AACA;AACA;;AACA,SAAOzC,KAAK,CAAC4C,cAAc,CAACE,GAAf,CAAmBC,QAAQ,IAAI,MAAM;AAC9C,WAAOC,OAAO,CAACC,OAAR,CAAgBF,QAAQ,CAACG,yBAAT,CAAmCT,KAAnC,EAA0CC,QAA1C,EAAoDC,KAApD,CAAhB,EACFQ,IADE,CACGC,SADH,EACchD,yBADd,CAAP;AAEH,GAHY,CAAD,EAGRN,MAAM,CAACuD,eAHC,CAAZ;AAIH;;AACD,MAAMC,0BAAN,CAAiC;AAC7BC,EAAAA,WAAW,CAACd,KAAD,EAAQe,SAAR,EAAmBC,cAAnB,EAAmC;AAC1C,SAAKC,UAAL,GAAkB,KAAKC,oBAAL,CAA0BlB,KAA1B,EAAiCe,SAAjC,CAAlB;AACA,SAAKI,MAAL,GAAc7D,uBAAuB,CAAC4C,KAAK,IAAI,KAAKkB,QAAL,CAAcpB,KAAd,EAAqBe,SAArB,EAAgCC,cAAhC,EAAgDd,KAAhD,CAAV,CAArC;AACH;;AACDgB,EAAAA,oBAAoB,CAAClB,KAAD,EAAQe,SAAR,EAAmB;AACnC,UAAMM,IAAI,GAAGrB,KAAK,CAACsB,iBAAN,CAAwBP,SAAS,CAACQ,WAAV,EAAxB,CAAb;;AACA,QAAIF,IAAJ,EAAU;AACN,aAAO,IAAInD,KAAJ,CAAU6C,SAAS,CAACS,eAApB,EAAqCH,IAAI,CAACI,WAA1C,EAAuDV,SAAS,CAACS,eAAjE,EAAkFH,IAAI,CAACK,SAAvF,CAAP;AACH;;AACD,WAAO,IAAP;AACH;;AACDC,EAAAA,OAAO,CAAC3B,KAAD,EAAQe,SAAR,EAAmBa,aAAnB,EAAkC;AACrC,UAAMC,UAAU,GAAGd,SAAS,CAACS,eAA7B;AACA,UAAMC,WAAW,GAAGV,SAAS,CAACU,WAA9B;AACA,UAAMC,SAAS,GAAGX,SAAS,CAACW,SAA5B;;AACA,UAAMI,gBAAgB,GAAG,KAAKZ,oBAAL,CAA0BlB,KAA1B,EAAiCe,SAAjC,CAAzB;;AACA,QAAIgB,cAAc,GAAGC,OAAO,CAAC,KAAKf,UAAL,IAAmB,KAAKA,UAAL,CAAgBgB,WAAhB,CAA4BH,gBAA5B,CAApB,CAA5B,CALqC,CAMrC;AACA;;AACA,SAAK,IAAI/E,CAAC,GAAG,CAAR,EAAWmF,GAAG,GAAGN,aAAa,CAACpF,MAApC,EAA4C,CAACuF,cAAD,IAAmBhF,CAAC,GAAGmF,GAAnE,EAAwEnF,CAAC,EAAzE,EAA6E;AACzE,UAAIoF,KAAK,GAAGnC,KAAK,CAACoC,kBAAN,CAAyBR,aAAa,CAAC7E,CAAD,CAAtC,CAAZ;;AACA,UAAIoF,KAAK,IAAIA,KAAK,CAACX,eAAN,KAA0BK,UAAvC,EAAmD;AAC/C,YAAIM,KAAK,CAACV,WAAN,IAAqBA,WAArB,IAAoCU,KAAK,CAACT,SAAN,IAAmBA,SAA3D,EAAsE;AAClEK,UAAAA,cAAc,GAAG,IAAjB;AACH;AACJ;AACJ;;AACD,WAAOA,cAAP;AACH;;AACDM,EAAAA,MAAM,GAAG;AACL,SAAKlB,MAAL,CAAYkB,MAAZ;AACH;;AAhC4B;;AAkCjC,MAAMC,kCAAN,SAAiDzB,0BAAjD,CAA4E;AACxEO,EAAAA,QAAQ,CAACpB,KAAD,EAAQe,SAAR,EAAmBC,cAAnB,EAAmCd,KAAnC,EAA0C;AAC9C,WAAOH,wBAAwB,CAACC,KAAD,EAAQe,SAAS,CAACQ,WAAV,EAAR,EAAiCrB,KAAjC,CAAxB,CAAgEQ,IAAhE,CAAqE6B,KAAK,IAAIA,KAAK,IAAI,EAAvF,CAAP;AACH;;AAHuE;;AAK5E,MAAMC,iCAAN,SAAgD3B,0BAAhD,CAA2E;AACvEC,EAAAA,WAAW,CAACd,KAAD,EAAQe,SAAR,EAAmBC,cAAnB,EAAmC;AAC1C,UAAMhB,KAAN,EAAae,SAAb,EAAwBC,cAAxB;AACA,SAAKyB,iBAAL,GAAyB1B,SAAS,CAAC2B,OAAV,EAAzB;AACH;;AACDtB,EAAAA,QAAQ,CAACpB,KAAD,EAAQe,SAAR,EAAmBC,cAAnB,EAAmCd,KAAnC,EAA0C;AAC9C,WAAO1C,OAAO,CAAC,GAAD,EAAM0C,KAAN,CAAP,CAAoBQ,IAApB,CAAyB,MAAM;AAClC,UAAI,CAACK,SAAS,CAAC2B,OAAV,EAAL,EAA0B;AACtB,eAAO,EAAP;AACH;;AACD,YAAMrB,IAAI,GAAGrB,KAAK,CAACsB,iBAAN,CAAwBP,SAAS,CAACQ,WAAV,EAAxB,CAAb;;AACA,UAAI,CAACF,IAAD,IAASA,IAAI,CAACA,IAAL,CAAU7E,MAAV,GAAmB,IAAhC,EAAsC;AAClC,eAAO,EAAP;AACH;;AACD,YAAMmG,OAAO,GAAG3C,KAAK,CAAC4C,WAAN,CAAkBvB,IAAI,CAACA,IAAvB,EAA6B,IAA7B,EAAmC,KAAnC,EAA0C,IAA1C,EAAgDL,cAAhD,EAAgE,KAAhE,CAAhB;AACA,aAAO2B,OAAO,CAACtC,GAAR,CAAYwC,CAAC,IAAI;AACpB,eAAO;AACHV,UAAAA,KAAK,EAAEU,CAAC,CAACV,KADN;AAEHW,UAAAA,IAAI,EAAEvE,qBAAqB,CAACwE;AAFzB,SAAP;AAIH,OALM,CAAP;AAMH,KAfM,CAAP;AAgBH;;AACDpB,EAAAA,OAAO,CAAC3B,KAAD,EAAQe,SAAR,EAAmBa,aAAnB,EAAkC;AACrC,UAAMoB,uBAAuB,GAAGjC,SAAS,CAAC2B,OAAV,EAAhC;;AACA,QAAI,KAAKD,iBAAL,KAA2BO,uBAA/B,EAAwD;AACpD,aAAO,KAAP;AACH;;AACD,WAAO,MAAMrB,OAAN,CAAc3B,KAAd,EAAqBe,SAArB,EAAgCa,aAAhC,CAAP;AACH;;AA7BsE;;AA+B3E,SAASqB,2BAAT,CAAqCjD,KAArC,EAA4Ce,SAA5C,EAAuDC,cAAvD,EAAuE;AACnE,MAAIxC,iCAAiC,CAAC0E,GAAlC,CAAsClD,KAAtC,CAAJ,EAAkD;AAC9C,WAAO,IAAIsC,kCAAJ,CAAuCtC,KAAvC,EAA8Ce,SAA9C,EAAyDC,cAAzD,CAAP;AACH;;AACD,SAAO,IAAIwB,iCAAJ,CAAsCxC,KAAtC,EAA6Ce,SAA7C,EAAwDC,cAAxD,CAAP;AACH;;AACD/C,+BAA+B,CAAC,4BAAD,EAA+B,CAAC+B,KAAD,EAAQC,QAAR,KAAqBF,wBAAwB,CAACC,KAAD,EAAQC,QAAR,EAAkBxC,iBAAiB,CAAC0F,IAApC,CAA5E,CAA/B;;AACA,MAAMC,eAAN,CAAsB;AAClBtC,EAAAA,WAAW,CAACuC,MAAD,EAASC,iBAAT,EAA4B;AACnC,SAAKC,QAAL,GAAgB,IAAI1F,eAAJ,EAAhB;AACA,SAAK2F,oBAAL,GAA4B,CAA5B;AACA,SAAKC,sBAAL,GAA8B,KAA9B;AACA,SAAKC,kBAAL,GAA0B,EAA1B;AACA,SAAKC,4BAAL,GAAoC,CAApC;AACA,SAAKC,sBAAL,GAA8B,CAAC,CAA/B;AACA,SAAKP,MAAL,GAAcA,MAAd;AACA,SAAKQ,kBAAL,GAA0B/D,oBAAoB,CAACgE,MAArB,CAA4BR,iBAA5B,CAA1B;AACA,SAAKS,0BAAL,GAAkC,KAAlC;AACA,SAAKC,oBAAL,GAA4B,KAAKX,MAAL,CAAYY,SAAZ,CAAsB;AAAG;AAAzB,KAA5B;AACA,SAAKjE,KAAL,GAAa,KAAKqD,MAAL,CAAYa,QAAZ,EAAb;AACA,SAAKX,QAAL,CAAcY,GAAd,CAAkBd,MAAM,CAACe,yBAAP,CAAkCC,CAAD,IAAO;AACtD,UAAI,KAAKN,0BAAT,EAAqC;AACjC;AACA;AACH;;AACD,UAAI,CAAC,KAAKC,oBAAV,EAAgC;AAC5B;AACA;AACA;AACH;;AACD,WAAKM,kBAAL,CAAwBD,CAAxB;AACH,KAXiB,CAAlB;AAYA,SAAKd,QAAL,CAAcY,GAAd,CAAkBd,MAAM,CAACkB,uBAAP,CAAgCF,CAAD,IAAO;AACpD,WAAKG,QAAL;AACH,KAFiB,CAAlB;AAGA,SAAKjB,QAAL,CAAcY,GAAd,CAAkBd,MAAM,CAACoB,wBAAP,CAAiCJ,CAAD,IAAO;AACrD,UAAIK,QAAQ,GAAG,KAAKrB,MAAL,CAAYY,SAAZ,CAAsB;AAAG;AAAzB,OAAf;;AACA,UAAI,KAAKD,oBAAL,KAA8BU,QAAlC,EAA4C;AACxC,aAAKV,oBAAL,GAA4BU,QAA5B;;AACA,aAAKF,QAAL;AACH;AACJ,KANiB,CAAlB;AAOA,SAAKG,cAAL,GAAsB,EAAtB;AACA,SAAKnB,oBAAL,GAA4B,CAA5B;AACA,SAAKoB,aAAL,GAAqB,IAArB;AACA,SAAKnB,sBAAL,GAA8B,KAA9B;AACA,SAAKE,4BAAL,GAAoC,CAApC;AACA,SAAKC,sBAAL,GAA8B,CAAC,CAA/B;AACH;;AACDiB,EAAAA,cAAc,GAAG;AACb,WAAQ,KAAKF,cAAL,CAAoBnI,MAApB,GAA6B,CAArC;AACH;;AACDsI,EAAAA,OAAO,GAAG;AACN,QAAI,CAAC,KAAKd,oBAAV,EAAgC;AAC5B;AACH;;AACD,SAAKe,IAAL;AACH;;AACDC,EAAAA,oBAAoB,GAAG;AACnB,WAAO3H,MAAM,CAAC4H,QAAP,CAAgB,KAAKN,cAAL,CAClBtE,GADkB,CACb6E,EAAD,IAAQ,KAAKlF,KAAL,CAAWoC,kBAAX,CAA8B8C,EAA9B,CADM,EAElBC,IAFkB,CAEbjH,KAAK,CAACkH,wBAFO,CAAhB,CAAP;AAGH;;AACDC,EAAAA,QAAQ,GAAG;AACP,QAAIC,UAAU,GAAG,KAAKN,oBAAL,EAAjB;;AACA,QAAIO,KAAK,GAAGD,UAAU,CAACE,SAAX,CAAsBrD,KAAD,IAAWA,KAAK,CAACsD,gBAAN,CAAuB,KAAKpC,MAAL,CAAY9B,WAAZ,EAAvB,CAAhC,CAAZ;AACA,QAAImE,QAAQ,GAAI,CAACH,KAAK,GAAG,CAAT,IAAcD,UAAU,CAAC9I,MAAzC;AACA,QAAImJ,IAAI,GAAGL,UAAU,CAACI,QAAD,CAArB;;AACA,QAAI;AACA,WAAK3B,0BAAL,GAAkC,IAAlC;AACA,WAAKV,MAAL,CAAYuC,WAAZ,CAAwBD,IAAI,CAACE,gBAAL,EAAxB;AACA,WAAKxC,MAAL,CAAYyC,oCAAZ,CAAiDH,IAAjD;;AACA,YAAMtE,IAAI,GAAG,KAAK0E,QAAL,EAAb;;AACA,UAAI1E,IAAJ,EAAU;AACN,cAAM2E,WAAW,GAAG,KAAK3C,MAAL,CAAYa,QAAZ,GAAuB+B,cAAvB,CAAsCN,IAAI,CAACnE,eAA3C,CAApB;AACApE,QAAAA,KAAK,CAAE,GAAE4I,WAAY,KAAIN,QAAQ,GAAG,CAAE,OAAMJ,UAAU,CAAC9I,MAAO,SAAQ6E,IAAI,CAACA,IAAK,GAA3E,CAAL;AACH;AACJ,KATD,SAUQ;AACJ,WAAK0C,0BAAL,GAAkC,KAAlC;AACH;AACJ;;AACDmC,EAAAA,QAAQ,GAAG;AACP,QAAIZ,UAAU,GAAG,KAAKN,oBAAL,EAAjB;;AACA,QAAIO,KAAK,GAAGD,UAAU,CAACE,SAAX,CAAsBrD,KAAD,IAAWA,KAAK,CAACsD,gBAAN,CAAuB,KAAKpC,MAAL,CAAY9B,WAAZ,EAAvB,CAAhC,CAAZ;AACA,QAAImE,QAAQ,GAAI,CAACH,KAAK,GAAG,CAAR,GAAYD,UAAU,CAAC9I,MAAxB,IAAkC8I,UAAU,CAAC9I,MAA7D;AACA,QAAImJ,IAAI,GAAGL,UAAU,CAACI,QAAD,CAArB;;AACA,QAAI;AACA,WAAK3B,0BAAL,GAAkC,IAAlC;AACA,WAAKV,MAAL,CAAYuC,WAAZ,CAAwBD,IAAI,CAACE,gBAAL,EAAxB;AACA,WAAKxC,MAAL,CAAYyC,oCAAZ,CAAiDH,IAAjD;;AACA,YAAMtE,IAAI,GAAG,KAAK0E,QAAL,EAAb;;AACA,UAAI1E,IAAJ,EAAU;AACN,cAAM2E,WAAW,GAAG,KAAK3C,MAAL,CAAYa,QAAZ,GAAuB+B,cAAvB,CAAsCN,IAAI,CAACnE,eAA3C,CAApB;AACApE,QAAAA,KAAK,CAAE,GAAE4I,WAAY,KAAIN,QAAQ,GAAG,CAAE,OAAMJ,UAAU,CAAC9I,MAAO,SAAQ6E,IAAI,CAACA,IAAK,GAA3E,CAAL;AACH;AACJ,KATD,SAUQ;AACJ,WAAK0C,0BAAL,GAAkC,KAAlC;AACH;AACJ;;AACDoC,EAAAA,kBAAkB,GAAG;AACjB,QAAI,KAAKxB,cAAL,CAAoBnI,MAApB,GAA6B,CAAjC,EAAoC;AAChC;AACA,WAAKmI,cAAL,GAAsB,KAAKtB,MAAL,CAAY+C,gBAAZ,CAA6B,KAAKzB,cAAlC,EAAkD,EAAlD,CAAtB;;AACA,WAAKd,kBAAL,CAAwBwC,GAAxB,CAA4B,KAA5B;AACH;AACJ;;AACD7B,EAAAA,QAAQ,GAAG;AACP;AACA,SAAK2B,kBAAL,GAFO,CAGP;;;AACA,QAAI,KAAKvC,sBAAL,KAAgC,CAAC,CAArC,EAAwC;AACpC0C,MAAAA,YAAY,CAAC,KAAK1C,sBAAN,CAAZ;AACA,WAAKA,sBAAL,GAA8B,CAAC,CAA/B;AACH,KAPM,CAQP;;;AACA,QAAI,KAAKgB,aAAL,KAAuB,IAA3B,EAAiC;AAC7B,WAAKA,aAAL,CAAmBvC,MAAnB;AACA,WAAKuC,aAAL,GAAqB,IAArB;AACH,KAZM,CAaP;;;AACA,QAAI,CAAC,KAAKnB,sBAAV,EAAkC;AAC9B,WAAKD,oBAAL;AACA,WAAKC,sBAAL,GAA8B,IAA9B;AACH;AACJ;;AACDa,EAAAA,kBAAkB,CAACD,CAAD,EAAI;AAClB;AACA,QAAI,CAAC,KAAKL,oBAAV,EAAgC;AAC5B,WAAKQ,QAAL;;AACA;AACH,KALiB,CAMlB;;;AACA,QAAIH,CAAC,CAACkC,MAAF,KAAa;AAAE;AAAnB,MAAmC;AAC/B,WAAK/B,QAAL;;AACA;AACH;;AACD,SAAKO,IAAL;AACH;;AACDgB,EAAAA,QAAQ,GAAG;AACP,QAAIS,eAAe,GAAG,KAAKnD,MAAL,CAAYoD,YAAZ,EAAtB;AACA,QAAI5E,UAAU,GAAG2E,eAAe,CAAChF,eAAjC;AACA,QAAIC,WAAW,GAAG+E,eAAe,CAAC/E,WAAlC;AACA,WAAO,KAAKzB,KAAL,CAAWsB,iBAAX,CAA6B;AAChCO,MAAAA,UAAU,EAAEA,UADoB;AAEhC6E,MAAAA,MAAM,EAAEjF;AAFwB,KAA7B,CAAP;AAIH;;AACDsD,EAAAA,IAAI,GAAG;AACH,QAAIyB,eAAe,GAAG,KAAKnD,MAAL,CAAYoD,YAAZ,EAAtB,CADG,CAEH;;AACA,QAAID,eAAe,CAAChF,eAAhB,KAAoCgF,eAAe,CAACG,aAAxD,EAAuE;AACnE,WAAKnC,QAAL;;AACA;AACH;;AACD,QAAI/C,WAAW,GAAG+E,eAAe,CAAC/E,WAAlC;AACA,QAAIC,SAAS,GAAG8E,eAAe,CAAC9E,SAAhC;;AACA,UAAML,IAAI,GAAG,KAAK0E,QAAL,EAAb,CATG,CAUH;;;AACA,QAAI,CAAC1E,IAAD,IAASA,IAAI,CAACI,WAAL,GAAmBA,WAA5B,IAA2CJ,IAAI,CAACK,SAAL,GAAiBA,SAAhE,EAA2E;AACvE,WAAK8C,QAAL;;AACA;AACH,KAdE,CAeH;AACA;AACA;AACA;;;AACA,UAAMoC,oBAAoB,GAAI,KAAKhC,aAAL,IAAsB,KAAKA,aAAL,CAAmBjD,OAAnB,CAA2B,KAAK3B,KAAhC,EAAuCwG,eAAvC,EAAwD,KAAK7B,cAA7D,CAApD,CAnBG,CAoBH;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAKhB,4BAAL,GAAqC,IAAIkD,IAAJ,EAAD,CAAaC,OAAb,EAApC;;AACA,QAAIF,oBAAJ,EAA0B;AACtB,UAAI,KAAKnD,sBAAL,IAA+B,KAAKG,sBAAL,KAAgC,CAAC,CAApE,EAAuE;AACnE;AACA;AACA0C,QAAAA,YAAY,CAAC,KAAK1C,sBAAN,CAAZ;AACA,aAAKA,sBAAL,GAA8B,CAAC,CAA/B;;AACA,aAAKmD,uBAAL;AACH;AACJ,KARD,MASK;AACD;AACA;AACA,WAAKvC,QAAL;;AACA,UAAIwC,WAAW,GAAG,EAAE,KAAKxD,oBAAzB;AACA,WAAKC,sBAAL,GAA8B,KAA9B;AACA,WAAKmB,aAAL,GAAqB3B,2BAA2B,CAAC,KAAKjD,KAAN,EAAa,KAAKqD,MAAL,CAAYoD,YAAZ,EAAb,EAAyC,KAAKpD,MAAL,CAAYY,SAAZ,CAAsB;AAAI;AAA1B,OAAzC,CAAhD;AACA,WAAKW,aAAL,CAAmBzD,MAAnB,CAA0BT,IAA1B,CAA+BuG,IAAI,IAAI;AACnC,YAAID,WAAW,KAAK,KAAKxD,oBAAzB,EAA+C;AAC3C,eAAKC,sBAAL,GAA8B,IAA9B;AACA,eAAKC,kBAAL,GAA0BuD,IAAI,IAAI,EAAlC;;AACA,eAAKF,uBAAL;AACH;AACJ,OAND,EAMGrJ,iBANH;AAOH;AACJ;;AACDqJ,EAAAA,uBAAuB,GAAG;AACtB,QAAIG,WAAW,GAAI,IAAIL,IAAJ,EAAD,CAAaC,OAAb,EAAlB;AACA,QAAIK,iBAAiB,GAAG,KAAKxD,4BAAL,GAAoC,GAA5D;;AACA,QAAIuD,WAAW,IAAIC,iBAAnB,EAAsC;AAClC;AACA,WAAKvD,sBAAL,GAA8B,CAAC,CAA/B;AACA,WAAKwD,iBAAL;AACH,KAJD,MAKK;AACD;AACA,WAAKxD,sBAAL,GAA8ByD,UAAU,CAAC,MAAM;AAC3C,aAAKD,iBAAL;AACH,OAFuC,EAEpCD,iBAAiB,GAAGD,WAFgB,CAAxC;AAGH;AACJ;;AACDE,EAAAA,iBAAiB,GAAG;AAChB,SAAKxD,sBAAL,GAA8B,CAAC,CAA/B;AACA,QAAI0D,WAAW,GAAG,EAAlB;;AACA,SAAK,MAAMC,IAAX,IAAmB,KAAK7D,kBAAxB,EAA4C;AACxC,UAAI6D,IAAI,CAACpF,KAAT,EAAgB;AACZmF,QAAAA,WAAW,CAACE,IAAZ,CAAiB;AACbrF,UAAAA,KAAK,EAAEoF,IAAI,CAACpF,KADC;AAEbsF,UAAAA,OAAO,EAAErE,eAAe,CAACsE,qBAAhB,CAAsCH,IAAI,CAACzE,IAA3C;AAFI,SAAjB;AAIH;AACJ;;AACD,SAAK6B,cAAL,GAAsB,KAAKtB,MAAL,CAAY+C,gBAAZ,CAA6B,KAAKzB,cAAlC,EAAkD2C,WAAlD,CAAtB;;AACA,SAAKzD,kBAAL,CAAwBwC,GAAxB,CAA4B,KAAKxB,cAAL,EAA5B;AACH;;AAC2B,SAArB6C,qBAAqB,CAAC5E,IAAD,EAAO;AAC/B,QAAIA,IAAI,KAAKvE,qBAAqB,CAACoJ,KAAnC,EAA0C;AACtC,aAAO,KAAKC,cAAZ;AACH,KAFD,MAGK,IAAI9E,IAAI,KAAKvE,qBAAqB,CAACwE,IAAnC,EAAyC;AAC1C,aAAO,KAAK8E,aAAZ;AACH,KAFI,MAGA;AACD,aAAO,KAAKC,gBAAZ;AACH;AACJ;;AACDC,EAAAA,OAAO,GAAG;AACN,SAAKvD,QAAL;;AACA,SAAKjB,QAAL,CAAcwE,OAAd;AACH;;AA9OiB;;AAgPtB3E,eAAe,CAACwE,cAAhB,GAAiCtJ,sBAAsB,CAAC0J,QAAvB,CAAgC;AAC7DC,EAAAA,WAAW,EAAE,uBADgD;AAE7DC,EAAAA,UAAU,EAAE;AAAE;AAF+C;AAG7DC,EAAAA,SAAS,EAAE,qBAHkD;AAI7DC,EAAAA,aAAa,EAAE;AACXC,IAAAA,KAAK,EAAElJ,gBAAgB,CAACU,0CAAD,CADZ;AAEXI,IAAAA,QAAQ,EAAE5B,iBAAiB,CAACiK;AAFjB,GAJ8C;AAQ7DC,EAAAA,OAAO,EAAE;AACLF,IAAAA,KAAK,EAAElJ,gBAAgB,CAACJ,mCAAD,CADlB;AAELkB,IAAAA,QAAQ,EAAE7B,eAAe,CAACoK;AAFrB;AARoD,CAAhC,CAAjC;AAaApF,eAAe,CAACyE,aAAhB,GAAgCvJ,sBAAsB,CAAC0J,QAAvB,CAAgC;AAC5DC,EAAAA,WAAW,EAAE,qBAD+C;AAE5DC,EAAAA,UAAU,EAAE;AAAE;AAF8C;AAG5DC,EAAAA,SAAS,EAAE,oBAHiD;AAI5DC,EAAAA,aAAa,EAAE;AACXC,IAAAA,KAAK,EAAElJ,gBAAgB,CAACH,yCAAD,CADZ;AAEXiB,IAAAA,QAAQ,EAAE5B,iBAAiB,CAACiK;AAFjB,GAJ6C;AAQ5DC,EAAAA,OAAO,EAAE;AACLF,IAAAA,KAAK,EAAElJ,gBAAgB,CAACJ,mCAAD,CADlB;AAELkB,IAAAA,QAAQ,EAAE7B,eAAe,CAACoK;AAFrB;AARmD,CAAhC,CAAhC;AAaApF,eAAe,CAAC0E,gBAAhB,GAAmCxJ,sBAAsB,CAAC0J,QAAvB,CAAgC;AAC/DC,EAAAA,WAAW,EAAE,gBADkD;AAE/DC,EAAAA,UAAU,EAAE;AAAE;AAFiD;AAG/DC,EAAAA,SAAS,EAAE,eAHoD;AAI/DC,EAAAA,aAAa,EAAE;AACXC,IAAAA,KAAK,EAAElJ,gBAAgB,CAACS,oCAAD,CADZ;AAEXK,IAAAA,QAAQ,EAAE5B,iBAAiB,CAACiK;AAFjB,GAJgD;AAQ/DC,EAAAA,OAAO,EAAE;AACLF,IAAAA,KAAK,EAAElJ,gBAAgB,CAACJ,mCAAD,CADlB;AAELkB,IAAAA,QAAQ,EAAE7B,eAAe,CAACoK;AAFrB;AARsD,CAAhC,CAAnC;AAaA,IAAIC,2BAA2B,GAAG,MAAMA,2BAAN,SAA0C7K,UAA1C,CAAqD;AACnFkD,EAAAA,WAAW,CAACuC,MAAD,EAASC,iBAAT,EAA4B;AACnC;AACA,SAAKoF,eAAL,GAAuB,IAAvB;;AACA,UAAMC,+BAA+B,GAAG,MAAM;AAC1C,UAAItF,MAAM,CAACuF,QAAP,EAAJ,EAAuB;AACnB,aAAKF,eAAL,GAAuB,IAAItF,eAAJ,CAAoBC,MAApB,EAA4BC,iBAA5B,CAAvB;AACH;AACJ,KAJD;;AAKA,SAAKuF,SAAL,CAAexF,MAAM,CAACyF,gBAAP,CAAyBzE,CAAD,IAAO;AAC1C,UAAI,KAAKqE,eAAT,EAA0B;AACtB,aAAKA,eAAL,CAAqBX,OAArB;AACA,aAAKW,eAAL,GAAuB,IAAvB;AACH;;AACDC,MAAAA,+BAA+B;AAClC,KANc,CAAf;;AAOAA,IAAAA,+BAA+B;AAClC;;AACS,SAAHI,GAAG,CAAC1F,MAAD,EAAS;AACf,WAAOA,MAAM,CAAC2F,eAAP,CAAuBP,2BAA2B,CAACQ,EAAnD,CAAP;AACH;;AACDC,EAAAA,aAAa,GAAG;AACZ,QAAI,KAAKR,eAAL,IAAwB,KAAKA,eAAL,CAAqB7D,cAArB,EAA5B,EAAmE;AAC/D,aAAO,IAAP;AACH;;AACD,WAAO,KAAP;AACH;;AACDQ,EAAAA,QAAQ,GAAG;AACP,QAAI,KAAKqD,eAAT,EAA0B;AACtB,WAAKA,eAAL,CAAqBrD,QAArB;AACH;AACJ;;AACDa,EAAAA,QAAQ,GAAG;AACP,QAAI,KAAKwC,eAAT,EAA0B;AACtB,WAAKA,eAAL,CAAqBxC,QAArB;AACH;AACJ;;AACDiD,EAAAA,gBAAgB,CAACC,KAAD,EAAQ;AACpB,QAAI,KAAKV,eAAL,IAAwBU,KAA5B,EAAmC;AAC/B,WAAKV,eAAL,CAAqB5D,OAArB;AACH;AACJ;;AACDiD,EAAAA,OAAO,GAAG;AACN,QAAI,KAAKW,eAAT,EAA0B;AACtB,WAAKA,eAAL,CAAqBX,OAArB;AACA,WAAKW,eAAL,GAAuB,IAAvB;AACH;;AACD,UAAMX,OAAN;AACH;;AAhDkF,CAAvF;AAkDAU,2BAA2B,CAACQ,EAA5B,GAAiC,gCAAjC;AACAR,2BAA2B,GAAGxM,UAAU,CAAC,CACrCgB,OAAO,CAAC,CAAD,EAAIyB,kBAAJ,CAD8B,CAAD,EAErC+J,2BAFqC,CAAxC;;AAGA,MAAMY,6BAAN,SAA4CvL,YAA5C,CAAyD;AACrDgD,EAAAA,WAAW,CAACwI,IAAD,EAAOC,IAAP,EAAa;AACpB,UAAMA,IAAN;AACA,SAAKC,OAAL,GAAeF,IAAf;AACH;;AACDG,EAAAA,GAAG,CAACC,QAAD,EAAWrG,MAAX,EAAmB;AAClB,UAAMsG,UAAU,GAAGlB,2BAA2B,CAACM,GAA5B,CAAgC1F,MAAhC,CAAnB;;AACA,QAAI,CAACsG,UAAL,EAAiB;AACb;AACH;;AACD,QAAI,KAAKH,OAAT,EAAkB;AACdG,MAAAA,UAAU,CAACtE,QAAX;AACH,KAFD,MAGK;AACDsE,MAAAA,UAAU,CAACzD,QAAX;AACH;AACJ;;AAhBoD;;AAkBzD,MAAM0D,uBAAN,SAAsCP,6BAAtC,CAAoE;AAChEvI,EAAAA,WAAW,GAAG;AACV,UAAM,IAAN,EAAY;AACRoE,MAAAA,EAAE,EAAE,kCADI;AAER2E,MAAAA,KAAK,EAAEpL,GAAG,CAACe,QAAJ,CAAa,0BAAb,EAAyC,6BAAzC,CAFC;AAGRsK,MAAAA,KAAK,EAAE,6BAHC;AAIRC,MAAAA,YAAY,EAAEjK,oBAJN;AAKRkK,MAAAA,MAAM,EAAE;AACJC,QAAAA,MAAM,EAAE9L,iBAAiB,CAAC+L,eADtB;AAEJC,QAAAA,OAAO,EAAE;AAAG;AAFR;AAGJC,QAAAA,MAAM,EAAE;AAAI;;AAHR;AALA,KAAZ;AAWH;;AAb+D;;AAepE,MAAMC,uBAAN,SAAsChB,6BAAtC,CAAoE;AAChEvI,EAAAA,WAAW,GAAG;AACV,UAAM,KAAN,EAAa;AACToE,MAAAA,EAAE,EAAE,kCADK;AAET2E,MAAAA,KAAK,EAAEpL,GAAG,CAACe,QAAJ,CAAa,8BAAb,EAA6C,iCAA7C,CAFE;AAGTsK,MAAAA,KAAK,EAAE,iCAHE;AAITC,MAAAA,YAAY,EAAEjK,oBAJL;AAKTkK,MAAAA,MAAM,EAAE;AACJC,QAAAA,MAAM,EAAE9L,iBAAiB,CAAC+L,eADtB;AAEJC,QAAAA,OAAO,EAAE;AAAK;AAAL,UAAmB;AAAG;AAF3B;AAGJC,QAAAA,MAAM,EAAE;AAAI;;AAHR;AALC,KAAb;AAWH;;AAb+D;;AAepE,MAAME,0BAAN,SAAyCxM,YAAzC,CAAsD;AAClDgD,EAAAA,WAAW,GAAG;AACV,UAAM;AACFoE,MAAAA,EAAE,EAAE,qCADF;AAEF2E,MAAAA,KAAK,EAAEpL,GAAG,CAACe,QAAJ,CAAa,6BAAb,EAA4C,0BAA5C,CAFL;AAGFsK,MAAAA,KAAK,EAAE,0BAHL;AAIFC,MAAAA,YAAY,EAAEjK,oBAAoB,CAACyK,SAArB,EAJZ;AAKFP,MAAAA,MAAM,EAAE;AACJC,QAAAA,MAAM,EAAE9L,iBAAiB,CAAC+L,eADtB;AAEJC,QAAAA,OAAO,EAAE,CAFL;AAGJC,QAAAA,MAAM,EAAE;AAAI;;AAHR;AALN,KAAN;AAWH;;AACDX,EAAAA,GAAG,CAACC,QAAD,EAAWrG,MAAX,EAAmBmH,IAAnB,EAAyB;AACxB,UAAMb,UAAU,GAAGlB,2BAA2B,CAACM,GAA5B,CAAgC1F,MAAhC,CAAnB;;AACA,QAAI,CAACsG,UAAL,EAAiB;AACb;AACH;;AACDA,IAAAA,UAAU,CAACR,gBAAX,CAA4B,IAA5B;AACH;;AApBiD;;AAsBtDnL,0BAA0B,CAACyK,2BAA2B,CAACQ,EAA7B,EAAiCR,2BAAjC,CAA1B;AACA1K,oBAAoB,CAAC6L,uBAAD,CAApB;AACA7L,oBAAoB,CAACsM,uBAAD,CAApB;AACAtM,oBAAoB,CAACuM,0BAAD,CAApB;AACApL,0BAA0B,CAAC,CAACuL,KAAD,EAAQC,SAAR,KAAsB;AAC7C,QAAMC,kBAAkB,GAAGF,KAAK,CAACG,QAAN,CAAe/L,wBAAf,CAA3B;;AACA,MAAI8L,kBAAJ,EAAwB;AACpBD,IAAAA,SAAS,CAACG,OAAV,CAAmB,mEAAkEF,kBAAmB,KAAxG;AACAD,IAAAA,SAAS,CAACG,OAAV,CAAmB,0DAAyDF,kBAAkB,CAACG,WAAnB,CAA+B,GAA/B,CAAoC,KAAhH;AACH;;AACD,QAAMC,aAAa,GAAGN,KAAK,CAACG,QAAN,CAAexL,mBAAf,CAAtB;;AACA,MAAI2L,aAAJ,EAAmB;AACfL,IAAAA,SAAS,CAACG,OAAV,CAAmB,qDAAoDE,aAAc,KAArF;AACH;;AACD,QAAMC,mBAAmB,GAAGP,KAAK,CAACG,QAAN,CAAenL,yBAAf,CAA5B;;AACA,MAAIuL,mBAAJ,EAAyB;AACrBN,IAAAA,SAAS,CAACG,OAAV,CAAmB,2DAA0DG,mBAAoB,KAAjG;AACH;;AACD,QAAMC,wBAAwB,GAAGR,KAAK,CAACG,QAAN,CAAe9L,8BAAf,CAAjC;;AACA,MAAImM,wBAAJ,EAA8B;AAC1BP,IAAAA,SAAS,CAACG,OAAV,CAAmB,oDAAmDJ,KAAK,CAACS,IAAN,KAAe,IAAf,GAAsB,QAAtB,GAAiC,OAAQ,IAAGD,wBAAyB,6BAA3I;AACH;;AACD,QAAME,mBAAmB,GAAGV,KAAK,CAACG,QAAN,CAAelL,yBAAf,CAA5B;;AACA,MAAIyL,mBAAJ,EAAyB;AACrBT,IAAAA,SAAS,CAACG,OAAV,CAAmB,+CAA8CJ,KAAK,CAACS,IAAN,KAAe,IAAf,GAAsB,QAAtB,GAAiC,OAAQ,IAAGC,mBAAoB,6BAAjI;AACH;;AACD,QAAMC,yBAAyB,GAAGX,KAAK,CAACG,QAAN,CAAejL,+BAAf,CAAlC;;AACA,MAAIyL,yBAAJ,EAA+B;AAC3BV,IAAAA,SAAS,CAACG,OAAV,CAAmB,qDAAoDJ,KAAK,CAACS,IAAN,KAAe,IAAf,GAAsB,QAAtB,GAAiC,OAAQ,IAAGE,yBAA0B,6BAA7I;AACH;AACJ,CA1ByB,CAA1B","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport * as arrays from '../../../../base/common/arrays.js';\nimport { createCancelablePromise, first, timeout } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution, registerModelAndPositionCommand } from '../../../browser/editorExtensions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { MinimapPosition, OverviewRulerLane } from '../../../common/model.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { DocumentHighlightKind, DocumentHighlightProviderRegistry } from '../../../common/languages.js';\nimport * as nls from '../../../../nls.js';\nimport { IContextKeyService, RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { activeContrastBorder, editorSelectionHighlight, editorSelectionHighlightBorder, minimapSelectionOccurrenceHighlight, overviewRulerSelectionHighlightForeground, registerColor } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant, themeColorFromId } from '../../../../platform/theme/common/themeService.js';\nconst editorWordHighlight = registerColor('editor.wordHighlightBackground', { dark: '#575757B8', light: '#57575740', hc: null }, nls.localize('wordHighlight', 'Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations.'), true);\nconst editorWordHighlightStrong = registerColor('editor.wordHighlightStrongBackground', { dark: '#004972B8', light: '#0e639c40', hc: null }, nls.localize('wordHighlightStrong', 'Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations.'), true);\nconst editorWordHighlightBorder = registerColor('editor.wordHighlightBorder', { light: null, dark: null, hc: activeContrastBorder }, nls.localize('wordHighlightBorder', 'Border color of a symbol during read-access, like reading a variable.'));\nconst editorWordHighlightStrongBorder = registerColor('editor.wordHighlightStrongBorder', { light: null, dark: null, hc: activeContrastBorder }, nls.localize('wordHighlightStrongBorder', 'Border color of a symbol during write-access, like writing to a variable.'));\nconst overviewRulerWordHighlightForeground = registerColor('editorOverviewRuler.wordHighlightForeground', { dark: '#A0A0A0CC', light: '#A0A0A0CC', hc: '#A0A0A0CC' }, nls.localize('overviewRulerWordHighlightForeground', 'Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nconst overviewRulerWordHighlightStrongForeground = registerColor('editorOverviewRuler.wordHighlightStrongForeground', { dark: '#C0A0C0CC', light: '#C0A0C0CC', hc: '#C0A0C0CC' }, nls.localize('overviewRulerWordHighlightStrongForeground', 'Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nconst ctxHasWordHighlights = new RawContextKey('hasWordHighlights', false);\nexport function getOccurrencesAtPosition(model, position, token) {\n    const orderedByScore = DocumentHighlightProviderRegistry.ordered(model);\n    // in order of score ask the occurrences provider\n    // until someone response with a good result\n    // (good = none empty array)\n    return first(orderedByScore.map(provider => () => {\n        return Promise.resolve(provider.provideDocumentHighlights(model, position, token))\n            .then(undefined, onUnexpectedExternalError);\n    }), arrays.isNonEmptyArray);\n}\nclass OccurenceAtPositionRequest {\n    constructor(model, selection, wordSeparators) {\n        this._wordRange = this._getCurrentWordRange(model, selection);\n        this.result = createCancelablePromise(token => this._compute(model, selection, wordSeparators, token));\n    }\n    _getCurrentWordRange(model, selection) {\n        const word = model.getWordAtPosition(selection.getPosition());\n        if (word) {\n            return new Range(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);\n        }\n        return null;\n    }\n    isValid(model, selection, decorationIds) {\n        const lineNumber = selection.startLineNumber;\n        const startColumn = selection.startColumn;\n        const endColumn = selection.endColumn;\n        const currentWordRange = this._getCurrentWordRange(model, selection);\n        let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));\n        // Even if we are on a different word, if that word is in the decorations ranges, the request is still valid\n        // (Same symbol)\n        for (let i = 0, len = decorationIds.length; !requestIsValid && i < len; i++) {\n            let range = model.getDecorationRange(decorationIds[i]);\n            if (range && range.startLineNumber === lineNumber) {\n                if (range.startColumn <= startColumn && range.endColumn >= endColumn) {\n                    requestIsValid = true;\n                }\n            }\n        }\n        return requestIsValid;\n    }\n    cancel() {\n        this.result.cancel();\n    }\n}\nclass SemanticOccurenceAtPositionRequest extends OccurenceAtPositionRequest {\n    _compute(model, selection, wordSeparators, token) {\n        return getOccurrencesAtPosition(model, selection.getPosition(), token).then(value => value || []);\n    }\n}\nclass TextualOccurenceAtPositionRequest extends OccurenceAtPositionRequest {\n    constructor(model, selection, wordSeparators) {\n        super(model, selection, wordSeparators);\n        this._selectionIsEmpty = selection.isEmpty();\n    }\n    _compute(model, selection, wordSeparators, token) {\n        return timeout(250, token).then(() => {\n            if (!selection.isEmpty()) {\n                return [];\n            }\n            const word = model.getWordAtPosition(selection.getPosition());\n            if (!word || word.word.length > 1000) {\n                return [];\n            }\n            const matches = model.findMatches(word.word, true, false, true, wordSeparators, false);\n            return matches.map(m => {\n                return {\n                    range: m.range,\n                    kind: DocumentHighlightKind.Text\n                };\n            });\n        });\n    }\n    isValid(model, selection, decorationIds) {\n        const currentSelectionIsEmpty = selection.isEmpty();\n        if (this._selectionIsEmpty !== currentSelectionIsEmpty) {\n            return false;\n        }\n        return super.isValid(model, selection, decorationIds);\n    }\n}\nfunction computeOccurencesAtPosition(model, selection, wordSeparators) {\n    if (DocumentHighlightProviderRegistry.has(model)) {\n        return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators);\n    }\n    return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators);\n}\nregisterModelAndPositionCommand('_executeDocumentHighlights', (model, position) => getOccurrencesAtPosition(model, position, CancellationToken.None));\nclass WordHighlighter {\n    constructor(editor, contextKeyService) {\n        this.toUnhook = new DisposableStore();\n        this.workerRequestTokenId = 0;\n        this.workerRequestCompleted = false;\n        this.workerRequestValue = [];\n        this.lastCursorPositionChangeTime = 0;\n        this.renderDecorationsTimer = -1;\n        this.editor = editor;\n        this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);\n        this._ignorePositionChangeEvent = false;\n        this.occurrencesHighlight = this.editor.getOption(72 /* occurrencesHighlight */);\n        this.model = this.editor.getModel();\n        this.toUnhook.add(editor.onDidChangeCursorPosition((e) => {\n            if (this._ignorePositionChangeEvent) {\n                // We are changing the position => ignore this event\n                return;\n            }\n            if (!this.occurrencesHighlight) {\n                // Early exit if nothing needs to be done!\n                // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n                return;\n            }\n            this._onPositionChanged(e);\n        }));\n        this.toUnhook.add(editor.onDidChangeModelContent((e) => {\n            this._stopAll();\n        }));\n        this.toUnhook.add(editor.onDidChangeConfiguration((e) => {\n            let newValue = this.editor.getOption(72 /* occurrencesHighlight */);\n            if (this.occurrencesHighlight !== newValue) {\n                this.occurrencesHighlight = newValue;\n                this._stopAll();\n            }\n        }));\n        this._decorationIds = [];\n        this.workerRequestTokenId = 0;\n        this.workerRequest = null;\n        this.workerRequestCompleted = false;\n        this.lastCursorPositionChangeTime = 0;\n        this.renderDecorationsTimer = -1;\n    }\n    hasDecorations() {\n        return (this._decorationIds.length > 0);\n    }\n    restore() {\n        if (!this.occurrencesHighlight) {\n            return;\n        }\n        this._run();\n    }\n    _getSortedHighlights() {\n        return arrays.coalesce(this._decorationIds\n            .map((id) => this.model.getDecorationRange(id))\n            .sort(Range.compareRangesUsingStarts));\n    }\n    moveNext() {\n        let highlights = this._getSortedHighlights();\n        let index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));\n        let newIndex = ((index + 1) % highlights.length);\n        let dest = highlights[newIndex];\n        try {\n            this._ignorePositionChangeEvent = true;\n            this.editor.setPosition(dest.getStartPosition());\n            this.editor.revealRangeInCenterIfOutsideViewport(dest);\n            const word = this._getWord();\n            if (word) {\n                const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);\n                alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);\n            }\n        }\n        finally {\n            this._ignorePositionChangeEvent = false;\n        }\n    }\n    moveBack() {\n        let highlights = this._getSortedHighlights();\n        let index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));\n        let newIndex = ((index - 1 + highlights.length) % highlights.length);\n        let dest = highlights[newIndex];\n        try {\n            this._ignorePositionChangeEvent = true;\n            this.editor.setPosition(dest.getStartPosition());\n            this.editor.revealRangeInCenterIfOutsideViewport(dest);\n            const word = this._getWord();\n            if (word) {\n                const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);\n                alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);\n            }\n        }\n        finally {\n            this._ignorePositionChangeEvent = false;\n        }\n    }\n    _removeDecorations() {\n        if (this._decorationIds.length > 0) {\n            // remove decorations\n            this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);\n            this._hasWordHighlights.set(false);\n        }\n    }\n    _stopAll() {\n        // Remove any existing decorations\n        this._removeDecorations();\n        // Cancel any renderDecorationsTimer\n        if (this.renderDecorationsTimer !== -1) {\n            clearTimeout(this.renderDecorationsTimer);\n            this.renderDecorationsTimer = -1;\n        }\n        // Cancel any worker request\n        if (this.workerRequest !== null) {\n            this.workerRequest.cancel();\n            this.workerRequest = null;\n        }\n        // Invalidate any worker request callback\n        if (!this.workerRequestCompleted) {\n            this.workerRequestTokenId++;\n            this.workerRequestCompleted = true;\n        }\n    }\n    _onPositionChanged(e) {\n        // disabled\n        if (!this.occurrencesHighlight) {\n            this._stopAll();\n            return;\n        }\n        // ignore typing & other\n        if (e.reason !== 3 /* Explicit */) {\n            this._stopAll();\n            return;\n        }\n        this._run();\n    }\n    _getWord() {\n        let editorSelection = this.editor.getSelection();\n        let lineNumber = editorSelection.startLineNumber;\n        let startColumn = editorSelection.startColumn;\n        return this.model.getWordAtPosition({\n            lineNumber: lineNumber,\n            column: startColumn\n        });\n    }\n    _run() {\n        let editorSelection = this.editor.getSelection();\n        // ignore multiline selection\n        if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {\n            this._stopAll();\n            return;\n        }\n        let startColumn = editorSelection.startColumn;\n        let endColumn = editorSelection.endColumn;\n        const word = this._getWord();\n        // The selection must be inside a word or surround one word at most\n        if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {\n            this._stopAll();\n            return;\n        }\n        // All the effort below is trying to achieve this:\n        // - when cursor is moved to a word, trigger immediately a findOccurrences request\n        // - 250ms later after the last cursor move event, render the occurrences\n        // - no flickering!\n        const workerRequestIsValid = (this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this._decorationIds));\n        // There are 4 cases:\n        // a) old workerRequest is valid & completed, renderDecorationsTimer fired\n        // b) old workerRequest is valid & completed, renderDecorationsTimer not fired\n        // c) old workerRequest is valid, but not completed\n        // d) old workerRequest is not valid\n        // For a) no action is needed\n        // For c), member 'lastCursorPositionChangeTime' will be used when installing the timer so no action is needed\n        this.lastCursorPositionChangeTime = (new Date()).getTime();\n        if (workerRequestIsValid) {\n            if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {\n                // case b)\n                // Delay the firing of renderDecorationsTimer by an extra 250 ms\n                clearTimeout(this.renderDecorationsTimer);\n                this.renderDecorationsTimer = -1;\n                this._beginRenderDecorations();\n            }\n        }\n        else {\n            // case d)\n            // Stop all previous actions and start fresh\n            this._stopAll();\n            let myRequestId = ++this.workerRequestTokenId;\n            this.workerRequestCompleted = false;\n            this.workerRequest = computeOccurencesAtPosition(this.model, this.editor.getSelection(), this.editor.getOption(117 /* wordSeparators */));\n            this.workerRequest.result.then(data => {\n                if (myRequestId === this.workerRequestTokenId) {\n                    this.workerRequestCompleted = true;\n                    this.workerRequestValue = data || [];\n                    this._beginRenderDecorations();\n                }\n            }, onUnexpectedError);\n        }\n    }\n    _beginRenderDecorations() {\n        let currentTime = (new Date()).getTime();\n        let minimumRenderTime = this.lastCursorPositionChangeTime + 250;\n        if (currentTime >= minimumRenderTime) {\n            // Synchronous\n            this.renderDecorationsTimer = -1;\n            this.renderDecorations();\n        }\n        else {\n            // Asynchronous\n            this.renderDecorationsTimer = setTimeout(() => {\n                this.renderDecorations();\n            }, (minimumRenderTime - currentTime));\n        }\n    }\n    renderDecorations() {\n        this.renderDecorationsTimer = -1;\n        let decorations = [];\n        for (const info of this.workerRequestValue) {\n            if (info.range) {\n                decorations.push({\n                    range: info.range,\n                    options: WordHighlighter._getDecorationOptions(info.kind)\n                });\n            }\n        }\n        this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);\n        this._hasWordHighlights.set(this.hasDecorations());\n    }\n    static _getDecorationOptions(kind) {\n        if (kind === DocumentHighlightKind.Write) {\n            return this._WRITE_OPTIONS;\n        }\n        else if (kind === DocumentHighlightKind.Text) {\n            return this._TEXT_OPTIONS;\n        }\n        else {\n            return this._REGULAR_OPTIONS;\n        }\n    }\n    dispose() {\n        this._stopAll();\n        this.toUnhook.dispose();\n    }\n}\nWordHighlighter._WRITE_OPTIONS = ModelDecorationOptions.register({\n    description: 'word-highlight-strong',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    className: 'wordHighlightStrong',\n    overviewRuler: {\n        color: themeColorFromId(overviewRulerWordHighlightStrongForeground),\n        position: OverviewRulerLane.Center\n    },\n    minimap: {\n        color: themeColorFromId(minimapSelectionOccurrenceHighlight),\n        position: MinimapPosition.Inline\n    },\n});\nWordHighlighter._TEXT_OPTIONS = ModelDecorationOptions.register({\n    description: 'selection-highlight',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    className: 'selectionHighlight',\n    overviewRuler: {\n        color: themeColorFromId(overviewRulerSelectionHighlightForeground),\n        position: OverviewRulerLane.Center\n    },\n    minimap: {\n        color: themeColorFromId(minimapSelectionOccurrenceHighlight),\n        position: MinimapPosition.Inline\n    },\n});\nWordHighlighter._REGULAR_OPTIONS = ModelDecorationOptions.register({\n    description: 'word-highlight',\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    className: 'wordHighlight',\n    overviewRuler: {\n        color: themeColorFromId(overviewRulerWordHighlightForeground),\n        position: OverviewRulerLane.Center\n    },\n    minimap: {\n        color: themeColorFromId(minimapSelectionOccurrenceHighlight),\n        position: MinimapPosition.Inline\n    },\n});\nlet WordHighlighterContribution = class WordHighlighterContribution extends Disposable {\n    constructor(editor, contextKeyService) {\n        super();\n        this.wordHighlighter = null;\n        const createWordHighlighterIfPossible = () => {\n            if (editor.hasModel()) {\n                this.wordHighlighter = new WordHighlighter(editor, contextKeyService);\n            }\n        };\n        this._register(editor.onDidChangeModel((e) => {\n            if (this.wordHighlighter) {\n                this.wordHighlighter.dispose();\n                this.wordHighlighter = null;\n            }\n            createWordHighlighterIfPossible();\n        }));\n        createWordHighlighterIfPossible();\n    }\n    static get(editor) {\n        return editor.getContribution(WordHighlighterContribution.ID);\n    }\n    saveViewState() {\n        if (this.wordHighlighter && this.wordHighlighter.hasDecorations()) {\n            return true;\n        }\n        return false;\n    }\n    moveNext() {\n        if (this.wordHighlighter) {\n            this.wordHighlighter.moveNext();\n        }\n    }\n    moveBack() {\n        if (this.wordHighlighter) {\n            this.wordHighlighter.moveBack();\n        }\n    }\n    restoreViewState(state) {\n        if (this.wordHighlighter && state) {\n            this.wordHighlighter.restore();\n        }\n    }\n    dispose() {\n        if (this.wordHighlighter) {\n            this.wordHighlighter.dispose();\n            this.wordHighlighter = null;\n        }\n        super.dispose();\n    }\n};\nWordHighlighterContribution.ID = 'editor.contrib.wordHighlighter';\nWordHighlighterContribution = __decorate([\n    __param(1, IContextKeyService)\n], WordHighlighterContribution);\nclass WordHighlightNavigationAction extends EditorAction {\n    constructor(next, opts) {\n        super(opts);\n        this._isNext = next;\n    }\n    run(accessor, editor) {\n        const controller = WordHighlighterContribution.get(editor);\n        if (!controller) {\n            return;\n        }\n        if (this._isNext) {\n            controller.moveNext();\n        }\n        else {\n            controller.moveBack();\n        }\n    }\n}\nclass NextWordHighlightAction extends WordHighlightNavigationAction {\n    constructor() {\n        super(true, {\n            id: 'editor.action.wordHighlight.next',\n            label: nls.localize('wordHighlight.next.label', \"Go to Next Symbol Highlight\"),\n            alias: 'Go to Next Symbol Highlight',\n            precondition: ctxHasWordHighlights,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 65 /* F7 */,\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n}\nclass PrevWordHighlightAction extends WordHighlightNavigationAction {\n    constructor() {\n        super(false, {\n            id: 'editor.action.wordHighlight.prev',\n            label: nls.localize('wordHighlight.previous.label', \"Go to Previous Symbol Highlight\"),\n            alias: 'Go to Previous Symbol Highlight',\n            precondition: ctxHasWordHighlights,\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 1024 /* Shift */ | 65 /* F7 */,\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n}\nclass TriggerWordHighlightAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.wordHighlight.trigger',\n            label: nls.localize('wordHighlight.trigger.label', \"Trigger Symbol Highlight\"),\n            alias: 'Trigger Symbol Highlight',\n            precondition: ctxHasWordHighlights.toNegated(),\n            kbOpts: {\n                kbExpr: EditorContextKeys.editorTextFocus,\n                primary: 0,\n                weight: 100 /* EditorContrib */\n            }\n        });\n    }\n    run(accessor, editor, args) {\n        const controller = WordHighlighterContribution.get(editor);\n        if (!controller) {\n            return;\n        }\n        controller.restoreViewState(true);\n    }\n}\nregisterEditorContribution(WordHighlighterContribution.ID, WordHighlighterContribution);\nregisterEditorAction(NextWordHighlightAction);\nregisterEditorAction(PrevWordHighlightAction);\nregisterEditorAction(TriggerWordHighlightAction);\nregisterThemingParticipant((theme, collector) => {\n    const selectionHighlight = theme.getColor(editorSelectionHighlight);\n    if (selectionHighlight) {\n        collector.addRule(`.monaco-editor .focused .selectionHighlight { background-color: ${selectionHighlight}; }`);\n        collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);\n    }\n    const wordHighlight = theme.getColor(editorWordHighlight);\n    if (wordHighlight) {\n        collector.addRule(`.monaco-editor .wordHighlight { background-color: ${wordHighlight}; }`);\n    }\n    const wordHighlightStrong = theme.getColor(editorWordHighlightStrong);\n    if (wordHighlightStrong) {\n        collector.addRule(`.monaco-editor .wordHighlightStrong { background-color: ${wordHighlightStrong}; }`);\n    }\n    const selectionHighlightBorder = theme.getColor(editorSelectionHighlightBorder);\n    if (selectionHighlightBorder) {\n        collector.addRule(`.monaco-editor .selectionHighlight { border: 1px ${theme.type === 'hc' ? 'dotted' : 'solid'} ${selectionHighlightBorder}; box-sizing: border-box; }`);\n    }\n    const wordHighlightBorder = theme.getColor(editorWordHighlightBorder);\n    if (wordHighlightBorder) {\n        collector.addRule(`.monaco-editor .wordHighlight { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${wordHighlightBorder}; box-sizing: border-box; }`);\n    }\n    const wordHighlightStrongBorder = theme.getColor(editorWordHighlightStrongBorder);\n    if (wordHighlightStrongBorder) {\n        collector.addRule(`.monaco-editor .wordHighlightStrong { border: 1px ${theme.type === 'hc' ? 'dashed' : 'solid'} ${wordHighlightStrongBorder}; box-sizing: border-box; }`);\n    }\n});\n"]},"metadata":{},"sourceType":"module"}