{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\n\nexport function concat23Trees(items) {\n  if (items.length === 0) {\n    return null;\n  }\n\n  if (items.length === 1) {\n    return items[0];\n  }\n\n  let i = 0;\n  /**\n   * Reads nodes of same height and concatenates them to a single node.\n  */\n\n  function readNode() {\n    if (i >= items.length) {\n      return null;\n    }\n\n    const start = i;\n    const height = items[start].listHeight;\n    i++;\n\n    while (i < items.length && items[i].listHeight === height) {\n      i++;\n    }\n\n    if (i - start >= 2) {\n      return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n    } else {\n      return items[start];\n    }\n  } // The items might not have the same height.\n  // We merge all items by using a binary concat operator.\n\n\n  let first = readNode(); // There must be a first item\n\n  let second = readNode();\n\n  if (!second) {\n    return first;\n  }\n\n  for (let item = readNode(); item; item = readNode()) {\n    // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n    if (heightDiff(first, second) <= heightDiff(second, item)) {\n      first = concat(first, second);\n      second = item;\n    } else {\n      second = concat(second, item);\n    }\n  }\n\n  const result = concat(first, second);\n  return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n  if (items.length === 0) {\n    return null;\n  }\n\n  if (items.length === 1) {\n    return items[0];\n  }\n\n  let length = items.length; // All trees have same height, just create parent nodes.\n\n  while (length > 3) {\n    const newLength = length >> 1;\n\n    for (let i = 0; i < newLength; i++) {\n      const j = i << 1;\n      items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n    }\n\n    length = newLength;\n  }\n\n  return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\n\nfunction heightDiff(node1, node2) {\n  return Math.abs(node1.listHeight - node2.listHeight);\n}\n\nfunction concat(node1, node2) {\n  if (node1.listHeight === node2.listHeight) {\n    return ListAstNode.create23(node1, node2, null, false);\n  } else if (node1.listHeight > node2.listHeight) {\n    // node1 is the tree we want to insert into\n    return append(node1, node2);\n  } else {\n    return prepend(node2, node1);\n  }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\n\n\nfunction append(list, nodeToAppend) {\n  list = list.toMutable();\n  let curNode = list;\n  const parents = new Array();\n  let nodeToAppendOfCorrectHeight;\n\n  while (true) {\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    if (nodeToAppend.listHeight === curNode.listHeight) {\n      nodeToAppendOfCorrectHeight = nodeToAppend;\n      break;\n    } // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\n\n    if (curNode.kind !== 4\n    /* List */\n    ) {\n      throw new Error('unexpected');\n    }\n\n    parents.push(curNode); // assert 2 <= curNode.childrenLength <= 3\n\n    curNode = curNode.makeLastElementMutable();\n  } // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\n\n  for (let i = parents.length - 1; i >= 0; i--) {\n    const parent = parents[i];\n\n    if (nodeToAppendOfCorrectHeight) {\n      // Can we take the element?\n      if (parent.childrenLength >= 3) {\n        // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n        // we need to split to maintain (2,3)-tree property.\n        // Send the third element + the new element to the parent.\n        nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n      } else {\n        parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n        nodeToAppendOfCorrectHeight = undefined;\n      }\n    } else {\n      parent.handleChildrenChanged();\n    }\n  }\n\n  if (nodeToAppendOfCorrectHeight) {\n    return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n  } else {\n    return list;\n  }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\n\n\nfunction prepend(list, nodeToAppend) {\n  list = list.toMutable();\n  let curNode = list;\n  const parents = new Array(); // assert nodeToInsert.listHeight <= curNode.listHeight\n\n  while (nodeToAppend.listHeight !== curNode.listHeight) {\n    // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n    if (curNode.kind !== 4\n    /* List */\n    ) {\n      throw new Error('unexpected');\n    }\n\n    parents.push(curNode); // assert 2 <= curNode.childrenFast.length <= 3\n\n    curNode = curNode.makeFirstElementMutable();\n  }\n\n  let nodeToPrependOfCorrectHeight = nodeToAppend; // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\n  for (let i = parents.length - 1; i >= 0; i--) {\n    const parent = parents[i];\n\n    if (nodeToPrependOfCorrectHeight) {\n      // Can we take the element?\n      if (parent.childrenLength >= 3) {\n        // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n        // we need to split to maintain (2,3)-tree property.\n        // Send the third element + the new element to the parent.\n        nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n      } else {\n        parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n        nodeToPrependOfCorrectHeight = undefined;\n      }\n    } else {\n      parent.handleChildrenChanged();\n    }\n  }\n\n  if (nodeToPrependOfCorrectHeight) {\n    return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n  } else {\n    return list;\n  }\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js"],"names":["ListAstNode","concat23Trees","items","length","i","readNode","start","height","listHeight","concat23TreesOfSameHeight","slice","first","second","item","heightDiff","concat","result","createImmutableLists","newLength","j","create23","node1","node2","Math","abs","append","prepend","list","nodeToAppend","toMutable","curNode","parents","Array","nodeToAppendOfCorrectHeight","kind","Error","push","makeLastElementMutable","parent","childrenLength","unappendChild","appendChildOfSameHeight","undefined","handleChildrenChanged","makeFirstElementMutable","nodeToPrependOfCorrectHeight","unprependChild","prependChildOfSameHeight"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = new Array();\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = new Array();\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}