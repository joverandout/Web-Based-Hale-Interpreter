{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { normalize, posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { startsWithIgnoreCase } from './strings.js';\nexport function isPathSeparator(code) {\n  return code === 47\n  /* Slash */\n  || code === 92\n  /* Backslash */\n  ;\n}\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\n\nexport function toSlashes(osPath) {\n  return osPath.replace(/[\\\\/]/g, posix.sep);\n}\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\n\nexport function toPosixPath(osPath) {\n  if (osPath.indexOf('/') === -1) {\n    osPath = toSlashes(osPath);\n  }\n\n  if (/^[a-zA-Z]:(\\/|$)/.test(osPath)) {\n    // starts with a drive letter\n    osPath = '/' + osPath;\n  }\n\n  return osPath;\n}\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\n\nexport function getRoot(path, sep = posix.sep) {\n  if (!path) {\n    return '';\n  }\n\n  const len = path.length;\n  const firstLetter = path.charCodeAt(0);\n\n  if (isPathSeparator(firstLetter)) {\n    if (isPathSeparator(path.charCodeAt(1))) {\n      // UNC candidate \\\\localhost\\shares\\ddd\n      //               ^^^^^^^^^^^^^^^^^^^\n      if (!isPathSeparator(path.charCodeAt(2))) {\n        let pos = 3;\n        const start = pos;\n\n        for (; pos < len; pos++) {\n          if (isPathSeparator(path.charCodeAt(pos))) {\n            break;\n          }\n        }\n\n        if (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n          pos += 1;\n\n          for (; pos < len; pos++) {\n            if (isPathSeparator(path.charCodeAt(pos))) {\n              return path.slice(0, pos + 1) // consume this separator\n              .replace(/[\\\\/]/g, sep);\n            }\n          }\n        }\n      }\n    } // /user/far\n    // ^\n\n\n    return sep;\n  } else if (isWindowsDriveLetter(firstLetter)) {\n    // check for windows drive letter c:\\ or c:\n    if (path.charCodeAt(1) === 58\n    /* Colon */\n    ) {\n      if (isPathSeparator(path.charCodeAt(2))) {\n        // C:\\fff\n        // ^^^\n        return path.slice(0, 2) + sep;\n      } else {\n        // C:\n        // ^^\n        return path.slice(0, 2);\n      }\n    }\n  } // check for URI\n  // scheme://authority/path\n  // ^^^^^^^^^^^^^^^^^^^\n\n\n  let pos = path.indexOf('://');\n\n  if (pos !== -1) {\n    pos += 3; // 3 -> \"://\".length\n\n    for (; pos < len; pos++) {\n      if (isPathSeparator(path.charCodeAt(pos))) {\n        return path.slice(0, pos + 1); // consume this separator\n      }\n    }\n  }\n\n  return '';\n}\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\n\nexport function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {\n  if (base === parentCandidate) {\n    return true;\n  }\n\n  if (!base || !parentCandidate) {\n    return false;\n  }\n\n  if (parentCandidate.length > base.length) {\n    return false;\n  }\n\n  if (ignoreCase) {\n    const beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\n    if (!beginsWith) {\n      return false;\n    }\n\n    if (parentCandidate.length === base.length) {\n      return true; // same path, different casing\n    }\n\n    let sepOffset = parentCandidate.length;\n\n    if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n      sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n    }\n\n    return base.charAt(sepOffset) === separator;\n  }\n\n  if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n    parentCandidate += separator;\n  }\n\n  return base.indexOf(parentCandidate) === 0;\n}\nexport function isWindowsDriveLetter(char0) {\n  return char0 >= 65\n  /* A */\n  && char0 <= 90\n  /* Z */\n  || char0 >= 97\n  /* a */\n  && char0 <= 122\n  /* z */\n  ;\n}\nexport function isRootOrDriveLetter(path) {\n  const pathNormalized = normalize(path);\n\n  if (isWindows) {\n    if (path.length > 3) {\n      return false;\n    }\n\n    return hasDriveLetter(pathNormalized) && (path.length === 2 || pathNormalized.charCodeAt(2) === 92\n    /* Backslash */\n    );\n  }\n\n  return pathNormalized === posix.sep;\n}\nexport function hasDriveLetter(path, continueAsWindows) {\n  const isWindowsPath = continueAsWindows !== undefined ? continueAsWindows : isWindows;\n\n  if (isWindowsPath) {\n    return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58\n    /* Colon */\n    ;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/extpath.js"],"names":["normalize","posix","sep","isWindows","startsWithIgnoreCase","isPathSeparator","code","toSlashes","osPath","replace","toPosixPath","indexOf","test","getRoot","path","len","length","firstLetter","charCodeAt","pos","start","slice","isWindowsDriveLetter","isEqualOrParent","base","parentCandidate","ignoreCase","separator","beginsWith","sepOffset","charAt","char0","isRootOrDriveLetter","pathNormalized","hasDriveLetter","continueAsWindows","isWindowsPath","undefined"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,SAAT,EAAoBC,KAApB,EAA2BC,GAA3B,QAAsC,WAAtC;AACA,SAASC,SAAT,QAA0B,eAA1B;AACA,SAASC,oBAAT,QAAqC,cAArC;AACA,OAAO,SAASC,eAAT,CAAyBC,IAAzB,EAA+B;AAClC,SAAOA,IAAI,KAAK;AAAG;AAAZ,KAA2BA,IAAI,KAAK;AAAG;AAA9C;AACH;AACD;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,SAAT,CAAmBC,MAAnB,EAA2B;AAC9B,SAAOA,MAAM,CAACC,OAAP,CAAe,QAAf,EAAyBR,KAAK,CAACC,GAA/B,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASQ,WAAT,CAAqBF,MAArB,EAA6B;AAChC,MAAIA,MAAM,CAACG,OAAP,CAAe,GAAf,MAAwB,CAAC,CAA7B,EAAgC;AAC5BH,IAAAA,MAAM,GAAGD,SAAS,CAACC,MAAD,CAAlB;AACH;;AACD,MAAI,mBAAmBI,IAAnB,CAAwBJ,MAAxB,CAAJ,EAAqC;AAAE;AACnCA,IAAAA,MAAM,GAAG,MAAMA,MAAf;AACH;;AACD,SAAOA,MAAP;AACH;AACD;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,OAAT,CAAiBC,IAAjB,EAAuBZ,GAAG,GAAGD,KAAK,CAACC,GAAnC,EAAwC;AAC3C,MAAI,CAACY,IAAL,EAAW;AACP,WAAO,EAAP;AACH;;AACD,QAAMC,GAAG,GAAGD,IAAI,CAACE,MAAjB;AACA,QAAMC,WAAW,GAAGH,IAAI,CAACI,UAAL,CAAgB,CAAhB,CAApB;;AACA,MAAIb,eAAe,CAACY,WAAD,CAAnB,EAAkC;AAC9B,QAAIZ,eAAe,CAACS,IAAI,CAACI,UAAL,CAAgB,CAAhB,CAAD,CAAnB,EAAyC;AACrC;AACA;AACA,UAAI,CAACb,eAAe,CAACS,IAAI,CAACI,UAAL,CAAgB,CAAhB,CAAD,CAApB,EAA0C;AACtC,YAAIC,GAAG,GAAG,CAAV;AACA,cAAMC,KAAK,GAAGD,GAAd;;AACA,eAAOA,GAAG,GAAGJ,GAAb,EAAkBI,GAAG,EAArB,EAAyB;AACrB,cAAId,eAAe,CAACS,IAAI,CAACI,UAAL,CAAgBC,GAAhB,CAAD,CAAnB,EAA2C;AACvC;AACH;AACJ;;AACD,YAAIC,KAAK,KAAKD,GAAV,IAAiB,CAACd,eAAe,CAACS,IAAI,CAACI,UAAL,CAAgBC,GAAG,GAAG,CAAtB,CAAD,CAArC,EAAiE;AAC7DA,UAAAA,GAAG,IAAI,CAAP;;AACA,iBAAOA,GAAG,GAAGJ,GAAb,EAAkBI,GAAG,EAArB,EAAyB;AACrB,gBAAId,eAAe,CAACS,IAAI,CAACI,UAAL,CAAgBC,GAAhB,CAAD,CAAnB,EAA2C;AACvC,qBAAOL,IAAI,CAACO,KAAL,CAAW,CAAX,EAAcF,GAAG,GAAG,CAApB,EAAuB;AAAvB,eACFV,OADE,CACM,QADN,EACgBP,GADhB,CAAP;AAEH;AACJ;AACJ;AACJ;AACJ,KAtB6B,CAuB9B;AACA;;;AACA,WAAOA,GAAP;AACH,GA1BD,MA2BK,IAAIoB,oBAAoB,CAACL,WAAD,CAAxB,EAAuC;AACxC;AACA,QAAIH,IAAI,CAACI,UAAL,CAAgB,CAAhB,MAAuB;AAAG;AAA9B,MAA2C;AACvC,UAAIb,eAAe,CAACS,IAAI,CAACI,UAAL,CAAgB,CAAhB,CAAD,CAAnB,EAAyC;AACrC;AACA;AACA,eAAOJ,IAAI,CAACO,KAAL,CAAW,CAAX,EAAc,CAAd,IAAmBnB,GAA1B;AACH,OAJD,MAKK;AACD;AACA;AACA,eAAOY,IAAI,CAACO,KAAL,CAAW,CAAX,EAAc,CAAd,CAAP;AACH;AACJ;AACJ,GA/C0C,CAgD3C;AACA;AACA;;;AACA,MAAIF,GAAG,GAAGL,IAAI,CAACH,OAAL,CAAa,KAAb,CAAV;;AACA,MAAIQ,GAAG,KAAK,CAAC,CAAb,EAAgB;AACZA,IAAAA,GAAG,IAAI,CAAP,CADY,CACF;;AACV,WAAOA,GAAG,GAAGJ,GAAb,EAAkBI,GAAG,EAArB,EAAyB;AACrB,UAAId,eAAe,CAACS,IAAI,CAACI,UAAL,CAAgBC,GAAhB,CAAD,CAAnB,EAA2C;AACvC,eAAOL,IAAI,CAACO,KAAL,CAAW,CAAX,EAAcF,GAAG,GAAG,CAApB,CAAP,CADuC,CACR;AAClC;AACJ;AACJ;;AACD,SAAO,EAAP;AACH;AACD;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,eAAT,CAAyBC,IAAzB,EAA+BC,eAA/B,EAAgDC,UAAhD,EAA4DC,SAAS,GAAGzB,GAAxE,EAA6E;AAChF,MAAIsB,IAAI,KAAKC,eAAb,EAA8B;AAC1B,WAAO,IAAP;AACH;;AACD,MAAI,CAACD,IAAD,IAAS,CAACC,eAAd,EAA+B;AAC3B,WAAO,KAAP;AACH;;AACD,MAAIA,eAAe,CAACT,MAAhB,GAAyBQ,IAAI,CAACR,MAAlC,EAA0C;AACtC,WAAO,KAAP;AACH;;AACD,MAAIU,UAAJ,EAAgB;AACZ,UAAME,UAAU,GAAGxB,oBAAoB,CAACoB,IAAD,EAAOC,eAAP,CAAvC;;AACA,QAAI,CAACG,UAAL,EAAiB;AACb,aAAO,KAAP;AACH;;AACD,QAAIH,eAAe,CAACT,MAAhB,KAA2BQ,IAAI,CAACR,MAApC,EAA4C;AACxC,aAAO,IAAP,CADwC,CAC3B;AAChB;;AACD,QAAIa,SAAS,GAAGJ,eAAe,CAACT,MAAhC;;AACA,QAAIS,eAAe,CAACK,MAAhB,CAAuBL,eAAe,CAACT,MAAhB,GAAyB,CAAhD,MAAuDW,SAA3D,EAAsE;AAClEE,MAAAA,SAAS,GADyD,CACrD;AAChB;;AACD,WAAOL,IAAI,CAACM,MAAL,CAAYD,SAAZ,MAA2BF,SAAlC;AACH;;AACD,MAAIF,eAAe,CAACK,MAAhB,CAAuBL,eAAe,CAACT,MAAhB,GAAyB,CAAhD,MAAuDW,SAA3D,EAAsE;AAClEF,IAAAA,eAAe,IAAIE,SAAnB;AACH;;AACD,SAAOH,IAAI,CAACb,OAAL,CAAac,eAAb,MAAkC,CAAzC;AACH;AACD,OAAO,SAASH,oBAAT,CAA8BS,KAA9B,EAAqC;AACxC,SAAOA,KAAK,IAAI;AAAG;AAAZ,KAAuBA,KAAK,IAAI;AAAG;AAAnC,KAA8CA,KAAK,IAAI;AAAG;AAAZ,KAAuBA,KAAK,IAAI;AAAI;AAAzF;AACH;AACD,OAAO,SAASC,mBAAT,CAA6BlB,IAA7B,EAAmC;AACtC,QAAMmB,cAAc,GAAGjC,SAAS,CAACc,IAAD,CAAhC;;AACA,MAAIX,SAAJ,EAAe;AACX,QAAIW,IAAI,CAACE,MAAL,GAAc,CAAlB,EAAqB;AACjB,aAAO,KAAP;AACH;;AACD,WAAOkB,cAAc,CAACD,cAAD,CAAd,KACFnB,IAAI,CAACE,MAAL,KAAgB,CAAhB,IAAqBiB,cAAc,CAACf,UAAf,CAA0B,CAA1B,MAAiC;AAAG;AADvD,KAAP;AAEH;;AACD,SAAOe,cAAc,KAAKhC,KAAK,CAACC,GAAhC;AACH;AACD,OAAO,SAASgC,cAAT,CAAwBpB,IAAxB,EAA8BqB,iBAA9B,EAAiD;AACpD,QAAMC,aAAa,GAAKD,iBAAiB,KAAKE,SAAvB,GAAoCF,iBAApC,GAAwDhC,SAA/E;;AACA,MAAIiC,aAAJ,EAAmB;AACf,WAAOd,oBAAoB,CAACR,IAAI,CAACI,UAAL,CAAgB,CAAhB,CAAD,CAApB,IAA4CJ,IAAI,CAACI,UAAL,CAAgB,CAAhB,MAAuB;AAAG;AAA7E;AACH;;AACD,SAAO,KAAP;AACH","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { normalize, posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { startsWithIgnoreCase } from './strings.js';\nexport function isPathSeparator(code) {\n    return code === 47 /* Slash */ || code === 92 /* Backslash */;\n}\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath) {\n    return osPath.replace(/[\\\\/]/g, posix.sep);\n}\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath) {\n    if (osPath.indexOf('/') === -1) {\n        osPath = toSlashes(osPath);\n    }\n    if (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n        osPath = '/' + osPath;\n    }\n    return osPath;\n}\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path, sep = posix.sep) {\n    if (!path) {\n        return '';\n    }\n    const len = path.length;\n    const firstLetter = path.charCodeAt(0);\n    if (isPathSeparator(firstLetter)) {\n        if (isPathSeparator(path.charCodeAt(1))) {\n            // UNC candidate \\\\localhost\\shares\\ddd\n            //               ^^^^^^^^^^^^^^^^^^^\n            if (!isPathSeparator(path.charCodeAt(2))) {\n                let pos = 3;\n                const start = pos;\n                for (; pos < len; pos++) {\n                    if (isPathSeparator(path.charCodeAt(pos))) {\n                        break;\n                    }\n                }\n                if (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n                    pos += 1;\n                    for (; pos < len; pos++) {\n                        if (isPathSeparator(path.charCodeAt(pos))) {\n                            return path.slice(0, pos + 1) // consume this separator\n                                .replace(/[\\\\/]/g, sep);\n                        }\n                    }\n                }\n            }\n        }\n        // /user/far\n        // ^\n        return sep;\n    }\n    else if (isWindowsDriveLetter(firstLetter)) {\n        // check for windows drive letter c:\\ or c:\n        if (path.charCodeAt(1) === 58 /* Colon */) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n                // C:\\fff\n                // ^^^\n                return path.slice(0, 2) + sep;\n            }\n            else {\n                // C:\n                // ^^\n                return path.slice(0, 2);\n            }\n        }\n    }\n    // check for URI\n    // scheme://authority/path\n    // ^^^^^^^^^^^^^^^^^^^\n    let pos = path.indexOf('://');\n    if (pos !== -1) {\n        pos += 3; // 3 -> \"://\".length\n        for (; pos < len; pos++) {\n            if (isPathSeparator(path.charCodeAt(pos))) {\n                return path.slice(0, pos + 1); // consume this separator\n            }\n        }\n    }\n    return '';\n}\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {\n    if (base === parentCandidate) {\n        return true;\n    }\n    if (!base || !parentCandidate) {\n        return false;\n    }\n    if (parentCandidate.length > base.length) {\n        return false;\n    }\n    if (ignoreCase) {\n        const beginsWith = startsWithIgnoreCase(base, parentCandidate);\n        if (!beginsWith) {\n            return false;\n        }\n        if (parentCandidate.length === base.length) {\n            return true; // same path, different casing\n        }\n        let sepOffset = parentCandidate.length;\n        if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n            sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n        }\n        return base.charAt(sepOffset) === separator;\n    }\n    if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n        parentCandidate += separator;\n    }\n    return base.indexOf(parentCandidate) === 0;\n}\nexport function isWindowsDriveLetter(char0) {\n    return char0 >= 65 /* A */ && char0 <= 90 /* Z */ || char0 >= 97 /* a */ && char0 <= 122 /* z */;\n}\nexport function isRootOrDriveLetter(path) {\n    const pathNormalized = normalize(path);\n    if (isWindows) {\n        if (path.length > 3) {\n            return false;\n        }\n        return hasDriveLetter(pathNormalized) &&\n            (path.length === 2 || pathNormalized.charCodeAt(2) === 92 /* Backslash */);\n    }\n    return pathNormalized === posix.sep;\n}\nexport function hasDriveLetter(path, continueAsWindows) {\n    const isWindowsPath = ((continueAsWindows !== undefined) ? continueAsWindows : isWindows);\n    if (isWindowsPath) {\n        return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* Colon */;\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"module"}