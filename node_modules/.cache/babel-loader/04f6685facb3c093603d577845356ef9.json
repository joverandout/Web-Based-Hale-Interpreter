{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from './cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nexport class TypeOperations {\n  static indent(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ShiftCommand(selections[i], {\n        isUnshift: false,\n        tabSize: config.tabSize,\n        indentSize: config.indentSize,\n        insertSpaces: config.insertSpaces,\n        useTabStops: config.useTabStops,\n        autoIndent: config.autoIndent\n      });\n    }\n\n    return commands;\n  }\n\n  static outdent(config, model, selections) {\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ShiftCommand(selections[i], {\n        isUnshift: true,\n        tabSize: config.tabSize,\n        indentSize: config.indentSize,\n        insertSpaces: config.insertSpaces,\n        useTabStops: config.useTabStops,\n        autoIndent: config.autoIndent\n      });\n    }\n\n    return commands;\n  }\n\n  static shiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n  }\n\n  static unshiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n  }\n\n  static _distributedPaste(config, model, selections, text) {\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], text[i]);\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n\n  static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const position = selection.getPosition();\n\n      if (pasteOnNewLine && !selection.isEmpty()) {\n        pasteOnNewLine = false;\n      }\n\n      if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n        pasteOnNewLine = false;\n      }\n\n      if (pasteOnNewLine) {\n        // Paste entire line at the beginning of line\n        const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n        commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n      } else {\n        commands[i] = new ReplaceCommand(selection, text);\n      }\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n\n  static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n    if (pasteOnNewLine) {\n      return null;\n    }\n\n    if (selections.length === 1) {\n      return null;\n    }\n\n    if (multicursorText && multicursorText.length === selections.length) {\n      return multicursorText;\n    }\n\n    if (config.multiCursorPaste === 'spread') {\n      // Try to spread the pasted text in case the line count matches the cursor count\n      // Remove trailing \\n if present\n      if (text.charCodeAt(text.length - 1) === 10\n      /* LineFeed */\n      ) {\n        text = text.substr(0, text.length - 1);\n      } // Remove trailing \\r if present\n\n\n      if (text.charCodeAt(text.length - 1) === 13\n      /* CarriageReturn */\n      ) {\n        text = text.substr(0, text.length - 1);\n      }\n\n      const lines = strings.splitLines(text);\n\n      if (lines.length === selections.length) {\n        return lines;\n      }\n    }\n\n    return null;\n  }\n\n  static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n    const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n\n    if (distributedPaste) {\n      selections = selections.sort(Range.compareRangesUsingStarts);\n      return this._distributedPaste(config, model, selections, distributedPaste);\n    } else {\n      return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n    }\n  }\n\n  static _goodIndentForLine(config, model, lineNumber) {\n    let action = null;\n    let indentation = '';\n    const expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model, lineNumber, false);\n\n    if (expectedIndentAction) {\n      action = expectedIndentAction.action;\n      indentation = expectedIndentAction.indentation;\n    } else if (lineNumber > 1) {\n      let lastLineNumber;\n\n      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n        const lineText = model.getLineContent(lastLineNumber);\n        const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n      }\n\n      if (lastLineNumber < 1) {\n        // No previous line with content found\n        return null;\n      }\n\n      const maxColumn = model.getLineMaxColumn(lastLineNumber);\n      const expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n\n      if (expectedEnterAction) {\n        indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n      }\n    }\n\n    if (action) {\n      if (action === IndentAction.Indent) {\n        indentation = TypeOperations.shiftIndent(config, indentation);\n      }\n\n      if (action === IndentAction.Outdent) {\n        indentation = TypeOperations.unshiftIndent(config, indentation);\n      }\n\n      indentation = config.normalizeIndentation(indentation);\n    }\n\n    if (!indentation) {\n      return null;\n    }\n\n    return indentation;\n  }\n\n  static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n    let typeText = '';\n    const position = selection.getStartPosition();\n\n    if (config.insertSpaces) {\n      const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n      const indentSize = config.indentSize;\n      const spacesCnt = indentSize - visibleColumnFromColumn % indentSize;\n\n      for (let i = 0; i < spacesCnt; i++) {\n        typeText += ' ';\n      }\n    } else {\n      typeText = '\\t';\n    }\n\n    return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n  }\n\n  static tab(config, model, selections) {\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n\n      if (selection.isEmpty()) {\n        const lineText = model.getLineContent(selection.startLineNumber);\n\n        if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n          let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n\n          goodIndent = goodIndent || '\\t';\n          const possibleTypeText = config.normalizeIndentation(goodIndent);\n\n          if (!lineText.startsWith(possibleTypeText)) {\n            commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n            continue;\n          }\n        }\n\n        commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n      } else {\n        if (selection.startLineNumber === selection.endLineNumber) {\n          const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n\n          if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n            // This is a single line selection that is not the entire line\n            commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n            continue;\n          }\n        }\n\n        commands[i] = new ShiftCommand(selection, {\n          isUnshift: false,\n          tabSize: config.tabSize,\n          indentSize: config.indentSize,\n          insertSpaces: config.insertSpaces,\n          useTabStops: config.useTabStops,\n          autoIndent: config.autoIndent\n        });\n      }\n    }\n\n    return commands;\n  }\n\n  static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n    const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n    return new EditOperationResult(4\n    /* TypingOther */\n    , commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4\n      /* TypingOther */\n      ),\n      shouldPushStackElementAfter: false\n    });\n  }\n\n  static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n    if (!selection.isEmpty()) {\n      // looks like https://github.com/microsoft/vscode/issues/2773\n      // where a cursor operation occurred before a canceled composition\n      // => ignore composition\n      return null;\n    }\n\n    const pos = selection.getPosition();\n    const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n    const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n    const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n    const oldText = model.getValueInRange(range);\n\n    if (oldText === text && positionDelta === 0) {\n      // => ignore composition that doesn't do anything\n      return null;\n    }\n\n    return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n  }\n\n  static _typeCommand(range, text, keepPosition) {\n    if (keepPosition) {\n      return new ReplaceCommandWithoutChangingPosition(range, text, true);\n    } else {\n      return new ReplaceCommand(range, text, true);\n    }\n  }\n\n  static _enter(config, model, keepPosition, range) {\n    if (config.autoIndent === 0\n    /* None */\n    ) {\n      return TypeOperations._typeCommand(range, '\\n', keepPosition);\n    }\n\n    if (!model.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1\n    /* Keep */\n    ) {\n      const lineText = model.getLineContent(range.startLineNumber);\n      const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n      return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n\n    const r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, range);\n\n    if (r) {\n      if (r.indentAction === IndentAction.None) {\n        // Nothing special\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n      } else if (r.indentAction === IndentAction.Indent) {\n        // Indent once\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n      } else if (r.indentAction === IndentAction.IndentOutdent) {\n        // Ultra special\n        const normalIndent = config.normalizeIndentation(r.indentation);\n        const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n        const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n        } else {\n          return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n        }\n      } else if (r.indentAction === IndentAction.Outdent) {\n        const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n      }\n    }\n\n    const lineText = model.getLineContent(range.startLineNumber);\n    const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\n    if (config.autoIndent >= 4\n    /* Full */\n    ) {\n      const ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model, range, {\n        unshiftIndent: indent => {\n          return TypeOperations.unshiftIndent(config, indent);\n        },\n        shiftIndent: indent => {\n          return TypeOperations.shiftIndent(config, indent);\n        },\n        normalizeIndentation: indent => {\n          return config.normalizeIndentation(indent);\n        }\n      });\n\n      if (ir) {\n        let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n        const oldEndColumn = range.endColumn;\n        const newLineContent = model.getLineContent(range.endLineNumber);\n        const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n\n        if (firstNonWhitespace >= 0) {\n          range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n        } else {\n          range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n        }\n\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n        } else {\n          let offset = 0;\n\n          if (oldEndColumn <= firstNonWhitespace + 1) {\n            if (!config.insertSpaces) {\n              oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n            }\n\n            offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n          }\n\n          return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n        }\n      }\n    }\n\n    return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n  }\n\n  static _isAutoIndentType(config, model, selections) {\n    if (config.autoIndent < 4\n    /* Full */\n    ) {\n      return false;\n    }\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static _runAutoIndentType(config, model, range, ch) {\n    const currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    const actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model, range, ch, {\n      shiftIndent: indentation => {\n        return TypeOperations.shiftIndent(config, indentation);\n      },\n      unshiftIndent: indentation => {\n        return TypeOperations.unshiftIndent(config, indentation);\n      }\n    });\n\n    if (actualIndentation === null) {\n      return null;\n    }\n\n    if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n      const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n\n      if (firstNonWhitespace === 0) {\n        return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n      } else {\n        return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n      }\n    }\n\n    return null;\n  }\n\n  static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n    if (config.autoClosingOvertype === 'never') {\n      return false;\n    }\n\n    if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n      return false;\n    }\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n\n      if (!selection.isEmpty()) {\n        return false;\n      }\n\n      const position = selection.getPosition();\n      const lineText = model.getLineContent(position.lineNumber);\n      const afterCharacter = lineText.charAt(position.column - 1);\n\n      if (afterCharacter !== ch) {\n        return false;\n      } // Do not over-type quotes after a backslash\n\n\n      const chIsQuote = isQuote(ch);\n      const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0\n      /* Null */\n      ;\n\n      if (beforeCharacter === 92\n      /* Backslash */\n      && chIsQuote) {\n        return false;\n      } // Must over-type a closing character typed by the editor\n\n\n      if (config.autoClosingOvertype === 'auto') {\n        let found = false;\n\n        for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n          const autoClosedCharacter = autoClosedCharacters[j];\n\n          if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const position = selection.getPosition();\n      const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n      commands[i] = new ReplaceCommand(typeSelection, ch);\n    }\n\n    return new EditOperationResult(4\n    /* TypingOther */\n    , commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4\n      /* TypingOther */\n      ),\n      shouldPushStackElementAfter: false\n    });\n  }\n\n  static _isBeforeClosingBrace(config, lineAfter) {\n    // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n    const nextChar = lineAfter.charAt(0);\n    const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n    const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n    const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n    const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n    return !isBeforeStartingBrace && isBeforeClosingBrace;\n  }\n  /**\n   * Determine if typing `ch` at all `positions` in the `model` results in an\n   * auto closing open sequence being typed.\n   *\n   * Auto closing open sequences can consist of multiple characters, which\n   * can lead to ambiguities. In such a case, the longest auto-closing open\n   * sequence is returned.\n   */\n\n\n  static _findAutoClosingPairOpen(config, model, positions, ch) {\n    const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n\n    if (!candidates) {\n      return null;\n    } // Determine which auto-closing pair it is\n\n\n    let result = null;\n\n    for (const candidate of candidates) {\n      if (result === null || candidate.open.length > result.open.length) {\n        let candidateIsMatch = true;\n\n        for (const position of positions) {\n          const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n\n          if (relevantText + ch !== candidate.open) {\n            candidateIsMatch = false;\n            break;\n          }\n        }\n\n        if (candidateIsMatch) {\n          result = candidate;\n        }\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Find another auto-closing pair that is contained by the one passed in.\n   *\n   * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n   * this method will find [(,)] as a containment pair for [(*,*)]\n   */\n\n\n  static _findContainedAutoClosingPair(config, pair) {\n    if (pair.open.length <= 1) {\n      return null;\n    }\n\n    const lastChar = pair.close.charAt(pair.close.length - 1); // get candidates with the same last character as close\n\n    const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n    let result = null;\n\n    for (const candidate of candidates) {\n      if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n        if (!result || candidate.open.length > result.open.length) {\n          result = candidate;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n    const chIsQuote = isQuote(ch);\n    const autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\n    const shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n\n    if (autoCloseConfig === 'never') {\n      return null;\n    }\n\n    for (const selection of selections) {\n      if (!selection.isEmpty()) {\n        return null;\n      }\n    } // This method is called both when typing (regularly) and when composition ends\n    // This means that we need to work with a text buffer where sometimes `ch` is not\n    // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n    //\n    // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n    // with two conceptual positions, the position before `ch` and the position after `ch`\n    //\n\n\n    const positions = selections.map(s => {\n      const position = s.getPosition();\n\n      if (chIsAlreadyTyped) {\n        return {\n          lineNumber: position.lineNumber,\n          beforeColumn: position.column - ch.length,\n          afterColumn: position.column\n        };\n      } else {\n        return {\n          lineNumber: position.lineNumber,\n          beforeColumn: position.column,\n          afterColumn: position.column\n        };\n      }\n    }); // Find the longest auto-closing open pair in case of multiple ending in `ch`\n    // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n\n    const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n\n    if (!pair) {\n      return null;\n    } // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n    // e.g. when having [(,)] and [(*,*)]\n    // - when typing (, the resulting state is (|)\n    // - when typing *, the desired resulting state is (*|*), not (*|*))\n\n\n    const containedPair = this._findContainedAutoClosingPair(config, pair);\n\n    const containedPairClose = containedPair ? containedPair.close : '';\n    let isContainedPairPresent = true;\n\n    for (const position of positions) {\n      const {\n        lineNumber,\n        beforeColumn,\n        afterColumn\n      } = position;\n      const lineText = model.getLineContent(lineNumber);\n      const lineBefore = lineText.substring(0, beforeColumn - 1);\n      const lineAfter = lineText.substring(afterColumn - 1);\n\n      if (!lineAfter.startsWith(containedPairClose)) {\n        isContainedPairPresent = false;\n      } // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n\n\n      if (lineAfter.length > 0) {\n        const characterAfter = lineAfter.charAt(0);\n\n        const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n\n        if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n          return null;\n        }\n      } // Do not auto-close ' or \" after a word character\n\n\n      if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n\n        if (lineBefore.length > 0) {\n          const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n\n          if (wordSeparators.get(characterBefore) === 0\n          /* Regular */\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (!model.isCheapToTokenize(lineNumber)) {\n        // Do not force tokenization\n        return null;\n      }\n\n      model.forceTokenization(lineNumber);\n      const lineTokens = model.getLineTokens(lineNumber);\n      const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n\n      if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n        return null;\n      } // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n      // or it could end a previously started string, in which case auto-closing is not desirable\n      //\n      // In certain cases, it is really not possible to look at the previous token to determine\n      // what would happen. That's why we do something really unusual, we pretend to type a different\n      // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n      // character, are we in a string (i.e. the quote would most likely end a string) or not?\n      //\n\n\n      const neutralCharacter = pair.findNeutralCharacter();\n\n      if (neutralCharacter) {\n        const tokenType = model.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n\n        if (!pair.isOK(tokenType)) {\n          return null;\n        }\n      }\n    }\n\n    if (isContainedPairPresent) {\n      return pair.close.substring(0, pair.close.length - containedPairClose.length);\n    } else {\n      return pair.close;\n    }\n  }\n\n  static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n    }\n\n    return new EditOperationResult(4\n    /* TypingOther */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: false\n    });\n  }\n\n  static _shouldSurroundChar(config, ch) {\n    if (isQuote(ch)) {\n      return config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined';\n    } else {\n      // Character is a bracket\n      return config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined';\n    }\n  }\n\n  static _isSurroundSelectionType(config, model, selections, ch) {\n    if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n      return false;\n    }\n\n    const isTypingAQuoteCharacter = isQuote(ch);\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n\n      if (selection.isEmpty()) {\n        return false;\n      }\n\n      let selectionContainsOnlyWhitespace = true;\n\n      for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n        const lineText = model.getLineContent(lineNumber);\n        const startIndex = lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0;\n        const endIndex = lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length;\n        const selectedText = lineText.substring(startIndex, endIndex);\n\n        if (/[^ \\t]/.test(selectedText)) {\n          // this selected text contains something other than whitespace\n          selectionContainsOnlyWhitespace = false;\n          break;\n        }\n      }\n\n      if (selectionContainsOnlyWhitespace) {\n        return false;\n      }\n\n      if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n        const selectionText = model.getValueInRange(selection);\n\n        if (isQuote(selectionText)) {\n          // Typing a quote character on top of another quote character\n          // => disable surround selection type\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const closeCharacter = config.surroundingPairs[ch];\n      commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n\n  static _isTypeInterceptorElectricChar(config, model, selections) {\n    if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n    if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n      return null;\n    }\n\n    const position = selection.getPosition();\n    model.forceTokenization(position.lineNumber);\n    const lineTokens = model.getLineTokens(position.lineNumber);\n    let electricAction;\n\n    try {\n      electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n    } catch (e) {\n      onUnexpectedError(e);\n      return null;\n    }\n\n    if (!electricAction) {\n      return null;\n    }\n\n    if (electricAction.matchOpenBracket) {\n      const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n      const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n        lineNumber: position.lineNumber,\n        column: endColumn\n      });\n\n      if (match) {\n        if (match.startLineNumber === position.lineNumber) {\n          // matched something on the same line => no change in indentation\n          return null;\n        }\n\n        const matchLine = model.getLineContent(match.startLineNumber);\n        const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n        const newIndentation = config.normalizeIndentation(matchLineIndentation);\n        const lineText = model.getLineContent(position.lineNumber);\n        const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n        const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n        const typeText = newIndentation + prefix + ch;\n        const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n        const command = new ReplaceCommand(typeSelection, typeText);\n        return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n          shouldPushStackElementBefore: false,\n          shouldPushStackElementAfter: true\n        });\n      }\n    }\n\n    return null;\n  }\n  /**\n   * This is very similar with typing, but the character is already in the text buffer!\n   */\n\n\n  static compositionEndWithInterceptors(prevEditOperationType, config, model, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {\n    if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {\n      // no content was typed\n      return null;\n    }\n\n    let ch = null; // extract last typed character\n\n    for (const selection of selections) {\n      if (!selection.isEmpty()) {\n        return null;\n      }\n\n      const position = selection.getPosition();\n      const currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\n\n      if (ch === null) {\n        ch = currentChar;\n      } else if (ch !== currentChar) {\n        return null;\n      }\n    }\n\n    if (!ch) {\n      return null;\n    }\n\n    if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n      const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n      return new EditOperationResult(4\n      /* TypingOther */\n      , commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n\n    const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n\n    if (autoClosingPairClose !== null) {\n      return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n    }\n\n    return null;\n  }\n\n  static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n    if (!isDoingComposition && ch === '\\n') {\n      const commands = [];\n\n      for (let i = 0, len = selections.length; i < len; i++) {\n        commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n      }\n\n      return new EditOperationResult(4\n      /* TypingOther */\n      , commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n\n    if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n      const commands = [];\n      let autoIndentFails = false;\n\n      for (let i = 0, len = selections.length; i < len; i++) {\n        commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n\n        if (!commands[i]) {\n          autoIndentFails = true;\n          break;\n        }\n      }\n\n      if (!autoIndentFails) {\n        return new EditOperationResult(4\n        /* TypingOther */\n        , commands, {\n          shouldPushStackElementBefore: true,\n          shouldPushStackElementAfter: false\n        });\n      }\n    }\n\n    if (!isDoingComposition && this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n    }\n\n    if (!isDoingComposition) {\n      const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n\n      if (autoClosingPairClose) {\n        return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n      }\n    }\n\n    if (this._isSurroundSelectionType(config, model, selections, ch)) {\n      return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n    } // Electric characters make sense only when dealing with a single cursor,\n    // as multiple cursors typing brackets for example would interfer with bracket matching\n\n\n    if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n      const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n\n      if (r) {\n        return r;\n      }\n    } // A simple character type\n\n\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], ch);\n    }\n\n    const opType = getTypingOperation(ch, prevEditOperationType);\n    return new EditOperationResult(opType, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n      shouldPushStackElementAfter: false\n    });\n  }\n\n  static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], str);\n    }\n\n    const opType = getTypingOperation(str, prevEditOperationType);\n    return new EditOperationResult(opType, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n      shouldPushStackElementAfter: false\n    });\n  }\n\n  static lineInsertBefore(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      let lineNumber = selections[i].positionLineNumber;\n\n      if (lineNumber === 1) {\n        commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n      } else {\n        lineNumber--;\n        const column = model.getLineMaxColumn(lineNumber);\n        commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n      }\n    }\n\n    return commands;\n  }\n\n  static lineInsertAfter(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const lineNumber = selections[i].positionLineNumber;\n      const column = model.getLineMaxColumn(lineNumber);\n      commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n    }\n\n    return commands;\n  }\n\n  static lineBreakInsert(config, model, selections) {\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = this._enter(config, model, true, selections[i]);\n    }\n\n    return commands;\n  }\n\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n  constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n    super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n    this._openCharacter = openCharacter;\n    this._closeCharacter = closeCharacter;\n    this.closeCharacterRange = null;\n    this.enclosingRange = null;\n  }\n\n  computeCursorState(model, helper) {\n    const inverseEditOperations = helper.getInverseEditOperations();\n    const range = inverseEditOperations[0].range;\n    this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    return super.computeCursorState(model, helper);\n  }\n\n}\n\nfunction getTypingOperation(typedText, previousTypingOperation) {\n  if (typedText === ' ') {\n    return previousTypingOperation === 5\n    /* TypingFirstSpace */\n    || previousTypingOperation === 6\n    /* TypingConsecutiveSpace */\n    ? 6\n    /* TypingConsecutiveSpace */\n    : 5\n    /* TypingFirstSpace */\n    ;\n  }\n\n  return 4\n  /* TypingOther */\n  ;\n}\n\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n  if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n    // Always set an undo stop before non-type operations\n    return true;\n  }\n\n  if (previousTypingOperation === 5\n  /* TypingFirstSpace */\n  ) {\n    // `abc |d`: No undo stop\n    // `abc  |d`: Undo stop\n    return false;\n  } // Insert undo stop between different operation types\n\n\n  return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\n\nfunction normalizeOperationType(type) {\n  return type === 6\n  /* TypingConsecutiveSpace */\n  || type === 5\n  /* TypingFirstSpace */\n  ? 'space' : type;\n}\n\nfunction isTypingOperation(type) {\n  return type === 4\n  /* TypingOther */\n  || type === 5\n  /* TypingFirstSpace */\n  || type === 6\n  /* TypingConsecutiveSpace */\n  ;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js"],"names":["onUnexpectedError","strings","ReplaceCommand","ReplaceCommandWithOffsetCursorState","ReplaceCommandWithoutChangingPosition","ReplaceCommandThatPreservesSelection","ShiftCommand","SurroundSelectionCommand","EditOperationResult","isQuote","getMapForWordSeparators","Range","Selection","Position","IndentAction","LanguageConfigurationRegistry","createScopedLineTokens","TypeOperations","indent","config","model","selections","commands","i","len","length","isUnshift","tabSize","indentSize","insertSpaces","useTabStops","autoIndent","outdent","shiftIndent","indentation","count","unshiftIndent","_distributedPaste","text","shouldPushStackElementBefore","shouldPushStackElementAfter","_simplePaste","pasteOnNewLine","selection","position","getPosition","isEmpty","indexOf","typeSelection","lineNumber","_distributePasteToCursors","multicursorText","multiCursorPaste","charCodeAt","substr","lines","splitLines","paste","distributedPaste","sort","compareRangesUsingStarts","_goodIndentForLine","action","expectedIndentAction","getInheritIndentForLine","lastLineNumber","lineText","getLineContent","nonWhitespaceIdx","lastNonWhitespaceIndex","maxColumn","getLineMaxColumn","expectedEnterAction","getEnterAction","appendText","Indent","Outdent","normalizeIndentation","_replaceJumpToNextIndent","insertsAutoWhitespace","typeText","getStartPosition","visibleColumnFromColumn","spacesCnt","tab","startLineNumber","test","isCheapToTokenize","goodIndent","possibleTypeText","startsWith","endLineNumber","lineMaxColumn","startColumn","endColumn","compositionType","prevEditOperationType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","map","_compositionType","shouldPushStackElementBetween","pos","Math","max","column","min","range","oldText","getValueInRange","_typeCommand","keepPosition","_enter","getLeadingWhitespace","substring","r","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","oldEndViewColumn","getEndPosition","oldEndColumn","newLineContent","firstNonWhitespace","firstNonWhitespaceIndex","setEndPosition","afterEnter","offset","ceil","_isAutoIndentType","_runAutoIndentType","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","getLineFirstNonWhitespaceColumn","_isAutoClosingOvertype","autoClosedCharacters","autoClosingOvertype","autoClosingPairs","autoClosingPairsCloseSingleChar","has","afterCharacter","charAt","chIsQuote","beforeCharacter","found","j","lenJ","autoClosedCharacter","_runAutoClosingOvertype","_isBeforeClosingBrace","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","get","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","some","x","open","isBeforeClosingBrace","close","_findAutoClosingPairOpen","positions","candidates","autoClosingPairsOpenByEnd","result","candidate","candidateIsMatch","relevantText","_findContainedAutoClosingPair","pair","lastChar","autoClosingPairsCloseByEnd","includes","endsWith","_getAutoClosingPairClose","chIsAlreadyTyped","autoCloseConfig","autoClosingQuotes","autoClosingBrackets","shouldAutoCloseBefore","quote","bracket","s","beforeColumn","afterColumn","p","containedPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","isBeforeCloseBrace","wordSeparators","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","_runAutoClosingOpenCharType","autoClosingPairClose","TypeWithAutoClosingCommand","_shouldSurroundChar","autoSurround","_isSurroundSelectionType","surroundingPairs","hasOwnProperty","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","_runSurroundSelectionType","closeCharacter","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","electricChars","electricAction","onElectricCharacter","e","matchOpenBracket","lastIndexOf","match","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","prefix","command","getTypingOperation","compositionEndWithInterceptors","selectionsWhenCompositionStarted","selectionsArrEqual","currentChar","positionLineNumber","positionColumn","typeWithInterceptors","isDoingComposition","autoIndentFails","opType","typeWithoutInterceptors","str","lineInsertBefore","lineInsertAfter","lineBreakInsert","constructor","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","closeCharacterRange","enclosingRange","computeCursorState","helper","inverseEditOperations","getInverseEditOperations","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","type"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from './cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            });\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            });\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model, lineNumber, false);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                });\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, range);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* Full */) {\n            const ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            });\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        });\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* Null */;\n            if (beforeCharacter === 92 /* Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        const chIsQuote = isQuote(ch);\n        const autoCloseConfig = (chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets);\n        const shouldAutoCloseBefore = (chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket);\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.forceTokenization(lineNumber);\n            const lineTokens = model.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.forceTokenization(position.lineNumber);\n        const lineTokens = model.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            });\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {\n        if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {\n            // no content was typed\n            return null;\n        }\n        let ch = null;\n        // extract last typed character\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n            const position = selection.getPosition();\n            const currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\n            if (ch === null) {\n                ch = currentChar;\n            }\n            else if (ch !== currentChar) {\n                return null;\n            }\n        }\n        if (!ch) {\n            return null;\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (!isDoingComposition && this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* TypingFirstSpace */\n            || previousTypingOperation === 6 /* TypingConsecutiveSpace */\n            ? 6 /* TypingConsecutiveSpace */\n            : 5 /* TypingFirstSpace */;\n    }\n    return 4 /* TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* TypingConsecutiveSpace */ || type === 5 /* TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* TypingOther */\n        || type === 5 /* TypingFirstSpace */\n        || type === 6 /* TypingConsecutiveSpace */;\n}\n"]},"metadata":{},"sourceType":"module"}