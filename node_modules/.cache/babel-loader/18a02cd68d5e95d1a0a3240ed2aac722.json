{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n  static _createWord(lineContent, wordType, nextCharClass, start, end) {\n    // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n    return {\n      start: start,\n      end: end,\n      wordType: wordType,\n      nextCharClass: nextCharClass\n    };\n  }\n\n  static _findPreviousWordOnLine(wordSeparators, model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n  }\n\n  static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n    let wordType = 0\n    /* None */\n    ;\n\n    for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n\n      if (chClass === 0\n      /* Regular */\n      ) {\n        if (wordType === 2\n        /* Separator */\n        ) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n\n        wordType = 1\n        /* Regular */\n        ;\n      } else if (chClass === 2\n      /* WordSeparator */\n      ) {\n        if (wordType === 1\n        /* Regular */\n        ) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n\n        wordType = 2\n        /* Separator */\n        ;\n      } else if (chClass === 1\n      /* Whitespace */\n      ) {\n        if (wordType !== 0\n        /* None */\n        ) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n      }\n    }\n\n    if (wordType !== 0\n    /* None */\n    ) {\n      return this._createWord(lineContent, wordType, 1\n      /* Whitespace */\n      , 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n    }\n\n    return null;\n  }\n\n  static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n    const len = lineContent.length;\n\n    for (let chIndex = startIndex; chIndex < len; chIndex++) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n\n      if (chClass === 1\n      /* Whitespace */\n      ) {\n        return chIndex;\n      }\n\n      if (wordType === 1\n      /* Regular */\n      && chClass === 2\n      /* WordSeparator */\n      ) {\n        return chIndex;\n      }\n\n      if (wordType === 2\n      /* Separator */\n      && chClass === 0\n      /* Regular */\n      ) {\n        return chIndex;\n      }\n    }\n\n    return len;\n  }\n\n  static _findNextWordOnLine(wordSeparators, model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n  }\n\n  static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n    let wordType = 0\n    /* None */\n    ;\n    const len = lineContent.length;\n\n    for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n\n      if (chClass === 0\n      /* Regular */\n      ) {\n        if (wordType === 2\n        /* Separator */\n        ) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n\n        wordType = 1\n        /* Regular */\n        ;\n      } else if (chClass === 2\n      /* WordSeparator */\n      ) {\n        if (wordType === 1\n        /* Regular */\n        ) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n\n        wordType = 2\n        /* Separator */\n        ;\n      } else if (chClass === 1\n      /* Whitespace */\n      ) {\n        if (wordType !== 0\n        /* None */\n        ) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n      }\n    }\n\n    if (wordType !== 0\n    /* None */\n    ) {\n      return this._createWord(lineContent, wordType, 1\n      /* Whitespace */\n      , this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n    }\n\n    return null;\n  }\n\n  static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n    for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n      const chCode = lineContent.charCodeAt(chIndex);\n      const chClass = wordSeparators.get(chCode);\n\n      if (chClass === 1\n      /* Whitespace */\n      ) {\n        return chIndex + 1;\n      }\n\n      if (wordType === 1\n      /* Regular */\n      && chClass === 2\n      /* WordSeparator */\n      ) {\n        return chIndex + 1;\n      }\n\n      if (wordType === 2\n      /* Separator */\n      && chClass === 0\n      /* Regular */\n      ) {\n        return chIndex + 1;\n      }\n    }\n\n    return 0;\n  }\n\n  static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n\n    if (column === 1) {\n      if (lineNumber > 1) {\n        lineNumber = lineNumber - 1;\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    }\n\n    let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n    if (wordNavigationType === 0\n    /* WordStart */\n    ) {\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n\n    if (wordNavigationType === 1\n    /* WordStartFast */\n    ) {\n      if (prevWordOnLine && prevWordOnLine.wordType === 2\n      /* Separator */\n      && prevWordOnLine.end - prevWordOnLine.start === 1 && prevWordOnLine.nextCharClass === 0\n      /* Regular */\n      ) {\n        // Skip over a word made up of one single separator and followed by a regular character\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n\n    if (wordNavigationType === 3\n    /* WordAccessibility */\n    ) {\n      while (prevWordOnLine && prevWordOnLine.wordType === 2\n      /* Separator */\n      ) {\n        // Skip over words made up of only separators\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    } // We are stopping at the ending of words\n\n\n    if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n      prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n    }\n\n    return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n  }\n\n  static _moveWordPartLeft(model, position) {\n    const lineNumber = position.lineNumber;\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n\n    if (position.column === 1) {\n      return lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position;\n    }\n\n    const lineContent = model.getLineContent(lineNumber);\n\n    for (let column = position.column - 1; column > 1; column--) {\n      const left = lineContent.charCodeAt(column - 2);\n      const right = lineContent.charCodeAt(column - 1);\n\n      if (left === 95\n      /* Underline */\n      && right !== 95\n      /* Underline */\n      ) {\n        // snake_case_variables\n        return new Position(lineNumber, column);\n      }\n\n      if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // camelCaseVariables\n        return new Position(lineNumber, column);\n      }\n\n      if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // thisIsACamelCaseWithOneLetterWords\n        if (column + 1 < maxColumn) {\n          const rightRight = lineContent.charCodeAt(column);\n\n          if (strings.isLowerAsciiLetter(rightRight)) {\n            return new Position(lineNumber, column);\n          }\n        }\n      }\n    }\n\n    return new Position(lineNumber, 1);\n  }\n\n  static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    let movedDown = false;\n\n    if (column === model.getLineMaxColumn(lineNumber)) {\n      if (lineNumber < model.getLineCount()) {\n        movedDown = true;\n        lineNumber = lineNumber + 1;\n        column = 1;\n      }\n    }\n\n    let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n    if (wordNavigationType === 2\n    /* WordEnd */\n    ) {\n      if (nextWordOnLine && nextWordOnLine.wordType === 2\n      /* Separator */\n      ) {\n        if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0\n        /* Regular */\n        ) {\n          // Skip over a word made up of one single separator and followed by a regular character\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n        }\n      }\n\n      if (nextWordOnLine) {\n        column = nextWordOnLine.end + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    } else if (wordNavigationType === 3\n    /* WordAccessibility */\n    ) {\n      if (movedDown) {\n        // If we move to the next line, pretend that the cursor is right before the first character.\n        // This is needed when the first word starts right at the first character - and in order not to miss it,\n        // we need to start before.\n        column = 0;\n      }\n\n      while (nextWordOnLine && (nextWordOnLine.wordType === 2\n      /* Separator */\n      || nextWordOnLine.start + 1 <= column)) {\n        // Skip over a word made up of one single separator\n        // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    } else {\n      if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    }\n\n    return new Position(lineNumber, column);\n  }\n\n  static _moveWordPartRight(model, position) {\n    const lineNumber = position.lineNumber;\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n\n    if (position.column === maxColumn) {\n      return lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position;\n    }\n\n    const lineContent = model.getLineContent(lineNumber);\n\n    for (let column = position.column + 1; column < maxColumn; column++) {\n      const left = lineContent.charCodeAt(column - 2);\n      const right = lineContent.charCodeAt(column - 1);\n\n      if (left !== 95\n      /* Underline */\n      && right === 95\n      /* Underline */\n      ) {\n        // snake_case_variables\n        return new Position(lineNumber, column);\n      }\n\n      if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // camelCaseVariables\n        return new Position(lineNumber, column);\n      }\n\n      if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // thisIsACamelCaseWithOneLetterWords\n        if (column + 1 < maxColumn) {\n          const rightRight = lineContent.charCodeAt(column);\n\n          if (strings.isLowerAsciiLetter(rightRight)) {\n            return new Position(lineNumber, column);\n          }\n        }\n      }\n    }\n\n    return new Position(lineNumber, maxColumn);\n  }\n\n  static _deleteWordLeftWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const startIndex = position.column - 2;\n    const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n\n    if (lastNonWhitespace + 1 < startIndex) {\n      return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n    }\n\n    return null;\n  }\n\n  static deleteWordLeft(ctx, wordNavigationType) {\n    const wordSeparators = ctx.wordSeparators;\n    const model = ctx.model;\n    const selection = ctx.selection;\n    const whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n\n    if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n      const position = ctx.selection.getPosition();\n      return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n    }\n\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n\n    if (lineNumber === 1 && column === 1) {\n      // Ignore deleting at beginning of file\n      return null;\n    }\n\n    if (whitespaceHeuristics) {\n      const r = this._deleteWordLeftWhitespace(model, position);\n\n      if (r) {\n        return r;\n      }\n    }\n\n    let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n    if (wordNavigationType === 0\n    /* WordStart */\n    ) {\n      if (prevWordOnLine) {\n        column = prevWordOnLine.start + 1;\n      } else {\n        if (column > 1) {\n          column = 1;\n        } else {\n          lineNumber--;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n    } else {\n      if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n\n      if (prevWordOnLine) {\n        column = prevWordOnLine.end + 1;\n      } else {\n        if (column > 1) {\n          column = 1;\n        } else {\n          lineNumber--;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n    }\n\n    return new Range(lineNumber, column, position.lineNumber, position.column);\n  }\n\n  static deleteInsideWord(wordSeparators, model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n    const r = this._deleteInsideWordWhitespace(model, position);\n\n    if (r) {\n      return r;\n    }\n\n    return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n  }\n\n  static _charAtIsWhitespace(str, index) {\n    const charCode = str.charCodeAt(index);\n    return charCode === 32\n    /* Space */\n    || charCode === 9\n    /* Tab */\n    ;\n  }\n\n  static _deleteInsideWordWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const lineContentLength = lineContent.length;\n\n    if (lineContentLength === 0) {\n      // empty line\n      return null;\n    }\n\n    let leftIndex = Math.max(position.column - 2, 0);\n\n    if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n      // touches a non-whitespace character to the left\n      return null;\n    }\n\n    let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n\n    if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n      // touches a non-whitespace character to the right\n      return null;\n    } // walk over whitespace to the left\n\n\n    while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n      leftIndex--;\n    } // walk over whitespace to the right\n\n\n    while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n      rightIndex++;\n    }\n\n    return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n  }\n\n  static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const lineLength = lineContent.length;\n\n    if (lineLength === 0) {\n      // empty line\n      if (position.lineNumber > 1) {\n        return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n      } else {\n        if (position.lineNumber < model.getLineCount()) {\n          return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n        } else {\n          // empty model\n          return new Range(position.lineNumber, 1, position.lineNumber, 1);\n        }\n      }\n    }\n\n    const touchesWord = word => {\n      return word.start + 1 <= position.column && position.column <= word.end + 1;\n    };\n\n    const createRangeWithPosition = (startColumn, endColumn) => {\n      startColumn = Math.min(startColumn, position.column);\n      endColumn = Math.max(endColumn, position.column);\n      return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n    };\n\n    const deleteWordAndAdjacentWhitespace = word => {\n      let startColumn = word.start + 1;\n      let endColumn = word.end + 1;\n      let expandedToTheRight = false;\n\n      while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n        expandedToTheRight = true;\n        endColumn++;\n      }\n\n      if (!expandedToTheRight) {\n        while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n          startColumn--;\n        }\n      }\n\n      return createRangeWithPosition(startColumn, endColumn);\n    };\n\n    const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n    if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n      return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n    }\n\n    const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n    if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n      return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n    }\n\n    if (prevWordOnLine && nextWordOnLine) {\n      return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n    }\n\n    if (prevWordOnLine) {\n      return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n    }\n\n    if (nextWordOnLine) {\n      return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n    }\n\n    return createRangeWithPosition(1, lineLength + 1);\n  }\n\n  static _deleteWordPartLeft(model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n\n    const pos = selection.getPosition();\n\n    const toPosition = WordOperations._moveWordPartLeft(model, pos);\n\n    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n  }\n\n  static _findFirstNonWhitespaceChar(str, startIndex) {\n    const len = str.length;\n\n    for (let chIndex = startIndex; chIndex < len; chIndex++) {\n      const ch = str.charAt(chIndex);\n\n      if (ch !== ' ' && ch !== '\\t') {\n        return chIndex;\n      }\n    }\n\n    return len;\n  }\n\n  static _deleteWordRightWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const startIndex = position.column - 1;\n\n    const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n\n    if (startIndex + 1 < firstNonWhitespace) {\n      // bingo\n      return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n    }\n\n    return null;\n  }\n\n  static deleteWordRight(ctx, wordNavigationType) {\n    const wordSeparators = ctx.wordSeparators;\n    const model = ctx.model;\n    const selection = ctx.selection;\n    const whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    const lineCount = model.getLineCount();\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n\n    if (lineNumber === lineCount && column === maxColumn) {\n      // Ignore deleting at end of file\n      return null;\n    }\n\n    if (whitespaceHeuristics) {\n      const r = this._deleteWordRightWhitespace(model, position);\n\n      if (r) {\n        return r;\n      }\n    }\n\n    let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n    if (wordNavigationType === 2\n    /* WordEnd */\n    ) {\n      if (nextWordOnLine) {\n        column = nextWordOnLine.end + 1;\n      } else {\n        if (column < maxColumn || lineNumber === lineCount) {\n          column = maxColumn;\n        } else {\n          lineNumber++;\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\n          if (nextWordOnLine) {\n            column = nextWordOnLine.start + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n    } else {\n      if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        if (column < maxColumn || lineNumber === lineCount) {\n          column = maxColumn;\n        } else {\n          lineNumber++;\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\n          if (nextWordOnLine) {\n            column = nextWordOnLine.start + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n    }\n\n    return new Range(lineNumber, column, position.lineNumber, position.column);\n  }\n\n  static _deleteWordPartRight(model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n\n    const pos = selection.getPosition();\n\n    const toPosition = WordOperations._moveWordPartRight(model, pos);\n\n    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n  }\n\n  static _createWordAtPosition(model, lineNumber, word) {\n    const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n    return {\n      word: model.getValueInRange(range),\n      startColumn: range.startColumn,\n      endColumn: range.endColumn\n    };\n  }\n\n  static getWordAtPosition(model, _wordSeparators, position) {\n    const wordSeparators = getMapForWordSeparators(_wordSeparators);\n\n    const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n    if (prevWord && prevWord.wordType === 1\n    /* Regular */\n    && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n      return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n    }\n\n    const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n    if (nextWord && nextWord.wordType === 1\n    /* Regular */\n    && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n      return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n    }\n\n    return null;\n  }\n\n  static word(config, model, cursor, inSelectionMode, position) {\n    const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n\n    const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n    const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n    if (!inSelectionMode) {\n      // Entering word selection for the first time\n      let startColumn;\n      let endColumn;\n\n      if (prevWord && prevWord.wordType === 1\n      /* Regular */\n      && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n        // isTouchingPrevWord\n        startColumn = prevWord.start + 1;\n        endColumn = prevWord.end + 1;\n      } else if (nextWord && nextWord.wordType === 1\n      /* Regular */\n      && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n        // isTouchingNextWord\n        startColumn = nextWord.start + 1;\n        endColumn = nextWord.end + 1;\n      } else {\n        if (prevWord) {\n          startColumn = prevWord.end + 1;\n        } else {\n          startColumn = 1;\n        }\n\n        if (nextWord) {\n          endColumn = nextWord.start + 1;\n        } else {\n          endColumn = model.getLineMaxColumn(position.lineNumber);\n        }\n      }\n\n      return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 0, new Position(position.lineNumber, endColumn), 0);\n    }\n\n    let startColumn;\n    let endColumn;\n\n    if (prevWord && prevWord.wordType === 1\n    /* Regular */\n    && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n      // isInsidePrevWord\n      startColumn = prevWord.start + 1;\n      endColumn = prevWord.end + 1;\n    } else if (nextWord && nextWord.wordType === 1\n    /* Regular */\n    && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n      // isInsideNextWord\n      startColumn = nextWord.start + 1;\n      endColumn = nextWord.end + 1;\n    } else {\n      startColumn = position.column;\n      endColumn = position.column;\n    }\n\n    const lineNumber = position.lineNumber;\n    let column;\n\n    if (cursor.selectionStart.containsPosition(position)) {\n      column = cursor.selectionStart.endColumn;\n    } else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n      column = startColumn;\n      const possiblePosition = new Position(lineNumber, column);\n\n      if (cursor.selectionStart.containsPosition(possiblePosition)) {\n        column = cursor.selectionStart.endColumn;\n      }\n    } else {\n      column = endColumn;\n      const possiblePosition = new Position(lineNumber, column);\n\n      if (cursor.selectionStart.containsPosition(possiblePosition)) {\n        column = cursor.selectionStart.startColumn;\n      }\n    }\n\n    return cursor.move(true, lineNumber, column, 0);\n  }\n\n}\nexport class WordPartOperations extends WordOperations {\n  static deleteWordPartLeft(ctx) {\n    const candidates = enforceDefined([WordOperations.deleteWordLeft(ctx, 0\n    /* WordStart */\n    ), WordOperations.deleteWordLeft(ctx, 2\n    /* WordEnd */\n    ), WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)]);\n    candidates.sort(Range.compareRangesUsingEnds);\n    return candidates[2];\n  }\n\n  static deleteWordPartRight(ctx) {\n    const candidates = enforceDefined([WordOperations.deleteWordRight(ctx, 0\n    /* WordStart */\n    ), WordOperations.deleteWordRight(ctx, 2\n    /* WordEnd */\n    ), WordOperations._deleteWordPartRight(ctx.model, ctx.selection)]);\n    candidates.sort(Range.compareRangesUsingStarts);\n    return candidates[0];\n  }\n\n  static moveWordPartLeft(wordSeparators, model, position) {\n    const candidates = enforceDefined([WordOperations.moveWordLeft(wordSeparators, model, position, 0\n    /* WordStart */\n    ), WordOperations.moveWordLeft(wordSeparators, model, position, 2\n    /* WordEnd */\n    ), WordOperations._moveWordPartLeft(model, position)]);\n    candidates.sort(Position.compare);\n    return candidates[2];\n  }\n\n  static moveWordPartRight(wordSeparators, model, position) {\n    const candidates = enforceDefined([WordOperations.moveWordRight(wordSeparators, model, position, 0\n    /* WordStart */\n    ), WordOperations.moveWordRight(wordSeparators, model, position, 2\n    /* WordEnd */\n    ), WordOperations._moveWordPartRight(model, position)]);\n    candidates.sort(Position.compare);\n    return candidates[0];\n  }\n\n}\n\nfunction enforceDefined(arr) {\n  return arr.filter(el => Boolean(el));\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js"],"names":["strings","SingleCursorState","DeleteOperations","getMapForWordSeparators","Position","Range","WordOperations","_createWord","lineContent","wordType","nextCharClass","start","end","_findPreviousWordOnLine","wordSeparators","model","position","getLineContent","lineNumber","_doFindPreviousWordOnLine","chIndex","column","chCode","charCodeAt","chClass","get","_findEndOfWord","startIndex","len","length","_findNextWordOnLine","_doFindNextWordOnLine","_findStartOfWord","moveWordLeft","wordNavigationType","getLineMaxColumn","prevWordOnLine","_moveWordPartLeft","maxColumn","left","right","isLowerAsciiLetter","isUpperAsciiLetter","rightRight","moveWordRight","movedDown","getLineCount","nextWordOnLine","_moveWordPartRight","_deleteWordLeftWhitespace","lastNonWhitespace","lastNonWhitespaceIndex","deleteWordLeft","ctx","selection","whitespaceHeuristics","isEmpty","isAutoClosingPairDelete","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairs","autoClosingPairsOpenByEnd","autoClosedCharacters","getPosition","positionLineNumber","positionColumn","r","deleteInsideWord","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","_charAtIsWhitespace","str","index","charCode","lineContentLength","leftIndex","Math","max","rightIndex","min","lineLength","touchesWord","word","createRangeWithPosition","startColumn","endColumn","deleteWordAndAdjacentWhitespace","expandedToTheRight","_deleteWordPartLeft","pos","toPosition","_findFirstNonWhitespaceChar","ch","charAt","_deleteWordRightWhitespace","firstNonWhitespace","deleteWordRight","lineCount","_deleteWordPartRight","_createWordAtPosition","range","getValueInRange","getWordAtPosition","_wordSeparators","prevWord","nextWord","config","cursor","inSelectionMode","selectionStart","containsPosition","isBeforeOrEqual","getStartPosition","possiblePosition","move","WordPartOperations","deleteWordPartLeft","candidates","enforceDefined","sort","compareRangesUsingEnds","deleteWordPartRight","compareRangesUsingStarts","moveWordPartLeft","compare","moveWordPartRight","arr","filter","el","Boolean"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* None */;\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* Regular */) {\n                if (wordType === 2 /* Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* Regular */;\n            }\n            else if (chClass === 2 /* WordSeparator */) {\n                if (wordType === 1 /* Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* Separator */;\n            }\n            else if (chClass === 1 /* Whitespace */) {\n                if (wordType !== 0 /* None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* None */) {\n            return this._createWord(lineContent, wordType, 1 /* Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* None */;\n        const len = lineContent.length;\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* Regular */) {\n                if (wordType === 2 /* Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* Regular */;\n            }\n            else if (chClass === 2 /* WordSeparator */) {\n                if (wordType === 1 /* Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* Separator */;\n            }\n            else if (chClass === 1 /* Whitespace */) {\n                if (wordType !== 0 /* None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* None */) {\n            return this._createWord(lineContent, wordType, 1 /* Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* Underline */ && right !== 95 /* Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* Underline */ && right === 95 /* Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* Space */ || charCode === 9 /* Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n"]},"metadata":{},"sourceType":"module"}