{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport * as DomUtils from './dom.js';\nimport * as arrays from '../common/arrays.js';\nimport { memoize } from '../common/decorators.js';\nimport { Disposable } from '../common/lifecycle.js';\nexport var EventType;\n\n(function (EventType) {\n  EventType.Tap = '-monaco-gesturetap';\n  EventType.Change = '-monaco-gesturechange';\n  EventType.Start = '-monaco-gesturestart';\n  EventType.End = '-monaco-gesturesend';\n  EventType.Contextmenu = '-monaco-gesturecontextmenu';\n})(EventType || (EventType = {}));\n\nexport class Gesture extends Disposable {\n  constructor() {\n    super();\n    this.dispatched = false;\n    this.activeTouches = {};\n    this.handle = null;\n    this.targets = [];\n    this.ignoreTargets = [];\n    this._lastSetTapCountTime = 0;\n\n    this._register(DomUtils.addDisposableListener(document, 'touchstart', e => this.onTouchStart(e), {\n      passive: false\n    }));\n\n    this._register(DomUtils.addDisposableListener(document, 'touchend', e => this.onTouchEnd(e)));\n\n    this._register(DomUtils.addDisposableListener(document, 'touchmove', e => this.onTouchMove(e), {\n      passive: false\n    }));\n  }\n\n  static addTarget(element) {\n    if (!Gesture.isTouchDevice()) {\n      return Disposable.None;\n    }\n\n    if (!Gesture.INSTANCE) {\n      Gesture.INSTANCE = new Gesture();\n    }\n\n    Gesture.INSTANCE.targets.push(element);\n    return {\n      dispose: () => {\n        Gesture.INSTANCE.targets = Gesture.INSTANCE.targets.filter(t => t !== element);\n      }\n    };\n  }\n\n  static ignoreTarget(element) {\n    if (!Gesture.isTouchDevice()) {\n      return Disposable.None;\n    }\n\n    if (!Gesture.INSTANCE) {\n      Gesture.INSTANCE = new Gesture();\n    }\n\n    Gesture.INSTANCE.ignoreTargets.push(element);\n    return {\n      dispose: () => {\n        Gesture.INSTANCE.ignoreTargets = Gesture.INSTANCE.ignoreTargets.filter(t => t !== element);\n      }\n    };\n  }\n\n  static isTouchDevice() {\n    // `'ontouchstart' in window` always evaluates to true with typescript's modern typings. This causes `window` to be\n    // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n  }\n\n  dispose() {\n    if (this.handle) {\n      this.handle.dispose();\n      this.handle = null;\n    }\n\n    super.dispose();\n  }\n\n  onTouchStart(e) {\n    let timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n    if (this.handle) {\n      this.handle.dispose();\n      this.handle = null;\n    }\n\n    for (let i = 0, len = e.targetTouches.length; i < len; i++) {\n      let touch = e.targetTouches.item(i);\n      this.activeTouches[touch.identifier] = {\n        id: touch.identifier,\n        initialTarget: touch.target,\n        initialTimeStamp: timestamp,\n        initialPageX: touch.pageX,\n        initialPageY: touch.pageY,\n        rollingTimestamps: [timestamp],\n        rollingPageX: [touch.pageX],\n        rollingPageY: [touch.pageY]\n      };\n      let evt = this.newGestureEvent(EventType.Start, touch.target);\n      evt.pageX = touch.pageX;\n      evt.pageY = touch.pageY;\n      this.dispatchEvent(evt);\n    }\n\n    if (this.dispatched) {\n      e.preventDefault();\n      e.stopPropagation();\n      this.dispatched = false;\n    }\n  }\n\n  onTouchEnd(e) {\n    let timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n    let activeTouchCount = Object.keys(this.activeTouches).length;\n\n    for (let i = 0, len = e.changedTouches.length; i < len; i++) {\n      let touch = e.changedTouches.item(i);\n\n      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n        console.warn('move of an UNKNOWN touch', touch);\n        continue;\n      }\n\n      let data = this.activeTouches[touch.identifier],\n          holdTime = Date.now() - data.initialTimeStamp;\n\n      if (holdTime < Gesture.HOLD_DELAY && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {\n        let evt = this.newGestureEvent(EventType.Tap, data.initialTarget);\n        evt.pageX = arrays.tail(data.rollingPageX);\n        evt.pageY = arrays.tail(data.rollingPageY);\n        this.dispatchEvent(evt);\n      } else if (holdTime >= Gesture.HOLD_DELAY && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {\n        let evt = this.newGestureEvent(EventType.Contextmenu, data.initialTarget);\n        evt.pageX = arrays.tail(data.rollingPageX);\n        evt.pageY = arrays.tail(data.rollingPageY);\n        this.dispatchEvent(evt);\n      } else if (activeTouchCount === 1) {\n        let finalX = arrays.tail(data.rollingPageX);\n        let finalY = arrays.tail(data.rollingPageY);\n        let deltaT = arrays.tail(data.rollingTimestamps) - data.rollingTimestamps[0];\n        let deltaX = finalX - data.rollingPageX[0];\n        let deltaY = finalY - data.rollingPageY[0]; // We need to get all the dispatch targets on the start of the inertia event\n\n        const dispatchTo = this.targets.filter(t => data.initialTarget instanceof Node && t.contains(data.initialTarget));\n        this.inertia(dispatchTo, timestamp, // time now\n        Math.abs(deltaX) / deltaT, // speed\n        deltaX > 0 ? 1 : -1, // x direction\n        finalX, // x now\n        Math.abs(deltaY) / deltaT, // y speed\n        deltaY > 0 ? 1 : -1, // y direction\n        finalY // y now\n        );\n      }\n\n      this.dispatchEvent(this.newGestureEvent(EventType.End, data.initialTarget)); // forget about this touch\n\n      delete this.activeTouches[touch.identifier];\n    }\n\n    if (this.dispatched) {\n      e.preventDefault();\n      e.stopPropagation();\n      this.dispatched = false;\n    }\n  }\n\n  newGestureEvent(type, initialTarget) {\n    let event = document.createEvent('CustomEvent');\n    event.initEvent(type, false, true);\n    event.initialTarget = initialTarget;\n    event.tapCount = 0;\n    return event;\n  }\n\n  dispatchEvent(event) {\n    if (event.type === EventType.Tap) {\n      const currentTime = new Date().getTime();\n      let setTapCount = 0;\n\n      if (currentTime - this._lastSetTapCountTime > Gesture.CLEAR_TAP_COUNT_TIME) {\n        setTapCount = 1;\n      } else {\n        setTapCount = 2;\n      }\n\n      this._lastSetTapCountTime = currentTime;\n      event.tapCount = setTapCount;\n    } else if (event.type === EventType.Change || event.type === EventType.Contextmenu) {\n      // tap is canceled by scrolling or context menu\n      this._lastSetTapCountTime = 0;\n    }\n\n    for (let i = 0; i < this.ignoreTargets.length; i++) {\n      if (event.initialTarget instanceof Node && this.ignoreTargets[i].contains(event.initialTarget)) {\n        return;\n      }\n    }\n\n    this.targets.forEach(target => {\n      if (event.initialTarget instanceof Node && target.contains(event.initialTarget)) {\n        target.dispatchEvent(event);\n        this.dispatched = true;\n      }\n    });\n  }\n\n  inertia(dispatchTo, t1, vX, dirX, x, vY, dirY, y) {\n    this.handle = DomUtils.scheduleAtNextAnimationFrame(() => {\n      let now = Date.now(); // velocity: old speed + accel_over_time\n\n      let deltaT = now - t1,\n          delta_pos_x = 0,\n          delta_pos_y = 0,\n          stopped = true;\n      vX += Gesture.SCROLL_FRICTION * deltaT;\n      vY += Gesture.SCROLL_FRICTION * deltaT;\n\n      if (vX > 0) {\n        stopped = false;\n        delta_pos_x = dirX * vX * deltaT;\n      }\n\n      if (vY > 0) {\n        stopped = false;\n        delta_pos_y = dirY * vY * deltaT;\n      } // dispatch translation event\n\n\n      let evt = this.newGestureEvent(EventType.Change);\n      evt.translationX = delta_pos_x;\n      evt.translationY = delta_pos_y;\n      dispatchTo.forEach(d => d.dispatchEvent(evt));\n\n      if (!stopped) {\n        this.inertia(dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);\n      }\n    });\n  }\n\n  onTouchMove(e) {\n    let timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n    for (let i = 0, len = e.changedTouches.length; i < len; i++) {\n      let touch = e.changedTouches.item(i);\n\n      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n        console.warn('end of an UNKNOWN touch', touch);\n        continue;\n      }\n\n      let data = this.activeTouches[touch.identifier];\n      let evt = this.newGestureEvent(EventType.Change, data.initialTarget);\n      evt.translationX = touch.pageX - arrays.tail(data.rollingPageX);\n      evt.translationY = touch.pageY - arrays.tail(data.rollingPageY);\n      evt.pageX = touch.pageX;\n      evt.pageY = touch.pageY;\n      this.dispatchEvent(evt); // only keep a few data points, to average the final speed\n\n      if (data.rollingPageX.length > 3) {\n        data.rollingPageX.shift();\n        data.rollingPageY.shift();\n        data.rollingTimestamps.shift();\n      }\n\n      data.rollingPageX.push(touch.pageX);\n      data.rollingPageY.push(touch.pageY);\n      data.rollingTimestamps.push(timestamp);\n    }\n\n    if (this.dispatched) {\n      e.preventDefault();\n      e.stopPropagation();\n      this.dispatched = false;\n    }\n  }\n\n}\nGesture.SCROLL_FRICTION = -0.005;\nGesture.HOLD_DELAY = 700;\nGesture.CLEAR_TAP_COUNT_TIME = 400; // ms\n\n__decorate([memoize], Gesture, \"isTouchDevice\", null);","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/browser/touch.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","DomUtils","arrays","memoize","Disposable","EventType","Tap","Change","Start","End","Contextmenu","Gesture","constructor","dispatched","activeTouches","handle","targets","ignoreTargets","_lastSetTapCountTime","_register","addDisposableListener","document","e","onTouchStart","passive","onTouchEnd","onTouchMove","addTarget","element","isTouchDevice","None","INSTANCE","push","dispose","filter","t","ignoreTarget","window","navigator","maxTouchPoints","timestamp","Date","now","len","targetTouches","touch","item","identifier","id","initialTarget","initialTimeStamp","initialPageX","pageX","initialPageY","pageY","rollingTimestamps","rollingPageX","rollingPageY","evt","newGestureEvent","dispatchEvent","preventDefault","stopPropagation","activeTouchCount","keys","changedTouches","hasOwnProperty","String","console","warn","data","holdTime","HOLD_DELAY","Math","abs","tail","finalX","finalY","deltaT","deltaX","deltaY","dispatchTo","Node","contains","inertia","type","event","createEvent","initEvent","tapCount","currentTime","getTime","setTapCount","CLEAR_TAP_COUNT_TIME","forEach","t1","vX","dirX","x","vY","dirY","y","scheduleAtNextAnimationFrame","delta_pos_x","delta_pos_y","stopped","SCROLL_FRICTION","translationX","translationY","shift"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport * as DomUtils from './dom.js';\nimport * as arrays from '../common/arrays.js';\nimport { memoize } from '../common/decorators.js';\nimport { Disposable } from '../common/lifecycle.js';\nexport var EventType;\n(function (EventType) {\n    EventType.Tap = '-monaco-gesturetap';\n    EventType.Change = '-monaco-gesturechange';\n    EventType.Start = '-monaco-gesturestart';\n    EventType.End = '-monaco-gesturesend';\n    EventType.Contextmenu = '-monaco-gesturecontextmenu';\n})(EventType || (EventType = {}));\nexport class Gesture extends Disposable {\n    constructor() {\n        super();\n        this.dispatched = false;\n        this.activeTouches = {};\n        this.handle = null;\n        this.targets = [];\n        this.ignoreTargets = [];\n        this._lastSetTapCountTime = 0;\n        this._register(DomUtils.addDisposableListener(document, 'touchstart', (e) => this.onTouchStart(e), { passive: false }));\n        this._register(DomUtils.addDisposableListener(document, 'touchend', (e) => this.onTouchEnd(e)));\n        this._register(DomUtils.addDisposableListener(document, 'touchmove', (e) => this.onTouchMove(e), { passive: false }));\n    }\n    static addTarget(element) {\n        if (!Gesture.isTouchDevice()) {\n            return Disposable.None;\n        }\n        if (!Gesture.INSTANCE) {\n            Gesture.INSTANCE = new Gesture();\n        }\n        Gesture.INSTANCE.targets.push(element);\n        return {\n            dispose: () => {\n                Gesture.INSTANCE.targets = Gesture.INSTANCE.targets.filter(t => t !== element);\n            }\n        };\n    }\n    static ignoreTarget(element) {\n        if (!Gesture.isTouchDevice()) {\n            return Disposable.None;\n        }\n        if (!Gesture.INSTANCE) {\n            Gesture.INSTANCE = new Gesture();\n        }\n        Gesture.INSTANCE.ignoreTargets.push(element);\n        return {\n            dispose: () => {\n                Gesture.INSTANCE.ignoreTargets = Gesture.INSTANCE.ignoreTargets.filter(t => t !== element);\n            }\n        };\n    }\n    static isTouchDevice() {\n        // `'ontouchstart' in window` always evaluates to true with typescript's modern typings. This causes `window` to be\n        // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast\n        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n    }\n    dispose() {\n        if (this.handle) {\n            this.handle.dispose();\n            this.handle = null;\n        }\n        super.dispose();\n    }\n    onTouchStart(e) {\n        let timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n        if (this.handle) {\n            this.handle.dispose();\n            this.handle = null;\n        }\n        for (let i = 0, len = e.targetTouches.length; i < len; i++) {\n            let touch = e.targetTouches.item(i);\n            this.activeTouches[touch.identifier] = {\n                id: touch.identifier,\n                initialTarget: touch.target,\n                initialTimeStamp: timestamp,\n                initialPageX: touch.pageX,\n                initialPageY: touch.pageY,\n                rollingTimestamps: [timestamp],\n                rollingPageX: [touch.pageX],\n                rollingPageY: [touch.pageY]\n            };\n            let evt = this.newGestureEvent(EventType.Start, touch.target);\n            evt.pageX = touch.pageX;\n            evt.pageY = touch.pageY;\n            this.dispatchEvent(evt);\n        }\n        if (this.dispatched) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.dispatched = false;\n        }\n    }\n    onTouchEnd(e) {\n        let timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n        let activeTouchCount = Object.keys(this.activeTouches).length;\n        for (let i = 0, len = e.changedTouches.length; i < len; i++) {\n            let touch = e.changedTouches.item(i);\n            if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n                console.warn('move of an UNKNOWN touch', touch);\n                continue;\n            }\n            let data = this.activeTouches[touch.identifier], holdTime = Date.now() - data.initialTimeStamp;\n            if (holdTime < Gesture.HOLD_DELAY\n                && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30\n                && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {\n                let evt = this.newGestureEvent(EventType.Tap, data.initialTarget);\n                evt.pageX = arrays.tail(data.rollingPageX);\n                evt.pageY = arrays.tail(data.rollingPageY);\n                this.dispatchEvent(evt);\n            }\n            else if (holdTime >= Gesture.HOLD_DELAY\n                && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30\n                && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {\n                let evt = this.newGestureEvent(EventType.Contextmenu, data.initialTarget);\n                evt.pageX = arrays.tail(data.rollingPageX);\n                evt.pageY = arrays.tail(data.rollingPageY);\n                this.dispatchEvent(evt);\n            }\n            else if (activeTouchCount === 1) {\n                let finalX = arrays.tail(data.rollingPageX);\n                let finalY = arrays.tail(data.rollingPageY);\n                let deltaT = arrays.tail(data.rollingTimestamps) - data.rollingTimestamps[0];\n                let deltaX = finalX - data.rollingPageX[0];\n                let deltaY = finalY - data.rollingPageY[0];\n                // We need to get all the dispatch targets on the start of the inertia event\n                const dispatchTo = this.targets.filter(t => data.initialTarget instanceof Node && t.contains(data.initialTarget));\n                this.inertia(dispatchTo, timestamp, // time now\n                Math.abs(deltaX) / deltaT, // speed\n                deltaX > 0 ? 1 : -1, // x direction\n                finalX, // x now\n                Math.abs(deltaY) / deltaT, // y speed\n                deltaY > 0 ? 1 : -1, // y direction\n                finalY // y now\n                );\n            }\n            this.dispatchEvent(this.newGestureEvent(EventType.End, data.initialTarget));\n            // forget about this touch\n            delete this.activeTouches[touch.identifier];\n        }\n        if (this.dispatched) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.dispatched = false;\n        }\n    }\n    newGestureEvent(type, initialTarget) {\n        let event = document.createEvent('CustomEvent');\n        event.initEvent(type, false, true);\n        event.initialTarget = initialTarget;\n        event.tapCount = 0;\n        return event;\n    }\n    dispatchEvent(event) {\n        if (event.type === EventType.Tap) {\n            const currentTime = (new Date()).getTime();\n            let setTapCount = 0;\n            if (currentTime - this._lastSetTapCountTime > Gesture.CLEAR_TAP_COUNT_TIME) {\n                setTapCount = 1;\n            }\n            else {\n                setTapCount = 2;\n            }\n            this._lastSetTapCountTime = currentTime;\n            event.tapCount = setTapCount;\n        }\n        else if (event.type === EventType.Change || event.type === EventType.Contextmenu) {\n            // tap is canceled by scrolling or context menu\n            this._lastSetTapCountTime = 0;\n        }\n        for (let i = 0; i < this.ignoreTargets.length; i++) {\n            if (event.initialTarget instanceof Node && this.ignoreTargets[i].contains(event.initialTarget)) {\n                return;\n            }\n        }\n        this.targets.forEach(target => {\n            if (event.initialTarget instanceof Node && target.contains(event.initialTarget)) {\n                target.dispatchEvent(event);\n                this.dispatched = true;\n            }\n        });\n    }\n    inertia(dispatchTo, t1, vX, dirX, x, vY, dirY, y) {\n        this.handle = DomUtils.scheduleAtNextAnimationFrame(() => {\n            let now = Date.now();\n            // velocity: old speed + accel_over_time\n            let deltaT = now - t1, delta_pos_x = 0, delta_pos_y = 0, stopped = true;\n            vX += Gesture.SCROLL_FRICTION * deltaT;\n            vY += Gesture.SCROLL_FRICTION * deltaT;\n            if (vX > 0) {\n                stopped = false;\n                delta_pos_x = dirX * vX * deltaT;\n            }\n            if (vY > 0) {\n                stopped = false;\n                delta_pos_y = dirY * vY * deltaT;\n            }\n            // dispatch translation event\n            let evt = this.newGestureEvent(EventType.Change);\n            evt.translationX = delta_pos_x;\n            evt.translationY = delta_pos_y;\n            dispatchTo.forEach(d => d.dispatchEvent(evt));\n            if (!stopped) {\n                this.inertia(dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);\n            }\n        });\n    }\n    onTouchMove(e) {\n        let timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n        for (let i = 0, len = e.changedTouches.length; i < len; i++) {\n            let touch = e.changedTouches.item(i);\n            if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n                console.warn('end of an UNKNOWN touch', touch);\n                continue;\n            }\n            let data = this.activeTouches[touch.identifier];\n            let evt = this.newGestureEvent(EventType.Change, data.initialTarget);\n            evt.translationX = touch.pageX - arrays.tail(data.rollingPageX);\n            evt.translationY = touch.pageY - arrays.tail(data.rollingPageY);\n            evt.pageX = touch.pageX;\n            evt.pageY = touch.pageY;\n            this.dispatchEvent(evt);\n            // only keep a few data points, to average the final speed\n            if (data.rollingPageX.length > 3) {\n                data.rollingPageX.shift();\n                data.rollingPageY.shift();\n                data.rollingTimestamps.shift();\n            }\n            data.rollingPageX.push(touch.pageX);\n            data.rollingPageY.push(touch.pageY);\n            data.rollingTimestamps.push(timestamp);\n        }\n        if (this.dispatched) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.dispatched = false;\n        }\n    }\n}\nGesture.SCROLL_FRICTION = -0.005;\nGesture.HOLD_DELAY = 700;\nGesture.CLEAR_TAP_COUNT_TIME = 400; // ms\n__decorate([\n    memoize\n], Gesture, \"isTouchDevice\", null);\n"]},"metadata":{},"sourceType":"module"}