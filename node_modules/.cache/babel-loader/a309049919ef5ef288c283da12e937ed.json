{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n  constructor(startColumn, endColumn, className, type) {\n    this.startColumn = startColumn;\n    this.endColumn = endColumn;\n    this.className = className;\n    this.type = type;\n    this._lineDecorationBrand = undefined;\n  }\n\n  static _equals(a, b) {\n    return a.startColumn === b.startColumn && a.endColumn === b.endColumn && a.className === b.className && a.type === b.type;\n  }\n\n  static equalsArr(a, b) {\n    const aLen = a.length;\n    const bLen = b.length;\n\n    if (aLen !== bLen) {\n      return false;\n    }\n\n    for (let i = 0; i < aLen; i++) {\n      if (!LineDecoration._equals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static extractWrapped(arr, startOffset, endOffset) {\n    if (arr.length === 0) {\n      return arr;\n    }\n\n    const startColumn = startOffset + 1;\n    const endColumn = endOffset + 1;\n    const lineLength = endOffset - startOffset;\n    const r = [];\n    let rLength = 0;\n\n    for (const dec of arr) {\n      if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n        continue;\n      }\n\n      r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n    }\n\n    return r;\n  }\n\n  static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n    if (lineDecorations.length === 0) {\n      return [];\n    }\n\n    const result = [];\n    let resultLen = 0;\n\n    for (let i = 0, len = lineDecorations.length; i < len; i++) {\n      const d = lineDecorations[i];\n      const range = d.range;\n\n      if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n        // Ignore decorations that sit outside this line\n        continue;\n      }\n\n      if (range.isEmpty() && (d.type === 0\n      /* Regular */\n      || d.type === 3\n      /* RegularAffectingLetterSpacing */\n      )) {\n        // Ignore empty range decorations\n        continue;\n      }\n\n      const startColumn = range.startLineNumber === lineNumber ? range.startColumn : minLineColumn;\n      const endColumn = range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn;\n      result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n    }\n\n    return result;\n  }\n\n  static _typeCompare(a, b) {\n    const ORDER = [2, 0, 1, 3];\n    return ORDER[a] - ORDER[b];\n  }\n\n  static compare(a, b) {\n    if (a.startColumn !== b.startColumn) {\n      return a.startColumn - b.startColumn;\n    }\n\n    if (a.endColumn !== b.endColumn) {\n      return a.endColumn - b.endColumn;\n    }\n\n    const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n\n    if (typeCmp !== 0) {\n      return typeCmp;\n    }\n\n    if (a.className !== b.className) {\n      return a.className < b.className ? -1 : 1;\n    }\n\n    return 0;\n  }\n\n}\nexport class DecorationSegment {\n  constructor(startOffset, endOffset, className, metadata) {\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.className = className;\n    this.metadata = metadata;\n  }\n\n}\n\nclass Stack {\n  constructor() {\n    this.stopOffsets = [];\n    this.classNames = [];\n    this.metadata = [];\n    this.count = 0;\n  }\n\n  static _metadata(metadata) {\n    let result = 0;\n\n    for (let i = 0, len = metadata.length; i < len; i++) {\n      result |= metadata[i];\n    }\n\n    return result;\n  }\n\n  consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n    while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n      let i = 0; // Take all equal stopping offsets\n\n      while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n        i++;\n      } // Basically we are consuming the first i + 1 elements of the stack\n\n\n      result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n      nextStartOffset = this.stopOffsets[i] + 1; // Consume them\n\n      this.stopOffsets.splice(0, i + 1);\n      this.classNames.splice(0, i + 1);\n      this.metadata.splice(0, i + 1);\n      this.count -= i + 1;\n    }\n\n    if (this.count > 0 && nextStartOffset < maxStopOffset) {\n      result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n      nextStartOffset = maxStopOffset;\n    }\n\n    return nextStartOffset;\n  }\n\n  insert(stopOffset, className, metadata) {\n    if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n      // Insert at the end\n      this.stopOffsets.push(stopOffset);\n      this.classNames.push(className);\n      this.metadata.push(metadata);\n    } else {\n      // Find the insertion position for `stopOffset`\n      for (let i = 0; i < this.count; i++) {\n        if (this.stopOffsets[i] >= stopOffset) {\n          this.stopOffsets.splice(i, 0, stopOffset);\n          this.classNames.splice(i, 0, className);\n          this.metadata.splice(i, 0, metadata);\n          break;\n        }\n      }\n    }\n\n    this.count++;\n    return;\n  }\n\n}\n\nexport class LineDecorationsNormalizer {\n  /**\n   * Normalize line decorations. Overlapping decorations will generate multiple segments\n   */\n  static normalize(lineContent, lineDecorations) {\n    if (lineDecorations.length === 0) {\n      return [];\n    }\n\n    const result = [];\n    const stack = new Stack();\n    let nextStartOffset = 0;\n\n    for (let i = 0, len = lineDecorations.length; i < len; i++) {\n      const d = lineDecorations[i];\n      let startColumn = d.startColumn;\n      let endColumn = d.endColumn;\n      const className = d.className;\n      const metadata = d.type === 1\n      /* Before */\n      ? 2\n      /* PSEUDO_BEFORE */\n      : d.type === 2\n      /* After */\n      ? 4\n      /* PSEUDO_AFTER */\n      : 0; // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n\n      if (startColumn > 1) {\n        const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n\n        if (strings.isHighSurrogate(charCodeBefore)) {\n          startColumn--;\n        }\n      }\n\n      if (endColumn > 1) {\n        const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n\n        if (strings.isHighSurrogate(charCodeBefore)) {\n          endColumn--;\n        }\n      }\n\n      const currentStartOffset = startColumn - 1;\n      const currentEndOffset = endColumn - 2;\n      nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n\n      if (stack.count === 0) {\n        nextStartOffset = currentStartOffset;\n      }\n\n      stack.insert(currentEndOffset, className, metadata);\n    }\n\n    stack.consumeLowerThan(1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    , nextStartOffset, result);\n    return result;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js"],"names":["strings","LineDecoration","constructor","startColumn","endColumn","className","type","_lineDecorationBrand","undefined","_equals","a","b","equalsArr","aLen","length","bLen","i","extractWrapped","arr","startOffset","endOffset","lineLength","r","rLength","dec","Math","max","min","filter","lineDecorations","lineNumber","minLineColumn","maxLineColumn","result","resultLen","len","d","range","endLineNumber","startLineNumber","isEmpty","inlineClassName","_typeCompare","ORDER","compare","typeCmp","DecorationSegment","metadata","Stack","stopOffsets","classNames","count","_metadata","consumeLowerThan","maxStopOffset","nextStartOffset","push","join","splice","insert","stopOffset","LineDecorationsNormalizer","normalize","lineContent","stack","charCodeBefore","charCodeAt","isHighSurrogate","currentStartOffset","currentEndOffset"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n    constructor(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n        this._lineDecorationBrand = undefined;\n    }\n    static _equals(a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    }\n    static equalsArr(a, b) {\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static extractWrapped(arr, startOffset, endOffset) {\n        if (arr.length === 0) {\n            return arr;\n        }\n        const startColumn = startOffset + 1;\n        const endColumn = endOffset + 1;\n        const lineLength = endOffset - startOffset;\n        const r = [];\n        let rLength = 0;\n        for (const dec of arr) {\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n                continue;\n            }\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n        return r;\n    }\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            const range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === 0 /* Regular */ || d.type === 3 /* RegularAffectingLetterSpacing */)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    }\n    static _typeCompare(a, b) {\n        const ORDER = [2, 0, 1, 3];\n        return ORDER[a] - ORDER[b];\n    }\n    static compare(a, b) {\n        if (a.startColumn !== b.startColumn) {\n            return a.startColumn - b.startColumn;\n        }\n        if (a.endColumn !== b.endColumn) {\n            return a.endColumn - b.endColumn;\n        }\n        const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n        if (typeCmp !== 0) {\n            return typeCmp;\n        }\n        if (a.className !== b.className) {\n            return a.className < b.className ? -1 : 1;\n        }\n        return 0;\n    }\n}\nexport class DecorationSegment {\n    constructor(startOffset, endOffset, className, metadata) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n        this.metadata = metadata;\n    }\n}\nclass Stack {\n    constructor() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.metadata = [];\n        this.count = 0;\n    }\n    static _metadata(metadata) {\n        let result = 0;\n        for (let i = 0, len = metadata.length; i < len; i++) {\n            result |= metadata[i];\n        }\n        return result;\n    }\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            let i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.metadata.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    }\n    insert(stopOffset, className, metadata) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n            this.metadata.push(metadata);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (let i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    this.metadata.splice(i, 0, metadata);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    }\n}\nexport class LineDecorationsNormalizer {\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    static normalize(lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        const stack = new Stack();\n        let nextStartOffset = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            let startColumn = d.startColumn;\n            let endColumn = d.endColumn;\n            const className = d.className;\n            const metadata = (d.type === 1 /* Before */\n                ? 2 /* PSEUDO_BEFORE */\n                : d.type === 2 /* After */\n                    ? 4 /* PSEUDO_AFTER */\n                    : 0);\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            const currentStartOffset = startColumn - 1;\n            const currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className, metadata);\n        }\n        stack.consumeLowerThan(1073741824 /* MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n        return result;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}