{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { computeIndentLevel } from '../../../common/model/utils.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5000;\nexport const ID_INDENT_PROVIDER = 'indent';\nexport class IndentRangeProvider {\n  constructor(editorModel, languageConfigurationService, maxFoldingRegions) {\n    this.editorModel = editorModel;\n    this.languageConfigurationService = languageConfigurationService;\n    this.maxFoldingRegions = maxFoldingRegions;\n    this.id = ID_INDENT_PROVIDER;\n  }\n\n  dispose() {}\n\n  compute(cancelationToken, notifyTooManyRegions) {\n    let foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;\n    let offSide = foldingRules && !!foldingRules.offSide;\n    let markers = foldingRules && foldingRules.markers;\n    return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.maxFoldingRegions, notifyTooManyRegions));\n  }\n\n} // public only for testing\n\nexport class RangesCollector {\n  constructor(foldingRangesLimit, _notifyTooManyRegions) {\n    this._notifyTooManyRegions = _notifyTooManyRegions;\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._indentOccurrences = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n\n  insertFirst(startLineNumber, endLineNumber, indent) {\n    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n      return;\n    }\n\n    let index = this._length;\n    this._startIndexes[index] = startLineNumber;\n    this._endIndexes[index] = endLineNumber;\n    this._length++;\n\n    if (indent < 1000) {\n      this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n    }\n  }\n\n  toIndentRanges(model) {\n    if (this._length <= this._foldingRangesLimit) {\n      // reverse and create arrays of the exact length\n      let startIndexes = new Uint32Array(this._length);\n      let endIndexes = new Uint32Array(this._length);\n\n      for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\n        startIndexes[k] = this._startIndexes[i];\n        endIndexes[k] = this._endIndexes[i];\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes);\n    } else {\n      if (this._notifyTooManyRegions) {\n        this._notifyTooManyRegions(this._foldingRangesLimit);\n      }\n\n      let entries = 0;\n      let maxIndent = this._indentOccurrences.length;\n\n      for (let i = 0; i < this._indentOccurrences.length; i++) {\n        let n = this._indentOccurrences[i];\n\n        if (n) {\n          if (n + entries > this._foldingRangesLimit) {\n            maxIndent = i;\n            break;\n          }\n\n          entries += n;\n        }\n      }\n\n      const tabSize = model.getOptions().tabSize; // reverse and create arrays of the exact length\n\n      let startIndexes = new Uint32Array(this._foldingRangesLimit);\n      let endIndexes = new Uint32Array(this._foldingRangesLimit);\n\n      for (let i = this._length - 1, k = 0; i >= 0; i--) {\n        let startIndex = this._startIndexes[i];\n        let lineContent = model.getLineContent(startIndex);\n        let indent = computeIndentLevel(lineContent, tabSize);\n\n        if (indent < maxIndent || indent === maxIndent && entries++ < this._foldingRangesLimit) {\n          startIndexes[k] = startIndex;\n          endIndexes[k] = this._endIndexes[i];\n          k++;\n        }\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes);\n    }\n  }\n\n}\nexport function computeRanges(model, offSide, markers, foldingRangesLimit, notifyTooManyRegions) {\n  const tabSize = model.getOptions().tabSize;\n  foldingRangesLimit = foldingRangesLimit !== null && foldingRangesLimit !== void 0 ? foldingRangesLimit : MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT;\n  let result = new RangesCollector(foldingRangesLimit, notifyTooManyRegions);\n  let pattern = undefined;\n\n  if (markers) {\n    pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);\n  }\n\n  let previousRegions = [];\n  let line = model.getLineCount() + 1;\n  previousRegions.push({\n    indent: -1,\n    endAbove: line,\n    line\n  }); // sentinel, to make sure there's at least one entry\n\n  for (let line = model.getLineCount(); line > 0; line--) {\n    let lineContent = model.getLineContent(line);\n    let indent = computeIndentLevel(lineContent, tabSize);\n    let previous = previousRegions[previousRegions.length - 1];\n\n    if (indent === -1) {\n      if (offSide) {\n        // for offSide languages, empty lines are associated to the previous block\n        // note: the next block is already written to the results, so this only\n        // impacts the end position of the block before\n        previous.endAbove = line;\n      }\n\n      continue; // only whitespace\n    }\n\n    let m;\n\n    if (pattern && (m = lineContent.match(pattern))) {\n      // folding pattern match\n      if (m[1]) {\n        // start pattern match\n        // discard all regions until the folding pattern\n        let i = previousRegions.length - 1;\n\n        while (i > 0 && previousRegions[i].indent !== -2) {\n          i--;\n        }\n\n        if (i > 0) {\n          previousRegions.length = i + 1;\n          previous = previousRegions[i]; // new folding range from pattern, includes the end line\n\n          result.insertFirst(line, previous.line, indent);\n          previous.line = line;\n          previous.indent = indent;\n          previous.endAbove = line;\n          continue;\n        } else {// no end marker found, treat line as a regular line\n        }\n      } else {\n        // end pattern match\n        previousRegions.push({\n          indent: -2,\n          endAbove: line,\n          line\n        });\n        continue;\n      }\n    }\n\n    if (previous.indent > indent) {\n      // discard all regions with larger indent\n      do {\n        previousRegions.pop();\n        previous = previousRegions[previousRegions.length - 1];\n      } while (previous.indent > indent); // new folding range\n\n\n      let endLineNumber = previous.endAbove - 1;\n\n      if (endLineNumber - line >= 1) {\n        // needs at east size 1\n        result.insertFirst(line, endLineNumber, indent);\n      }\n    }\n\n    if (previous.indent === indent) {\n      previous.endAbove = line;\n    } else {\n      // previous.indent < indent\n      // new region with a bigger indent\n      previousRegions.push({\n        indent,\n        endAbove: line,\n        line\n      });\n    }\n  }\n\n  return result.toIndentRanges(model);\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/indentRangeProvider.js"],"names":["computeIndentLevel","FoldingRegions","MAX_LINE_NUMBER","MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT","ID_INDENT_PROVIDER","IndentRangeProvider","constructor","editorModel","languageConfigurationService","maxFoldingRegions","id","dispose","compute","cancelationToken","notifyTooManyRegions","foldingRules","getLanguageConfiguration","getLanguageId","offSide","markers","Promise","resolve","computeRanges","RangesCollector","foldingRangesLimit","_notifyTooManyRegions","_startIndexes","_endIndexes","_indentOccurrences","_length","_foldingRangesLimit","insertFirst","startLineNumber","endLineNumber","indent","index","toIndentRanges","model","startIndexes","Uint32Array","endIndexes","i","k","entries","maxIndent","length","n","tabSize","getOptions","startIndex","lineContent","getLineContent","result","pattern","undefined","RegExp","start","source","end","previousRegions","line","getLineCount","push","endAbove","previous","m","match","pop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { computeIndentLevel } from '../../../common/model/utils.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5000;\nexport const ID_INDENT_PROVIDER = 'indent';\nexport class IndentRangeProvider {\n    constructor(editorModel, languageConfigurationService, maxFoldingRegions) {\n        this.editorModel = editorModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.maxFoldingRegions = maxFoldingRegions;\n        this.id = ID_INDENT_PROVIDER;\n    }\n    dispose() { }\n    compute(cancelationToken, notifyTooManyRegions) {\n        let foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;\n        let offSide = foldingRules && !!foldingRules.offSide;\n        let markers = foldingRules && foldingRules.markers;\n        return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.maxFoldingRegions, notifyTooManyRegions));\n    }\n}\n// public only for testing\nexport class RangesCollector {\n    constructor(foldingRangesLimit, _notifyTooManyRegions) {\n        this._notifyTooManyRegions = _notifyTooManyRegions;\n        this._startIndexes = [];\n        this._endIndexes = [];\n        this._indentOccurrences = [];\n        this._length = 0;\n        this._foldingRangesLimit = foldingRangesLimit;\n    }\n    insertFirst(startLineNumber, endLineNumber, indent) {\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n            return;\n        }\n        let index = this._length;\n        this._startIndexes[index] = startLineNumber;\n        this._endIndexes[index] = endLineNumber;\n        this._length++;\n        if (indent < 1000) {\n            this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n        }\n    }\n    toIndentRanges(model) {\n        if (this._length <= this._foldingRangesLimit) {\n            // reverse and create arrays of the exact length\n            let startIndexes = new Uint32Array(this._length);\n            let endIndexes = new Uint32Array(this._length);\n            for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\n                startIndexes[k] = this._startIndexes[i];\n                endIndexes[k] = this._endIndexes[i];\n            }\n            return new FoldingRegions(startIndexes, endIndexes);\n        }\n        else {\n            if (this._notifyTooManyRegions) {\n                this._notifyTooManyRegions(this._foldingRangesLimit);\n            }\n            let entries = 0;\n            let maxIndent = this._indentOccurrences.length;\n            for (let i = 0; i < this._indentOccurrences.length; i++) {\n                let n = this._indentOccurrences[i];\n                if (n) {\n                    if (n + entries > this._foldingRangesLimit) {\n                        maxIndent = i;\n                        break;\n                    }\n                    entries += n;\n                }\n            }\n            const tabSize = model.getOptions().tabSize;\n            // reverse and create arrays of the exact length\n            let startIndexes = new Uint32Array(this._foldingRangesLimit);\n            let endIndexes = new Uint32Array(this._foldingRangesLimit);\n            for (let i = this._length - 1, k = 0; i >= 0; i--) {\n                let startIndex = this._startIndexes[i];\n                let lineContent = model.getLineContent(startIndex);\n                let indent = computeIndentLevel(lineContent, tabSize);\n                if (indent < maxIndent || (indent === maxIndent && entries++ < this._foldingRangesLimit)) {\n                    startIndexes[k] = startIndex;\n                    endIndexes[k] = this._endIndexes[i];\n                    k++;\n                }\n            }\n            return new FoldingRegions(startIndexes, endIndexes);\n        }\n    }\n}\nexport function computeRanges(model, offSide, markers, foldingRangesLimit, notifyTooManyRegions) {\n    const tabSize = model.getOptions().tabSize;\n    foldingRangesLimit = foldingRangesLimit !== null && foldingRangesLimit !== void 0 ? foldingRangesLimit : MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT;\n    let result = new RangesCollector(foldingRangesLimit, notifyTooManyRegions);\n    let pattern = undefined;\n    if (markers) {\n        pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);\n    }\n    let previousRegions = [];\n    let line = model.getLineCount() + 1;\n    previousRegions.push({ indent: -1, endAbove: line, line }); // sentinel, to make sure there's at least one entry\n    for (let line = model.getLineCount(); line > 0; line--) {\n        let lineContent = model.getLineContent(line);\n        let indent = computeIndentLevel(lineContent, tabSize);\n        let previous = previousRegions[previousRegions.length - 1];\n        if (indent === -1) {\n            if (offSide) {\n                // for offSide languages, empty lines are associated to the previous block\n                // note: the next block is already written to the results, so this only\n                // impacts the end position of the block before\n                previous.endAbove = line;\n            }\n            continue; // only whitespace\n        }\n        let m;\n        if (pattern && (m = lineContent.match(pattern))) {\n            // folding pattern match\n            if (m[1]) { // start pattern match\n                // discard all regions until the folding pattern\n                let i = previousRegions.length - 1;\n                while (i > 0 && previousRegions[i].indent !== -2) {\n                    i--;\n                }\n                if (i > 0) {\n                    previousRegions.length = i + 1;\n                    previous = previousRegions[i];\n                    // new folding range from pattern, includes the end line\n                    result.insertFirst(line, previous.line, indent);\n                    previous.line = line;\n                    previous.indent = indent;\n                    previous.endAbove = line;\n                    continue;\n                }\n                else {\n                    // no end marker found, treat line as a regular line\n                }\n            }\n            else { // end pattern match\n                previousRegions.push({ indent: -2, endAbove: line, line });\n                continue;\n            }\n        }\n        if (previous.indent > indent) {\n            // discard all regions with larger indent\n            do {\n                previousRegions.pop();\n                previous = previousRegions[previousRegions.length - 1];\n            } while (previous.indent > indent);\n            // new folding range\n            let endLineNumber = previous.endAbove - 1;\n            if (endLineNumber - line >= 1) { // needs at east size 1\n                result.insertFirst(line, endLineNumber, indent);\n            }\n        }\n        if (previous.indent === indent) {\n            previous.endAbove = line;\n        }\n        else { // previous.indent < indent\n            // new region with a bigger indent\n            previousRegions.push({ indent, endAbove: line, line });\n        }\n    }\n    return result.toIndentRanges(model);\n}\n"]},"metadata":{},"sourceType":"module"}