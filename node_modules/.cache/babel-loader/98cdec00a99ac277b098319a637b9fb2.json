{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/core/cursorColumns.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/cursor/cursorAtomicMoveOperations.js';\n\nclass UnknownHitTestResult {\n  constructor(hitTarget = null) {\n    this.hitTarget = hitTarget;\n    this.type = 0\n    /* Unknown */\n    ;\n  }\n\n}\n\nclass ContentHitTestResult {\n  constructor(position, spanNode, injectedText) {\n    this.position = position;\n    this.spanNode = spanNode;\n    this.injectedText = injectedText;\n    this.type = 1\n    /* Content */\n    ;\n  }\n\n}\n\nvar HitTestResult;\n\n(function (HitTestResult) {\n  function createFromDOMInfo(ctx, spanNode, offset) {\n    const position = ctx.getPositionFromDOMInfo(spanNode, offset);\n\n    if (position) {\n      return new ContentHitTestResult(position, spanNode, null);\n    }\n\n    return new UnknownHitTestResult(spanNode);\n  }\n\n  HitTestResult.createFromDOMInfo = createFromDOMInfo;\n})(HitTestResult || (HitTestResult = {}));\n\nexport class PointerHandlerLastRenderData {\n  constructor(lastViewCursorsRenderData, lastTextareaPosition) {\n    this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n    this.lastTextareaPosition = lastTextareaPosition;\n  }\n\n}\nexport class MouseTarget {\n  static _deduceRage(position, range = null) {\n    if (!range && position) {\n      return new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n    }\n\n    return range !== null && range !== void 0 ? range : null;\n  }\n\n  static createUnknown(element, mouseColumn, position) {\n    return {\n      type: 0\n      /* UNKNOWN */\n      ,\n      element,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position)\n    };\n  }\n\n  static createTextarea(element, mouseColumn) {\n    return {\n      type: 1\n      /* TEXTAREA */\n      ,\n      element,\n      mouseColumn,\n      position: null,\n      range: null\n    };\n  }\n\n  static createMargin(type, element, mouseColumn, position, range, detail) {\n    return {\n      type,\n      element,\n      mouseColumn,\n      position,\n      range,\n      detail\n    };\n  }\n\n  static createViewZone(type, element, mouseColumn, position, detail) {\n    return {\n      type,\n      element,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position),\n      detail\n    };\n  }\n\n  static createContentText(element, mouseColumn, position, range, detail) {\n    return {\n      type: 6\n      /* CONTENT_TEXT */\n      ,\n      element,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position, range),\n      detail\n    };\n  }\n\n  static createContentEmpty(element, mouseColumn, position, detail) {\n    return {\n      type: 7\n      /* CONTENT_EMPTY */\n      ,\n      element,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position),\n      detail\n    };\n  }\n\n  static createContentWidget(element, mouseColumn, detail) {\n    return {\n      type: 9\n      /* CONTENT_WIDGET */\n      ,\n      element,\n      mouseColumn,\n      position: null,\n      range: null,\n      detail\n    };\n  }\n\n  static createScrollbar(element, mouseColumn, position) {\n    return {\n      type: 11\n      /* SCROLLBAR */\n      ,\n      element,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position)\n    };\n  }\n\n  static createOverlayWidget(element, mouseColumn, detail) {\n    return {\n      type: 12\n      /* OVERLAY_WIDGET */\n      ,\n      element,\n      mouseColumn,\n      position: null,\n      range: null,\n      detail\n    };\n  }\n\n  static createOutsideEditor(mouseColumn, position) {\n    return {\n      type: 13\n      /* OUTSIDE_EDITOR */\n      ,\n      element: null,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position)\n    };\n  }\n\n  static _typeToString(type) {\n    if (type === 1\n    /* TEXTAREA */\n    ) {\n      return 'TEXTAREA';\n    }\n\n    if (type === 2\n    /* GUTTER_GLYPH_MARGIN */\n    ) {\n      return 'GUTTER_GLYPH_MARGIN';\n    }\n\n    if (type === 3\n    /* GUTTER_LINE_NUMBERS */\n    ) {\n      return 'GUTTER_LINE_NUMBERS';\n    }\n\n    if (type === 4\n    /* GUTTER_LINE_DECORATIONS */\n    ) {\n      return 'GUTTER_LINE_DECORATIONS';\n    }\n\n    if (type === 5\n    /* GUTTER_VIEW_ZONE */\n    ) {\n      return 'GUTTER_VIEW_ZONE';\n    }\n\n    if (type === 6\n    /* CONTENT_TEXT */\n    ) {\n      return 'CONTENT_TEXT';\n    }\n\n    if (type === 7\n    /* CONTENT_EMPTY */\n    ) {\n      return 'CONTENT_EMPTY';\n    }\n\n    if (type === 8\n    /* CONTENT_VIEW_ZONE */\n    ) {\n      return 'CONTENT_VIEW_ZONE';\n    }\n\n    if (type === 9\n    /* CONTENT_WIDGET */\n    ) {\n      return 'CONTENT_WIDGET';\n    }\n\n    if (type === 10\n    /* OVERVIEW_RULER */\n    ) {\n      return 'OVERVIEW_RULER';\n    }\n\n    if (type === 11\n    /* SCROLLBAR */\n    ) {\n      return 'SCROLLBAR';\n    }\n\n    if (type === 12\n    /* OVERLAY_WIDGET */\n    ) {\n      return 'OVERLAY_WIDGET';\n    }\n\n    return 'UNKNOWN';\n  }\n\n  static toString(target) {\n    return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + JSON.stringify(target.detail);\n  }\n\n}\n\nclass ElementPath {\n  static isTextArea(path) {\n    return path.length === 2 && path[0] === 3\n    /* OverflowGuard */\n    && path[1] === 6\n    /* TextArea */\n    ;\n  }\n\n  static isChildOfViewLines(path) {\n    return path.length >= 4 && path[0] === 3\n    /* OverflowGuard */\n    && path[3] === 7\n    /* ViewLines */\n    ;\n  }\n\n  static isStrictChildOfViewLines(path) {\n    return path.length > 4 && path[0] === 3\n    /* OverflowGuard */\n    && path[3] === 7\n    /* ViewLines */\n    ;\n  }\n\n  static isChildOfScrollableElement(path) {\n    return path.length >= 2 && path[0] === 3\n    /* OverflowGuard */\n    && path[1] === 5\n    /* ScrollableElement */\n    ;\n  }\n\n  static isChildOfMinimap(path) {\n    return path.length >= 2 && path[0] === 3\n    /* OverflowGuard */\n    && path[1] === 8\n    /* Minimap */\n    ;\n  }\n\n  static isChildOfContentWidgets(path) {\n    return path.length >= 4 && path[0] === 3\n    /* OverflowGuard */\n    && path[3] === 1\n    /* ContentWidgets */\n    ;\n  }\n\n  static isChildOfOverflowingContentWidgets(path) {\n    return path.length >= 1 && path[0] === 2\n    /* OverflowingContentWidgets */\n    ;\n  }\n\n  static isChildOfOverlayWidgets(path) {\n    return path.length >= 2 && path[0] === 3\n    /* OverflowGuard */\n    && path[1] === 4\n    /* OverlayWidgets */\n    ;\n  }\n\n}\n\nexport class HitTestContext {\n  constructor(context, viewHelper, lastRenderData) {\n    this.model = context.model;\n    const options = context.configuration.options;\n    this.layoutInfo = options.get(131\n    /* layoutInfo */\n    );\n    this.viewDomNode = viewHelper.viewDomNode;\n    this.lineHeight = options.get(59\n    /* lineHeight */\n    );\n    this.stickyTabStops = options.get(104\n    /* stickyTabStops */\n    );\n    this.typicalHalfwidthCharacterWidth = options.get(44\n    /* fontInfo */\n    ).typicalHalfwidthCharacterWidth;\n    this.lastRenderData = lastRenderData;\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n\n  getZoneAtCoord(mouseVerticalOffset) {\n    return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n  }\n\n  static getZoneAtCoord(context, mouseVerticalOffset) {\n    // The target is either a view zone or the empty space after the last view-line\n    const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n\n    if (viewZoneWhitespace) {\n      const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n      const lineCount = context.model.getLineCount();\n      let positionBefore = null;\n      let position;\n      let positionAfter = null;\n\n      if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n        // There are more lines after this view zone\n        positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n      }\n\n      if (viewZoneWhitespace.afterLineNumber > 0) {\n        // There are more lines above this view zone\n        positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n      }\n\n      if (positionAfter === null) {\n        position = positionBefore;\n      } else if (positionBefore === null) {\n        position = positionAfter;\n      } else if (mouseVerticalOffset < viewZoneMiddle) {\n        position = positionBefore;\n      } else {\n        position = positionAfter;\n      }\n\n      return {\n        viewZoneId: viewZoneWhitespace.id,\n        afterLineNumber: viewZoneWhitespace.afterLineNumber,\n        positionBefore: positionBefore,\n        positionAfter: positionAfter,\n        position: position\n      };\n    }\n\n    return null;\n  }\n\n  getFullLineRangeAtCoord(mouseVerticalOffset) {\n    if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n      // Below the last line\n      const lineNumber = this._context.model.getLineCount();\n\n      const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\n\n      return {\n        range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\n        isAfterLines: true\n      };\n    }\n\n    const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n\n    const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\n\n    return {\n      range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n      isAfterLines: false\n    };\n  }\n\n  getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n    return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n  }\n\n  isAfterLines(mouseVerticalOffset) {\n    return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n  }\n\n  isInTopPadding(mouseVerticalOffset) {\n    return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n  }\n\n  isInBottomPadding(mouseVerticalOffset) {\n    return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n  }\n\n  getVerticalOffsetForLineNumber(lineNumber) {\n    return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n  }\n\n  findAttribute(element, attr) {\n    return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n  }\n\n  static _findAttribute(element, attr, stopAt) {\n    while (element && element !== document.body) {\n      if (element.hasAttribute && element.hasAttribute(attr)) {\n        return element.getAttribute(attr);\n      }\n\n      if (element === stopAt) {\n        return null;\n      }\n\n      element = element.parentNode;\n    }\n\n    return null;\n  }\n\n  getLineWidth(lineNumber) {\n    return this._viewHelper.getLineWidth(lineNumber);\n  }\n\n  visibleRangeForPosition(lineNumber, column) {\n    return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n  }\n\n  getPositionFromDOMInfo(spanNode, offset) {\n    return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n  }\n\n  getCurrentScrollTop() {\n    return this._context.viewLayout.getCurrentScrollTop();\n  }\n\n  getCurrentScrollLeft() {\n    return this._context.viewLayout.getCurrentScrollLeft();\n  }\n\n}\n\nclass BareHitTestRequest {\n  constructor(ctx, editorPos, pos, relativePos) {\n    this.editorPos = editorPos;\n    this.pos = pos;\n    this.relativePos = relativePos;\n    this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + this.relativePos.y);\n    this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + this.relativePos.x - ctx.layoutInfo.contentLeft;\n    this.isInMarginArea = this.relativePos.x < ctx.layoutInfo.contentLeft && this.relativePos.x >= ctx.layoutInfo.glyphMarginLeft;\n    this.isInContentArea = !this.isInMarginArea;\n    this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n  }\n\n}\n\nclass HitTestRequest extends BareHitTestRequest {\n  constructor(ctx, editorPos, pos, relativePos, target) {\n    super(ctx, editorPos, pos, relativePos);\n    this._ctx = ctx;\n\n    if (target) {\n      this.target = target;\n      this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);\n    } else {\n      this.target = null;\n      this.targetPath = new Uint8Array(0);\n    }\n  }\n\n  toString() {\n    return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\\n\\ttarget: ${this.target ? this.target.outerHTML : null}`;\n  }\n\n  _getMouseColumn(position = null) {\n    if (position && position.column < this._ctx.model.getLineMaxColumn(position.lineNumber)) {\n      // Most likely, the line contains foreign decorations...\n      return CursorColumns.visibleColumnFromColumn(this._ctx.model.getLineContent(position.lineNumber), position.column, this._ctx.model.getTextModelOptions().tabSize) + 1;\n    }\n\n    return this.mouseColumn;\n  }\n\n  fulfillUnknown(position = null) {\n    return MouseTarget.createUnknown(this.target, this._getMouseColumn(position), position);\n  }\n\n  fulfillTextarea() {\n    return MouseTarget.createTextarea(this.target, this._getMouseColumn());\n  }\n\n  fulfillMargin(type, position, range, detail) {\n    return MouseTarget.createMargin(type, this.target, this._getMouseColumn(position), position, range, detail);\n  }\n\n  fulfillViewZone(type, position, detail) {\n    return MouseTarget.createViewZone(type, this.target, this._getMouseColumn(position), position, detail);\n  }\n\n  fulfillContentText(position, range, detail) {\n    return MouseTarget.createContentText(this.target, this._getMouseColumn(position), position, range, detail);\n  }\n\n  fulfillContentEmpty(position, detail) {\n    return MouseTarget.createContentEmpty(this.target, this._getMouseColumn(position), position, detail);\n  }\n\n  fulfillContentWidget(detail) {\n    return MouseTarget.createContentWidget(this.target, this._getMouseColumn(), detail);\n  }\n\n  fulfillScrollbar(position) {\n    return MouseTarget.createScrollbar(this.target, this._getMouseColumn(position), position);\n  }\n\n  fulfillOverlayWidget(detail) {\n    return MouseTarget.createOverlayWidget(this.target, this._getMouseColumn(), detail);\n  }\n\n  withTarget(target) {\n    return new HitTestRequest(this._ctx, this.editorPos, this.pos, this.relativePos, target);\n  }\n\n}\n\nconst EMPTY_CONTENT_AFTER_LINES = {\n  isAfterLines: true\n};\n\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n  return {\n    isAfterLines: false,\n    horizontalDistanceToText: horizontalDistanceToText\n  };\n}\n\nexport class MouseTargetFactory {\n  constructor(context, viewHelper) {\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n\n  mouseTargetIsWidget(e) {\n    const t = e.target;\n    const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode); // Is it a content widget?\n\n    if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n      return true;\n    } // Is it an overlay widget?\n\n\n    if (ElementPath.isChildOfOverlayWidgets(path)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  createMouseTarget(lastRenderData, editorPos, pos, relativePos, target) {\n    const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n    const request = new HitTestRequest(ctx, editorPos, pos, relativePos, target);\n\n    try {\n      const r = MouseTargetFactory._createMouseTarget(ctx, request, false); // console.log(MouseTarget.toString(r));\n\n\n      return r;\n    } catch (err) {\n      // console.log(err);\n      return request.fulfillUnknown();\n    }\n  }\n\n  static _createMouseTarget(ctx, request, domHitTestExecuted) {\n    // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n    // First ensure the request has a target\n    if (request.target === null) {\n      if (domHitTestExecuted) {\n        // Still no target... and we have already executed hit test...\n        return request.fulfillUnknown();\n      }\n\n      const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n\n      if (hitTestResult.type === 1\n      /* Content */\n      ) {\n        return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n      }\n\n      return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n    } // we know for a fact that request.target is not null\n\n\n    const resolvedRequest = request;\n    let result = null;\n    result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest, domHitTestExecuted);\n    result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n    return result || request.fulfillUnknown();\n  }\n\n  static _hitTestContentWidget(ctx, request) {\n    // Is it a content widget?\n    if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n      const widgetId = ctx.findAttribute(request.target, 'widgetId');\n\n      if (widgetId) {\n        return request.fulfillContentWidget(widgetId);\n      } else {\n        return request.fulfillUnknown();\n      }\n    }\n\n    return null;\n  }\n\n  static _hitTestOverlayWidget(ctx, request) {\n    // Is it an overlay widget?\n    if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {\n      const widgetId = ctx.findAttribute(request.target, 'widgetId');\n\n      if (widgetId) {\n        return request.fulfillOverlayWidget(widgetId);\n      } else {\n        return request.fulfillUnknown();\n      }\n    }\n\n    return null;\n  }\n\n  static _hitTestViewCursor(ctx, request) {\n    if (request.target) {\n      // Check if we've hit a painted cursor\n      const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n\n      for (const d of lastViewCursorsRenderData) {\n        if (request.target === d.domNode) {\n          return request.fulfillContentText(d.position, null, {\n            mightBeForeignElement: false,\n            injectedText: null\n          });\n        }\n      }\n    }\n\n    if (request.isInContentArea) {\n      // Edge has a bug when hit-testing the exact position of a cursor,\n      // instead of returning the correct dom node, it returns the\n      // first or last rendered view line dom node, therefore help it out\n      // and first check if we are on top of a cursor\n      const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n      const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n      const mouseVerticalOffset = request.mouseVerticalOffset;\n\n      for (const d of lastViewCursorsRenderData) {\n        if (mouseContentHorizontalOffset < d.contentLeft) {\n          // mouse position is to the left of the cursor\n          continue;\n        }\n\n        if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\n          // mouse position is to the right of the cursor\n          continue;\n        }\n\n        const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\n\n        if (cursorVerticalOffset <= mouseVerticalOffset && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\n          return request.fulfillContentText(d.position, null, {\n            mightBeForeignElement: false,\n            injectedText: null\n          });\n        }\n      }\n    }\n\n    return null;\n  }\n\n  static _hitTestViewZone(ctx, request) {\n    const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n\n    if (viewZoneData) {\n      const mouseTargetType = request.isInContentArea ? 8\n      /* CONTENT_VIEW_ZONE */\n      : 5\n      /* GUTTER_VIEW_ZONE */\n      ;\n      return request.fulfillViewZone(mouseTargetType, viewZoneData.position, viewZoneData);\n    }\n\n    return null;\n  }\n\n  static _hitTestTextArea(ctx, request) {\n    // Is it the textarea?\n    if (ElementPath.isTextArea(request.targetPath)) {\n      if (ctx.lastRenderData.lastTextareaPosition) {\n        return request.fulfillContentText(ctx.lastRenderData.lastTextareaPosition, null, {\n          mightBeForeignElement: false,\n          injectedText: null\n        });\n      }\n\n      return request.fulfillTextarea();\n    }\n\n    return null;\n  }\n\n  static _hitTestMargin(ctx, request) {\n    if (request.isInMarginArea) {\n      const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n      const pos = res.range.getStartPosition();\n      let offset = Math.abs(request.relativePos.x);\n      const detail = {\n        isAfterLines: res.isAfterLines,\n        glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n        glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n        lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n        offsetX: offset\n      };\n      offset -= ctx.layoutInfo.glyphMarginLeft;\n\n      if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n        // On the glyph margin\n        return request.fulfillMargin(2\n        /* GUTTER_GLYPH_MARGIN */\n        , pos, res.range, detail);\n      }\n\n      offset -= ctx.layoutInfo.glyphMarginWidth;\n\n      if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n        // On the line numbers\n        return request.fulfillMargin(3\n        /* GUTTER_LINE_NUMBERS */\n        , pos, res.range, detail);\n      }\n\n      offset -= ctx.layoutInfo.lineNumbersWidth; // On the line decorations\n\n      return request.fulfillMargin(4\n      /* GUTTER_LINE_DECORATIONS */\n      , pos, res.range, detail);\n    }\n\n    return null;\n  }\n\n  static _hitTestViewLines(ctx, request, domHitTestExecuted) {\n    if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n      return null;\n    }\n\n    if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n      return request.fulfillContentEmpty(new Position(1, 1), EMPTY_CONTENT_AFTER_LINES);\n    } // Check if it is below any lines and any view zones\n\n\n    if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n      // This most likely indicates it happened after the last view-line\n      const lineCount = ctx.model.getLineCount();\n      const maxLineColumn = ctx.model.getLineMaxColumn(lineCount);\n      return request.fulfillContentEmpty(new Position(lineCount, maxLineColumn), EMPTY_CONTENT_AFTER_LINES);\n    }\n\n    if (domHitTestExecuted) {\n      // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n      // See https://github.com/microsoft/vscode/issues/46942\n      if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n\n        if (ctx.model.getLineLength(lineNumber) === 0) {\n          const lineWidth = ctx.getLineWidth(lineNumber);\n          const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n          return request.fulfillContentEmpty(new Position(lineNumber, 1), detail);\n        }\n\n        const lineWidth = ctx.getLineWidth(lineNumber);\n\n        if (request.mouseContentHorizontalOffset >= lineWidth) {\n          const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n          const pos = new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber));\n          return request.fulfillContentEmpty(pos, detail);\n        }\n      } // We have already executed hit test...\n\n\n      return request.fulfillUnknown();\n    }\n\n    const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n\n    if (hitTestResult.type === 1\n    /* Content */\n    ) {\n      return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n    }\n\n    return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n  }\n\n  static _hitTestMinimap(ctx, request) {\n    if (ElementPath.isChildOfMinimap(request.targetPath)) {\n      const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n      return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n    }\n\n    return null;\n  }\n\n  static _hitTestScrollbarSlider(ctx, request) {\n    if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n      if (request.target && request.target.nodeType === 1) {\n        const className = request.target.className;\n\n        if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n          const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n          const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n          return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n      }\n    }\n\n    return null;\n  }\n\n  static _hitTestScrollbar(ctx, request) {\n    // Is it the overview ruler?\n    // Is it a child of the scrollable element?\n    if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n      const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n      return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n    }\n\n    return null;\n  }\n\n  getMouseColumn(relativePos) {\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(131\n    /* layoutInfo */\n    );\n    const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + relativePos.x - layoutInfo.contentLeft;\n    return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(44\n    /* fontInfo */\n    ).typicalHalfwidthCharacterWidth);\n  }\n\n  static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n    if (mouseContentHorizontalOffset < 0) {\n      return 1;\n    }\n\n    const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n    return chars + 1;\n  }\n\n  static createMouseTargetFromHitTestPosition(ctx, request, spanNode, pos, injectedText) {\n    const lineNumber = pos.lineNumber;\n    const column = pos.column;\n    const lineWidth = ctx.getLineWidth(lineNumber);\n\n    if (request.mouseContentHorizontalOffset > lineWidth) {\n      const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n      return request.fulfillContentEmpty(pos, detail);\n    }\n\n    const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n\n    if (!visibleRange) {\n      return request.fulfillUnknown(pos);\n    }\n\n    const columnHorizontalOffset = visibleRange.left;\n\n    if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {\n      return request.fulfillContentText(pos, null, {\n        mightBeForeignElement: !!injectedText,\n        injectedText\n      });\n    }\n\n    const points = [];\n    points.push({\n      offset: visibleRange.left,\n      column: column\n    });\n\n    if (column > 1) {\n      const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n\n      if (visibleRange) {\n        points.push({\n          offset: visibleRange.left,\n          column: column - 1\n        });\n      }\n    }\n\n    const lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);\n\n    if (column < lineMaxColumn) {\n      const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\n\n      if (visibleRange) {\n        points.push({\n          offset: visibleRange.left,\n          column: column + 1\n        });\n      }\n    }\n\n    points.sort((a, b) => a.offset - b.offset);\n    const mouseCoordinates = request.pos.toClientCoordinates();\n    const spanNodeClientRect = spanNode.getBoundingClientRect();\n    const mouseIsOverSpanNode = spanNodeClientRect.left <= mouseCoordinates.clientX && mouseCoordinates.clientX <= spanNodeClientRect.right;\n\n    for (let i = 1; i < points.length; i++) {\n      const prev = points[i - 1];\n      const curr = points[i];\n\n      if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n        const rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n        return request.fulfillContentText(pos, rng, {\n          mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText,\n          injectedText\n        });\n      }\n    }\n\n    return request.fulfillContentText(pos, null, {\n      mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText,\n      injectedText\n    });\n  }\n  /**\n   * Most probably WebKit browsers and Edge\n   */\n\n\n  static _doHitTestWithCaretRangeFromPoint(ctx, request) {\n    // In Chrome, especially on Linux it is possible to click between lines,\n    // so try to adjust the `hity` below so that it lands in the center of a line\n    const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n    const lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n    const lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);\n    let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n\n    if (adjustedPageY <= request.editorPos.y) {\n      adjustedPageY = request.editorPos.y + 1;\n    }\n\n    if (adjustedPageY >= request.editorPos.y + request.editorPos.height) {\n      adjustedPageY = request.editorPos.y + request.editorPos.height - 1;\n    }\n\n    const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n\n    const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());\n\n    if (r.type === 1\n    /* Content */\n    ) {\n      return r;\n    } // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n\n\n    return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());\n  }\n\n  static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n    const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n    let range;\n\n    if (shadowRoot) {\n      if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n        range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n      } else {\n        range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n      }\n    } else {\n      range = document.caretRangeFromPoint(coords.clientX, coords.clientY);\n    }\n\n    if (!range || !range.startContainer) {\n      return new UnknownHitTestResult();\n    } // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n\n\n    const startContainer = range.startContainer;\n\n    if (startContainer.nodeType === startContainer.TEXT_NODE) {\n      // startContainer is expected to be the token text\n      const parent1 = startContainer.parentNode; // expected to be the token span\n\n      const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n\n      const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n\n      const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n\n      if (parent3ClassName === ViewLine.CLASS_NAME) {\n        return HitTestResult.createFromDOMInfo(ctx, parent1, range.startOffset);\n      } else {\n        return new UnknownHitTestResult(startContainer.parentNode);\n      }\n    } else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n      // startContainer is expected to be the token span\n      const parent1 = startContainer.parentNode; // expected to be the view line container span\n\n      const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\n\n      const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n\n      if (parent2ClassName === ViewLine.CLASS_NAME) {\n        return HitTestResult.createFromDOMInfo(ctx, startContainer, startContainer.textContent.length);\n      } else {\n        return new UnknownHitTestResult(startContainer);\n      }\n    }\n\n    return new UnknownHitTestResult();\n  }\n  /**\n   * Most probably Gecko\n   */\n\n\n  static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n    const hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);\n\n    if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n      // offsetNode is expected to be the token text\n      const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n\n      const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n\n      const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n\n      const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n\n      if (parent3ClassName === ViewLine.CLASS_NAME) {\n        return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode.parentNode, hitResult.offset);\n      } else {\n        return new UnknownHitTestResult(hitResult.offsetNode.parentNode);\n      }\n    } // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n    // Some other times, it returns the `<span>` with the inline decoration\n\n\n    if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n      const parent1 = hitResult.offsetNode.parentNode;\n      const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\n      const parent2 = parent1 ? parent1.parentNode : null;\n      const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n\n      if (parent1ClassName === ViewLine.CLASS_NAME) {\n        // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n        const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n\n        if (tokenSpan) {\n          return HitTestResult.createFromDOMInfo(ctx, tokenSpan, 0);\n        }\n      } else if (parent2ClassName === ViewLine.CLASS_NAME) {\n        // it returned the `<span>` with the inline decoration\n        return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode, 0);\n      }\n    }\n\n    return new UnknownHitTestResult(hitResult.offsetNode);\n  }\n\n  static _snapToSoftTabBoundary(position, viewModel) {\n    const lineContent = viewModel.getLineContent(position.lineNumber);\n    const {\n      tabSize\n    } = viewModel.getTextModelOptions();\n    const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2\n    /* Nearest */\n    );\n\n    if (newPosition !== -1) {\n      return new Position(position.lineNumber, newPosition + 1);\n    }\n\n    return position;\n  }\n\n  static _doHitTest(ctx, request) {\n    let result = new UnknownHitTestResult();\n\n    if (typeof document.caretRangeFromPoint === 'function') {\n      result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n    } else if (document.caretPositionFromPoint) {\n      result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());\n    }\n\n    if (result.type === 1\n    /* Content */\n    ) {\n      const injectedText = ctx.model.getInjectedTextAt(result.position);\n      const normalizedPosition = ctx.model.normalizePosition(result.position, 2\n      /* None */\n      );\n\n      if (injectedText || !normalizedPosition.equals(result.position)) {\n        result = new ContentHitTestResult(normalizedPosition, result.spanNode, injectedText);\n      }\n    } // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n\n\n    if (result.type === 1\n    /* Content */\n    && ctx.stickyTabStops) {\n      result = new ContentHitTestResult(this._snapToSoftTabBoundary(result.position, ctx.model), result.spanNode, result.injectedText);\n    }\n\n    return result;\n  }\n\n}\nexport function shadowCaretRangeFromPoint(shadowRoot, x, y) {\n  const range = document.createRange(); // Get the element under the point\n\n  let el = shadowRoot.elementFromPoint(x, y);\n\n  if (el !== null) {\n    // Get the last child of the element until its firstChild is a text node\n    // This assumes that the pointer is on the right of the line, out of the tokens\n    // and that we want to get the offset of the last token of the line\n    while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n      el = el.lastChild;\n    } // Grab its rect\n\n\n    const rect = el.getBoundingClientRect(); // And its font\n\n    const font = window.getComputedStyle(el, null).getPropertyValue('font'); // And also its txt content\n\n    const text = el.innerText; // Position the pixel cursor at the left of the element\n\n    let pixelCursor = rect.left;\n    let offset = 0;\n    let step; // If the point is on the right of the box put the cursor after the last character\n\n    if (x > rect.left + rect.width) {\n      offset = text.length;\n    } else {\n      const charWidthReader = CharWidthReader.getInstance(); // Goes through all the characters of the innerText, and checks if the x of the point\n      // belongs to the character.\n\n      for (let i = 0; i < text.length + 1; i++) {\n        // The step is half the width of the character\n        step = charWidthReader.getCharWidth(text.charAt(i), font) / 2; // Move to the center of the character\n\n        pixelCursor += step; // If the x of the point is smaller that the position of the cursor, the point is over that character\n\n        if (x < pixelCursor) {\n          offset = i;\n          break;\n        } // Move between the current character and the next\n\n\n        pixelCursor += step;\n      }\n    } // Creates a range with the text node of the element and set the offset found\n\n\n    range.setStart(el.firstChild, offset);\n    range.setEnd(el.firstChild, offset);\n  }\n\n  return range;\n}\n\nclass CharWidthReader {\n  constructor() {\n    this._cache = {};\n    this._canvas = document.createElement('canvas');\n  }\n\n  static getInstance() {\n    if (!CharWidthReader._INSTANCE) {\n      CharWidthReader._INSTANCE = new CharWidthReader();\n    }\n\n    return CharWidthReader._INSTANCE;\n  }\n\n  getCharWidth(char, font) {\n    const cacheKey = char + font;\n\n    if (this._cache[cacheKey]) {\n      return this._cache[cacheKey];\n    }\n\n    const context = this._canvas.getContext('2d');\n\n    context.font = font;\n    const metrics = context.measureText(char);\n    const width = metrics.width;\n    this._cache[cacheKey] = width;\n    return width;\n  }\n\n}\n\nCharWidthReader._INSTANCE = null;","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseTarget.js"],"names":["PageCoordinates","PartFingerprints","ViewLine","Position","Range","EditorRange","CursorColumns","dom","AtomicTabMoveOperations","UnknownHitTestResult","constructor","hitTarget","type","ContentHitTestResult","position","spanNode","injectedText","HitTestResult","createFromDOMInfo","ctx","offset","getPositionFromDOMInfo","PointerHandlerLastRenderData","lastViewCursorsRenderData","lastTextareaPosition","MouseTarget","_deduceRage","range","lineNumber","column","createUnknown","element","mouseColumn","createTextarea","createMargin","detail","createViewZone","createContentText","createContentEmpty","createContentWidget","createScrollbar","createOverlayWidget","createOutsideEditor","_typeToString","toString","target","JSON","stringify","ElementPath","isTextArea","path","length","isChildOfViewLines","isStrictChildOfViewLines","isChildOfScrollableElement","isChildOfMinimap","isChildOfContentWidgets","isChildOfOverflowingContentWidgets","isChildOfOverlayWidgets","HitTestContext","context","viewHelper","lastRenderData","model","options","configuration","layoutInfo","get","viewDomNode","lineHeight","stickyTabStops","typicalHalfwidthCharacterWidth","_context","_viewHelper","getZoneAtCoord","mouseVerticalOffset","viewZoneWhitespace","viewLayout","getWhitespaceAtVerticalOffset","viewZoneMiddle","verticalOffset","height","lineCount","getLineCount","positionBefore","positionAfter","afterLineNumber","getLineMaxColumn","viewZoneId","id","getFullLineRangeAtCoord","isAfterLines","maxLineColumn","getLineNumberAtVerticalOffset","isInTopPadding","isInBottomPadding","getVerticalOffsetForLineNumber","findAttribute","attr","_findAttribute","stopAt","document","body","hasAttribute","getAttribute","parentNode","getLineWidth","visibleRangeForPosition","getCurrentScrollTop","getCurrentScrollLeft","BareHitTestRequest","editorPos","pos","relativePos","Math","max","y","mouseContentHorizontalOffset","x","contentLeft","isInMarginArea","glyphMarginLeft","isInContentArea","MouseTargetFactory","_getMouseColumn","HitTestRequest","_ctx","targetPath","collect","Uint8Array","outerHTML","visibleColumnFromColumn","getLineContent","getTextModelOptions","tabSize","fulfillUnknown","fulfillTextarea","fulfillMargin","fulfillViewZone","fulfillContentText","fulfillContentEmpty","fulfillContentWidget","fulfillScrollbar","fulfillOverlayWidget","withTarget","EMPTY_CONTENT_AFTER_LINES","createEmptyContentDataInLines","horizontalDistanceToText","mouseTargetIsWidget","e","t","createMouseTarget","request","r","_createMouseTarget","err","domHitTestExecuted","hitTestResult","_doHitTest","createMouseTargetFromHitTestPosition","resolvedRequest","result","_hitTestContentWidget","_hitTestOverlayWidget","_hitTestMinimap","_hitTestScrollbarSlider","_hitTestViewZone","_hitTestMargin","_hitTestViewCursor","_hitTestTextArea","_hitTestViewLines","_hitTestScrollbar","widgetId","d","domNode","mightBeForeignElement","width","cursorVerticalOffset","viewZoneData","mouseTargetType","res","getStartPosition","abs","glyphMarginWidth","lineNumbersWidth","offsetX","getLineLength","lineWidth","possibleLineNumber","maxColumn","nodeType","className","test","getMouseColumn","chars","round","visibleRange","columnHorizontalOffset","left","points","push","lineMaxColumn","sort","a","b","mouseCoordinates","toClientCoordinates","spanNodeClientRect","getBoundingClientRect","mouseIsOverSpanNode","clientX","right","i","prev","curr","rng","_doHitTestWithCaretRangeFromPoint","lineVerticalOffset","lineCenteredVerticalOffset","floor","adjustedPageY","adjustedPage","_actualDoHitTestWithCaretRangeFromPoint","coords","shadowRoot","getShadowRoot","caretRangeFromPoint","shadowCaretRangeFromPoint","clientY","startContainer","TEXT_NODE","parent1","parent2","parent3","parent3ClassName","ELEMENT_NODE","CLASS_NAME","startOffset","parent2ClassName","textContent","_doHitTestWithCaretPositionFromPoint","hitResult","caretPositionFromPoint","offsetNode","parent1ClassName","tokenSpan","childNodes","min","_snapToSoftTabBoundary","viewModel","lineContent","newPosition","atomicPosition","getInjectedTextAt","normalizedPosition","normalizePosition","equals","createRange","el","elementFromPoint","firstChild","lastChild","rect","font","window","getComputedStyle","getPropertyValue","text","innerText","pixelCursor","step","charWidthReader","CharWidthReader","getInstance","getCharWidth","charAt","setStart","setEnd","_cache","_canvas","createElement","_INSTANCE","char","cacheKey","getContext","metrics","measureText"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/core/cursorColumns.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/cursor/cursorAtomicMoveOperations.js';\nclass UnknownHitTestResult {\n    constructor(hitTarget = null) {\n        this.hitTarget = hitTarget;\n        this.type = 0 /* Unknown */;\n    }\n}\nclass ContentHitTestResult {\n    constructor(position, spanNode, injectedText) {\n        this.position = position;\n        this.spanNode = spanNode;\n        this.injectedText = injectedText;\n        this.type = 1 /* Content */;\n    }\n}\nvar HitTestResult;\n(function (HitTestResult) {\n    function createFromDOMInfo(ctx, spanNode, offset) {\n        const position = ctx.getPositionFromDOMInfo(spanNode, offset);\n        if (position) {\n            return new ContentHitTestResult(position, spanNode, null);\n        }\n        return new UnknownHitTestResult(spanNode);\n    }\n    HitTestResult.createFromDOMInfo = createFromDOMInfo;\n})(HitTestResult || (HitTestResult = {}));\nexport class PointerHandlerLastRenderData {\n    constructor(lastViewCursorsRenderData, lastTextareaPosition) {\n        this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n        this.lastTextareaPosition = lastTextareaPosition;\n    }\n}\nexport class MouseTarget {\n    static _deduceRage(position, range = null) {\n        if (!range && position) {\n            return new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n        }\n        return range !== null && range !== void 0 ? range : null;\n    }\n    static createUnknown(element, mouseColumn, position) {\n        return { type: 0 /* UNKNOWN */, element, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static createTextarea(element, mouseColumn) {\n        return { type: 1 /* TEXTAREA */, element, mouseColumn, position: null, range: null };\n    }\n    static createMargin(type, element, mouseColumn, position, range, detail) {\n        return { type, element, mouseColumn, position, range, detail };\n    }\n    static createViewZone(type, element, mouseColumn, position, detail) {\n        return { type, element, mouseColumn, position, range: this._deduceRage(position), detail };\n    }\n    static createContentText(element, mouseColumn, position, range, detail) {\n        return { type: 6 /* CONTENT_TEXT */, element, mouseColumn, position, range: this._deduceRage(position, range), detail };\n    }\n    static createContentEmpty(element, mouseColumn, position, detail) {\n        return { type: 7 /* CONTENT_EMPTY */, element, mouseColumn, position, range: this._deduceRage(position), detail };\n    }\n    static createContentWidget(element, mouseColumn, detail) {\n        return { type: 9 /* CONTENT_WIDGET */, element, mouseColumn, position: null, range: null, detail };\n    }\n    static createScrollbar(element, mouseColumn, position) {\n        return { type: 11 /* SCROLLBAR */, element, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static createOverlayWidget(element, mouseColumn, detail) {\n        return { type: 12 /* OVERLAY_WIDGET */, element, mouseColumn, position: null, range: null, detail };\n    }\n    static createOutsideEditor(mouseColumn, position) {\n        return { type: 13 /* OUTSIDE_EDITOR */, element: null, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static _typeToString(type) {\n        if (type === 1 /* TEXTAREA */) {\n            return 'TEXTAREA';\n        }\n        if (type === 2 /* GUTTER_GLYPH_MARGIN */) {\n            return 'GUTTER_GLYPH_MARGIN';\n        }\n        if (type === 3 /* GUTTER_LINE_NUMBERS */) {\n            return 'GUTTER_LINE_NUMBERS';\n        }\n        if (type === 4 /* GUTTER_LINE_DECORATIONS */) {\n            return 'GUTTER_LINE_DECORATIONS';\n        }\n        if (type === 5 /* GUTTER_VIEW_ZONE */) {\n            return 'GUTTER_VIEW_ZONE';\n        }\n        if (type === 6 /* CONTENT_TEXT */) {\n            return 'CONTENT_TEXT';\n        }\n        if (type === 7 /* CONTENT_EMPTY */) {\n            return 'CONTENT_EMPTY';\n        }\n        if (type === 8 /* CONTENT_VIEW_ZONE */) {\n            return 'CONTENT_VIEW_ZONE';\n        }\n        if (type === 9 /* CONTENT_WIDGET */) {\n            return 'CONTENT_WIDGET';\n        }\n        if (type === 10 /* OVERVIEW_RULER */) {\n            return 'OVERVIEW_RULER';\n        }\n        if (type === 11 /* SCROLLBAR */) {\n            return 'SCROLLBAR';\n        }\n        if (type === 12 /* OVERLAY_WIDGET */) {\n            return 'OVERLAY_WIDGET';\n        }\n        return 'UNKNOWN';\n    }\n    static toString(target) {\n        return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + JSON.stringify(target.detail);\n    }\n}\nclass ElementPath {\n    static isTextArea(path) {\n        return (path.length === 2\n            && path[0] === 3 /* OverflowGuard */\n            && path[1] === 6 /* TextArea */);\n    }\n    static isChildOfViewLines(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* OverflowGuard */\n            && path[3] === 7 /* ViewLines */);\n    }\n    static isStrictChildOfViewLines(path) {\n        return (path.length > 4\n            && path[0] === 3 /* OverflowGuard */\n            && path[3] === 7 /* ViewLines */);\n    }\n    static isChildOfScrollableElement(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* OverflowGuard */\n            && path[1] === 5 /* ScrollableElement */);\n    }\n    static isChildOfMinimap(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* OverflowGuard */\n            && path[1] === 8 /* Minimap */);\n    }\n    static isChildOfContentWidgets(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* OverflowGuard */\n            && path[3] === 1 /* ContentWidgets */);\n    }\n    static isChildOfOverflowingContentWidgets(path) {\n        return (path.length >= 1\n            && path[0] === 2 /* OverflowingContentWidgets */);\n    }\n    static isChildOfOverlayWidgets(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* OverflowGuard */\n            && path[1] === 4 /* OverlayWidgets */);\n    }\n}\nexport class HitTestContext {\n    constructor(context, viewHelper, lastRenderData) {\n        this.model = context.model;\n        const options = context.configuration.options;\n        this.layoutInfo = options.get(131 /* layoutInfo */);\n        this.viewDomNode = viewHelper.viewDomNode;\n        this.lineHeight = options.get(59 /* lineHeight */);\n        this.stickyTabStops = options.get(104 /* stickyTabStops */);\n        this.typicalHalfwidthCharacterWidth = options.get(44 /* fontInfo */).typicalHalfwidthCharacterWidth;\n        this.lastRenderData = lastRenderData;\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    getZoneAtCoord(mouseVerticalOffset) {\n        return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n    }\n    static getZoneAtCoord(context, mouseVerticalOffset) {\n        // The target is either a view zone or the empty space after the last view-line\n        const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n        if (viewZoneWhitespace) {\n            const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n            const lineCount = context.model.getLineCount();\n            let positionBefore = null;\n            let position;\n            let positionAfter = null;\n            if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n                // There are more lines after this view zone\n                positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n            }\n            if (viewZoneWhitespace.afterLineNumber > 0) {\n                // There are more lines above this view zone\n                positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n            }\n            if (positionAfter === null) {\n                position = positionBefore;\n            }\n            else if (positionBefore === null) {\n                position = positionAfter;\n            }\n            else if (mouseVerticalOffset < viewZoneMiddle) {\n                position = positionBefore;\n            }\n            else {\n                position = positionAfter;\n            }\n            return {\n                viewZoneId: viewZoneWhitespace.id,\n                afterLineNumber: viewZoneWhitespace.afterLineNumber,\n                positionBefore: positionBefore,\n                positionAfter: positionAfter,\n                position: position\n            };\n        }\n        return null;\n    }\n    getFullLineRangeAtCoord(mouseVerticalOffset) {\n        if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n            // Below the last line\n            const lineNumber = this._context.model.getLineCount();\n            const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\n            return {\n                range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\n                isAfterLines: true\n            };\n        }\n        const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n        const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\n        return {\n            range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n            isAfterLines: false\n        };\n    }\n    getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n        return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n    }\n    isAfterLines(mouseVerticalOffset) {\n        return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n    }\n    isInTopPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n    }\n    isInBottomPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n    }\n    getVerticalOffsetForLineNumber(lineNumber) {\n        return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n    findAttribute(element, attr) {\n        return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n    }\n    static _findAttribute(element, attr, stopAt) {\n        while (element && element !== document.body) {\n            if (element.hasAttribute && element.hasAttribute(attr)) {\n                return element.getAttribute(attr);\n            }\n            if (element === stopAt) {\n                return null;\n            }\n            element = element.parentNode;\n        }\n        return null;\n    }\n    getLineWidth(lineNumber) {\n        return this._viewHelper.getLineWidth(lineNumber);\n    }\n    visibleRangeForPosition(lineNumber, column) {\n        return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n    }\n    getPositionFromDOMInfo(spanNode, offset) {\n        return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n    }\n    getCurrentScrollTop() {\n        return this._context.viewLayout.getCurrentScrollTop();\n    }\n    getCurrentScrollLeft() {\n        return this._context.viewLayout.getCurrentScrollLeft();\n    }\n}\nclass BareHitTestRequest {\n    constructor(ctx, editorPos, pos, relativePos) {\n        this.editorPos = editorPos;\n        this.pos = pos;\n        this.relativePos = relativePos;\n        this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + this.relativePos.y);\n        this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + this.relativePos.x - ctx.layoutInfo.contentLeft;\n        this.isInMarginArea = (this.relativePos.x < ctx.layoutInfo.contentLeft && this.relativePos.x >= ctx.layoutInfo.glyphMarginLeft);\n        this.isInContentArea = !this.isInMarginArea;\n        this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n    }\n}\nclass HitTestRequest extends BareHitTestRequest {\n    constructor(ctx, editorPos, pos, relativePos, target) {\n        super(ctx, editorPos, pos, relativePos);\n        this._ctx = ctx;\n        if (target) {\n            this.target = target;\n            this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);\n        }\n        else {\n            this.target = null;\n            this.targetPath = new Uint8Array(0);\n        }\n    }\n    toString() {\n        return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\\n\\ttarget: ${this.target ? this.target.outerHTML : null}`;\n    }\n    _getMouseColumn(position = null) {\n        if (position && position.column < this._ctx.model.getLineMaxColumn(position.lineNumber)) {\n            // Most likely, the line contains foreign decorations...\n            return CursorColumns.visibleColumnFromColumn(this._ctx.model.getLineContent(position.lineNumber), position.column, this._ctx.model.getTextModelOptions().tabSize) + 1;\n        }\n        return this.mouseColumn;\n    }\n    fulfillUnknown(position = null) {\n        return MouseTarget.createUnknown(this.target, this._getMouseColumn(position), position);\n    }\n    fulfillTextarea() {\n        return MouseTarget.createTextarea(this.target, this._getMouseColumn());\n    }\n    fulfillMargin(type, position, range, detail) {\n        return MouseTarget.createMargin(type, this.target, this._getMouseColumn(position), position, range, detail);\n    }\n    fulfillViewZone(type, position, detail) {\n        return MouseTarget.createViewZone(type, this.target, this._getMouseColumn(position), position, detail);\n    }\n    fulfillContentText(position, range, detail) {\n        return MouseTarget.createContentText(this.target, this._getMouseColumn(position), position, range, detail);\n    }\n    fulfillContentEmpty(position, detail) {\n        return MouseTarget.createContentEmpty(this.target, this._getMouseColumn(position), position, detail);\n    }\n    fulfillContentWidget(detail) {\n        return MouseTarget.createContentWidget(this.target, this._getMouseColumn(), detail);\n    }\n    fulfillScrollbar(position) {\n        return MouseTarget.createScrollbar(this.target, this._getMouseColumn(position), position);\n    }\n    fulfillOverlayWidget(detail) {\n        return MouseTarget.createOverlayWidget(this.target, this._getMouseColumn(), detail);\n    }\n    withTarget(target) {\n        return new HitTestRequest(this._ctx, this.editorPos, this.pos, this.relativePos, target);\n    }\n}\nconst EMPTY_CONTENT_AFTER_LINES = { isAfterLines: true };\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n    return {\n        isAfterLines: false,\n        horizontalDistanceToText: horizontalDistanceToText\n    };\n}\nexport class MouseTargetFactory {\n    constructor(context, viewHelper) {\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    mouseTargetIsWidget(e) {\n        const t = e.target;\n        const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n            return true;\n        }\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(path)) {\n            return true;\n        }\n        return false;\n    }\n    createMouseTarget(lastRenderData, editorPos, pos, relativePos, target) {\n        const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n        const request = new HitTestRequest(ctx, editorPos, pos, relativePos, target);\n        try {\n            const r = MouseTargetFactory._createMouseTarget(ctx, request, false);\n            // console.log(MouseTarget.toString(r));\n            return r;\n        }\n        catch (err) {\n            // console.log(err);\n            return request.fulfillUnknown();\n        }\n    }\n    static _createMouseTarget(ctx, request, domHitTestExecuted) {\n        // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n        // First ensure the request has a target\n        if (request.target === null) {\n            if (domHitTestExecuted) {\n                // Still no target... and we have already executed hit test...\n                return request.fulfillUnknown();\n            }\n            const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n            if (hitTestResult.type === 1 /* Content */) {\n                return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n            }\n            return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n        }\n        // we know for a fact that request.target is not null\n        const resolvedRequest = request;\n        let result = null;\n        result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest, domHitTestExecuted);\n        result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n        return (result || request.fulfillUnknown());\n    }\n    static _hitTestContentWidget(ctx, request) {\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfillContentWidget(widgetId);\n            }\n            else {\n                return request.fulfillUnknown();\n            }\n        }\n        return null;\n    }\n    static _hitTestOverlayWidget(ctx, request) {\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfillOverlayWidget(widgetId);\n            }\n            else {\n                return request.fulfillUnknown();\n            }\n        }\n        return null;\n    }\n    static _hitTestViewCursor(ctx, request) {\n        if (request.target) {\n            // Check if we've hit a painted cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            for (const d of lastViewCursorsRenderData) {\n                if (request.target === d.domNode) {\n                    return request.fulfillContentText(d.position, null, { mightBeForeignElement: false, injectedText: null });\n                }\n            }\n        }\n        if (request.isInContentArea) {\n            // Edge has a bug when hit-testing the exact position of a cursor,\n            // instead of returning the correct dom node, it returns the\n            // first or last rendered view line dom node, therefore help it out\n            // and first check if we are on top of a cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n            const mouseVerticalOffset = request.mouseVerticalOffset;\n            for (const d of lastViewCursorsRenderData) {\n                if (mouseContentHorizontalOffset < d.contentLeft) {\n                    // mouse position is to the left of the cursor\n                    continue;\n                }\n                if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\n                    // mouse position is to the right of the cursor\n                    continue;\n                }\n                const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\n                if (cursorVerticalOffset <= mouseVerticalOffset\n                    && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\n                    return request.fulfillContentText(d.position, null, { mightBeForeignElement: false, injectedText: null });\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestViewZone(ctx, request) {\n        const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n        if (viewZoneData) {\n            const mouseTargetType = (request.isInContentArea ? 8 /* CONTENT_VIEW_ZONE */ : 5 /* GUTTER_VIEW_ZONE */);\n            return request.fulfillViewZone(mouseTargetType, viewZoneData.position, viewZoneData);\n        }\n        return null;\n    }\n    static _hitTestTextArea(ctx, request) {\n        // Is it the textarea?\n        if (ElementPath.isTextArea(request.targetPath)) {\n            if (ctx.lastRenderData.lastTextareaPosition) {\n                return request.fulfillContentText(ctx.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: false, injectedText: null });\n            }\n            return request.fulfillTextarea();\n        }\n        return null;\n    }\n    static _hitTestMargin(ctx, request) {\n        if (request.isInMarginArea) {\n            const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n            const pos = res.range.getStartPosition();\n            let offset = Math.abs(request.relativePos.x);\n            const detail = {\n                isAfterLines: res.isAfterLines,\n                glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n                glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n                lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n                offsetX: offset\n            };\n            offset -= ctx.layoutInfo.glyphMarginLeft;\n            if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n                // On the glyph margin\n                return request.fulfillMargin(2 /* GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.glyphMarginWidth;\n            if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n                // On the line numbers\n                return request.fulfillMargin(3 /* GUTTER_LINE_NUMBERS */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.lineNumbersWidth;\n            // On the line decorations\n            return request.fulfillMargin(4 /* GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\n        }\n        return null;\n    }\n    static _hitTestViewLines(ctx, request, domHitTestExecuted) {\n        if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n            return null;\n        }\n        if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n            return request.fulfillContentEmpty(new Position(1, 1), EMPTY_CONTENT_AFTER_LINES);\n        }\n        // Check if it is below any lines and any view zones\n        if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n            // This most likely indicates it happened after the last view-line\n            const lineCount = ctx.model.getLineCount();\n            const maxLineColumn = ctx.model.getLineMaxColumn(lineCount);\n            return request.fulfillContentEmpty(new Position(lineCount, maxLineColumn), EMPTY_CONTENT_AFTER_LINES);\n        }\n        if (domHitTestExecuted) {\n            // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n            // See https://github.com/microsoft/vscode/issues/46942\n            if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n                const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n                if (ctx.model.getLineLength(lineNumber) === 0) {\n                    const lineWidth = ctx.getLineWidth(lineNumber);\n                    const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                    return request.fulfillContentEmpty(new Position(lineNumber, 1), detail);\n                }\n                const lineWidth = ctx.getLineWidth(lineNumber);\n                if (request.mouseContentHorizontalOffset >= lineWidth) {\n                    const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                    const pos = new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber));\n                    return request.fulfillContentEmpty(pos, detail);\n                }\n            }\n            // We have already executed hit test...\n            return request.fulfillUnknown();\n        }\n        const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n        if (hitTestResult.type === 1 /* Content */) {\n            return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n        }\n        return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n    }\n    static _hitTestMinimap(ctx, request) {\n        if (ElementPath.isChildOfMinimap(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    static _hitTestScrollbarSlider(ctx, request) {\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            if (request.target && request.target.nodeType === 1) {\n                const className = request.target.className;\n                if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n                    const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n                    const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n                    return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestScrollbar(ctx, request) {\n        // Is it the overview ruler?\n        // Is it a child of the scrollable element?\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    getMouseColumn(relativePos) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(131 /* layoutInfo */);\n        const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + relativePos.x - layoutInfo.contentLeft;\n        return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(44 /* fontInfo */).typicalHalfwidthCharacterWidth);\n    }\n    static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n        if (mouseContentHorizontalOffset < 0) {\n            return 1;\n        }\n        const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n        return (chars + 1);\n    }\n    static createMouseTargetFromHitTestPosition(ctx, request, spanNode, pos, injectedText) {\n        const lineNumber = pos.lineNumber;\n        const column = pos.column;\n        const lineWidth = ctx.getLineWidth(lineNumber);\n        if (request.mouseContentHorizontalOffset > lineWidth) {\n            const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n            return request.fulfillContentEmpty(pos, detail);\n        }\n        const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n        if (!visibleRange) {\n            return request.fulfillUnknown(pos);\n        }\n        const columnHorizontalOffset = visibleRange.left;\n        if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {\n            return request.fulfillContentText(pos, null, { mightBeForeignElement: !!injectedText, injectedText });\n        }\n        const points = [];\n        points.push({ offset: visibleRange.left, column: column });\n        if (column > 1) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column - 1 });\n            }\n        }\n        const lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);\n        if (column < lineMaxColumn) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column + 1 });\n            }\n        }\n        points.sort((a, b) => a.offset - b.offset);\n        const mouseCoordinates = request.pos.toClientCoordinates();\n        const spanNodeClientRect = spanNode.getBoundingClientRect();\n        const mouseIsOverSpanNode = (spanNodeClientRect.left <= mouseCoordinates.clientX && mouseCoordinates.clientX <= spanNodeClientRect.right);\n        for (let i = 1; i < points.length; i++) {\n            const prev = points[i - 1];\n            const curr = points[i];\n            if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n                const rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n                return request.fulfillContentText(pos, rng, { mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText, injectedText });\n            }\n        }\n        return request.fulfillContentText(pos, null, { mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText, injectedText });\n    }\n    /**\n     * Most probably WebKit browsers and Edge\n     */\n    static _doHitTestWithCaretRangeFromPoint(ctx, request) {\n        // In Chrome, especially on Linux it is possible to click between lines,\n        // so try to adjust the `hity` below so that it lands in the center of a line\n        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        const lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n        const lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);\n        let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n        if (adjustedPageY <= request.editorPos.y) {\n            adjustedPageY = request.editorPos.y + 1;\n        }\n        if (adjustedPageY >= request.editorPos.y + request.editorPos.height) {\n            adjustedPageY = request.editorPos.y + request.editorPos.height - 1;\n        }\n        const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n        const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());\n        if (r.type === 1 /* Content */) {\n            return r;\n        }\n        // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n        return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());\n    }\n    static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n        const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n        let range;\n        if (shadowRoot) {\n            if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n                range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n            }\n            else {\n                range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n            }\n        }\n        else {\n            range = document.caretRangeFromPoint(coords.clientX, coords.clientY);\n        }\n        if (!range || !range.startContainer) {\n            return new UnknownHitTestResult();\n        }\n        // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n        const startContainer = range.startContainer;\n        if (startContainer.nodeType === startContainer.TEXT_NODE) {\n            // startContainer is expected to be the token text\n            const parent1 = startContainer.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, parent1, range.startOffset);\n            }\n            else {\n                return new UnknownHitTestResult(startContainer.parentNode);\n            }\n        }\n        else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n            // startContainer is expected to be the token span\n            const parent1 = startContainer.parentNode; // expected to be the view line container span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent2ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, startContainer, startContainer.textContent.length);\n            }\n            else {\n                return new UnknownHitTestResult(startContainer);\n            }\n        }\n        return new UnknownHitTestResult();\n    }\n    /**\n     * Most probably Gecko\n     */\n    static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n        const hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n            // offsetNode is expected to be the token text\n            const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode.parentNode, hitResult.offset);\n            }\n            else {\n                return new UnknownHitTestResult(hitResult.offsetNode.parentNode);\n            }\n        }\n        // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n        // Some other times, it returns the `<span>` with the inline decoration\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n            const parent1 = hitResult.offsetNode.parentNode;\n            const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\n            const parent2 = parent1 ? parent1.parentNode : null;\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent1ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n                const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n                if (tokenSpan) {\n                    return HitTestResult.createFromDOMInfo(ctx, tokenSpan, 0);\n                }\n            }\n            else if (parent2ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` with the inline decoration\n                return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode, 0);\n            }\n        }\n        return new UnknownHitTestResult(hitResult.offsetNode);\n    }\n    static _snapToSoftTabBoundary(position, viewModel) {\n        const lineContent = viewModel.getLineContent(position.lineNumber);\n        const { tabSize } = viewModel.getTextModelOptions();\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Nearest */);\n        if (newPosition !== -1) {\n            return new Position(position.lineNumber, newPosition + 1);\n        }\n        return position;\n    }\n    static _doHitTest(ctx, request) {\n        let result = new UnknownHitTestResult();\n        if (typeof document.caretRangeFromPoint === 'function') {\n            result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n        }\n        else if (document.caretPositionFromPoint) {\n            result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());\n        }\n        if (result.type === 1 /* Content */) {\n            const injectedText = ctx.model.getInjectedTextAt(result.position);\n            const normalizedPosition = ctx.model.normalizePosition(result.position, 2 /* None */);\n            if (injectedText || !normalizedPosition.equals(result.position)) {\n                result = new ContentHitTestResult(normalizedPosition, result.spanNode, injectedText);\n            }\n        }\n        // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n        if (result.type === 1 /* Content */ && ctx.stickyTabStops) {\n            result = new ContentHitTestResult(this._snapToSoftTabBoundary(result.position, ctx.model), result.spanNode, result.injectedText);\n        }\n        return result;\n    }\n}\nexport function shadowCaretRangeFromPoint(shadowRoot, x, y) {\n    const range = document.createRange();\n    // Get the element under the point\n    let el = shadowRoot.elementFromPoint(x, y);\n    if (el !== null) {\n        // Get the last child of the element until its firstChild is a text node\n        // This assumes that the pointer is on the right of the line, out of the tokens\n        // and that we want to get the offset of the last token of the line\n        while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n            el = el.lastChild;\n        }\n        // Grab its rect\n        const rect = el.getBoundingClientRect();\n        // And its font\n        const font = window.getComputedStyle(el, null).getPropertyValue('font');\n        // And also its txt content\n        const text = el.innerText;\n        // Position the pixel cursor at the left of the element\n        let pixelCursor = rect.left;\n        let offset = 0;\n        let step;\n        // If the point is on the right of the box put the cursor after the last character\n        if (x > rect.left + rect.width) {\n            offset = text.length;\n        }\n        else {\n            const charWidthReader = CharWidthReader.getInstance();\n            // Goes through all the characters of the innerText, and checks if the x of the point\n            // belongs to the character.\n            for (let i = 0; i < text.length + 1; i++) {\n                // The step is half the width of the character\n                step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\n                // Move to the center of the character\n                pixelCursor += step;\n                // If the x of the point is smaller that the position of the cursor, the point is over that character\n                if (x < pixelCursor) {\n                    offset = i;\n                    break;\n                }\n                // Move between the current character and the next\n                pixelCursor += step;\n            }\n        }\n        // Creates a range with the text node of the element and set the offset found\n        range.setStart(el.firstChild, offset);\n        range.setEnd(el.firstChild, offset);\n    }\n    return range;\n}\nclass CharWidthReader {\n    constructor() {\n        this._cache = {};\n        this._canvas = document.createElement('canvas');\n    }\n    static getInstance() {\n        if (!CharWidthReader._INSTANCE) {\n            CharWidthReader._INSTANCE = new CharWidthReader();\n        }\n        return CharWidthReader._INSTANCE;\n    }\n    getCharWidth(char, font) {\n        const cacheKey = char + font;\n        if (this._cache[cacheKey]) {\n            return this._cache[cacheKey];\n        }\n        const context = this._canvas.getContext('2d');\n        context.font = font;\n        const metrics = context.measureText(char);\n        const width = metrics.width;\n        this._cache[cacheKey] = width;\n        return width;\n    }\n}\nCharWidthReader._INSTANCE = null;\n"]},"metadata":{},"sourceType":"module"}