{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\n\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\n\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount) {\n  switch (starCount) {\n    case 0:\n      return '';\n\n    case 1:\n      return `${NO_PATH_REGEX}*?`;\n    // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\n    default:\n      // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n      // Group is non capturing because we don't need to capture at all (?:...)\n      // Overall we use non-greedy matching because it could be that we match too much\n      return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n  }\n}\n\nexport function splitGlobAware(pattern, splitChar) {\n  if (!pattern) {\n    return [];\n  }\n\n  const segments = [];\n  let inBraces = false;\n  let inBrackets = false;\n  let curVal = '';\n\n  for (const char of pattern) {\n    switch (char) {\n      case splitChar:\n        if (!inBraces && !inBrackets) {\n          segments.push(curVal);\n          curVal = '';\n          continue;\n        }\n\n        break;\n\n      case '{':\n        inBraces = true;\n        break;\n\n      case '}':\n        inBraces = false;\n        break;\n\n      case '[':\n        inBrackets = true;\n        break;\n\n      case ']':\n        inBrackets = false;\n        break;\n    }\n\n    curVal += char;\n  } // Tail\n\n\n  if (curVal) {\n    segments.push(curVal);\n  }\n\n  return segments;\n}\n\nfunction parseRegExp(pattern) {\n  if (!pattern) {\n    return '';\n  }\n\n  let regEx = ''; // Split up into segments for each slash found\n\n  const segments = splitGlobAware(pattern, GLOB_SPLIT); // Special case where we only have globstars\n\n  if (segments.every(s => s === GLOBSTAR)) {\n    regEx = '.*';\n  } // Build regex over segments\n  else {\n    let previousSegmentWasGlobStar = false;\n    segments.forEach((segment, index) => {\n      // Globstar is special\n      if (segment === GLOBSTAR) {\n        // if we have more than one globstar after another, just ignore it\n        if (!previousSegmentWasGlobStar) {\n          regEx += starsToRegExp(2);\n          previousSegmentWasGlobStar = true;\n        }\n\n        return;\n      } // States\n\n\n      let inBraces = false;\n      let braceVal = '';\n      let inBrackets = false;\n      let bracketVal = '';\n\n      for (const char of segment) {\n        // Support brace expansion\n        if (char !== '}' && inBraces) {\n          braceVal += char;\n          continue;\n        } // Support brackets\n\n\n        if (inBrackets && (char !== ']' || !bracketVal)\n        /* ] is literally only allowed as first character in brackets to match it */\n        ) {\n          let res; // range operator\n\n          if (char === '-') {\n            res = char;\n          } // negation operator (only valid on first index in bracket)\n          else if ((char === '^' || char === '!') && !bracketVal) {\n            res = '^';\n          } // glob split matching is not allowed within character ranges\n          // see http://man7.org/linux/man-pages/man7/glob.7.html\n          else if (char === GLOB_SPLIT) {\n            res = '';\n          } // anything else gets escaped\n          else {\n            res = escapeRegExpCharacters(char);\n          }\n\n          bracketVal += res;\n          continue;\n        }\n\n        switch (char) {\n          case '{':\n            inBraces = true;\n            continue;\n\n          case '[':\n            inBrackets = true;\n            continue;\n\n          case '}':\n            {\n              const choices = splitGlobAware(braceVal, ','); // Converts {foo,bar} => [foo|bar]\n\n              const braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n              regEx += braceRegExp;\n              inBraces = false;\n              braceVal = '';\n              break;\n            }\n\n          case ']':\n            regEx += '[' + bracketVal + ']';\n            inBrackets = false;\n            bracketVal = '';\n            break;\n\n          case '?':\n            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\n            continue;\n\n          case '*':\n            regEx += starsToRegExp(1);\n            continue;\n\n          default:\n            regEx += escapeRegExpCharacters(char);\n        }\n      } // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n      // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n      // a folder called \"something\" to match as well.\n      // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n      // is to match 0-N segments.\n\n\n      if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n        regEx += PATH_REGEX;\n      } // reset state\n\n\n      previousSegmentWasGlobStar = false;\n    });\n  }\n\n  return regEx;\n} // regexes to check for trivial glob patterns that just check for String#endsWith\n\n\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\n\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\n\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\n\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\n\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\n\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\n\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n  return false;\n};\n\nconst NULL = function () {\n  return null;\n};\n\nfunction parsePattern(arg1, options) {\n  if (!arg1) {\n    return NULL;\n  } // Handle IRelativePattern\n\n\n  let pattern;\n\n  if (typeof arg1 !== 'string') {\n    pattern = arg1.pattern;\n  } else {\n    pattern = arg1;\n  } // Whitespace trimming\n\n\n  pattern = pattern.trim(); // Check cache\n\n  const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n  let parsedPattern = CACHE.get(patternKey);\n\n  if (parsedPattern) {\n    return wrapRelativePattern(parsedPattern, arg1);\n  } // Check for Trivials\n\n\n  let match;\n\n  if (T1.test(pattern)) {\n    // common pattern: **/*.txt just need endsWith check\n    const base = pattern.substr(4); // '**/*'.length === 4\n\n    parsedPattern = function (path, basename) {\n      return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n  } else if (match = T2.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/some.txt just need basename check\n    parsedPattern = trivia2(match[1], pattern);\n  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n    // repetition of common patterns (see above) {**/*.txt,**/*.png}\n    parsedPattern = trivia3(pattern, options);\n  } else if (match = T4.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/something/else just need endsWith check\n    parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n  } else if (match = T5.exec(trimForExclusions(pattern, options))) {\n    // common pattern: something/else just need equals check\n    parsedPattern = trivia4and5(match[1], pattern, false);\n  } // Otherwise convert to pattern\n  else {\n    parsedPattern = toRegExp(pattern);\n  } // Cache\n\n\n  CACHE.set(patternKey, parsedPattern);\n  return wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern, arg2) {\n  if (typeof arg2 === 'string') {\n    return parsedPattern;\n  }\n\n  return function (path, basename) {\n    if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n      // skip glob matching if `base` is not a parent of `path`\n      return null;\n    } // Given we have checked `base` being a parent of `path`,\n    // we can now remove the `base` portion of the `path`\n    // and only match on the remaining path components\n\n\n    return parsedPattern(path.substr(arg2.base.length + 1), basename);\n  };\n}\n\nfunction trimForExclusions(pattern, options) {\n  return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n} // common pattern: **/some.txt just need basename check\n\n\nfunction trivia2(base, originalPattern) {\n  const slashBase = `/${base}`;\n  const backslashBase = `\\\\${base}`;\n\n  const parsedPattern = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n\n    if (basename) {\n      return basename === base ? originalPattern : null;\n    }\n\n    return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n  };\n\n  const basenames = [base];\n  parsedPattern.basenames = basenames;\n  parsedPattern.patterns = [originalPattern];\n  parsedPattern.allBasenames = basenames;\n  return parsedPattern;\n} // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\n\nfunction trivia3(pattern, options) {\n  const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',').map(pattern => parsePattern(pattern, options)).filter(pattern => pattern !== NULL), pattern);\n  const n = parsedPatterns.length;\n\n  if (!n) {\n    return NULL;\n  }\n\n  if (n === 1) {\n    return parsedPatterns[0];\n  }\n\n  const parsedPattern = function (path, basename) {\n    for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n      if (parsedPatterns[i](path, basename)) {\n        return pattern;\n      }\n    }\n\n    return null;\n  };\n\n  const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\n  if (withBasenames) {\n    parsedPattern.allBasenames = withBasenames.allBasenames;\n  }\n\n  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n\n  if (allPaths.length) {\n    parsedPattern.allPaths = allPaths;\n  }\n\n  return parsedPattern;\n} // common patterns: **/something/else just need endsWith check, something/else just needs and equals check\n\n\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n  const usingPosixSep = sep === posix.sep;\n  const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n  const nativePathEnd = sep + nativePath;\n  const targetPathEnd = posix.sep + targetPath;\n  const parsedPattern = matchPathEnds ? function (testPath, basename) {\n    return typeof testPath === 'string' && (testPath === nativePath || testPath.endsWith(nativePathEnd) || !usingPosixSep && (testPath === targetPath || testPath.endsWith(targetPathEnd))) ? pattern : null;\n  } : function (testPath, basename) {\n    return typeof testPath === 'string' && (testPath === nativePath || !usingPosixSep && testPath === targetPath) ? pattern : null;\n  };\n  parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n  return parsedPattern;\n}\n\nfunction toRegExp(pattern) {\n  try {\n    const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n    return function (path) {\n      regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n      return typeof path === 'string' && regExp.test(path) ? pattern : null;\n    };\n  } catch (error) {\n    return NULL;\n  }\n}\n\nexport function match(arg1, path, hasSibling) {\n  if (!arg1 || typeof path !== 'string') {\n    return false;\n  }\n\n  return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n  if (!arg1) {\n    return FALSE;\n  } // Glob with String\n\n\n  if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n    const parsedPattern = parsePattern(arg1, options);\n\n    if (parsedPattern === NULL) {\n      return FALSE;\n    }\n\n    const resultPattern = function (path, basename) {\n      return !!parsedPattern(path, basename);\n    };\n\n    if (parsedPattern.allBasenames) {\n      resultPattern.allBasenames = parsedPattern.allBasenames;\n    }\n\n    if (parsedPattern.allPaths) {\n      resultPattern.allPaths = parsedPattern.allPaths;\n    }\n\n    return resultPattern;\n  } // Glob with Expression\n\n\n  return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n  const rp = obj;\n\n  if (!rp) {\n    return false;\n  }\n\n  return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nfunction parsedExpression(expression, options) {\n  const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map(pattern => parseExpressionPattern(pattern, expression[pattern], options)).filter(pattern => pattern !== NULL));\n  const n = parsedPatterns.length;\n\n  if (!n) {\n    return NULL;\n  }\n\n  if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n    if (n === 1) {\n      return parsedPatterns[0];\n    }\n\n    const resultExpression = function (path, basename) {\n      for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n        // Pattern matches path\n        const result = parsedPatterns[i](path, basename);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      return null;\n    };\n\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\n    if (withBasenames) {\n      resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n\n    if (allPaths.length) {\n      resultExpression.allPaths = allPaths;\n    }\n\n    return resultExpression;\n  }\n\n  const resultExpression = function (path, base, hasSibling) {\n    let name = undefined;\n\n    for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n      // Pattern matches path\n      const parsedPattern = parsedPatterns[i];\n\n      if (parsedPattern.requiresSiblings && hasSibling) {\n        if (!base) {\n          base = basename(path);\n        }\n\n        if (!name) {\n          name = base.substr(0, base.length - extname(path).length);\n        }\n      }\n\n      const result = parsedPattern(path, base, name, hasSibling);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n\n  const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\n  if (withBasenames) {\n    resultExpression.allBasenames = withBasenames.allBasenames;\n  }\n\n  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n\n  if (allPaths.length) {\n    resultExpression.allPaths = allPaths;\n  }\n\n  return resultExpression;\n}\n\nfunction parseExpressionPattern(pattern, value, options) {\n  if (value === false) {\n    return NULL; // pattern is disabled\n  }\n\n  const parsedPattern = parsePattern(pattern, options);\n\n  if (parsedPattern === NULL) {\n    return NULL;\n  } // Expression Pattern is <boolean>\n\n\n  if (typeof value === 'boolean') {\n    return parsedPattern;\n  } // Expression Pattern is <SiblingClause>\n\n\n  if (value) {\n    const when = value.when;\n\n    if (typeof when === 'string') {\n      const result = (path, basename, name, hasSibling) => {\n        if (!hasSibling || !parsedPattern(path, basename)) {\n          return null;\n        }\n\n        const clausePattern = when.replace('$(basename)', name);\n        const matched = hasSibling(clausePattern);\n        return isThenable(matched) ? matched.then(m => m ? pattern : null) : matched ? pattern : null;\n      };\n\n      result.requiresSiblings = true;\n      return result;\n    }\n  } // Expression is Anything\n\n\n  return parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n  const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n\n  if (basenamePatterns.length < 2) {\n    return parsedPatterns;\n  }\n\n  const basenames = basenamePatterns.reduce((all, current) => {\n    const basenames = current.basenames;\n    return basenames ? all.concat(basenames) : all;\n  }, []);\n  let patterns;\n\n  if (result) {\n    patterns = [];\n\n    for (let i = 0, n = basenames.length; i < n; i++) {\n      patterns.push(result);\n    }\n  } else {\n    patterns = basenamePatterns.reduce((all, current) => {\n      const patterns = current.patterns;\n      return patterns ? all.concat(patterns) : all;\n    }, []);\n  }\n\n  const aggregate = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n\n    if (!basename) {\n      let i;\n\n      for (i = path.length; i > 0; i--) {\n        const ch = path.charCodeAt(i - 1);\n\n        if (ch === 47\n        /* Slash */\n        || ch === 92\n        /* Backslash */\n        ) {\n          break;\n        }\n      }\n\n      basename = path.substr(i);\n    }\n\n    const index = basenames.indexOf(basename);\n    return index !== -1 ? patterns[index] : null;\n  };\n\n  aggregate.basenames = basenames;\n  aggregate.patterns = patterns;\n  aggregate.allBasenames = basenames;\n  const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n  aggregatedPatterns.push(aggregate);\n  return aggregatedPatterns;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/glob.js"],"names":["isThenable","isEqualOrParent","LRUCache","basename","extname","posix","sep","isLinux","escapeRegExpCharacters","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","push","parseRegExp","regEx","every","s","previousSegmentWasGlobStar","forEach","segment","index","braceVal","bracketVal","res","choices","braceRegExp","map","c","join","length","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","parsedPattern","get","wrapRelativePattern","match","test","base","substr","path","endsWith","exec","trivia2","trivia3","trivia4and5","toRegExp","set","arg2","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","parsedPatterns","aggregateBasenameMatches","slice","split","filter","n","i","withBasenames","find","allPaths","reduce","all","current","concat","targetPath","matchPathEnds","usingPosixSep","nativePath","replace","nativePathEnd","targetPathEnd","testPath","regExp","RegExp","lastIndex","error","hasSibling","parse","undefined","isRelativePattern","resultPattern","parsedExpression","obj","rp","expression","Object","getOwnPropertyNames","parseExpressionPattern","some","requiresSiblings","resultExpression","result","name","value","when","clausePattern","matched","then","m","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(s => s === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Globstar is special\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (!previousSegmentWasGlobStar) {\n                    regEx += starsToRegExp(2);\n                    previousSegmentWasGlobStar = true;\n                }\n                return;\n            }\n            // States\n            let inBraces = false;\n            let braceVal = '';\n            let inBrackets = false;\n            let bracketVal = '';\n            for (const char of segment) {\n                // Support brace expansion\n                if (char !== '}' && inBraces) {\n                    braceVal += char;\n                    continue;\n                }\n                // Support brackets\n                if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                    let res;\n                    // range operator\n                    if (char === '-') {\n                        res = char;\n                    }\n                    // negation operator (only valid on first index in bracket)\n                    else if ((char === '^' || char === '!') && !bracketVal) {\n                        res = '^';\n                    }\n                    // glob split matching is not allowed within character ranges\n                    // see http://man7.org/linux/man-pages/man7/glob.7.html\n                    else if (char === GLOB_SPLIT) {\n                        res = '';\n                    }\n                    // anything else gets escaped\n                    else {\n                        res = escapeRegExpCharacters(char);\n                    }\n                    bracketVal += res;\n                    continue;\n                }\n                switch (char) {\n                    case '{':\n                        inBraces = true;\n                        continue;\n                    case '[':\n                        inBrackets = true;\n                        continue;\n                    case '}': {\n                        const choices = splitGlobAware(braceVal, ',');\n                        // Converts {foo,bar} => [foo|bar]\n                        const braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\n                        regEx += braceRegExp;\n                        inBraces = false;\n                        braceVal = '';\n                        break;\n                    }\n                    case ']':\n                        regEx += ('[' + bracketVal + ']');\n                        inBrackets = false;\n                        bracketVal = '';\n                        break;\n                    case '?':\n                        regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                        continue;\n                    case '*':\n                        regEx += starsToRegExp(1);\n                        continue;\n                    default:\n                        regEx += escapeRegExpCharacters(char);\n                }\n            }\n            // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n            // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n            // a folder called \"something\" to match as well.\n            // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n            // is to match 0-N segments.\n            if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n                regEx += PATH_REGEX;\n            }\n            // reset state\n            previousSegmentWasGlobStar = false;\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle IRelativePattern\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\n        const base = pattern.substr(4); // '**/*'.length === 4\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n        };\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    return function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            // skip glob matching if `base` is not a parent of `path`\n            return null;\n        }\n        // Given we have checked `base` being a parent of `path`,\n        // we can now remove the `base` portion of the `path`\n        // and only match on the remaining path components\n        return parsedPattern(path.substr(arg2.base.length + 1), basename);\n    };\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, originalPattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? originalPattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [originalPattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const n = parsedPatterns.length;\n    if (!n) {\n        return NULL;\n    }\n    if (n === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    const parsedPattern = matchPathEnds ? function (testPath, basename) {\n        return typeof testPath === 'string' &&\n            ((testPath === nativePath || testPath.endsWith(nativePathEnd))\n                || !usingPosixSep && (testPath === targetPath || testPath.endsWith(targetPathEnd)))\n            ? pattern : null;\n    } : function (testPath, basename) {\n        return typeof testPath === 'string' &&\n            (testPath === nativePath\n                || (!usingPosixSep && testPath === targetPath))\n            ? pattern : null;\n    };\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const n = parsedPatterns.length;\n    if (!n) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (n === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                // Pattern matches path\n                const result = parsedPatterns[i](path, basename);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(m => m ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is Anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n"]},"metadata":{},"sourceType":"module"}