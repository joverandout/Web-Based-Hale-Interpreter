{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\n\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nexport class RenderedLinesCollection {\n  constructor(createLine) {\n    this._createLine = createLine;\n\n    this._set(1, []);\n  }\n\n  flush() {\n    this._set(1, []);\n  }\n\n  _set(rendLineNumberStart, lines) {\n    this._lines = lines;\n    this._rendLineNumberStart = rendLineNumberStart;\n  }\n\n  _get() {\n    return {\n      rendLineNumberStart: this._rendLineNumberStart,\n      lines: this._lines\n    };\n  }\n  /**\n   * @returns Inclusive line number that is inside this collection\n   */\n\n\n  getStartLineNumber() {\n    return this._rendLineNumberStart;\n  }\n  /**\n   * @returns Inclusive line number that is inside this collection\n   */\n\n\n  getEndLineNumber() {\n    return this._rendLineNumberStart + this._lines.length - 1;\n  }\n\n  getCount() {\n    return this._lines.length;\n  }\n\n  getLine(lineNumber) {\n    const lineIndex = lineNumber - this._rendLineNumberStart;\n\n    if (lineIndex < 0 || lineIndex >= this._lines.length) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._lines[lineIndex];\n  }\n  /**\n   * @returns Lines that were removed from this collection\n   */\n\n\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    if (this.getCount() === 0) {\n      // no lines\n      return null;\n    }\n\n    const startLineNumber = this.getStartLineNumber();\n    const endLineNumber = this.getEndLineNumber();\n\n    if (deleteToLineNumber < startLineNumber) {\n      // deleting above the viewport\n      const deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;\n      this._rendLineNumberStart -= deleteCnt;\n      return null;\n    }\n\n    if (deleteFromLineNumber > endLineNumber) {\n      // deleted below the viewport\n      return null;\n    } // Record what needs to be deleted\n\n\n    let deleteStartIndex = 0;\n    let deleteCount = 0;\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineIndex = lineNumber - this._rendLineNumberStart;\n\n      if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {\n        // this is a line to be deleted\n        if (deleteCount === 0) {\n          // this is the first line to be deleted\n          deleteStartIndex = lineIndex;\n          deleteCount = 1;\n        } else {\n          deleteCount++;\n        }\n      }\n    } // Adjust this._rendLineNumberStart for lines deleted above\n\n\n    if (deleteFromLineNumber < startLineNumber) {\n      // Something was deleted above\n      let deleteAboveCount = 0;\n\n      if (deleteToLineNumber < startLineNumber) {\n        // the entire deleted lines are above\n        deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;\n      } else {\n        deleteAboveCount = startLineNumber - deleteFromLineNumber;\n      }\n\n      this._rendLineNumberStart -= deleteAboveCount;\n    }\n\n    const deleted = this._lines.splice(deleteStartIndex, deleteCount);\n\n    return deleted;\n  }\n\n  onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n    if (this.getCount() === 0) {\n      // no lines\n      return false;\n    }\n\n    const startLineNumber = this.getStartLineNumber();\n    const endLineNumber = this.getEndLineNumber();\n    let someoneNotified = false;\n\n    for (let changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {\n      if (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {\n        // Notify the line\n        this._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();\n\n        someoneNotified = true;\n      }\n    }\n\n    return someoneNotified;\n  }\n\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    if (this.getCount() === 0) {\n      // no lines\n      return null;\n    }\n\n    const insertCnt = insertToLineNumber - insertFromLineNumber + 1;\n    const startLineNumber = this.getStartLineNumber();\n    const endLineNumber = this.getEndLineNumber();\n\n    if (insertFromLineNumber <= startLineNumber) {\n      // inserting above the viewport\n      this._rendLineNumberStart += insertCnt;\n      return null;\n    }\n\n    if (insertFromLineNumber > endLineNumber) {\n      // inserting below the viewport\n      return null;\n    }\n\n    if (insertCnt + insertFromLineNumber > endLineNumber) {\n      // insert inside the viewport in such a way that all remaining lines are pushed outside\n      const deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);\n\n      return deleted;\n    } // insert inside the viewport, push out some lines, but not all remaining lines\n\n\n    const newLines = [];\n\n    for (let i = 0; i < insertCnt; i++) {\n      newLines[i] = this._createLine();\n    }\n\n    const insertIndex = insertFromLineNumber - this._rendLineNumberStart;\n\n    const beforeLines = this._lines.slice(0, insertIndex);\n\n    const afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);\n\n    const deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);\n\n    this._lines = beforeLines.concat(newLines).concat(afterLines);\n    return deletedLines;\n  }\n\n  onTokensChanged(ranges) {\n    if (this.getCount() === 0) {\n      // no lines\n      return false;\n    }\n\n    const startLineNumber = this.getStartLineNumber();\n    const endLineNumber = this.getEndLineNumber();\n    let notifiedSomeone = false;\n\n    for (let i = 0, len = ranges.length; i < len; i++) {\n      const rng = ranges[i];\n\n      if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {\n        // range outside viewport\n        continue;\n      }\n\n      const from = Math.max(startLineNumber, rng.fromLineNumber);\n      const to = Math.min(endLineNumber, rng.toLineNumber);\n\n      for (let lineNumber = from; lineNumber <= to; lineNumber++) {\n        const lineIndex = lineNumber - this._rendLineNumberStart;\n\n        this._lines[lineIndex].onTokensChanged();\n\n        notifiedSomeone = true;\n      }\n    }\n\n    return notifiedSomeone;\n  }\n\n}\nexport class VisibleLinesCollection {\n  constructor(host) {\n    this._host = host;\n    this.domNode = this._createDomNode();\n    this._linesCollection = new RenderedLinesCollection(() => this._host.createVisibleLine());\n  }\n\n  _createDomNode() {\n    const domNode = createFastDomNode(document.createElement('div'));\n    domNode.setClassName('view-layer');\n    domNode.setPosition('absolute');\n    domNode.domNode.setAttribute('role', 'presentation');\n    domNode.domNode.setAttribute('aria-hidden', 'true');\n    return domNode;\n  } // ---- begin view event handlers\n\n\n  onConfigurationChanged(e) {\n    if (e.hasChanged(131\n    /* layoutInfo */\n    )) {\n      return true;\n    }\n\n    return false;\n  }\n\n  onFlushed(e) {\n    this._linesCollection.flush(); // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render\n\n\n    return true;\n  }\n\n  onLinesChanged(e) {\n    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.toLineNumber);\n  }\n\n  onLinesDeleted(e) {\n    const deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n\n    if (deleted) {\n      // Remove from DOM\n      for (let i = 0, len = deleted.length; i < len; i++) {\n        const lineDomNode = deleted[i].getDomNode();\n\n        if (lineDomNode) {\n          this.domNode.domNode.removeChild(lineDomNode);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  onLinesInserted(e) {\n    const deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n\n    if (deleted) {\n      // Remove from DOM\n      for (let i = 0, len = deleted.length; i < len; i++) {\n        const lineDomNode = deleted[i].getDomNode();\n\n        if (lineDomNode) {\n          this.domNode.domNode.removeChild(lineDomNode);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  onScrollChanged(e) {\n    return e.scrollTopChanged;\n  }\n\n  onTokensChanged(e) {\n    return this._linesCollection.onTokensChanged(e.ranges);\n  }\n\n  onZonesChanged(e) {\n    return true;\n  } // ---- end view event handlers\n\n\n  getStartLineNumber() {\n    return this._linesCollection.getStartLineNumber();\n  }\n\n  getEndLineNumber() {\n    return this._linesCollection.getEndLineNumber();\n  }\n\n  getVisibleLine(lineNumber) {\n    return this._linesCollection.getLine(lineNumber);\n  }\n\n  renderLines(viewportData) {\n    const inp = this._linesCollection._get();\n\n    const renderer = new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData);\n    const ctx = {\n      rendLineNumberStart: inp.rendLineNumberStart,\n      lines: inp.lines,\n      linesLength: inp.lines.length\n    }; // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)\n\n    const resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);\n\n    this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);\n  }\n\n}\n\nclass ViewLayerRenderer {\n  constructor(domNode, host, viewportData) {\n    this.domNode = domNode;\n    this.host = host;\n    this.viewportData = viewportData;\n  }\n\n  render(inContext, startLineNumber, stopLineNumber, deltaTop) {\n    const ctx = {\n      rendLineNumberStart: inContext.rendLineNumberStart,\n      lines: inContext.lines.slice(0),\n      linesLength: inContext.linesLength\n    };\n\n    if (ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber || stopLineNumber < ctx.rendLineNumberStart) {\n      // There is no overlap whatsoever\n      ctx.rendLineNumberStart = startLineNumber;\n      ctx.linesLength = stopLineNumber - startLineNumber + 1;\n      ctx.lines = [];\n\n      for (let x = startLineNumber; x <= stopLineNumber; x++) {\n        ctx.lines[x - startLineNumber] = this.host.createVisibleLine();\n      }\n\n      this._finishRendering(ctx, true, deltaTop);\n\n      return ctx;\n    } // Update lines which will remain untouched\n\n\n    this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);\n\n    if (ctx.rendLineNumberStart > startLineNumber) {\n      // Insert lines before\n      const fromLineNumber = startLineNumber;\n      const toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);\n\n      if (fromLineNumber <= toLineNumber) {\n        this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n\n        ctx.linesLength += toLineNumber - fromLineNumber + 1;\n      }\n    } else if (ctx.rendLineNumberStart < startLineNumber) {\n      // Remove lines before\n      const removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);\n\n      if (removeCnt > 0) {\n        this._removeLinesBefore(ctx, removeCnt);\n\n        ctx.linesLength -= removeCnt;\n      }\n    }\n\n    ctx.rendLineNumberStart = startLineNumber;\n\n    if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {\n      // Insert lines after\n      const fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;\n      const toLineNumber = stopLineNumber;\n\n      if (fromLineNumber <= toLineNumber) {\n        this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n\n        ctx.linesLength += toLineNumber - fromLineNumber + 1;\n      }\n    } else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {\n      // Remove lines after\n      const fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);\n      const toLineNumber = ctx.linesLength - 1;\n      const removeCnt = toLineNumber - fromLineNumber + 1;\n\n      if (removeCnt > 0) {\n        this._removeLinesAfter(ctx, removeCnt);\n\n        ctx.linesLength -= removeCnt;\n      }\n    }\n\n    this._finishRendering(ctx, false, deltaTop);\n\n    return ctx;\n  }\n\n  _renderUntouchedLines(ctx, startIndex, endIndex, deltaTop, deltaLN) {\n    const rendLineNumberStart = ctx.rendLineNumberStart;\n    const lines = ctx.lines;\n\n    for (let i = startIndex; i <= endIndex; i++) {\n      const lineNumber = rendLineNumberStart + i;\n      lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);\n    }\n  }\n\n  _insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n    const newLines = [];\n    let newLinesLen = 0;\n\n    for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n      newLines[newLinesLen++] = this.host.createVisibleLine();\n    }\n\n    ctx.lines = newLines.concat(ctx.lines);\n  }\n\n  _removeLinesBefore(ctx, removeCount) {\n    for (let i = 0; i < removeCount; i++) {\n      const lineDomNode = ctx.lines[i].getDomNode();\n\n      if (lineDomNode) {\n        this.domNode.removeChild(lineDomNode);\n      }\n    }\n\n    ctx.lines.splice(0, removeCount);\n  }\n\n  _insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n    const newLines = [];\n    let newLinesLen = 0;\n\n    for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n      newLines[newLinesLen++] = this.host.createVisibleLine();\n    }\n\n    ctx.lines = ctx.lines.concat(newLines);\n  }\n\n  _removeLinesAfter(ctx, removeCount) {\n    const removeIndex = ctx.linesLength - removeCount;\n\n    for (let i = 0; i < removeCount; i++) {\n      const lineDomNode = ctx.lines[removeIndex + i].getDomNode();\n\n      if (lineDomNode) {\n        this.domNode.removeChild(lineDomNode);\n      }\n    }\n\n    ctx.lines.splice(removeIndex, removeCount);\n  }\n\n  _finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew) {\n    if (ViewLayerRenderer._ttPolicy) {\n      newLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(newLinesHTML);\n    }\n\n    const lastChild = this.domNode.lastChild;\n\n    if (domNodeIsEmpty || !lastChild) {\n      this.domNode.innerHTML = newLinesHTML; // explains the ugly casts -> https://github.com/microsoft/vscode/issues/106396#issuecomment-692625393;\n    } else {\n      lastChild.insertAdjacentHTML('afterend', newLinesHTML);\n    }\n\n    let currChild = this.domNode.lastChild;\n\n    for (let i = ctx.linesLength - 1; i >= 0; i--) {\n      const line = ctx.lines[i];\n\n      if (wasNew[i]) {\n        line.setDomNode(currChild);\n        currChild = currChild.previousSibling;\n      }\n    }\n  }\n\n  _finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid) {\n    const hugeDomNode = document.createElement('div');\n\n    if (ViewLayerRenderer._ttPolicy) {\n      invalidLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(invalidLinesHTML);\n    }\n\n    hugeDomNode.innerHTML = invalidLinesHTML;\n\n    for (let i = 0; i < ctx.linesLength; i++) {\n      const line = ctx.lines[i];\n\n      if (wasInvalid[i]) {\n        const source = hugeDomNode.firstChild;\n        const lineDomNode = line.getDomNode();\n        lineDomNode.parentNode.replaceChild(source, lineDomNode);\n        line.setDomNode(source);\n      }\n    }\n  }\n\n  _finishRendering(ctx, domNodeIsEmpty, deltaTop) {\n    const sb = ViewLayerRenderer._sb;\n    const linesLength = ctx.linesLength;\n    const lines = ctx.lines;\n    const rendLineNumberStart = ctx.rendLineNumberStart;\n    const wasNew = [];\n    {\n      sb.reset();\n      let hadNewLine = false;\n\n      for (let i = 0; i < linesLength; i++) {\n        const line = lines[i];\n        wasNew[i] = false;\n        const lineDomNode = line.getDomNode();\n\n        if (lineDomNode) {\n          // line is not new\n          continue;\n        }\n\n        const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n\n        if (!renderResult) {\n          // line does not need rendering\n          continue;\n        }\n\n        wasNew[i] = true;\n        hadNewLine = true;\n      }\n\n      if (hadNewLine) {\n        this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);\n      }\n    }\n    {\n      sb.reset();\n      let hadInvalidLine = false;\n      const wasInvalid = [];\n\n      for (let i = 0; i < linesLength; i++) {\n        const line = lines[i];\n        wasInvalid[i] = false;\n\n        if (wasNew[i]) {\n          // line was new\n          continue;\n        }\n\n        const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n\n        if (!renderResult) {\n          // line does not need rendering\n          continue;\n        }\n\n        wasInvalid[i] = true;\n        hadInvalidLine = true;\n      }\n\n      if (hadInvalidLine) {\n        this._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);\n      }\n    }\n  }\n\n}\n\nViewLayerRenderer._ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('editorViewLayer', {\n  createHTML: value => value\n});\nViewLayerRenderer._sb = createStringBuilder(100000);","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/browser/view/viewLayer.js"],"names":["_a","createFastDomNode","createStringBuilder","RenderedLinesCollection","constructor","createLine","_createLine","_set","flush","rendLineNumberStart","lines","_lines","_rendLineNumberStart","_get","getStartLineNumber","getEndLineNumber","length","getCount","getLine","lineNumber","lineIndex","Error","onLinesDeleted","deleteFromLineNumber","deleteToLineNumber","startLineNumber","endLineNumber","deleteCnt","deleteStartIndex","deleteCount","deleteAboveCount","deleted","splice","onLinesChanged","changeFromLineNumber","changeToLineNumber","someoneNotified","changedLineNumber","onContentChanged","onLinesInserted","insertFromLineNumber","insertToLineNumber","insertCnt","newLines","i","insertIndex","beforeLines","slice","afterLines","deletedLines","concat","onTokensChanged","ranges","notifiedSomeone","len","rng","toLineNumber","fromLineNumber","from","Math","max","to","min","VisibleLinesCollection","host","_host","domNode","_createDomNode","_linesCollection","createVisibleLine","document","createElement","setClassName","setPosition","setAttribute","onConfigurationChanged","e","hasChanged","onFlushed","lineDomNode","getDomNode","removeChild","onScrollChanged","scrollTopChanged","onZonesChanged","getVisibleLine","renderLines","viewportData","inp","renderer","ViewLayerRenderer","ctx","linesLength","resCtx","render","relativeVerticalOffset","inContext","stopLineNumber","deltaTop","x","_finishRendering","_renderUntouchedLines","_insertLinesBefore","removeCnt","_removeLinesBefore","_insertLinesAfter","_removeLinesAfter","startIndex","endIndex","deltaLN","layoutLine","newLinesLen","removeCount","removeIndex","_finishRenderingNewLines","domNodeIsEmpty","newLinesHTML","wasNew","_ttPolicy","createHTML","lastChild","innerHTML","insertAdjacentHTML","currChild","line","setDomNode","previousSibling","_finishRenderingInvalidLines","invalidLinesHTML","wasInvalid","hugeDomNode","source","firstChild","parentNode","replaceChild","sb","_sb","reset","hadNewLine","renderResult","renderLine","build","hadInvalidLine","window","trustedTypes","createPolicy","value"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nexport class RenderedLinesCollection {\n    constructor(createLine) {\n        this._createLine = createLine;\n        this._set(1, []);\n    }\n    flush() {\n        this._set(1, []);\n    }\n    _set(rendLineNumberStart, lines) {\n        this._lines = lines;\n        this._rendLineNumberStart = rendLineNumberStart;\n    }\n    _get() {\n        return {\n            rendLineNumberStart: this._rendLineNumberStart,\n            lines: this._lines\n        };\n    }\n    /**\n     * @returns Inclusive line number that is inside this collection\n     */\n    getStartLineNumber() {\n        return this._rendLineNumberStart;\n    }\n    /**\n     * @returns Inclusive line number that is inside this collection\n     */\n    getEndLineNumber() {\n        return this._rendLineNumberStart + this._lines.length - 1;\n    }\n    getCount() {\n        return this._lines.length;\n    }\n    getLine(lineNumber) {\n        const lineIndex = lineNumber - this._rendLineNumberStart;\n        if (lineIndex < 0 || lineIndex >= this._lines.length) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._lines[lineIndex];\n    }\n    /**\n     * @returns Lines that were removed from this collection\n     */\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        if (this.getCount() === 0) {\n            // no lines\n            return null;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        if (deleteToLineNumber < startLineNumber) {\n            // deleting above the viewport\n            const deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;\n            this._rendLineNumberStart -= deleteCnt;\n            return null;\n        }\n        if (deleteFromLineNumber > endLineNumber) {\n            // deleted below the viewport\n            return null;\n        }\n        // Record what needs to be deleted\n        let deleteStartIndex = 0;\n        let deleteCount = 0;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - this._rendLineNumberStart;\n            if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {\n                // this is a line to be deleted\n                if (deleteCount === 0) {\n                    // this is the first line to be deleted\n                    deleteStartIndex = lineIndex;\n                    deleteCount = 1;\n                }\n                else {\n                    deleteCount++;\n                }\n            }\n        }\n        // Adjust this._rendLineNumberStart for lines deleted above\n        if (deleteFromLineNumber < startLineNumber) {\n            // Something was deleted above\n            let deleteAboveCount = 0;\n            if (deleteToLineNumber < startLineNumber) {\n                // the entire deleted lines are above\n                deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;\n            }\n            else {\n                deleteAboveCount = startLineNumber - deleteFromLineNumber;\n            }\n            this._rendLineNumberStart -= deleteAboveCount;\n        }\n        const deleted = this._lines.splice(deleteStartIndex, deleteCount);\n        return deleted;\n    }\n    onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n        if (this.getCount() === 0) {\n            // no lines\n            return false;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        let someoneNotified = false;\n        for (let changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {\n            if (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {\n                // Notify the line\n                this._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();\n                someoneNotified = true;\n            }\n        }\n        return someoneNotified;\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        if (this.getCount() === 0) {\n            // no lines\n            return null;\n        }\n        const insertCnt = insertToLineNumber - insertFromLineNumber + 1;\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        if (insertFromLineNumber <= startLineNumber) {\n            // inserting above the viewport\n            this._rendLineNumberStart += insertCnt;\n            return null;\n        }\n        if (insertFromLineNumber > endLineNumber) {\n            // inserting below the viewport\n            return null;\n        }\n        if (insertCnt + insertFromLineNumber > endLineNumber) {\n            // insert inside the viewport in such a way that all remaining lines are pushed outside\n            const deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);\n            return deleted;\n        }\n        // insert inside the viewport, push out some lines, but not all remaining lines\n        const newLines = [];\n        for (let i = 0; i < insertCnt; i++) {\n            newLines[i] = this._createLine();\n        }\n        const insertIndex = insertFromLineNumber - this._rendLineNumberStart;\n        const beforeLines = this._lines.slice(0, insertIndex);\n        const afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);\n        const deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);\n        this._lines = beforeLines.concat(newLines).concat(afterLines);\n        return deletedLines;\n    }\n    onTokensChanged(ranges) {\n        if (this.getCount() === 0) {\n            // no lines\n            return false;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        let notifiedSomeone = false;\n        for (let i = 0, len = ranges.length; i < len; i++) {\n            const rng = ranges[i];\n            if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {\n                // range outside viewport\n                continue;\n            }\n            const from = Math.max(startLineNumber, rng.fromLineNumber);\n            const to = Math.min(endLineNumber, rng.toLineNumber);\n            for (let lineNumber = from; lineNumber <= to; lineNumber++) {\n                const lineIndex = lineNumber - this._rendLineNumberStart;\n                this._lines[lineIndex].onTokensChanged();\n                notifiedSomeone = true;\n            }\n        }\n        return notifiedSomeone;\n    }\n}\nexport class VisibleLinesCollection {\n    constructor(host) {\n        this._host = host;\n        this.domNode = this._createDomNode();\n        this._linesCollection = new RenderedLinesCollection(() => this._host.createVisibleLine());\n    }\n    _createDomNode() {\n        const domNode = createFastDomNode(document.createElement('div'));\n        domNode.setClassName('view-layer');\n        domNode.setPosition('absolute');\n        domNode.domNode.setAttribute('role', 'presentation');\n        domNode.domNode.setAttribute('aria-hidden', 'true');\n        return domNode;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        if (e.hasChanged(131 /* layoutInfo */)) {\n            return true;\n        }\n        return false;\n    }\n    onFlushed(e) {\n        this._linesCollection.flush();\n        // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render\n        return true;\n    }\n    onLinesChanged(e) {\n        return this._linesCollection.onLinesChanged(e.fromLineNumber, e.toLineNumber);\n    }\n    onLinesDeleted(e) {\n        const deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n        if (deleted) {\n            // Remove from DOM\n            for (let i = 0, len = deleted.length; i < len; i++) {\n                const lineDomNode = deleted[i].getDomNode();\n                if (lineDomNode) {\n                    this.domNode.domNode.removeChild(lineDomNode);\n                }\n            }\n        }\n        return true;\n    }\n    onLinesInserted(e) {\n        const deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n        if (deleted) {\n            // Remove from DOM\n            for (let i = 0, len = deleted.length; i < len; i++) {\n                const lineDomNode = deleted[i].getDomNode();\n                if (lineDomNode) {\n                    this.domNode.domNode.removeChild(lineDomNode);\n                }\n            }\n        }\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onTokensChanged(e) {\n        return this._linesCollection.onTokensChanged(e.ranges);\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // ---- end view event handlers\n    getStartLineNumber() {\n        return this._linesCollection.getStartLineNumber();\n    }\n    getEndLineNumber() {\n        return this._linesCollection.getEndLineNumber();\n    }\n    getVisibleLine(lineNumber) {\n        return this._linesCollection.getLine(lineNumber);\n    }\n    renderLines(viewportData) {\n        const inp = this._linesCollection._get();\n        const renderer = new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData);\n        const ctx = {\n            rendLineNumberStart: inp.rendLineNumberStart,\n            lines: inp.lines,\n            linesLength: inp.lines.length\n        };\n        // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)\n        const resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);\n        this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);\n    }\n}\nclass ViewLayerRenderer {\n    constructor(domNode, host, viewportData) {\n        this.domNode = domNode;\n        this.host = host;\n        this.viewportData = viewportData;\n    }\n    render(inContext, startLineNumber, stopLineNumber, deltaTop) {\n        const ctx = {\n            rendLineNumberStart: inContext.rendLineNumberStart,\n            lines: inContext.lines.slice(0),\n            linesLength: inContext.linesLength\n        };\n        if ((ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber) || (stopLineNumber < ctx.rendLineNumberStart)) {\n            // There is no overlap whatsoever\n            ctx.rendLineNumberStart = startLineNumber;\n            ctx.linesLength = stopLineNumber - startLineNumber + 1;\n            ctx.lines = [];\n            for (let x = startLineNumber; x <= stopLineNumber; x++) {\n                ctx.lines[x - startLineNumber] = this.host.createVisibleLine();\n            }\n            this._finishRendering(ctx, true, deltaTop);\n            return ctx;\n        }\n        // Update lines which will remain untouched\n        this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);\n        if (ctx.rendLineNumberStart > startLineNumber) {\n            // Insert lines before\n            const fromLineNumber = startLineNumber;\n            const toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);\n            if (fromLineNumber <= toLineNumber) {\n                this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n                ctx.linesLength += toLineNumber - fromLineNumber + 1;\n            }\n        }\n        else if (ctx.rendLineNumberStart < startLineNumber) {\n            // Remove lines before\n            const removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);\n            if (removeCnt > 0) {\n                this._removeLinesBefore(ctx, removeCnt);\n                ctx.linesLength -= removeCnt;\n            }\n        }\n        ctx.rendLineNumberStart = startLineNumber;\n        if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {\n            // Insert lines after\n            const fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;\n            const toLineNumber = stopLineNumber;\n            if (fromLineNumber <= toLineNumber) {\n                this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n                ctx.linesLength += toLineNumber - fromLineNumber + 1;\n            }\n        }\n        else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {\n            // Remove lines after\n            const fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);\n            const toLineNumber = ctx.linesLength - 1;\n            const removeCnt = toLineNumber - fromLineNumber + 1;\n            if (removeCnt > 0) {\n                this._removeLinesAfter(ctx, removeCnt);\n                ctx.linesLength -= removeCnt;\n            }\n        }\n        this._finishRendering(ctx, false, deltaTop);\n        return ctx;\n    }\n    _renderUntouchedLines(ctx, startIndex, endIndex, deltaTop, deltaLN) {\n        const rendLineNumberStart = ctx.rendLineNumberStart;\n        const lines = ctx.lines;\n        for (let i = startIndex; i <= endIndex; i++) {\n            const lineNumber = rendLineNumberStart + i;\n            lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);\n        }\n    }\n    _insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n        const newLines = [];\n        let newLinesLen = 0;\n        for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n            newLines[newLinesLen++] = this.host.createVisibleLine();\n        }\n        ctx.lines = newLines.concat(ctx.lines);\n    }\n    _removeLinesBefore(ctx, removeCount) {\n        for (let i = 0; i < removeCount; i++) {\n            const lineDomNode = ctx.lines[i].getDomNode();\n            if (lineDomNode) {\n                this.domNode.removeChild(lineDomNode);\n            }\n        }\n        ctx.lines.splice(0, removeCount);\n    }\n    _insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n        const newLines = [];\n        let newLinesLen = 0;\n        for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n            newLines[newLinesLen++] = this.host.createVisibleLine();\n        }\n        ctx.lines = ctx.lines.concat(newLines);\n    }\n    _removeLinesAfter(ctx, removeCount) {\n        const removeIndex = ctx.linesLength - removeCount;\n        for (let i = 0; i < removeCount; i++) {\n            const lineDomNode = ctx.lines[removeIndex + i].getDomNode();\n            if (lineDomNode) {\n                this.domNode.removeChild(lineDomNode);\n            }\n        }\n        ctx.lines.splice(removeIndex, removeCount);\n    }\n    _finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew) {\n        if (ViewLayerRenderer._ttPolicy) {\n            newLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(newLinesHTML);\n        }\n        const lastChild = this.domNode.lastChild;\n        if (domNodeIsEmpty || !lastChild) {\n            this.domNode.innerHTML = newLinesHTML; // explains the ugly casts -> https://github.com/microsoft/vscode/issues/106396#issuecomment-692625393;\n        }\n        else {\n            lastChild.insertAdjacentHTML('afterend', newLinesHTML);\n        }\n        let currChild = this.domNode.lastChild;\n        for (let i = ctx.linesLength - 1; i >= 0; i--) {\n            const line = ctx.lines[i];\n            if (wasNew[i]) {\n                line.setDomNode(currChild);\n                currChild = currChild.previousSibling;\n            }\n        }\n    }\n    _finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid) {\n        const hugeDomNode = document.createElement('div');\n        if (ViewLayerRenderer._ttPolicy) {\n            invalidLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(invalidLinesHTML);\n        }\n        hugeDomNode.innerHTML = invalidLinesHTML;\n        for (let i = 0; i < ctx.linesLength; i++) {\n            const line = ctx.lines[i];\n            if (wasInvalid[i]) {\n                const source = hugeDomNode.firstChild;\n                const lineDomNode = line.getDomNode();\n                lineDomNode.parentNode.replaceChild(source, lineDomNode);\n                line.setDomNode(source);\n            }\n        }\n    }\n    _finishRendering(ctx, domNodeIsEmpty, deltaTop) {\n        const sb = ViewLayerRenderer._sb;\n        const linesLength = ctx.linesLength;\n        const lines = ctx.lines;\n        const rendLineNumberStart = ctx.rendLineNumberStart;\n        const wasNew = [];\n        {\n            sb.reset();\n            let hadNewLine = false;\n            for (let i = 0; i < linesLength; i++) {\n                const line = lines[i];\n                wasNew[i] = false;\n                const lineDomNode = line.getDomNode();\n                if (lineDomNode) {\n                    // line is not new\n                    continue;\n                }\n                const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n                if (!renderResult) {\n                    // line does not need rendering\n                    continue;\n                }\n                wasNew[i] = true;\n                hadNewLine = true;\n            }\n            if (hadNewLine) {\n                this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);\n            }\n        }\n        {\n            sb.reset();\n            let hadInvalidLine = false;\n            const wasInvalid = [];\n            for (let i = 0; i < linesLength; i++) {\n                const line = lines[i];\n                wasInvalid[i] = false;\n                if (wasNew[i]) {\n                    // line was new\n                    continue;\n                }\n                const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n                if (!renderResult) {\n                    // line does not need rendering\n                    continue;\n                }\n                wasInvalid[i] = true;\n                hadInvalidLine = true;\n            }\n            if (hadInvalidLine) {\n                this._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);\n            }\n        }\n    }\n}\nViewLayerRenderer._ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('editorViewLayer', { createHTML: value => value });\nViewLayerRenderer._sb = createStringBuilder(100000);\n"]},"metadata":{},"sourceType":"module"}