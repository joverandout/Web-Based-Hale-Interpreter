{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\nexport class FoldingModel {\n  constructor(textModel, decorationProvider) {\n    this._updateEventEmitter = new Emitter();\n    this.onDidChange = this._updateEventEmitter.event;\n    this._textModel = textModel;\n    this._decorationProvider = decorationProvider;\n    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n    this._editorDecorationIds = [];\n    this._isInitialized = false;\n  }\n\n  get regions() {\n    return this._regions;\n  }\n\n  get textModel() {\n    return this._textModel;\n  }\n\n  get isInitialized() {\n    return this._isInitialized;\n  }\n\n  toggleCollapseState(toggledRegions) {\n    if (!toggledRegions.length) {\n      return;\n    }\n\n    toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\n    const processed = {};\n\n    this._decorationProvider.changeDecorations(accessor => {\n      let k = 0; // index from [0 ... this.regions.length]\n\n      let dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n\n      let lastHiddenLine = -1; // the end of the last hidden lines\n\n      const updateDecorationsUntil = index => {\n        while (k < index) {\n          const endLineNumber = this._regions.getEndLineNumber(k);\n\n          const isCollapsed = this._regions.isCollapsed(k);\n\n          if (endLineNumber <= dirtyRegionEndLine) {\n            accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine));\n          }\n\n          if (isCollapsed && endLineNumber > lastHiddenLine) {\n            lastHiddenLine = endLineNumber;\n          }\n\n          k++;\n        }\n      };\n\n      for (let region of toggledRegions) {\n        let index = region.regionIndex;\n        let editorDecorationId = this._editorDecorationIds[index];\n\n        if (editorDecorationId && !processed[editorDecorationId]) {\n          processed[editorDecorationId] = true;\n          updateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n\n          let newCollapseState = !this._regions.isCollapsed(index);\n\n          this._regions.setCollapsed(index, newCollapseState);\n\n          dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\n        }\n      }\n\n      updateDecorationsUntil(this._regions.length);\n    });\n\n    this._updateEventEmitter.fire({\n      model: this,\n      collapseStateChanged: toggledRegions\n    });\n  }\n\n  update(newRegions, blockedLineNumers = []) {\n    let newEditorDecorations = [];\n\n    let isBlocked = (startLineNumber, endLineNumber) => {\n      for (let blockedLineNumber of blockedLineNumers) {\n        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {\n          // first line is visible\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    let lastHiddenLine = -1;\n\n    let initRange = (index, isCollapsed) => {\n      const startLineNumber = newRegions.getStartLineNumber(index);\n      const endLineNumber = newRegions.getEndLineNumber(index);\n\n      if (!isCollapsed) {\n        isCollapsed = newRegions.isCollapsed(index);\n      }\n\n      if (isCollapsed && isBlocked(startLineNumber, endLineNumber)) {\n        isCollapsed = false;\n      }\n\n      newRegions.setCollapsed(index, isCollapsed);\n\n      const maxColumn = this._textModel.getLineMaxColumn(startLineNumber);\n\n      const decorationRange = {\n        startLineNumber: startLineNumber,\n        startColumn: Math.max(maxColumn - 1, 1),\n        endLineNumber: startLineNumber,\n        endColumn: maxColumn\n      };\n      newEditorDecorations.push({\n        range: decorationRange,\n        options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine)\n      });\n\n      if (isCollapsed && endLineNumber > lastHiddenLine) {\n        lastHiddenLine = endLineNumber;\n      }\n    };\n\n    let i = 0;\n\n    let nextCollapsed = () => {\n      while (i < this._regions.length) {\n        let isCollapsed = this._regions.isCollapsed(i);\n\n        i++;\n\n        if (isCollapsed) {\n          return i - 1;\n        }\n      }\n\n      return -1;\n    };\n\n    let k = 0;\n    let collapsedIndex = nextCollapsed();\n\n    while (collapsedIndex !== -1 && k < newRegions.length) {\n      // get the latest range\n      let decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\n\n      if (decRange) {\n        let collapsedStartLineNumber = decRange.startLineNumber;\n\n        if (decRange.startColumn === Math.max(decRange.endColumn - 1, 1) && this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.endColumn) {\n          // test that the decoration is still covering the full line else it got deleted\n          while (k < newRegions.length) {\n            let startLineNumber = newRegions.getStartLineNumber(k);\n\n            if (collapsedStartLineNumber >= startLineNumber) {\n              initRange(k, collapsedStartLineNumber === startLineNumber);\n              k++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n\n      collapsedIndex = nextCollapsed();\n    }\n\n    while (k < newRegions.length) {\n      initRange(k, false);\n      k++;\n    }\n\n    this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\n    this._regions = newRegions;\n    this._isInitialized = true;\n\n    this._updateEventEmitter.fire({\n      model: this\n    });\n  }\n  /**\n   * Collapse state memento, for persistence only\n   */\n\n\n  getMemento() {\n    let collapsedRanges = [];\n\n    for (let i = 0; i < this._regions.length; i++) {\n      if (this._regions.isCollapsed(i)) {\n        let range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n\n        if (range) {\n          let startLineNumber = range.startLineNumber;\n\n          let endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\n\n          collapsedRanges.push({\n            startLineNumber,\n            endLineNumber\n          });\n        }\n      }\n    }\n\n    if (collapsedRanges.length > 0) {\n      return collapsedRanges;\n    }\n\n    return undefined;\n  }\n  /**\n   * Apply persisted state, for persistence only\n   */\n\n\n  applyMemento(state) {\n    if (!Array.isArray(state)) {\n      return;\n    }\n\n    let toToogle = [];\n\n    for (let range of state) {\n      let region = this.getRegionAtLine(range.startLineNumber);\n\n      if (region && !region.isCollapsed) {\n        toToogle.push(region);\n      }\n    }\n\n    this.toggleCollapseState(toToogle);\n  }\n\n  dispose() {\n    this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\n  }\n\n  getAllRegionsAtLine(lineNumber, filter) {\n    let result = [];\n\n    if (this._regions) {\n      let index = this._regions.findRange(lineNumber);\n\n      let level = 1;\n\n      while (index >= 0) {\n        let current = this._regions.toRegion(index);\n\n        if (!filter || filter(current, level)) {\n          result.push(current);\n        }\n\n        level++;\n        index = current.parentIndex;\n      }\n    }\n\n    return result;\n  }\n\n  getRegionAtLine(lineNumber) {\n    if (this._regions) {\n      let index = this._regions.findRange(lineNumber);\n\n      if (index >= 0) {\n        return this._regions.toRegion(index);\n      }\n    }\n\n    return null;\n  }\n\n  getRegionsInside(region, filter) {\n    let result = [];\n    let index = region ? region.regionIndex + 1 : 0;\n    let endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n\n    if (filter && filter.length === 2) {\n      const levelStack = [];\n\n      for (let i = index, len = this._regions.length; i < len; i++) {\n        let current = this._regions.toRegion(i);\n\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n            levelStack.pop();\n          }\n\n          levelStack.push(current);\n\n          if (filter(current, levelStack.length)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    } else {\n      for (let i = index, len = this._regions.length; i < len; i++) {\n        let current = this._regions.toRegion(i);\n\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          if (!filter || filter(current)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n}\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\n\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n  let toToggle = [];\n\n  for (let lineNumber of lineNumbers) {\n    let region = foldingModel.getRegionAtLine(lineNumber);\n\n    if (region) {\n      const doCollapse = !region.isCollapsed;\n      toToggle.push(region);\n\n      if (levels > 1) {\n        let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n        toToggle.push(...regionsInside);\n      }\n    }\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\n\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {\n  let toToggle = [];\n\n  if (lineNumbers && lineNumbers.length > 0) {\n    for (let lineNumber of lineNumbers) {\n      let region = foldingModel.getRegionAtLine(lineNumber);\n\n      if (region) {\n        if (region.isCollapsed !== doCollapse) {\n          toToggle.push(region);\n        }\n\n        if (levels > 1) {\n          let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n          toToggle.push(...regionsInside);\n        }\n      }\n    }\n  } else {\n    let regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n    toToggle.push(...regionsInside);\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\n\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n  let toToggle = [];\n\n  for (let lineNumber of lineNumbers) {\n    let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n    toToggle.push(...regions);\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\n\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n  let toToggle = [];\n\n  for (let lineNumber of lineNumbers) {\n    let regions = foldingModel.getAllRegionsAtLine(lineNumber, region => region.isCollapsed !== doCollapse);\n\n    if (regions.length > 0) {\n      toToggle.push(regions[0]);\n    }\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n*/\n\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n  let filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n\n  let toToggle = foldingModel.getRegionsInside(null, filter);\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\n\nexport function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {\n  let filteredRegions = [];\n\n  for (let lineNumber of blockedLineNumbers) {\n    const regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n\n    if (regions.length > 0) {\n      filteredRegions.push(regions[0]);\n    }\n  }\n\n  let filter = region => filteredRegions.every(filteredRegion => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;\n\n  let toToggle = foldingModel.getRegionsInside(null, filter);\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\n\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n  let editorModel = foldingModel.textModel;\n  let regions = foldingModel.regions;\n  let toToggle = [];\n\n  for (let i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i)) {\n      let startLineNumber = regions.getStartLineNumber(i);\n\n      if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n        toToggle.push(regions.toRegion(i));\n      }\n    }\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\n\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n  let regions = foldingModel.regions;\n  let toToggle = [];\n\n  for (let i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n      toToggle.push(regions.toRegion(i));\n    }\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\n\nexport function getParentFoldLine(lineNumber, foldingModel) {\n  let startLineNumber = null;\n  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n\n  if (foldingRegion !== null) {\n    startLineNumber = foldingRegion.startLineNumber; // If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n\n    if (lineNumber === startLineNumber) {\n      let parentFoldingIdx = foldingRegion.parentIndex;\n\n      if (parentFoldingIdx !== -1) {\n        startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);\n      } else {\n        startLineNumber = null;\n      }\n    }\n  }\n\n  return startLineNumber;\n}\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\n\nexport function getPreviousFoldLine(lineNumber, foldingModel) {\n  let foldingRegion = foldingModel.getRegionAtLine(lineNumber); // If on the folding range start line, go to previous sibling.\n\n  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n    // If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n    if (lineNumber !== foldingRegion.startLineNumber) {\n      return foldingRegion.startLineNumber;\n    } else {\n      // Find min line number to stay within parent.\n      let expectedParentIndex = foldingRegion.parentIndex;\n      let minLineNumber = 0;\n\n      if (expectedParentIndex !== -1) {\n        minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);\n      } // Find fold at same level.\n\n\n      while (foldingRegion !== null) {\n        if (foldingRegion.regionIndex > 0) {\n          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1); // Keep at same level.\n\n          if (foldingRegion.startLineNumber <= minLineNumber) {\n            return null;\n          } else if (foldingRegion.parentIndex === expectedParentIndex) {\n            return foldingRegion.startLineNumber;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n  } else {\n    // Go to last fold that's before the current line.\n    if (foldingModel.regions.length > 0) {\n      foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);\n\n      while (foldingRegion !== null) {\n        // Found fold before current line.\n        if (foldingRegion.startLineNumber < lineNumber) {\n          return foldingRegion.startLineNumber;\n        }\n\n        if (foldingRegion.regionIndex > 0) {\n          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n        } else {\n          foldingRegion = null;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\n\nexport function getNextFoldLine(lineNumber, foldingModel) {\n  let foldingRegion = foldingModel.getRegionAtLine(lineNumber); // If on the folding range start line, go to next sibling.\n\n  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n    // Find max line number to stay within parent.\n    let expectedParentIndex = foldingRegion.parentIndex;\n    let maxLineNumber = 0;\n\n    if (expectedParentIndex !== -1) {\n      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);\n    } else if (foldingModel.regions.length === 0) {\n      return null;\n    } else {\n      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);\n    } // Find fold at same level.\n\n\n    while (foldingRegion !== null) {\n      if (foldingRegion.regionIndex < foldingModel.regions.length) {\n        foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1); // Keep at same level.\n\n        if (foldingRegion.startLineNumber >= maxLineNumber) {\n          return null;\n        } else if (foldingRegion.parentIndex === expectedParentIndex) {\n          return foldingRegion.startLineNumber;\n        }\n      } else {\n        return null;\n      }\n    }\n  } else {\n    // Go to first fold that's after the current line.\n    if (foldingModel.regions.length > 0) {\n      foldingRegion = foldingModel.regions.toRegion(0);\n\n      while (foldingRegion !== null) {\n        // Found fold after current line.\n        if (foldingRegion.startLineNumber > lineNumber) {\n          return foldingRegion.startLineNumber;\n        }\n\n        if (foldingRegion.regionIndex < foldingModel.regions.length) {\n          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n        } else {\n          foldingRegion = null;\n        }\n      }\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js"],"names":["Emitter","FoldingRegions","FoldingModel","constructor","textModel","decorationProvider","_updateEventEmitter","onDidChange","event","_textModel","_decorationProvider","_regions","Uint32Array","_editorDecorationIds","_isInitialized","regions","isInitialized","toggleCollapseState","toggledRegions","length","sort","r1","r2","regionIndex","processed","changeDecorations","accessor","k","dirtyRegionEndLine","lastHiddenLine","updateDecorationsUntil","index","endLineNumber","getEndLineNumber","isCollapsed","changeDecorationOptions","getDecorationOption","region","editorDecorationId","newCollapseState","setCollapsed","Math","max","fire","model","collapseStateChanged","update","newRegions","blockedLineNumers","newEditorDecorations","isBlocked","startLineNumber","blockedLineNumber","initRange","getStartLineNumber","maxColumn","getLineMaxColumn","decorationRange","startColumn","endColumn","push","range","options","i","nextCollapsed","collapsedIndex","decRange","getDecorationRange","collapsedStartLineNumber","deltaDecorations","getMemento","collapsedRanges","undefined","applyMemento","state","Array","isArray","toToogle","getRegionAtLine","dispose","getAllRegionsAtLine","lineNumber","filter","result","findRange","level","current","toRegion","parentIndex","getRegionsInside","Number","MAX_VALUE","levelStack","len","containedBy","pop","foldingModel","levels","lineNumbers","toToggle","doCollapse","regionsInside","r","setCollapseStateLevelsDown","setCollapseStateLevelsUp","setCollapseStateUp","setCollapseStateAtLevel","foldLevel","blockedLineNumbers","some","line","containsLine","setCollapseStateForRest","filteredRegions","every","filteredRegion","setCollapseStateForMatchingLines","regExp","editorModel","test","getLineContent","setCollapseStateForType","type","getType","getParentFoldLine","foldingRegion","parentFoldingIdx","getPreviousFoldLine","expectedParentIndex","minLineNumber","getNextFoldLine","maxLineNumber"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\nexport class FoldingModel {\n    constructor(textModel, decorationProvider) {\n        this._updateEventEmitter = new Emitter();\n        this.onDidChange = this._updateEventEmitter.event;\n        this._textModel = textModel;\n        this._decorationProvider = decorationProvider;\n        this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n        this._editorDecorationIds = [];\n        this._isInitialized = false;\n    }\n    get regions() { return this._regions; }\n    get textModel() { return this._textModel; }\n    get isInitialized() { return this._isInitialized; }\n    toggleCollapseState(toggledRegions) {\n        if (!toggledRegions.length) {\n            return;\n        }\n        toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\n        const processed = {};\n        this._decorationProvider.changeDecorations(accessor => {\n            let k = 0; // index from [0 ... this.regions.length]\n            let dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n            let lastHiddenLine = -1; // the end of the last hidden lines\n            const updateDecorationsUntil = (index) => {\n                while (k < index) {\n                    const endLineNumber = this._regions.getEndLineNumber(k);\n                    const isCollapsed = this._regions.isCollapsed(k);\n                    if (endLineNumber <= dirtyRegionEndLine) {\n                        accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine));\n                    }\n                    if (isCollapsed && endLineNumber > lastHiddenLine) {\n                        lastHiddenLine = endLineNumber;\n                    }\n                    k++;\n                }\n            };\n            for (let region of toggledRegions) {\n                let index = region.regionIndex;\n                let editorDecorationId = this._editorDecorationIds[index];\n                if (editorDecorationId && !processed[editorDecorationId]) {\n                    processed[editorDecorationId] = true;\n                    updateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n                    let newCollapseState = !this._regions.isCollapsed(index);\n                    this._regions.setCollapsed(index, newCollapseState);\n                    dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\n                }\n            }\n            updateDecorationsUntil(this._regions.length);\n        });\n        this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });\n    }\n    update(newRegions, blockedLineNumers = []) {\n        let newEditorDecorations = [];\n        let isBlocked = (startLineNumber, endLineNumber) => {\n            for (let blockedLineNumber of blockedLineNumers) {\n                if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\n                    return true;\n                }\n            }\n            return false;\n        };\n        let lastHiddenLine = -1;\n        let initRange = (index, isCollapsed) => {\n            const startLineNumber = newRegions.getStartLineNumber(index);\n            const endLineNumber = newRegions.getEndLineNumber(index);\n            if (!isCollapsed) {\n                isCollapsed = newRegions.isCollapsed(index);\n            }\n            if (isCollapsed && isBlocked(startLineNumber, endLineNumber)) {\n                isCollapsed = false;\n            }\n            newRegions.setCollapsed(index, isCollapsed);\n            const maxColumn = this._textModel.getLineMaxColumn(startLineNumber);\n            const decorationRange = {\n                startLineNumber: startLineNumber,\n                startColumn: Math.max(maxColumn - 1, 1),\n                endLineNumber: startLineNumber,\n                endColumn: maxColumn\n            };\n            newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine) });\n            if (isCollapsed && endLineNumber > lastHiddenLine) {\n                lastHiddenLine = endLineNumber;\n            }\n        };\n        let i = 0;\n        let nextCollapsed = () => {\n            while (i < this._regions.length) {\n                let isCollapsed = this._regions.isCollapsed(i);\n                i++;\n                if (isCollapsed) {\n                    return i - 1;\n                }\n            }\n            return -1;\n        };\n        let k = 0;\n        let collapsedIndex = nextCollapsed();\n        while (collapsedIndex !== -1 && k < newRegions.length) {\n            // get the latest range\n            let decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\n            if (decRange) {\n                let collapsedStartLineNumber = decRange.startLineNumber;\n                if (decRange.startColumn === Math.max(decRange.endColumn - 1, 1) && this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.endColumn) { // test that the decoration is still covering the full line else it got deleted\n                    while (k < newRegions.length) {\n                        let startLineNumber = newRegions.getStartLineNumber(k);\n                        if (collapsedStartLineNumber >= startLineNumber) {\n                            initRange(k, collapsedStartLineNumber === startLineNumber);\n                            k++;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n            collapsedIndex = nextCollapsed();\n        }\n        while (k < newRegions.length) {\n            initRange(k, false);\n            k++;\n        }\n        this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\n        this._regions = newRegions;\n        this._isInitialized = true;\n        this._updateEventEmitter.fire({ model: this });\n    }\n    /**\n     * Collapse state memento, for persistence only\n     */\n    getMemento() {\n        let collapsedRanges = [];\n        for (let i = 0; i < this._regions.length; i++) {\n            if (this._regions.isCollapsed(i)) {\n                let range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n                if (range) {\n                    let startLineNumber = range.startLineNumber;\n                    let endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\n                    collapsedRanges.push({ startLineNumber, endLineNumber });\n                }\n            }\n        }\n        if (collapsedRanges.length > 0) {\n            return collapsedRanges;\n        }\n        return undefined;\n    }\n    /**\n     * Apply persisted state, for persistence only\n     */\n    applyMemento(state) {\n        if (!Array.isArray(state)) {\n            return;\n        }\n        let toToogle = [];\n        for (let range of state) {\n            let region = this.getRegionAtLine(range.startLineNumber);\n            if (region && !region.isCollapsed) {\n                toToogle.push(region);\n            }\n        }\n        this.toggleCollapseState(toToogle);\n    }\n    dispose() {\n        this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\n    }\n    getAllRegionsAtLine(lineNumber, filter) {\n        let result = [];\n        if (this._regions) {\n            let index = this._regions.findRange(lineNumber);\n            let level = 1;\n            while (index >= 0) {\n                let current = this._regions.toRegion(index);\n                if (!filter || filter(current, level)) {\n                    result.push(current);\n                }\n                level++;\n                index = current.parentIndex;\n            }\n        }\n        return result;\n    }\n    getRegionAtLine(lineNumber) {\n        if (this._regions) {\n            let index = this._regions.findRange(lineNumber);\n            if (index >= 0) {\n                return this._regions.toRegion(index);\n            }\n        }\n        return null;\n    }\n    getRegionsInside(region, filter) {\n        let result = [];\n        let index = region ? region.regionIndex + 1 : 0;\n        let endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n        if (filter && filter.length === 2) {\n            const levelStack = [];\n            for (let i = index, len = this._regions.length; i < len; i++) {\n                let current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n                        levelStack.pop();\n                    }\n                    levelStack.push(current);\n                    if (filter(current, levelStack.length)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            for (let i = index, len = this._regions.length; i < len; i++) {\n                let current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    if (!filter || filter(current)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n    let toToggle = [];\n    for (let lineNumber of lineNumbers) {\n        let region = foldingModel.getRegionAtLine(lineNumber);\n        if (region) {\n            const doCollapse = !region.isCollapsed;\n            toToggle.push(region);\n            if (levels > 1) {\n                let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                toToggle.push(...regionsInside);\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {\n    let toToggle = [];\n    if (lineNumbers && lineNumbers.length > 0) {\n        for (let lineNumber of lineNumbers) {\n            let region = foldingModel.getRegionAtLine(lineNumber);\n            if (region) {\n                if (region.isCollapsed !== doCollapse) {\n                    toToggle.push(region);\n                }\n                if (levels > 1) {\n                    let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                    toToggle.push(...regionsInside);\n                }\n            }\n        }\n    }\n    else {\n        let regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n        toToggle.push(...regionsInside);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n    let toToggle = [];\n    for (let lineNumber of lineNumbers) {\n        let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n        toToggle.push(...regions);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n    let toToggle = [];\n    for (let lineNumber of lineNumbers) {\n        let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);\n        if (regions.length > 0) {\n            toToggle.push(regions[0]);\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n*/\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n    let filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n    let toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\nexport function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {\n    let filteredRegions = [];\n    for (let lineNumber of blockedLineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n        if (regions.length > 0) {\n            filteredRegions.push(regions[0]);\n        }\n    }\n    let filter = (region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;\n    let toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n    let editorModel = foldingModel.textModel;\n    let regions = foldingModel.regions;\n    let toToggle = [];\n    for (let i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i)) {\n            let startLineNumber = regions.getStartLineNumber(i);\n            if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n                toToggle.push(regions.toRegion(i));\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n    let regions = foldingModel.regions;\n    let toToggle = [];\n    for (let i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n            toToggle.push(regions.toRegion(i));\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\nexport function getParentFoldLine(lineNumber, foldingModel) {\n    let startLineNumber = null;\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    if (foldingRegion !== null) {\n        startLineNumber = foldingRegion.startLineNumber;\n        // If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n        if (lineNumber === startLineNumber) {\n            let parentFoldingIdx = foldingRegion.parentIndex;\n            if (parentFoldingIdx !== -1) {\n                startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);\n            }\n            else {\n                startLineNumber = null;\n            }\n        }\n    }\n    return startLineNumber;\n}\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\nexport function getPreviousFoldLine(lineNumber, foldingModel) {\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    // If on the folding range start line, go to previous sibling.\n    if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n        // If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n        if (lineNumber !== foldingRegion.startLineNumber) {\n            return foldingRegion.startLineNumber;\n        }\n        else {\n            // Find min line number to stay within parent.\n            let expectedParentIndex = foldingRegion.parentIndex;\n            let minLineNumber = 0;\n            if (expectedParentIndex !== -1) {\n                minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);\n            }\n            // Find fold at same level.\n            while (foldingRegion !== null) {\n                if (foldingRegion.regionIndex > 0) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n                    // Keep at same level.\n                    if (foldingRegion.startLineNumber <= minLineNumber) {\n                        return null;\n                    }\n                    else if (foldingRegion.parentIndex === expectedParentIndex) {\n                        return foldingRegion.startLineNumber;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    }\n    else {\n        // Go to last fold that's before the current line.\n        if (foldingModel.regions.length > 0) {\n            foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);\n            while (foldingRegion !== null) {\n                // Found fold before current line.\n                if (foldingRegion.startLineNumber < lineNumber) {\n                    return foldingRegion.startLineNumber;\n                }\n                if (foldingRegion.regionIndex > 0) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n                }\n                else {\n                    foldingRegion = null;\n                }\n            }\n        }\n    }\n    return null;\n}\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\nexport function getNextFoldLine(lineNumber, foldingModel) {\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    // If on the folding range start line, go to next sibling.\n    if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n        // Find max line number to stay within parent.\n        let expectedParentIndex = foldingRegion.parentIndex;\n        let maxLineNumber = 0;\n        if (expectedParentIndex !== -1) {\n            maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);\n        }\n        else if (foldingModel.regions.length === 0) {\n            return null;\n        }\n        else {\n            maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);\n        }\n        // Find fold at same level.\n        while (foldingRegion !== null) {\n            if (foldingRegion.regionIndex < foldingModel.regions.length) {\n                foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n                // Keep at same level.\n                if (foldingRegion.startLineNumber >= maxLineNumber) {\n                    return null;\n                }\n                else if (foldingRegion.parentIndex === expectedParentIndex) {\n                    return foldingRegion.startLineNumber;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    else {\n        // Go to first fold that's after the current line.\n        if (foldingModel.regions.length > 0) {\n            foldingRegion = foldingModel.regions.toRegion(0);\n            while (foldingRegion !== null) {\n                // Found fold after current line.\n                if (foldingRegion.startLineNumber > lineNumber) {\n                    return foldingRegion.startLineNumber;\n                }\n                if (foldingRegion.regionIndex < foldingModel.regions.length) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n                }\n                else {\n                    foldingRegion = null;\n                }\n            }\n        }\n    }\n    return null;\n}\n"]},"metadata":{},"sourceType":"module"}