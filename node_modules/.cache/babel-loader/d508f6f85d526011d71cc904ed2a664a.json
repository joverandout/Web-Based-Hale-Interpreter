{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n  constructor(token, index, fontStyle, foreground, background) {\n    this._parsedThemeRuleBrand = undefined;\n    this.token = token;\n    this.index = index;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n\n}\n/**\n * Parse a raw theme into rules.\n */\n\nexport function parseTokenTheme(source) {\n  if (!source || !Array.isArray(source)) {\n    return [];\n  }\n\n  const result = [];\n  let resultLen = 0;\n\n  for (let i = 0, len = source.length; i < len; i++) {\n    const entry = source[i];\n    let fontStyle = -1\n    /* NotSet */\n    ;\n\n    if (typeof entry.fontStyle === 'string') {\n      fontStyle = 0\n      /* None */\n      ;\n      const segments = entry.fontStyle.split(' ');\n\n      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n        const segment = segments[j];\n\n        switch (segment) {\n          case 'italic':\n            fontStyle = fontStyle | 1\n            /* Italic */\n            ;\n            break;\n\n          case 'bold':\n            fontStyle = fontStyle | 2\n            /* Bold */\n            ;\n            break;\n\n          case 'underline':\n            fontStyle = fontStyle | 4\n            /* Underline */\n            ;\n            break;\n\n          case 'strikethrough':\n            fontStyle = fontStyle | 8\n            /* Strikethrough */\n            ;\n            break;\n        }\n      }\n    }\n\n    let foreground = null;\n\n    if (typeof entry.foreground === 'string') {\n      foreground = entry.foreground;\n    }\n\n    let background = null;\n\n    if (typeof entry.background === 'string') {\n      background = entry.background;\n    }\n\n    result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n  }\n\n  return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\n\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n  // Sort rules lexicographically, and then by index if necessary\n  parsedThemeRules.sort((a, b) => {\n    const r = strcmp(a.token, b.token);\n\n    if (r !== 0) {\n      return r;\n    }\n\n    return a.index - b.index;\n  }); // Determine defaults\n\n  let defaultFontStyle = 0\n  /* None */\n  ;\n  let defaultForeground = '000000';\n  let defaultBackground = 'ffffff';\n\n  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n    const incomingDefaults = parsedThemeRules.shift();\n\n    if (incomingDefaults.fontStyle !== -1\n    /* NotSet */\n    ) {\n      defaultFontStyle = incomingDefaults.fontStyle;\n    }\n\n    if (incomingDefaults.foreground !== null) {\n      defaultForeground = incomingDefaults.foreground;\n    }\n\n    if (incomingDefaults.background !== null) {\n      defaultBackground = incomingDefaults.background;\n    }\n  }\n\n  const colorMap = new ColorMap(); // start with token colors from custom token themes\n\n  for (let color of customTokenColors) {\n    colorMap.getId(color);\n  }\n\n  const foregroundColorId = colorMap.getId(defaultForeground);\n  const backgroundColorId = colorMap.getId(defaultBackground);\n  const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n  const root = new ThemeTrieElement(defaults);\n\n  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n    const rule = parsedThemeRules[i];\n    root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n  }\n\n  return new TokenTheme(colorMap, root);\n}\n\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n  constructor() {\n    this._lastColorId = 0;\n    this._id2color = [];\n    this._color2id = new Map();\n  }\n\n  getId(color) {\n    if (color === null) {\n      return 0;\n    }\n\n    const match = color.match(colorRegExp);\n\n    if (!match) {\n      throw new Error('Illegal value for token color: ' + color);\n    }\n\n    color = match[1].toUpperCase();\n\n    let value = this._color2id.get(color);\n\n    if (value) {\n      return value;\n    }\n\n    value = ++this._lastColorId;\n\n    this._color2id.set(color, value);\n\n    this._id2color[value] = Color.fromHex('#' + color);\n    return value;\n  }\n\n  getColorMap() {\n    return this._id2color.slice(0);\n  }\n\n}\nexport class TokenTheme {\n  constructor(colorMap, root) {\n    this._colorMap = colorMap;\n    this._root = root;\n    this._cache = new Map();\n  }\n\n  static createFromRawTokenTheme(source, customTokenColors) {\n    return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n  }\n\n  static createFromParsedTokenTheme(source, customTokenColors) {\n    return resolveParsedTokenThemeRules(source, customTokenColors);\n  }\n\n  getColorMap() {\n    return this._colorMap.getColorMap();\n  }\n\n  _match(token) {\n    return this._root.match(token);\n  }\n\n  match(languageId, token) {\n    // The cache contains the metadata without the language bits set.\n    let result = this._cache.get(token);\n\n    if (typeof result === 'undefined') {\n      const rule = this._match(token);\n\n      const standardToken = toStandardTokenType(token);\n      result = (rule.metadata | standardToken << 8\n      /* TOKEN_TYPE_OFFSET */\n      ) >>> 0;\n\n      this._cache.set(token, result);\n    }\n\n    return (result | languageId << 0\n    /* LANGUAGEID_OFFSET */\n    ) >>> 0;\n  }\n\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n  const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n\n  if (!m) {\n    return 0\n    /* Other */\n    ;\n  }\n\n  switch (m[1]) {\n    case 'comment':\n      return 1\n      /* Comment */\n      ;\n\n    case 'string':\n      return 2\n      /* String */\n      ;\n\n    case 'regex':\n      return 3\n      /* RegEx */\n      ;\n\n    case 'regexp':\n      return 3\n      /* RegEx */\n      ;\n  }\n\n  throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n\n  if (a > b) {\n    return 1;\n  }\n\n  return 0;\n}\nexport class ThemeTrieElementRule {\n  constructor(fontStyle, foreground, background) {\n    this._themeTrieElementRuleBrand = undefined;\n    this._fontStyle = fontStyle;\n    this._foreground = foreground;\n    this._background = background;\n    this.metadata = (this._fontStyle << 10\n    /* FONT_STYLE_OFFSET */\n    | this._foreground << 14\n    /* FOREGROUND_OFFSET */\n    | this._background << 23\n    /* BACKGROUND_OFFSET */\n    ) >>> 0;\n  }\n\n  clone() {\n    return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n  }\n\n  acceptOverwrite(fontStyle, foreground, background) {\n    if (fontStyle !== -1\n    /* NotSet */\n    ) {\n      this._fontStyle = fontStyle;\n    }\n\n    if (foreground !== 0\n    /* None */\n    ) {\n      this._foreground = foreground;\n    }\n\n    if (background !== 0\n    /* None */\n    ) {\n      this._background = background;\n    }\n\n    this.metadata = (this._fontStyle << 10\n    /* FONT_STYLE_OFFSET */\n    | this._foreground << 14\n    /* FOREGROUND_OFFSET */\n    | this._background << 23\n    /* BACKGROUND_OFFSET */\n    ) >>> 0;\n  }\n\n}\nexport class ThemeTrieElement {\n  constructor(mainRule) {\n    this._themeTrieElementBrand = undefined;\n    this._mainRule = mainRule;\n    this._children = new Map();\n  }\n\n  match(token) {\n    if (token === '') {\n      return this._mainRule;\n    }\n\n    const dotIndex = token.indexOf('.');\n    let head;\n    let tail;\n\n    if (dotIndex === -1) {\n      head = token;\n      tail = '';\n    } else {\n      head = token.substring(0, dotIndex);\n      tail = token.substring(dotIndex + 1);\n    }\n\n    const child = this._children.get(head);\n\n    if (typeof child !== 'undefined') {\n      return child.match(tail);\n    }\n\n    return this._mainRule;\n  }\n\n  insert(token, fontStyle, foreground, background) {\n    if (token === '') {\n      // Merge into the main rule\n      this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n\n      return;\n    }\n\n    const dotIndex = token.indexOf('.');\n    let head;\n    let tail;\n\n    if (dotIndex === -1) {\n      head = token;\n      tail = '';\n    } else {\n      head = token.substring(0, dotIndex);\n      tail = token.substring(dotIndex + 1);\n    }\n\n    let child = this._children.get(head);\n\n    if (typeof child === 'undefined') {\n      child = new ThemeTrieElement(this._mainRule.clone());\n\n      this._children.set(head, child);\n    }\n\n    child.insert(tail, fontStyle, foreground, background);\n  }\n\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n  const rules = [];\n\n  for (let i = 1, len = colorMap.length; i < len; i++) {\n    const color = colorMap[i];\n    rules[i] = `.mtk${i} { color: ${color}; }`;\n  }\n\n  rules.push('.mtki { font-style: italic; }');\n  rules.push('.mtkb { font-weight: bold; }');\n  rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n  rules.push('.mtks { text-decoration: line-through; }');\n  rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n  return rules.join('\\n');\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js"],"names":["Color","ParsedTokenThemeRule","constructor","token","index","fontStyle","foreground","background","_parsedThemeRuleBrand","undefined","parseTokenTheme","source","Array","isArray","result","resultLen","i","len","length","entry","segments","split","j","lenJ","segment","resolveParsedTokenThemeRules","parsedThemeRules","customTokenColors","sort","a","b","r","strcmp","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","shift","colorMap","ColorMap","color","getId","foregroundColorId","backgroundColorId","defaults","ThemeTrieElementRule","root","ThemeTrieElement","rule","insert","TokenTheme","colorRegExp","_lastColorId","_id2color","_color2id","Map","match","Error","toUpperCase","value","get","set","fromHex","getColorMap","slice","_colorMap","_root","_cache","createFromRawTokenTheme","createFromParsedTokenTheme","_match","languageId","standardToken","toStandardTokenType","metadata","STANDARD_TOKEN_TYPE_REGEXP","tokenType","m","_themeTrieElementRuleBrand","_fontStyle","_foreground","_background","clone","acceptOverwrite","mainRule","_themeTrieElementBrand","_mainRule","_children","dotIndex","indexOf","head","tail","substring","child","generateTokensCSSForColorMap","rules","push","join"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (let color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* Comment */;\n        case 'string':\n            return 2 /* String */;\n        case 'regex':\n            return 3 /* RegEx */;\n        case 'regexp':\n            return 3 /* RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 10 /* FONT_STYLE_OFFSET */)\n            | (this._foreground << 14 /* FOREGROUND_OFFSET */)\n            | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 10 /* FONT_STYLE_OFFSET */)\n            | (this._foreground << 14 /* FOREGROUND_OFFSET */)\n            | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n"]},"metadata":{},"sourceType":"module"}