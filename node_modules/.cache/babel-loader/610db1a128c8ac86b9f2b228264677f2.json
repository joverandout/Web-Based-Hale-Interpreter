{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\n\nexport class SparseMultilineTokens {\n  constructor(startLineNumber, tokens) {\n    this._startLineNumber = startLineNumber;\n    this._tokens = tokens;\n    this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n  }\n\n  static create(startLineNumber, tokens) {\n    return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n  }\n  /**\n   * (Inclusive) start line number for these tokens.\n   */\n\n\n  get startLineNumber() {\n    return this._startLineNumber;\n  }\n  /**\n   * (Inclusive) end line number for these tokens.\n   */\n\n\n  get endLineNumber() {\n    return this._endLineNumber;\n  }\n\n  toString() {\n    return this._tokens.toString(this._startLineNumber);\n  }\n\n  _updateEndLineNumber() {\n    this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n  }\n\n  isEmpty() {\n    return this._tokens.isEmpty();\n  }\n\n  getLineTokens(lineNumber) {\n    if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n      return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n    }\n\n    return null;\n  }\n\n  getRange() {\n    const deltaRange = this._tokens.getRange();\n\n    if (!deltaRange) {\n      return deltaRange;\n    }\n\n    return new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n  }\n\n  removeTokens(range) {\n    const startLineIndex = range.startLineNumber - this._startLineNumber;\n    const endLineIndex = range.endLineNumber - this._startLineNumber;\n    this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\n    this._updateEndLineNumber();\n  }\n\n  split(range) {\n    // split tokens to two:\n    // a) all the tokens before `range`\n    // b) all the tokens after `range`\n    const startLineIndex = range.startLineNumber - this._startLineNumber;\n    const endLineIndex = range.endLineNumber - this._startLineNumber;\n\n    const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\n    return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n  }\n\n  applyEdit(range, text) {\n    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n    this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0\n    /* Null */\n    );\n  }\n\n  acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    this._acceptDeleteRange(range);\n\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n\n    this._updateEndLineNumber();\n  }\n\n  _acceptDeleteRange(range) {\n    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n      // Nothing to delete\n      return;\n    }\n\n    const firstLineIndex = range.startLineNumber - this._startLineNumber;\n    const lastLineIndex = range.endLineNumber - this._startLineNumber;\n\n    if (lastLineIndex < 0) {\n      // this deletion occurs entirely before this block, so we only need to adjust line numbers\n      const deletedLinesCount = lastLineIndex - firstLineIndex;\n      this._startLineNumber -= deletedLinesCount;\n      return;\n    }\n\n    const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n\n    if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n      // this deletion occurs entirely after this block, so there is nothing to do\n      return;\n    }\n\n    if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n      // this deletion completely encompasses this block\n      this._startLineNumber = 0;\n\n      this._tokens.clear();\n\n      return;\n    }\n\n    if (firstLineIndex < 0) {\n      const deletedBefore = -firstLineIndex;\n      this._startLineNumber -= deletedBefore;\n\n      this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n    } else {\n      this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n    }\n  }\n\n  _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      // Nothing to insert\n      return;\n    }\n\n    const lineIndex = position.lineNumber - this._startLineNumber;\n\n    if (lineIndex < 0) {\n      // this insertion occurs before this block, so we only need to adjust line numbers\n      this._startLineNumber += eolCount;\n      return;\n    }\n\n    const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n\n    if (lineIndex >= tokenMaxDeltaLine + 1) {\n      // this insertion occurs after this block, so there is nothing to do\n      return;\n    }\n\n    this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n  }\n\n}\n\nclass SparseMultilineTokensStorage {\n  constructor(tokens) {\n    this._tokens = tokens;\n    this._tokenCount = tokens.length / 4;\n  }\n\n  toString(startLineNumber) {\n    const pieces = [];\n\n    for (let i = 0; i < this._tokenCount; i++) {\n      pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n    }\n\n    return `[${pieces.join(',')}]`;\n  }\n\n  getMaxDeltaLine() {\n    const tokenCount = this._getTokenCount();\n\n    if (tokenCount === 0) {\n      return -1;\n    }\n\n    return this._getDeltaLine(tokenCount - 1);\n  }\n\n  getRange() {\n    const tokenCount = this._getTokenCount();\n\n    if (tokenCount === 0) {\n      return null;\n    }\n\n    const startChar = this._getStartCharacter(0);\n\n    const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n\n    const endChar = this._getEndCharacter(tokenCount - 1);\n\n    return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n  }\n\n  _getTokenCount() {\n    return this._tokenCount;\n  }\n\n  _getDeltaLine(tokenIndex) {\n    return this._tokens[4 * tokenIndex];\n  }\n\n  _getStartCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 1];\n  }\n\n  _getEndCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 2];\n  }\n\n  isEmpty() {\n    return this._getTokenCount() === 0;\n  }\n\n  getLineTokens(deltaLine) {\n    let low = 0;\n    let high = this._getTokenCount() - 1;\n\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2);\n\n      const midDeltaLine = this._getDeltaLine(mid);\n\n      if (midDeltaLine < deltaLine) {\n        low = mid + 1;\n      } else if (midDeltaLine > deltaLine) {\n        high = mid - 1;\n      } else {\n        let min = mid;\n\n        while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n          min--;\n        }\n\n        let max = mid;\n\n        while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n          max++;\n        }\n\n        return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n      }\n    }\n\n    if (this._getDeltaLine(low) === deltaLine) {\n      return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n    }\n\n    return null;\n  }\n\n  clear() {\n    this._tokenCount = 0;\n  }\n\n  removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    let newTokenCount = 0;\n    let hasDeletedTokens = false;\n    let firstDeltaLine = 0;\n\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 4 * i;\n      const tokenDeltaLine = tokens[srcOffset];\n      const tokenStartCharacter = tokens[srcOffset + 1];\n      const tokenEndCharacter = tokens[srcOffset + 2];\n      const tokenMetadata = tokens[srcOffset + 3];\n\n      if ((tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) && (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar)) {\n        hasDeletedTokens = true;\n      } else {\n        if (newTokenCount === 0) {\n          firstDeltaLine = tokenDeltaLine;\n        }\n\n        if (hasDeletedTokens) {\n          // must move the token to the left\n          const destOffset = 4 * newTokenCount;\n          tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n          tokens[destOffset + 1] = tokenStartCharacter;\n          tokens[destOffset + 2] = tokenEndCharacter;\n          tokens[destOffset + 3] = tokenMetadata;\n        }\n\n        newTokenCount++;\n      }\n    }\n\n    this._tokenCount = newTokenCount;\n    return firstDeltaLine;\n  }\n\n  split(startDeltaLine, startChar, endDeltaLine, endChar) {\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    const aTokens = [];\n    const bTokens = [];\n    let destTokens = aTokens;\n    let destOffset = 0;\n    let destFirstDeltaLine = 0;\n\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 4 * i;\n      const tokenDeltaLine = tokens[srcOffset];\n      const tokenStartCharacter = tokens[srcOffset + 1];\n      const tokenEndCharacter = tokens[srcOffset + 2];\n      const tokenMetadata = tokens[srcOffset + 3];\n\n      if (tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) {\n        if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar) {\n          // this token is touching the range\n          continue;\n        } else {\n          // this token is after the range\n          if (destTokens !== bTokens) {\n            // this token is the first token after the range\n            destTokens = bTokens;\n            destOffset = 0;\n            destFirstDeltaLine = tokenDeltaLine;\n          }\n        }\n      }\n\n      destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n      destTokens[destOffset++] = tokenStartCharacter;\n      destTokens[destOffset++] = tokenEndCharacter;\n      destTokens[destOffset++] = tokenMetadata;\n    }\n\n    return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n  }\n\n  acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n    // This is a bit complex, here are the cases I used to think about this:\n    //\n    // 1. The token starts before the deletion range\n    // 1a. The token is completely before the deletion range\n    //               -----------\n    //                          xxxxxxxxxxx\n    // 1b. The token starts before, the deletion range ends after the token\n    //               -----------\n    //                      xxxxxxxxxxx\n    // 1c. The token starts before, the deletion range ends precisely with the token\n    //               ---------------\n    //                      xxxxxxxx\n    // 1d. The token starts before, the deletion range is inside the token\n    //               ---------------\n    //                    xxxxx\n    //\n    // 2. The token starts at the same position with the deletion range\n    // 2a. The token starts at the same position, and ends inside the deletion range\n    //               -------\n    //               xxxxxxxxxxx\n    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n    //               ----------\n    //               xxxxxxxxxx\n    // 2c. The token starts at the same position, and ends after the deletion range\n    //               -------------\n    //               xxxxxxx\n    //\n    // 3. The token starts inside the deletion range\n    // 3a. The token is inside the deletion range\n    //                -------\n    //             xxxxxxxxxxxxx\n    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n    //                ----------\n    //             xxxxxxxxxxxxx\n    // 3c. The token starts inside the deletion range, and ends after the deletion range\n    //                ------------\n    //             xxxxxxxxxxx\n    //\n    // 4. The token starts after the deletion range\n    //                  -----------\n    //          xxxxxxxx\n    //\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    const deletedLineCount = endDeltaLine - startDeltaLine;\n    let newTokenCount = 0;\n    let hasDeletedTokens = false;\n\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 4 * i;\n      let tokenDeltaLine = tokens[srcOffset];\n      let tokenStartCharacter = tokens[srcOffset + 1];\n      let tokenEndCharacter = tokens[srcOffset + 2];\n      const tokenMetadata = tokens[srcOffset + 3];\n\n      if (tokenDeltaLine < startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter) {\n        // 1a. The token is completely before the deletion range\n        // => nothing to do\n        newTokenCount++;\n        continue;\n      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n        // 1b, 1c, 1d\n        // => the token survives, but it needs to shrink\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 1d. The token starts before, the deletion range is inside the token\n          // => the token shrinks by the deletion character count\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          // 1b. The token starts before, the deletion range ends after the token\n          // 1c. The token starts before, the deletion range ends precisely with the token\n          // => the token shrinks its ending to the deletion start\n          tokenEndCharacter = startCharacter;\n        }\n      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n        // 2a, 2b, 2c\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 2c. The token starts at the same position, and ends after the deletion range\n          // => the token shrinks by the deletion character count\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          // 2a. The token starts at the same position, and ends inside the deletion range\n          // 2b. The token starts at the same position, and ends at the same position as the deletion range\n          // => the token is deleted\n          hasDeletedTokens = true;\n          continue;\n        }\n      } else if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter) {\n        // 3a, 3b, 3c\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 3c. The token starts inside the deletion range, and ends after the deletion range\n          // => the token moves left and shrinks\n          if (tokenDeltaLine === startDeltaLine) {\n            // the deletion started on the same line as the token\n            // => the token moves left and shrinks\n            tokenStartCharacter = startCharacter;\n            tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n          } else {\n            // the deletion started on a line above the token\n            // => the token moves to the beginning of the line\n            tokenStartCharacter = 0;\n            tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n          }\n        } else {\n          // 3a. The token is inside the deletion range\n          // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n          // => the token is deleted\n          hasDeletedTokens = true;\n          continue;\n        }\n      } else if (tokenDeltaLine > endDeltaLine) {\n        // 4. (partial) The token starts after the deletion range, on a line below...\n        if (deletedLineCount === 0 && !hasDeletedTokens) {\n          // early stop, there is no need to walk all the tokens and do nothing...\n          newTokenCount = tokenCount;\n          break;\n        }\n\n        tokenDeltaLine -= deletedLineCount;\n      } else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n        // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n        if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n          tokenStartCharacter += horizontalShiftForFirstLineTokens;\n          tokenEndCharacter += horizontalShiftForFirstLineTokens;\n        }\n\n        tokenDeltaLine -= deletedLineCount;\n        tokenStartCharacter -= endCharacter - startCharacter;\n        tokenEndCharacter -= endCharacter - startCharacter;\n      } else {\n        throw new Error(`Not possible!`);\n      }\n\n      const destOffset = 4 * newTokenCount;\n      tokens[destOffset] = tokenDeltaLine;\n      tokens[destOffset + 1] = tokenStartCharacter;\n      tokens[destOffset + 2] = tokenEndCharacter;\n      tokens[destOffset + 3] = tokenMetadata;\n      newTokenCount++;\n    }\n\n    this._tokenCount = newTokenCount;\n  }\n\n  acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    // Here are the cases I used to think about this:\n    //\n    // 1. The token is completely before the insertion point\n    //            -----------   |\n    // 2. The token ends precisely at the insertion point\n    //            -----------|\n    // 3. The token contains the insertion point\n    //            -----|------\n    // 4. The token starts precisely at the insertion point\n    //            |-----------\n    // 5. The token is completely after the insertion point\n    //            |   -----------\n    //\n    const isInsertingPreciselyOneWordCharacter = eolCount === 0 && firstLineLength === 1 && (firstCharCode >= 48\n    /* Digit0 */\n    && firstCharCode <= 57\n    /* Digit9 */\n    || firstCharCode >= 65\n    /* A */\n    && firstCharCode <= 90\n    /* Z */\n    || firstCharCode >= 97\n    /* a */\n    && firstCharCode <= 122\n    /* z */\n    );\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n\n    for (let i = 0; i < tokenCount; i++) {\n      const offset = 4 * i;\n      let tokenDeltaLine = tokens[offset];\n      let tokenStartCharacter = tokens[offset + 1];\n      let tokenEndCharacter = tokens[offset + 2];\n\n      if (tokenDeltaLine < deltaLine || tokenDeltaLine === deltaLine && tokenEndCharacter < character) {\n        // 1. The token is completely before the insertion point\n        // => nothing to do\n        continue;\n      } else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n        // 2. The token ends precisely at the insertion point\n        // => expand the end character only if inserting precisely one character that is a word character\n        if (isInsertingPreciselyOneWordCharacter) {\n          tokenEndCharacter += 1;\n        } else {\n          continue;\n        }\n      } else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n        // 3. The token contains the insertion point\n        if (eolCount === 0) {\n          // => just expand the end character\n          tokenEndCharacter += firstLineLength;\n        } else {\n          // => cut off the token\n          tokenEndCharacter = character;\n        }\n      } else {\n        // 4. or 5.\n        if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n          // 4. The token starts precisely at the insertion point\n          // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n          // => otherwise behave as in case 5.\n          if (isInsertingPreciselyOneWordCharacter) {\n            continue;\n          }\n        } // => the token must move and keep its size constant\n\n\n        if (tokenDeltaLine === deltaLine) {\n          tokenDeltaLine += eolCount; // this token is on the line where the insertion is taking place\n\n          if (eolCount === 0) {\n            tokenStartCharacter += firstLineLength;\n            tokenEndCharacter += firstLineLength;\n          } else {\n            const tokenLength = tokenEndCharacter - tokenStartCharacter;\n            tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n            tokenEndCharacter = tokenStartCharacter + tokenLength;\n          }\n        } else {\n          tokenDeltaLine += eolCount;\n        }\n      }\n\n      tokens[offset] = tokenDeltaLine;\n      tokens[offset + 1] = tokenStartCharacter;\n      tokens[offset + 2] = tokenEndCharacter;\n    }\n  }\n\n}\n\nexport class SparseLineTokens {\n  constructor(tokens) {\n    this._tokens = tokens;\n  }\n\n  getCount() {\n    return this._tokens.length / 4;\n  }\n\n  getStartCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 1];\n  }\n\n  getEndCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 2];\n  }\n\n  getMetadata(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 3];\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js"],"names":["Position","Range","countEOL","SparseMultilineTokens","constructor","startLineNumber","tokens","_startLineNumber","_tokens","_endLineNumber","getMaxDeltaLine","create","SparseMultilineTokensStorage","endLineNumber","toString","_updateEndLineNumber","isEmpty","getLineTokens","lineNumber","getRange","deltaRange","startColumn","endColumn","removeTokens","range","startLineIndex","endLineIndex","split","a","b","bDeltaLine","applyEdit","text","eolCount","firstLineLength","lastLineLength","acceptEdit","length","charCodeAt","firstCharCode","_acceptDeleteRange","_acceptInsertText","firstLineIndex","lastLineIndex","deletedLinesCount","tokenMaxDeltaLine","clear","deletedBefore","acceptDeleteRange","position","lineIndex","acceptInsertText","column","_tokenCount","pieces","i","push","_getDeltaLine","_getStartCharacter","_getEndCharacter","join","tokenCount","_getTokenCount","startChar","maxDeltaLine","endChar","tokenIndex","deltaLine","low","high","mid","Math","floor","midDeltaLine","min","max","SparseLineTokens","subarray","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","tokenMetadata","destOffset","aTokens","bTokens","destTokens","destFirstDeltaLine","Uint32Array","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","Error","character","isInsertingPreciselyOneWordCharacter","offset","tokenLength","getCount","getStartCharacter","getEndCharacter","getMetadata"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    static create(startLineNumber, tokens) {\n        return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._endLineNumber;\n    }\n    toString() {\n        return this._tokens.toString(this._startLineNumber);\n    }\n    _updateEndLineNumber() {\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    isEmpty() {\n        return this._tokens.isEmpty();\n    }\n    getLineTokens(lineNumber) {\n        if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n            return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n        }\n        return null;\n    }\n    getRange() {\n        const deltaRange = this._tokens.getRange();\n        if (!deltaRange) {\n            return deltaRange;\n        }\n        return new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n    removeTokens(range) {\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        this._updateEndLineNumber();\n    }\n    split(range) {\n        // split tokens to two:\n        // a) all the tokens before `range`\n        // b) all the tokens after `range`\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n    }\n    applyEdit(range, text) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n        this._updateEndLineNumber();\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            // Nothing to delete\n            return;\n        }\n        const firstLineIndex = range.startLineNumber - this._startLineNumber;\n        const lastLineIndex = range.endLineNumber - this._startLineNumber;\n        if (lastLineIndex < 0) {\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\n            this._startLineNumber -= deletedLinesCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion occurs entirely after this block, so there is nothing to do\n            return;\n        }\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion completely encompasses this block\n            this._startLineNumber = 0;\n            this._tokens.clear();\n            return;\n        }\n        if (firstLineIndex < 0) {\n            const deletedBefore = -firstLineIndex;\n            this._startLineNumber -= deletedBefore;\n            this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n        }\n        else {\n            this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n        }\n    }\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - this._startLineNumber;\n        if (lineIndex < 0) {\n            // this insertion occurs before this block, so we only need to adjust line numbers\n            this._startLineNumber += eolCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\n            // this insertion occurs after this block, so there is nothing to do\n            return;\n        }\n        this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n}\nclass SparseMultilineTokensStorage {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._tokenCount = tokens.length / 4;\n    }\n    toString(startLineNumber) {\n        const pieces = [];\n        for (let i = 0; i < this._tokenCount; i++) {\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n        }\n        return `[${pieces.join(',')}]`;\n    }\n    getMaxDeltaLine() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return -1;\n        }\n        return this._getDeltaLine(tokenCount - 1);\n    }\n    getRange() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return null;\n        }\n        const startChar = this._getStartCharacter(0);\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n        const endChar = this._getEndCharacter(tokenCount - 1);\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n    _getTokenCount() {\n        return this._tokenCount;\n    }\n    _getDeltaLine(tokenIndex) {\n        return this._tokens[4 * tokenIndex];\n    }\n    _getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    _getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    isEmpty() {\n        return (this._getTokenCount() === 0);\n    }\n    getLineTokens(deltaLine) {\n        let low = 0;\n        let high = this._getTokenCount() - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const midDeltaLine = this._getDeltaLine(mid);\n            if (midDeltaLine < deltaLine) {\n                low = mid + 1;\n            }\n            else if (midDeltaLine > deltaLine) {\n                high = mid - 1;\n            }\n            else {\n                let min = mid;\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n                    min--;\n                }\n                let max = mid;\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n                    max++;\n                }\n                return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n            }\n        }\n        if (this._getDeltaLine(low) === deltaLine) {\n            return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n        }\n        return null;\n    }\n    clear() {\n        this._tokenCount = 0;\n    }\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        let firstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                hasDeletedTokens = true;\n            }\n            else {\n                if (newTokenCount === 0) {\n                    firstDeltaLine = tokenDeltaLine;\n                }\n                if (hasDeletedTokens) {\n                    // must move the token to the left\n                    const destOffset = 4 * newTokenCount;\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n                    tokens[destOffset + 1] = tokenStartCharacter;\n                    tokens[destOffset + 2] = tokenEndCharacter;\n                    tokens[destOffset + 3] = tokenMetadata;\n                }\n                newTokenCount++;\n            }\n        }\n        this._tokenCount = newTokenCount;\n        return firstDeltaLine;\n    }\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const aTokens = [];\n        const bTokens = [];\n        let destTokens = aTokens;\n        let destOffset = 0;\n        let destFirstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                    // this token is touching the range\n                    continue;\n                }\n                else {\n                    // this token is after the range\n                    if (destTokens !== bTokens) {\n                        // this token is the first token after the range\n                        destTokens = bTokens;\n                        destOffset = 0;\n                        destFirstDeltaLine = tokenDeltaLine;\n                    }\n                }\n            }\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n            destTokens[destOffset++] = tokenStartCharacter;\n            destTokens[destOffset++] = tokenEndCharacter;\n            destTokens[destOffset++] = tokenMetadata;\n        }\n        return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n        // This is a bit complex, here are the cases I used to think about this:\n        //\n        // 1. The token starts before the deletion range\n        // 1a. The token is completely before the deletion range\n        //               -----------\n        //                          xxxxxxxxxxx\n        // 1b. The token starts before, the deletion range ends after the token\n        //               -----------\n        //                      xxxxxxxxxxx\n        // 1c. The token starts before, the deletion range ends precisely with the token\n        //               ---------------\n        //                      xxxxxxxx\n        // 1d. The token starts before, the deletion range is inside the token\n        //               ---------------\n        //                    xxxxx\n        //\n        // 2. The token starts at the same position with the deletion range\n        // 2a. The token starts at the same position, and ends inside the deletion range\n        //               -------\n        //               xxxxxxxxxxx\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\n        //               ----------\n        //               xxxxxxxxxx\n        // 2c. The token starts at the same position, and ends after the deletion range\n        //               -------------\n        //               xxxxxxx\n        //\n        // 3. The token starts inside the deletion range\n        // 3a. The token is inside the deletion range\n        //                -------\n        //             xxxxxxxxxxxxx\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n        //                ----------\n        //             xxxxxxxxxxxxx\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\n        //                ------------\n        //             xxxxxxxxxxx\n        //\n        // 4. The token starts after the deletion range\n        //                  -----------\n        //          xxxxxxxx\n        //\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            let tokenDeltaLine = tokens[srcOffset];\n            let tokenStartCharacter = tokens[srcOffset + 1];\n            let tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n                // 1a. The token is completely before the deletion range\n                // => nothing to do\n                newTokenCount++;\n                continue;\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n                // 1b, 1c, 1d\n                // => the token survives, but it needs to shrink\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 1d. The token starts before, the deletion range is inside the token\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 1b. The token starts before, the deletion range ends after the token\n                    // 1c. The token starts before, the deletion range ends precisely with the token\n                    // => the token shrinks its ending to the deletion start\n                    tokenEndCharacter = startCharacter;\n                }\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n                // 2a, 2b, 2c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 2c. The token starts at the same position, and ends after the deletion range\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 2a. The token starts at the same position, and ends inside the deletion range\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n                // 3a, 3b, 3c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\n                    // => the token moves left and shrinks\n                    if (tokenDeltaLine === startDeltaLine) {\n                        // the deletion started on the same line as the token\n                        // => the token moves left and shrinks\n                        tokenStartCharacter = startCharacter;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                    else {\n                        // the deletion started on a line above the token\n                        // => the token moves to the beginning of the line\n                        tokenStartCharacter = 0;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                }\n                else {\n                    // 3a. The token is inside the deletion range\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine > endDeltaLine) {\n                // 4. (partial) The token starts after the deletion range, on a line below...\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\n                    // early stop, there is no need to walk all the tokens and do nothing...\n                    newTokenCount = tokenCount;\n                    break;\n                }\n                tokenDeltaLine -= deletedLineCount;\n            }\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\n                }\n                tokenDeltaLine -= deletedLineCount;\n                tokenStartCharacter -= (endCharacter - startCharacter);\n                tokenEndCharacter -= (endCharacter - startCharacter);\n            }\n            else {\n                throw new Error(`Not possible!`);\n            }\n            const destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n            newTokenCount++;\n        }\n        this._tokenCount = newTokenCount;\n    }\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        // Here are the cases I used to think about this:\n        //\n        // 1. The token is completely before the insertion point\n        //            -----------   |\n        // 2. The token ends precisely at the insertion point\n        //            -----------|\n        // 3. The token contains the insertion point\n        //            -----|------\n        // 4. The token starts precisely at the insertion point\n        //            |-----------\n        // 5. The token is completely after the insertion point\n        //            |   -----------\n        //\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\n            && firstLineLength === 1\n            && ((firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */)\n                || (firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */)\n                || (firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */)));\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        for (let i = 0; i < tokenCount; i++) {\n            const offset = 4 * i;\n            let tokenDeltaLine = tokens[offset];\n            let tokenStartCharacter = tokens[offset + 1];\n            let tokenEndCharacter = tokens[offset + 2];\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n                // 1. The token is completely before the insertion point\n                // => nothing to do\n                continue;\n            }\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n                // 2. The token ends precisely at the insertion point\n                // => expand the end character only if inserting precisely one character that is a word character\n                if (isInsertingPreciselyOneWordCharacter) {\n                    tokenEndCharacter += 1;\n                }\n                else {\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n                // 3. The token contains the insertion point\n                if (eolCount === 0) {\n                    // => just expand the end character\n                    tokenEndCharacter += firstLineLength;\n                }\n                else {\n                    // => cut off the token\n                    tokenEndCharacter = character;\n                }\n            }\n            else {\n                // 4. or 5.\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n                    // 4. The token starts precisely at the insertion point\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n                    // => otherwise behave as in case 5.\n                    if (isInsertingPreciselyOneWordCharacter) {\n                        continue;\n                    }\n                }\n                // => the token must move and keep its size constant\n                if (tokenDeltaLine === deltaLine) {\n                    tokenDeltaLine += eolCount;\n                    // this token is on the line where the insertion is taking place\n                    if (eolCount === 0) {\n                        tokenStartCharacter += firstLineLength;\n                        tokenEndCharacter += firstLineLength;\n                    }\n                    else {\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\n                    }\n                }\n                else {\n                    tokenDeltaLine += eolCount;\n                }\n            }\n            tokens[offset] = tokenDeltaLine;\n            tokens[offset + 1] = tokenStartCharacter;\n            tokens[offset + 2] = tokenEndCharacter;\n        }\n    }\n}\nexport class SparseLineTokens {\n    constructor(tokens) {\n        this._tokens = tokens;\n    }\n    getCount() {\n        return this._tokens.length / 4;\n    }\n    getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    getMetadata(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 3];\n    }\n}\n"]},"metadata":{},"sourceType":"module"}