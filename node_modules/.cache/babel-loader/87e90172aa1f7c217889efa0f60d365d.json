{"ast":null,"code":"import * as queryString from 'query-string';\nimport fromEntries from './fromEntries';\nimport validatePathConfig from './validatePathConfig';\n\nconst getActiveRoute = state => {\n  const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\n\n\nexport default function getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  } // Create a normalized configs object which will be easier to use\n\n\n  const configs = options !== null && options !== void 0 && options.screens ? createNormalizedConfigs(options === null || options === void 0 ? void 0 : options.screens) : {};\n  let path = '/';\n  let current = state;\n  const allParams = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index];\n    let pattern;\n    let focusedParams;\n    let focusedRoute = getActiveRoute(state);\n    let currentOptions = configs; // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n\n    let nestedRouteNames = [];\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        var _currentOptions$route;\n\n        const stringify = (_currentOptions$route = currentOptions[route.name]) === null || _currentOptions$route === void 0 ? void 0 : _currentOptions$route.stringify;\n        const currentParams = fromEntries(Object.entries(route.params).map(_ref => {\n          let [key, value] = _ref;\n          return [key, stringify !== null && stringify !== void 0 && stringify[key] ? stringify[key](value) : String(value)];\n        }));\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          var _pattern; // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n\n\n          focusedParams = { ...currentParams\n          };\n          (_pattern = pattern) === null || _pattern === void 0 ? void 0 : _pattern.split('/').filter(p => p.startsWith(':')) // eslint-disable-next-line no-loop-func\n          .forEach(p => {\n            const name = getParamName(p); // Remove the params present in the pattern since we'll only use the rest for query string\n\n            if (focusedParams) {\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete focusedParams[name];\n            }\n          });\n        }\n      } // If there is no `screens` property or no nested state, we return pattern\n\n\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens; // if there is config for next route name, we go deeper\n\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern.split('/').map(p => {\n        const name = getParamName(p); // We don't know what to show for wildcard patterns\n        // Showing the route name seems ok, though whatever we show here will be incorrect\n        // Since the page doesn't actually exist\n\n        if (p === '*') {\n          return route.name;\n        } // If the path has a pattern for a param, put the param in the path\n\n\n        if (p.startsWith(':')) {\n          const value = allParams[name];\n\n          if (value === undefined && p.endsWith('?')) {\n            // Optional params without value assigned in route.params should be ignored\n            return '';\n          }\n\n          return encodeURIComponent(value);\n        }\n\n        return encodeURIComponent(p);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (let param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams, {\n        sort: false\n      });\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  } // Remove multiple as well as trailing slashes\n\n\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  return path;\n}\n\nconst getParamName = pattern => pattern.replace(/^:/, '').replace(/\\?$/, '');\n\nconst joinPaths = function () {\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n\n  return [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');\n};\n\nconst createConfigItem = (config, parentPattern) => {\n  var _pattern2;\n\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n    return {\n      pattern\n    };\n  } // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n\n\n  let pattern;\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n\n  pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: (_pattern2 = pattern) === null || _pattern2 === void 0 ? void 0 : _pattern2.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens\n  };\n};\n\nconst createNormalizedConfigs = (options, pattern) => fromEntries(Object.entries(options).map(_ref2 => {\n  let [name, c] = _ref2;\n  const result = createConfigItem(c, pattern);\n  return [name, result];\n}));","map":{"version":3,"sources":["getPathFromState.tsx"],"names":["getActiveRoute","state","route","Error","validatePathConfig","configs","options","createNormalizedConfigs","path","current","allParams","index","focusedRoute","currentOptions","nestedRouteNames","hasNext","pattern","stringify","currentParams","fromEntries","String","Object","focusedParams","p","name","getParamName","nextRoute","nestedConfig","value","encodeURIComponent","query","sort","joinPaths","paths","createConfigItem","parentPattern","config","screens","result"],"mappings":"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","sourcesContent":["import type {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport * as queryString from 'query-string';\n\nimport fromEntries from './fromEntries';\nimport type { PathConfig, PathConfigMap } from './types';\nimport validatePathConfig from './validatePathConfig';\n\ntype Options<ParamList> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState<ParamList extends {}>(\n  state: State,\n  options?: Options<ParamList>\n): string {\n  if (state == null) {\n    throw Error(\n      \"Got 'undefined' for the navigation state. You must pass a valid state object.\"\n    );\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  // Create a normalized configs object which will be easier to use\n  const configs: Record<string, ConfigItem> = options?.screens\n    ? createNormalizedConfigs(options?.screens)\n    : {};\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let focusedParams: Record<string, any> | undefined;\n    let focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        const currentParams = fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          pattern\n            ?.split('/')\n            .filter((p) => p.startsWith(':'))\n            // eslint-disable-next-line no-loop-func\n            .forEach((p) => {\n              const name = getParamName(p);\n\n              // Remove the params present in the pattern since we'll only use the rest for query string\n              if (focusedParams) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete focusedParams[name];\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = getParamName(p);\n\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (p === '*') {\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (let param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams, { sort: false });\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n\nconst getParamName = (pattern: string) =>\n  pattern.replace(/^:/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  let pattern: string | undefined;\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  pattern =\n    config.exact !== true\n      ? joinPaths(parentPattern || '', config.path || '')\n      : config.path || '';\n\n  const screens = config.screens\n    ? createNormalizedConfigs(config.screens, pattern)\n    : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, pattern);\n\n      return [name, result];\n    })\n  );\n"]},"metadata":{},"sourceType":"module"}