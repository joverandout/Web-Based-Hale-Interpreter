{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var TextAreaSyntethicEvents;\n\n(function (TextAreaSyntethicEvents) {\n  TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\n\nexport const CopyOptions = {\n  forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\n\nexport class InMemoryClipboardMetadataManager {\n  constructor() {\n    this._lastState = null;\n  }\n\n  set(lastCopiedValue, data) {\n    this._lastState = {\n      lastCopiedValue,\n      data\n    };\n  }\n\n  get(pastedText) {\n    if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n      // match!\n      return this._lastState.data;\n    }\n\n    this._lastState = null;\n    return null;\n  }\n\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\n\nclass CompositionContext {\n  constructor() {\n    this._lastTypeTextLength = 0;\n  }\n\n  handleCompositionUpdate(text) {\n    text = text || '';\n    const typeInput = {\n      text: text,\n      replacePrevCharCnt: this._lastTypeTextLength,\n      replaceNextCharCnt: 0,\n      positionDelta: 0\n    };\n    this._lastTypeTextLength = text.length;\n    return typeInput;\n  }\n\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\n\n\nexport class TextAreaInput extends Disposable {\n  constructor(_host, _textArea, _OS, _browser) {\n    super();\n    this._host = _host;\n    this._textArea = _textArea;\n    this._OS = _OS;\n    this._browser = _browser;\n    this._onFocus = this._register(new Emitter());\n    this.onFocus = this._onFocus.event;\n    this._onBlur = this._register(new Emitter());\n    this.onBlur = this._onBlur.event;\n    this._onKeyDown = this._register(new Emitter());\n    this.onKeyDown = this._onKeyDown.event;\n    this._onKeyUp = this._register(new Emitter());\n    this.onKeyUp = this._onKeyUp.event;\n    this._onCut = this._register(new Emitter());\n    this.onCut = this._onCut.event;\n    this._onPaste = this._register(new Emitter());\n    this.onPaste = this._onPaste.event;\n    this._onType = this._register(new Emitter());\n    this.onType = this._onType.event;\n    this._onCompositionStart = this._register(new Emitter());\n    this.onCompositionStart = this._onCompositionStart.event;\n    this._onCompositionUpdate = this._register(new Emitter());\n    this.onCompositionUpdate = this._onCompositionUpdate.event;\n    this._onCompositionEnd = this._register(new Emitter());\n    this.onCompositionEnd = this._onCompositionEnd.event;\n    this._onSelectionChangeRequest = this._register(new Emitter());\n    this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n    this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n    this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n    this._textAreaState = TextAreaState.EMPTY;\n    this._selectionChangeListener = null;\n    this.writeScreenReaderContent('ctor');\n    this._hasFocus = false;\n    this._currentComposition = null;\n    let lastKeyDown = null;\n\n    this._register(this._textArea.onKeyDown(_e => {\n      const e = new StandardKeyboardEvent(_e);\n\n      if (e.keyCode === 109\n      /* KEY_IN_COMPOSITION */\n      || this._currentComposition && e.keyCode === 1\n      /* Backspace */\n      ) {\n        // Stop propagation for keyDown events if the IME is processing key input\n        e.stopPropagation();\n      }\n\n      if (e.equals(9\n      /* Escape */\n      )) {\n        // Prevent default always for `Esc`, otherwise it will generate a keypress\n        // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n        e.preventDefault();\n      }\n\n      lastKeyDown = e;\n\n      this._onKeyDown.fire(e);\n    }));\n\n    this._register(this._textArea.onKeyUp(_e => {\n      const e = new StandardKeyboardEvent(_e);\n\n      this._onKeyUp.fire(e);\n    }));\n\n    this._register(this._textArea.onCompositionStart(e => {\n      if (_debugComposition) {\n        console.log(`[compositionstart]`, e);\n      }\n\n      const currentComposition = new CompositionContext();\n\n      if (this._currentComposition) {\n        // simply reset the composition context\n        this._currentComposition = currentComposition;\n        return;\n      }\n\n      this._currentComposition = currentComposition;\n\n      if (this._OS === 2\n      /* Macintosh */\n      && lastKeyDown && lastKeyDown.equals(109\n      /* KEY_IN_COMPOSITION */\n      ) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n        // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n        if (_debugComposition) {\n          console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n        } // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n\n\n        currentComposition.handleCompositionUpdate('x');\n\n        this._onCompositionStart.fire({\n          data: e.data\n        });\n\n        return;\n      }\n\n      if (this._browser.isAndroid) {\n        // when tapping on the editor, Android enters composition mode to edit the current word\n        // so we cannot clear the textarea on Android and we must pretend the current word was selected\n        this._onCompositionStart.fire({\n          data: e.data\n        });\n\n        return;\n      }\n\n      this._onCompositionStart.fire({\n        data: e.data\n      });\n    }));\n\n    this._register(this._textArea.onCompositionUpdate(e => {\n      if (_debugComposition) {\n        console.log(`[compositionupdate]`, e);\n      }\n\n      const currentComposition = this._currentComposition;\n\n      if (!currentComposition) {\n        // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n        return;\n      }\n\n      if (this._browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        const newState = TextAreaState.readFromTextArea(this._textArea);\n        const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n        this._textAreaState = newState;\n\n        this._onType.fire(typeInput);\n\n        this._onCompositionUpdate.fire(e);\n\n        return;\n      }\n\n      const typeInput = currentComposition.handleCompositionUpdate(e.data);\n      this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n\n      this._onType.fire(typeInput);\n\n      this._onCompositionUpdate.fire(e);\n    }));\n\n    this._register(this._textArea.onCompositionEnd(e => {\n      if (_debugComposition) {\n        console.log(`[compositionend]`, e);\n      }\n\n      const currentComposition = this._currentComposition;\n\n      if (!currentComposition) {\n        // https://github.com/microsoft/monaco-editor/issues/1663\n        // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n        return;\n      }\n\n      this._currentComposition = null;\n\n      if (this._browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        const newState = TextAreaState.readFromTextArea(this._textArea);\n        const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n        this._textAreaState = newState;\n\n        this._onType.fire(typeInput);\n\n        this._onCompositionEnd.fire();\n\n        return;\n      }\n\n      const typeInput = currentComposition.handleCompositionUpdate(e.data);\n      this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n\n      this._onType.fire(typeInput);\n\n      this._onCompositionEnd.fire();\n    }));\n\n    this._register(this._textArea.onInput(e => {\n      if (_debugComposition) {\n        console.log(`[input]`, e);\n      } // Pretend here we touched the text area, as the `input` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n\n\n      this._textArea.setIgnoreSelectionChangeTime('received input event');\n\n      if (this._currentComposition) {\n        return;\n      }\n\n      const newState = TextAreaState.readFromTextArea(this._textArea);\n      const typeInput = TextAreaState.deduceInput(this._textAreaState, newState,\n      /*couldBeEmojiInput*/\n      this._OS === 2\n      /* Macintosh */\n      );\n\n      if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n        // Ignore invalid input but keep it around for next time\n        return;\n      }\n\n      this._textAreaState = newState;\n\n      if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0 || typeInput.replaceNextCharCnt !== 0 || typeInput.positionDelta !== 0) {\n        this._onType.fire(typeInput);\n      }\n    })); // --- Clipboard operations\n\n\n    this._register(this._textArea.onCut(e => {\n      // Pretend here we touched the text area, as the `cut` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received cut event');\n\n      this._ensureClipboardGetsEditorSelection(e);\n\n      this._asyncTriggerCut.schedule();\n    }));\n\n    this._register(this._textArea.onCopy(e => {\n      this._ensureClipboardGetsEditorSelection(e);\n    }));\n\n    this._register(this._textArea.onPaste(e => {\n      // Pretend here we touched the text area, as the `paste` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received paste event');\n\n      e.preventDefault();\n\n      if (!e.clipboardData) {\n        return;\n      }\n\n      let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n\n      if (!text) {\n        return;\n      } // try the in-memory store\n\n\n      metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n\n      this._onPaste.fire({\n        text: text,\n        metadata: metadata\n      });\n    }));\n\n    this._register(this._textArea.onFocus(() => {\n      const hadFocus = this._hasFocus;\n\n      this._setHasFocus(true);\n\n      if (this._browser.isSafari && !hadFocus && this._hasFocus) {\n        // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n        // Safari will always move the selection at offset 0 in the textarea\n        this._asyncFocusGainWriteScreenReaderContent.schedule();\n      }\n    }));\n\n    this._register(this._textArea.onBlur(() => {\n      if (this._currentComposition) {\n        // See https://github.com/microsoft/vscode/issues/112621\n        // where compositionend is not triggered when the editor\n        // is taken off-dom during a composition\n        // Clear the flag to be able to write to the textarea\n        this._currentComposition = null; // Clear the textarea to avoid an unwanted cursor type\n\n        this.writeScreenReaderContent('blurWithoutCompositionEnd'); // Fire artificial composition end\n\n        this._onCompositionEnd.fire();\n      }\n\n      this._setHasFocus(false);\n    }));\n\n    this._register(this._textArea.onSyntheticTap(() => {\n      if (this._browser.isAndroid && this._currentComposition) {\n        // on Android, tapping does not cancel the current composition, so the\n        // textarea is stuck showing the old composition\n        // Clear the flag to be able to write to the textarea\n        this._currentComposition = null; // Clear the textarea to avoid an unwanted cursor type\n\n        this.writeScreenReaderContent('tapWithoutCompositionEnd'); // Fire artificial composition end\n\n        this._onCompositionEnd.fire();\n      }\n    }));\n  }\n\n  _installSelectionChangeListener() {\n    // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n    // When using a Braille display, it is possible for users to reposition the\n    // system caret. This is reflected in Chrome as a `selectionchange` event.\n    //\n    // The `selectionchange` event appears to be emitted under numerous other circumstances,\n    // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n    // using a Braille display from all the other cases.\n    //\n    // The problems with the `selectionchange` event are:\n    //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n    //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n    //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n    //  * the event is emitted when tabbing into the textarea\n    //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n    //  * the event sometimes comes in bursts for a single logical textarea operation\n    // `selectionchange` events often come multiple times for a single logical change\n    // so throttle multiple `selectionchange` events that burst in a short period of time.\n    let previousSelectionChangeEventTime = 0;\n    return dom.addDisposableListener(document, 'selectionchange', e => {\n      if (!this._hasFocus) {\n        return;\n      }\n\n      if (this._currentComposition) {\n        return;\n      }\n\n      if (!this._browser.isChrome) {\n        // Support only for Chrome until testing happens on other browsers\n        return;\n      }\n\n      const now = Date.now();\n      const delta1 = now - previousSelectionChangeEventTime;\n      previousSelectionChangeEventTime = now;\n\n      if (delta1 < 5) {\n        // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n        // => ignore it\n        return;\n      }\n\n      const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n\n      this._textArea.resetSelectionChangeTime();\n\n      if (delta2 < 100) {\n        // received a `selectionchange` event within 100ms since we touched the textarea\n        // => ignore it, since we caused it\n        return;\n      }\n\n      if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n\n      const newValue = this._textArea.getValue();\n\n      if (this._textAreaState.value !== newValue) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n\n      const newSelectionStart = this._textArea.getSelectionStart();\n\n      const newSelectionEnd = this._textArea.getSelectionEnd();\n\n      if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n        // Nothing to do...\n        return;\n      }\n\n      const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n\n      const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n\n      const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n\n      const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n\n      const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n\n      this._onSelectionChangeRequest.fire(newSelection);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n\n      this._selectionChangeListener = null;\n    }\n  }\n\n  focusTextArea() {\n    // Setting this._hasFocus and writing the screen reader content\n    // will result in a focus() and setSelectionRange() in the textarea\n    this._setHasFocus(true); // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n\n\n    this.refreshFocusState();\n  }\n\n  isFocused() {\n    return this._hasFocus;\n  }\n\n  refreshFocusState() {\n    this._setHasFocus(this._textArea.hasFocus());\n  }\n\n  _setHasFocus(newHasFocus) {\n    if (this._hasFocus === newHasFocus) {\n      // no change\n      return;\n    }\n\n    this._hasFocus = newHasFocus;\n\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n\n      this._selectionChangeListener = null;\n    }\n\n    if (this._hasFocus) {\n      this._selectionChangeListener = this._installSelectionChangeListener();\n    }\n\n    if (this._hasFocus) {\n      this.writeScreenReaderContent('focusgain');\n    }\n\n    if (this._hasFocus) {\n      this._onFocus.fire();\n    } else {\n      this._onBlur.fire();\n    }\n  }\n\n  _setAndWriteTextAreaState(reason, textAreaState) {\n    if (!this._hasFocus) {\n      textAreaState = textAreaState.collapseSelection();\n    }\n\n    textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n    this._textAreaState = textAreaState;\n  }\n\n  writeScreenReaderContent(reason) {\n    if (this._currentComposition) {\n      // Do not write to the text area when doing composition\n      return;\n    }\n\n    this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n  }\n\n  _ensureClipboardGetsEditorSelection(e) {\n    const dataToCopy = this._host.getDataToCopy();\n\n    const storedMetadata = {\n      version: 1,\n      isFromEmptySelection: dataToCopy.isFromEmptySelection,\n      multicursorText: dataToCopy.multicursorText,\n      mode: dataToCopy.mode\n    };\n    InMemoryClipboardMetadataManager.INSTANCE.set( // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n    // Firefox pastes \"LINE\\n\", so let's work around this quirk\n    this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text, storedMetadata);\n    e.preventDefault();\n\n    if (e.clipboardData) {\n      ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n    }\n  }\n\n}\n\nclass ClipboardEventUtils {\n  static getTextData(clipboardData) {\n    const text = clipboardData.getData(Mimes.text);\n    let metadata = null;\n    const rawmetadata = clipboardData.getData('vscode-editor-data');\n\n    if (typeof rawmetadata === 'string') {\n      try {\n        metadata = JSON.parse(rawmetadata);\n\n        if (metadata.version !== 1) {\n          metadata = null;\n        }\n      } catch (err) {// no problem!\n      }\n    }\n\n    return [text, metadata];\n  }\n\n  static setTextData(clipboardData, text, html, metadata) {\n    clipboardData.setData(Mimes.text, text);\n\n    if (typeof html === 'string') {\n      clipboardData.setData('text/html', html);\n    }\n\n    clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n  }\n\n}\n\nexport class TextAreaWrapper extends Disposable {\n  constructor(_actual) {\n    super();\n    this._actual = _actual;\n    this.onKeyDown = this._register(dom.createEventEmitter(this._actual, 'keydown')).event;\n    this.onKeyUp = this._register(dom.createEventEmitter(this._actual, 'keyup')).event;\n    this.onCompositionStart = this._register(dom.createEventEmitter(this._actual, 'compositionstart')).event;\n    this.onCompositionUpdate = this._register(dom.createEventEmitter(this._actual, 'compositionupdate')).event;\n    this.onCompositionEnd = this._register(dom.createEventEmitter(this._actual, 'compositionend')).event;\n    this.onInput = this._register(dom.createEventEmitter(this._actual, 'input')).event;\n    this.onCut = this._register(dom.createEventEmitter(this._actual, 'cut')).event;\n    this.onCopy = this._register(dom.createEventEmitter(this._actual, 'copy')).event;\n    this.onPaste = this._register(dom.createEventEmitter(this._actual, 'paste')).event;\n    this.onFocus = this._register(dom.createEventEmitter(this._actual, 'focus')).event;\n    this.onBlur = this._register(dom.createEventEmitter(this._actual, 'blur')).event;\n    this._onSyntheticTap = this._register(new Emitter());\n    this.onSyntheticTap = this._onSyntheticTap.event;\n    this._ignoreSelectionChangeTime = 0;\n\n    this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n  }\n\n  hasFocus() {\n    const shadowRoot = dom.getShadowRoot(this._actual);\n\n    if (shadowRoot) {\n      return shadowRoot.activeElement === this._actual;\n    } else if (dom.isInDOM(this._actual)) {\n      return document.activeElement === this._actual;\n    } else {\n      return false;\n    }\n  }\n\n  setIgnoreSelectionChangeTime(reason) {\n    this._ignoreSelectionChangeTime = Date.now();\n  }\n\n  getIgnoreSelectionChangeTime() {\n    return this._ignoreSelectionChangeTime;\n  }\n\n  resetSelectionChangeTime() {\n    this._ignoreSelectionChangeTime = 0;\n  }\n\n  getValue() {\n    // console.log('current value: ' + this._textArea.value);\n    return this._actual.value;\n  }\n\n  setValue(reason, value) {\n    const textArea = this._actual;\n\n    if (textArea.value === value) {\n      // No change\n      return;\n    } // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n\n\n    this.setIgnoreSelectionChangeTime('setValue');\n    textArea.value = value;\n  }\n\n  getSelectionStart() {\n    return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n  }\n\n  getSelectionEnd() {\n    return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n  }\n\n  setSelectionRange(reason, selectionStart, selectionEnd) {\n    const textArea = this._actual;\n    let activeElement = null;\n    const shadowRoot = dom.getShadowRoot(textArea);\n\n    if (shadowRoot) {\n      activeElement = shadowRoot.activeElement;\n    } else {\n      activeElement = document.activeElement;\n    }\n\n    const currentIsFocused = activeElement === textArea;\n    const currentSelectionStart = textArea.selectionStart;\n    const currentSelectionEnd = textArea.selectionEnd;\n\n    if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n      // No change\n      // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n\n      return;\n    } // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n\n\n    if (currentIsFocused) {\n      // No need to focus, only need to change the selection range\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n\n      return;\n    } // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n    // Here, we try to undo the browser's desperate reveal.\n\n\n    try {\n      const scrollState = dom.saveParentsScrollTop(textArea);\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.focus();\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      dom.restoreParentsScrollTop(textArea, scrollState);\n    } catch (e) {// Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js"],"names":["browser","dom","StandardKeyboardEvent","RunOnceScheduler","Emitter","Disposable","Mimes","strings","TextAreaState","_debugComposition","Selection","TextAreaSyntethicEvents","Tap","CopyOptions","forceCopyWithSyntaxHighlighting","InMemoryClipboardMetadataManager","constructor","_lastState","set","lastCopiedValue","data","get","pastedText","INSTANCE","CompositionContext","_lastTypeTextLength","handleCompositionUpdate","text","typeInput","replacePrevCharCnt","replaceNextCharCnt","positionDelta","length","TextAreaInput","_host","_textArea","_OS","_browser","_onFocus","_register","onFocus","event","_onBlur","onBlur","_onKeyDown","onKeyDown","_onKeyUp","onKeyUp","_onCut","onCut","_onPaste","onPaste","_onType","onType","_onCompositionStart","onCompositionStart","_onCompositionUpdate","onCompositionUpdate","_onCompositionEnd","onCompositionEnd","_onSelectionChangeRequest","onSelectionChangeRequest","_asyncTriggerCut","fire","_asyncFocusGainWriteScreenReaderContent","writeScreenReaderContent","_textAreaState","EMPTY","_selectionChangeListener","_hasFocus","_currentComposition","lastKeyDown","_e","e","keyCode","stopPropagation","equals","preventDefault","console","log","currentComposition","selectionStart","selectionEnd","value","substr","code","isAndroid","newState","readFromTextArea","deduceAndroidCompositionInput","onInput","setIgnoreSelectionChangeTime","deduceInput","isHighSurrogate","charCodeAt","_ensureClipboardGetsEditorSelection","schedule","onCopy","clipboardData","metadata","ClipboardEventUtils","getTextData","hadFocus","_setHasFocus","isSafari","onSyntheticTap","_installSelectionChangeListener","previousSelectionChangeEventTime","addDisposableListener","document","isChrome","now","Date","delta1","delta2","getIgnoreSelectionChangeTime","resetSelectionChangeTime","selectionStartPosition","selectionEndPosition","newValue","getValue","newSelectionStart","getSelectionStart","newSelectionEnd","getSelectionEnd","_newSelectionStartPosition","deduceEditorPosition","newSelectionStartPosition","deduceModelPosition","_newSelectionEndPosition","newSelectionEndPosition","newSelection","lineNumber","column","dispose","focusTextArea","refreshFocusState","isFocused","hasFocus","newHasFocus","_setAndWriteTextAreaState","reason","textAreaState","collapseSelection","writeToTextArea","getScreenReaderContent","dataToCopy","getDataToCopy","storedMetadata","version","isFromEmptySelection","multicursorText","mode","isFirefox","replace","setTextData","html","getData","rawmetadata","JSON","parse","err","setData","stringify","TextAreaWrapper","_actual","createEventEmitter","_onSyntheticTap","_ignoreSelectionChangeTime","shadowRoot","getShadowRoot","activeElement","isInDOM","setValue","textArea","selectionDirection","setSelectionRange","currentIsFocused","currentSelectionStart","currentSelectionEnd","window","parent","focus","scrollState","saveParentsScrollTop","restoreParentsScrollTop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n    TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n    forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n    constructor() {\n        this._lastState = null;\n    }\n    set(lastCopiedValue, data) {\n        this._lastState = { lastCopiedValue, data };\n    }\n    get(pastedText) {\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n            // match!\n            return this._lastState.data;\n        }\n        this._lastState = null;\n        return null;\n    }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\nclass CompositionContext {\n    constructor() {\n        this._lastTypeTextLength = 0;\n    }\n    handleCompositionUpdate(text) {\n        text = text || '';\n        const typeInput = {\n            text: text,\n            replacePrevCharCnt: this._lastTypeTextLength,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n        this._lastTypeTextLength = text.length;\n        return typeInput;\n    }\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nexport class TextAreaInput extends Disposable {\n    constructor(_host, _textArea, _OS, _browser) {\n        super();\n        this._host = _host;\n        this._textArea = _textArea;\n        this._OS = _OS;\n        this._browser = _browser;\n        this._onFocus = this._register(new Emitter());\n        this.onFocus = this._onFocus.event;\n        this._onBlur = this._register(new Emitter());\n        this.onBlur = this._onBlur.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onKeyUp = this._register(new Emitter());\n        this.onKeyUp = this._onKeyUp.event;\n        this._onCut = this._register(new Emitter());\n        this.onCut = this._onCut.event;\n        this._onPaste = this._register(new Emitter());\n        this.onPaste = this._onPaste.event;\n        this._onType = this._register(new Emitter());\n        this.onType = this._onType.event;\n        this._onCompositionStart = this._register(new Emitter());\n        this.onCompositionStart = this._onCompositionStart.event;\n        this._onCompositionUpdate = this._register(new Emitter());\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\n        this._onCompositionEnd = this._register(new Emitter());\n        this.onCompositionEnd = this._onCompositionEnd.event;\n        this._onSelectionChangeRequest = this._register(new Emitter());\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n        this._textAreaState = TextAreaState.EMPTY;\n        this._selectionChangeListener = null;\n        this.writeScreenReaderContent('ctor');\n        this._hasFocus = false;\n        this._currentComposition = null;\n        let lastKeyDown = null;\n        this._register(this._textArea.onKeyDown((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            if (e.keyCode === 109 /* KEY_IN_COMPOSITION */\n                || (this._currentComposition && e.keyCode === 1 /* Backspace */)) {\n                // Stop propagation for keyDown events if the IME is processing key input\n                e.stopPropagation();\n            }\n            if (e.equals(9 /* Escape */)) {\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n                e.preventDefault();\n            }\n            lastKeyDown = e;\n            this._onKeyDown.fire(e);\n        }));\n        this._register(this._textArea.onKeyUp((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            this._onKeyUp.fire(e);\n        }));\n        this._register(this._textArea.onCompositionStart((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionstart]`, e);\n            }\n            const currentComposition = new CompositionContext();\n            if (this._currentComposition) {\n                // simply reset the composition context\n                this._currentComposition = currentComposition;\n                return;\n            }\n            this._currentComposition = currentComposition;\n            if (this._OS === 2 /* Macintosh */\n                && lastKeyDown\n                && lastKeyDown.equals(109 /* KEY_IN_COMPOSITION */)\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\n                && this._textAreaState.selectionStart > 0\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data\n                && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n                // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n                if (_debugComposition) {\n                    console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n                }\n                // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n                currentComposition.handleCompositionUpdate('x');\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // when tapping on the editor, Android enters composition mode to edit the current word\n                // so we cannot clear the textarea on Android and we must pretend the current word was selected\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            this._onCompositionStart.fire({ data: e.data });\n        }));\n        this._register(this._textArea.onCompositionUpdate((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionupdate]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionUpdate.fire(e);\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n            this._onType.fire(typeInput);\n            this._onCompositionUpdate.fire(e);\n        }));\n        this._register(this._textArea.onCompositionEnd((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionend]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // https://github.com/microsoft/monaco-editor/issues/1663\n                // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n                return;\n            }\n            this._currentComposition = null;\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionEnd.fire();\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n            this._onType.fire(typeInput);\n            this._onCompositionEnd.fire();\n        }));\n        this._register(this._textArea.onInput((e) => {\n            if (_debugComposition) {\n                console.log(`[input]`, e);\n            }\n            // Pretend here we touched the text area, as the `input` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\n            if (this._currentComposition) {\n                return;\n            }\n            const newState = TextAreaState.readFromTextArea(this._textArea);\n            const typeInput = TextAreaState.deduceInput(this._textAreaState, newState, /*couldBeEmojiInput*/ this._OS === 2 /* Macintosh */);\n            if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n                // Ignore invalid input but keep it around for next time\n                return;\n            }\n            this._textAreaState = newState;\n            if (typeInput.text !== ''\n                || typeInput.replacePrevCharCnt !== 0\n                || typeInput.replaceNextCharCnt !== 0\n                || typeInput.positionDelta !== 0) {\n                this._onType.fire(typeInput);\n            }\n        }));\n        // --- Clipboard operations\n        this._register(this._textArea.onCut((e) => {\n            // Pretend here we touched the text area, as the `cut` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\n            this._ensureClipboardGetsEditorSelection(e);\n            this._asyncTriggerCut.schedule();\n        }));\n        this._register(this._textArea.onCopy((e) => {\n            this._ensureClipboardGetsEditorSelection(e);\n        }));\n        this._register(this._textArea.onPaste((e) => {\n            // Pretend here we touched the text area, as the `paste` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\n            e.preventDefault();\n            if (!e.clipboardData) {\n                return;\n            }\n            let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n            if (!text) {\n                return;\n            }\n            // try the in-memory store\n            metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n            this._onPaste.fire({\n                text: text,\n                metadata: metadata\n            });\n        }));\n        this._register(this._textArea.onFocus(() => {\n            const hadFocus = this._hasFocus;\n            this._setHasFocus(true);\n            if (this._browser.isSafari && !hadFocus && this._hasFocus) {\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n                // Safari will always move the selection at offset 0 in the textarea\n                this._asyncFocusGainWriteScreenReaderContent.schedule();\n            }\n        }));\n        this._register(this._textArea.onBlur(() => {\n            if (this._currentComposition) {\n                // See https://github.com/microsoft/vscode/issues/112621\n                // where compositionend is not triggered when the editor\n                // is taken off-dom during a composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('blurWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n            this._setHasFocus(false);\n        }));\n        this._register(this._textArea.onSyntheticTap(() => {\n            if (this._browser.isAndroid && this._currentComposition) {\n                // on Android, tapping does not cancel the current composition, so the\n                // textarea is stuck showing the old composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('tapWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n        }));\n    }\n    _installSelectionChangeListener() {\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n        // When using a Braille display, it is possible for users to reposition the\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\n        //\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n        // using a Braille display from all the other cases.\n        //\n        // The problems with the `selectionchange` event are:\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n        //  * the event is emitted when tabbing into the textarea\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n        //  * the event sometimes comes in bursts for a single logical textarea operation\n        // `selectionchange` events often come multiple times for a single logical change\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\n        let previousSelectionChangeEventTime = 0;\n        return dom.addDisposableListener(document, 'selectionchange', (e) => {\n            if (!this._hasFocus) {\n                return;\n            }\n            if (this._currentComposition) {\n                return;\n            }\n            if (!this._browser.isChrome) {\n                // Support only for Chrome until testing happens on other browsers\n                return;\n            }\n            const now = Date.now();\n            const delta1 = now - previousSelectionChangeEventTime;\n            previousSelectionChangeEventTime = now;\n            if (delta1 < 5) {\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n                // => ignore it\n                return;\n            }\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n            this._textArea.resetSelectionChangeTime();\n            if (delta2 < 100) {\n                // received a `selectionchange` event within 100ms since we touched the textarea\n                // => ignore it, since we caused it\n                return;\n            }\n            if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newValue = this._textArea.getValue();\n            if (this._textAreaState.value !== newValue) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newSelectionStart = this._textArea.getSelectionStart();\n            const newSelectionEnd = this._textArea.getSelectionEnd();\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n                // Nothing to do...\n                return;\n            }\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n            this._onSelectionChangeRequest.fire(newSelection);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n    }\n    focusTextArea() {\n        // Setting this._hasFocus and writing the screen reader content\n        // will result in a focus() and setSelectionRange() in the textarea\n        this._setHasFocus(true);\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n        this.refreshFocusState();\n    }\n    isFocused() {\n        return this._hasFocus;\n    }\n    refreshFocusState() {\n        this._setHasFocus(this._textArea.hasFocus());\n    }\n    _setHasFocus(newHasFocus) {\n        if (this._hasFocus === newHasFocus) {\n            // no change\n            return;\n        }\n        this._hasFocus = newHasFocus;\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n        if (this._hasFocus) {\n            this._selectionChangeListener = this._installSelectionChangeListener();\n        }\n        if (this._hasFocus) {\n            this.writeScreenReaderContent('focusgain');\n        }\n        if (this._hasFocus) {\n            this._onFocus.fire();\n        }\n        else {\n            this._onBlur.fire();\n        }\n    }\n    _setAndWriteTextAreaState(reason, textAreaState) {\n        if (!this._hasFocus) {\n            textAreaState = textAreaState.collapseSelection();\n        }\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n        this._textAreaState = textAreaState;\n    }\n    writeScreenReaderContent(reason) {\n        if (this._currentComposition) {\n            // Do not write to the text area when doing composition\n            return;\n        }\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n    }\n    _ensureClipboardGetsEditorSelection(e) {\n        const dataToCopy = this._host.getDataToCopy();\n        const storedMetadata = {\n            version: 1,\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\n            multicursorText: dataToCopy.multicursorText,\n            mode: dataToCopy.mode\n        };\n        InMemoryClipboardMetadataManager.INSTANCE.set(\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\n        (this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\n        e.preventDefault();\n        if (e.clipboardData) {\n            ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n        }\n    }\n}\nclass ClipboardEventUtils {\n    static getTextData(clipboardData) {\n        const text = clipboardData.getData(Mimes.text);\n        let metadata = null;\n        const rawmetadata = clipboardData.getData('vscode-editor-data');\n        if (typeof rawmetadata === 'string') {\n            try {\n                metadata = JSON.parse(rawmetadata);\n                if (metadata.version !== 1) {\n                    metadata = null;\n                }\n            }\n            catch (err) {\n                // no problem!\n            }\n        }\n        return [text, metadata];\n    }\n    static setTextData(clipboardData, text, html, metadata) {\n        clipboardData.setData(Mimes.text, text);\n        if (typeof html === 'string') {\n            clipboardData.setData('text/html', html);\n        }\n        clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n    }\n}\nexport class TextAreaWrapper extends Disposable {\n    constructor(_actual) {\n        super();\n        this._actual = _actual;\n        this.onKeyDown = this._register(dom.createEventEmitter(this._actual, 'keydown')).event;\n        this.onKeyUp = this._register(dom.createEventEmitter(this._actual, 'keyup')).event;\n        this.onCompositionStart = this._register(dom.createEventEmitter(this._actual, 'compositionstart')).event;\n        this.onCompositionUpdate = this._register(dom.createEventEmitter(this._actual, 'compositionupdate')).event;\n        this.onCompositionEnd = this._register(dom.createEventEmitter(this._actual, 'compositionend')).event;\n        this.onInput = this._register(dom.createEventEmitter(this._actual, 'input')).event;\n        this.onCut = this._register(dom.createEventEmitter(this._actual, 'cut')).event;\n        this.onCopy = this._register(dom.createEventEmitter(this._actual, 'copy')).event;\n        this.onPaste = this._register(dom.createEventEmitter(this._actual, 'paste')).event;\n        this.onFocus = this._register(dom.createEventEmitter(this._actual, 'focus')).event;\n        this.onBlur = this._register(dom.createEventEmitter(this._actual, 'blur')).event;\n        this._onSyntheticTap = this._register(new Emitter());\n        this.onSyntheticTap = this._onSyntheticTap.event;\n        this._ignoreSelectionChangeTime = 0;\n        this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n    }\n    hasFocus() {\n        const shadowRoot = dom.getShadowRoot(this._actual);\n        if (shadowRoot) {\n            return shadowRoot.activeElement === this._actual;\n        }\n        else if (dom.isInDOM(this._actual)) {\n            return document.activeElement === this._actual;\n        }\n        else {\n            return false;\n        }\n    }\n    setIgnoreSelectionChangeTime(reason) {\n        this._ignoreSelectionChangeTime = Date.now();\n    }\n    getIgnoreSelectionChangeTime() {\n        return this._ignoreSelectionChangeTime;\n    }\n    resetSelectionChangeTime() {\n        this._ignoreSelectionChangeTime = 0;\n    }\n    getValue() {\n        // console.log('current value: ' + this._textArea.value);\n        return this._actual.value;\n    }\n    setValue(reason, value) {\n        const textArea = this._actual;\n        if (textArea.value === value) {\n            // No change\n            return;\n        }\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n        this.setIgnoreSelectionChangeTime('setValue');\n        textArea.value = value;\n    }\n    getSelectionStart() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n    }\n    getSelectionEnd() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n    }\n    setSelectionRange(reason, selectionStart, selectionEnd) {\n        const textArea = this._actual;\n        let activeElement = null;\n        const shadowRoot = dom.getShadowRoot(textArea);\n        if (shadowRoot) {\n            activeElement = shadowRoot.activeElement;\n        }\n        else {\n            activeElement = document.activeElement;\n        }\n        const currentIsFocused = (activeElement === textArea);\n        const currentSelectionStart = textArea.selectionStart;\n        const currentSelectionEnd = textArea.selectionEnd;\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n            // No change\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n        if (currentIsFocused) {\n            // No need to focus, only need to change the selection range\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n        // Here, we try to undo the browser's desperate reveal.\n        try {\n            const scrollState = dom.saveParentsScrollTop(textArea);\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.focus();\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            dom.restoreParentsScrollTop(textArea, scrollState);\n        }\n        catch (e) {\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}