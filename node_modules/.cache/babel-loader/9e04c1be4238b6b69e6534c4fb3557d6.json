{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/range.js';\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\n\nexport function groupIntersect(range, groups) {\n  const result = [];\n\n  for (let r of groups) {\n    if (range.start >= r.range.end) {\n      continue;\n    }\n\n    if (range.end < r.range.start) {\n      break;\n    }\n\n    const intersection = Range.intersect(range, r.range);\n\n    if (Range.isEmpty(intersection)) {\n      continue;\n    }\n\n    result.push({\n      range: intersection,\n      size: r.size\n    });\n  }\n\n  return result;\n}\n/**\n * Shifts a range by that `much`.\n */\n\nexport function shift({\n  start,\n  end\n}, much) {\n  return {\n    start: start + much,\n    end: end + much\n  };\n}\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\n\nexport function consolidate(groups) {\n  const result = [];\n  let previousGroup = null;\n\n  for (let group of groups) {\n    const start = group.range.start;\n    const end = group.range.end;\n    const size = group.size;\n\n    if (previousGroup && size === previousGroup.size) {\n      previousGroup.range.end = end;\n      continue;\n    }\n\n    previousGroup = {\n      range: {\n        start,\n        end\n      },\n      size\n    };\n    result.push(previousGroup);\n  }\n\n  return result;\n}\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\n\nfunction concat(...groups) {\n  return consolidate(groups.reduce((r, g) => r.concat(g), []));\n}\n\nexport class RangeMap {\n  constructor() {\n    this.groups = [];\n    this._size = 0;\n  }\n\n  splice(index, deleteCount, items = []) {\n    const diff = items.length - deleteCount;\n    const before = groupIntersect({\n      start: 0,\n      end: index\n    }, this.groups);\n    const after = groupIntersect({\n      start: index + deleteCount,\n      end: Number.POSITIVE_INFINITY\n    }, this.groups).map(g => ({\n      range: shift(g.range, diff),\n      size: g.size\n    }));\n    const middle = items.map((item, i) => ({\n      range: {\n        start: index + i,\n        end: index + i + 1\n      },\n      size: item.size\n    }));\n    this.groups = concat(before, middle, after);\n    this._size = this.groups.reduce((t, g) => t + g.size * (g.range.end - g.range.start), 0);\n  }\n  /**\n   * Returns the number of items in the range map.\n   */\n\n\n  get count() {\n    const len = this.groups.length;\n\n    if (!len) {\n      return 0;\n    }\n\n    return this.groups[len - 1].range.end;\n  }\n  /**\n   * Returns the sum of the sizes of all items in the range map.\n   */\n\n\n  get size() {\n    return this._size;\n  }\n  /**\n   * Returns the index of the item at the given position.\n   */\n\n\n  indexAt(position) {\n    if (position < 0) {\n      return -1;\n    }\n\n    let index = 0;\n    let size = 0;\n\n    for (let group of this.groups) {\n      const count = group.range.end - group.range.start;\n      const newSize = size + count * group.size;\n\n      if (position < newSize) {\n        return index + Math.floor((position - size) / group.size);\n      }\n\n      index += count;\n      size = newSize;\n    }\n\n    return index;\n  }\n  /**\n   * Returns the index of the item right after the item at the\n   * index of the given position.\n   */\n\n\n  indexAfter(position) {\n    return Math.min(this.indexAt(position) + 1, this.count);\n  }\n  /**\n   * Returns the start position of the item at the given index.\n   */\n\n\n  positionAt(index) {\n    if (index < 0) {\n      return -1;\n    }\n\n    let position = 0;\n    let count = 0;\n\n    for (let group of this.groups) {\n      const groupCount = group.range.end - group.range.start;\n      const newCount = count + groupCount;\n\n      if (index < newCount) {\n        return position + (index - count) * group.size;\n      }\n\n      position += groupCount * group.size;\n      count = newCount;\n    }\n\n    return -1;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/browser/ui/list/rangeMap.js"],"names":["Range","groupIntersect","range","groups","result","r","start","end","intersection","intersect","isEmpty","push","size","shift","much","consolidate","previousGroup","group","concat","reduce","g","RangeMap","constructor","_size","splice","index","deleteCount","items","diff","length","before","after","Number","POSITIVE_INFINITY","map","middle","item","i","t","count","len","indexAt","position","newSize","Math","floor","indexAfter","min","positionAt","groupCount","newCount"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/range.js';\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\nexport function groupIntersect(range, groups) {\n    const result = [];\n    for (let r of groups) {\n        if (range.start >= r.range.end) {\n            continue;\n        }\n        if (range.end < r.range.start) {\n            break;\n        }\n        const intersection = Range.intersect(range, r.range);\n        if (Range.isEmpty(intersection)) {\n            continue;\n        }\n        result.push({\n            range: intersection,\n            size: r.size\n        });\n    }\n    return result;\n}\n/**\n * Shifts a range by that `much`.\n */\nexport function shift({ start, end }, much) {\n    return { start: start + much, end: end + much };\n}\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\nexport function consolidate(groups) {\n    const result = [];\n    let previousGroup = null;\n    for (let group of groups) {\n        const start = group.range.start;\n        const end = group.range.end;\n        const size = group.size;\n        if (previousGroup && size === previousGroup.size) {\n            previousGroup.range.end = end;\n            continue;\n        }\n        previousGroup = { range: { start, end }, size };\n        result.push(previousGroup);\n    }\n    return result;\n}\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\nfunction concat(...groups) {\n    return consolidate(groups.reduce((r, g) => r.concat(g), []));\n}\nexport class RangeMap {\n    constructor() {\n        this.groups = [];\n        this._size = 0;\n    }\n    splice(index, deleteCount, items = []) {\n        const diff = items.length - deleteCount;\n        const before = groupIntersect({ start: 0, end: index }, this.groups);\n        const after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\n            .map(g => ({ range: shift(g.range, diff), size: g.size }));\n        const middle = items.map((item, i) => ({\n            range: { start: index + i, end: index + i + 1 },\n            size: item.size\n        }));\n        this.groups = concat(before, middle, after);\n        this._size = this.groups.reduce((t, g) => t + (g.size * (g.range.end - g.range.start)), 0);\n    }\n    /**\n     * Returns the number of items in the range map.\n     */\n    get count() {\n        const len = this.groups.length;\n        if (!len) {\n            return 0;\n        }\n        return this.groups[len - 1].range.end;\n    }\n    /**\n     * Returns the sum of the sizes of all items in the range map.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Returns the index of the item at the given position.\n     */\n    indexAt(position) {\n        if (position < 0) {\n            return -1;\n        }\n        let index = 0;\n        let size = 0;\n        for (let group of this.groups) {\n            const count = group.range.end - group.range.start;\n            const newSize = size + (count * group.size);\n            if (position < newSize) {\n                return index + Math.floor((position - size) / group.size);\n            }\n            index += count;\n            size = newSize;\n        }\n        return index;\n    }\n    /**\n     * Returns the index of the item right after the item at the\n     * index of the given position.\n     */\n    indexAfter(position) {\n        return Math.min(this.indexAt(position) + 1, this.count);\n    }\n    /**\n     * Returns the start position of the item at the given index.\n     */\n    positionAt(index) {\n        if (index < 0) {\n            return -1;\n        }\n        let position = 0;\n        let count = 0;\n        for (let group of this.groups) {\n            const groupCount = group.range.end - group.range.start;\n            const newCount = count + groupCount;\n            if (index < newCount) {\n                return position + ((index - count) * group.size);\n            }\n            position += groupCount * group.size;\n            count = newCount;\n        }\n        return -1;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}