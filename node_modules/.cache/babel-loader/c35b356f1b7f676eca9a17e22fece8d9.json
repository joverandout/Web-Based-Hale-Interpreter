{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nexport class BlockCommentCommand {\n  constructor(selection, insertSpace, languageConfigurationService) {\n    this.languageConfigurationService = languageConfigurationService;\n    this._selection = selection;\n    this._insertSpace = insertSpace;\n    this._usedEndToken = null;\n  }\n\n  static _haystackHasNeedleAtOffset(haystack, needle, offset) {\n    if (offset < 0) {\n      return false;\n    }\n\n    const needleLength = needle.length;\n    const haystackLength = haystack.length;\n\n    if (offset + needleLength > haystackLength) {\n      return false;\n    }\n\n    for (let i = 0; i < needleLength; i++) {\n      const codeA = haystack.charCodeAt(offset + i);\n      const codeB = needle.charCodeAt(i);\n\n      if (codeA === codeB) {\n        continue;\n      }\n\n      if (codeA >= 65\n      /* A */\n      && codeA <= 90\n      /* Z */\n      && codeA + 32 === codeB) {\n        // codeA is upper-case variant of codeB\n        continue;\n      }\n\n      if (codeB >= 65\n      /* A */\n      && codeB <= 90\n      /* Z */\n      && codeB + 32 === codeA) {\n        // codeB is upper-case variant of codeA\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {\n    const startLineNumber = selection.startLineNumber;\n    const startColumn = selection.startColumn;\n    const endLineNumber = selection.endLineNumber;\n    const endColumn = selection.endColumn;\n    const startLineText = model.getLineContent(startLineNumber);\n    const endLineText = model.getLineContent(endLineNumber);\n    let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);\n    let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);\n\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      if (startLineNumber === endLineNumber) {\n        const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);\n\n        if (lineBetweenTokens.indexOf(endToken) >= 0) {\n          // force to add a block comment\n          startTokenIndex = -1;\n          endTokenIndex = -1;\n        }\n      } else {\n        const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);\n        const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);\n\n        if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {\n          // force to add a block comment\n          startTokenIndex = -1;\n          endTokenIndex = -1;\n        }\n      }\n    }\n\n    let ops;\n\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      // Consider spaces as part of the comment tokens\n      if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32\n      /* Space */\n      ) {\n        // Pretend the start token contains a trailing space\n        startToken = startToken + ' ';\n      }\n\n      if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32\n      /* Space */\n      ) {\n        // Pretend the end token contains a leading space\n        endToken = ' ' + endToken;\n        endTokenIndex -= 1;\n      }\n\n      ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n    } else {\n      ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);\n      this._usedEndToken = ops.length === 1 ? endToken : null;\n    }\n\n    for (const op of ops) {\n      builder.addTrackedEditOperation(op.range, op.text);\n    }\n  }\n\n  static _createRemoveBlockCommentOperations(r, startToken, endToken) {\n    let res = [];\n\n    if (!Range.isEmpty(r)) {\n      // Remove block comment start\n      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn))); // Remove block comment end\n\n      res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));\n    } else {\n      // Remove both continuously\n      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));\n    }\n\n    return res;\n  }\n\n  static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {\n    let res = [];\n\n    if (!Range.isEmpty(r)) {\n      // Insert block comment start\n      res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + (insertSpace ? ' ' : ''))); // Insert block comment end\n\n      res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), (insertSpace ? ' ' : '') + endToken));\n    } else {\n      // Insert both continuously\n      res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + '  ' + endToken));\n    }\n\n    return res;\n  }\n\n  getEditOperations(model, builder) {\n    const startLineNumber = this._selection.startLineNumber;\n    const startColumn = this._selection.startColumn;\n    model.tokenizeIfCheap(startLineNumber);\n    const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);\n    const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n\n    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n      // Mode does not support block comments\n      return;\n    }\n\n    this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);\n  }\n\n  computeCursorState(model, helper) {\n    const inverseEditOperations = helper.getInverseEditOperations();\n\n    if (inverseEditOperations.length === 2) {\n      const startTokenEditOperation = inverseEditOperations[0];\n      const endTokenEditOperation = inverseEditOperations[1];\n      return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);\n    } else {\n      const srcRange = inverseEditOperations[0].range;\n      const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0; // minus 1 space before endToken\n\n      return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/blockCommentCommand.js"],"names":["EditOperation","Position","Range","Selection","BlockCommentCommand","constructor","selection","insertSpace","languageConfigurationService","_selection","_insertSpace","_usedEndToken","_haystackHasNeedleAtOffset","haystack","needle","offset","needleLength","length","haystackLength","i","codeA","charCodeAt","codeB","_createOperationsForBlockComment","startToken","endToken","model","builder","startLineNumber","startColumn","endLineNumber","endColumn","startLineText","getLineContent","endLineText","startTokenIndex","lastIndexOf","endTokenIndex","indexOf","lineBetweenTokens","substring","startLineAfterStartToken","endLineBeforeEndToken","ops","_createRemoveBlockCommentOperations","_createAddBlockCommentOperations","op","addTrackedEditOperation","range","text","r","res","isEmpty","push","delete","insert","replace","getEditOperations","tokenizeIfCheap","languageId","getLanguageIdAtPosition","config","getLanguageConfiguration","comments","blockCommentStartToken","blockCommentEndToken","computeCursorState","helper","inverseEditOperations","getInverseEditOperations","startTokenEditOperation","endTokenEditOperation","srcRange","deltaColumn"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nexport class BlockCommentCommand {\n    constructor(selection, insertSpace, languageConfigurationService) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._selection = selection;\n        this._insertSpace = insertSpace;\n        this._usedEndToken = null;\n    }\n    static _haystackHasNeedleAtOffset(haystack, needle, offset) {\n        if (offset < 0) {\n            return false;\n        }\n        const needleLength = needle.length;\n        const haystackLength = haystack.length;\n        if (offset + needleLength > haystackLength) {\n            return false;\n        }\n        for (let i = 0; i < needleLength; i++) {\n            const codeA = haystack.charCodeAt(offset + i);\n            const codeB = needle.charCodeAt(i);\n            if (codeA === codeB) {\n                continue;\n            }\n            if (codeA >= 65 /* A */ && codeA <= 90 /* Z */ && codeA + 32 === codeB) {\n                // codeA is upper-case variant of codeB\n                continue;\n            }\n            if (codeB >= 65 /* A */ && codeB <= 90 /* Z */ && codeB + 32 === codeA) {\n                // codeB is upper-case variant of codeA\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {\n        const startLineNumber = selection.startLineNumber;\n        const startColumn = selection.startColumn;\n        const endLineNumber = selection.endLineNumber;\n        const endColumn = selection.endColumn;\n        const startLineText = model.getLineContent(startLineNumber);\n        const endLineText = model.getLineContent(endLineNumber);\n        let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);\n        let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            if (startLineNumber === endLineNumber) {\n                const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);\n                if (lineBetweenTokens.indexOf(endToken) >= 0) {\n                    // force to add a block comment\n                    startTokenIndex = -1;\n                    endTokenIndex = -1;\n                }\n            }\n            else {\n                const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);\n                const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);\n                if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {\n                    // force to add a block comment\n                    startTokenIndex = -1;\n                    endTokenIndex = -1;\n                }\n            }\n        }\n        let ops;\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            // Consider spaces as part of the comment tokens\n            if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {\n                // Pretend the start token contains a trailing space\n                startToken = startToken + ' ';\n            }\n            if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32 /* Space */) {\n                // Pretend the end token contains a leading space\n                endToken = ' ' + endToken;\n                endTokenIndex -= 1;\n            }\n            ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n        }\n        else {\n            ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);\n            this._usedEndToken = ops.length === 1 ? endToken : null;\n        }\n        for (const op of ops) {\n            builder.addTrackedEditOperation(op.range, op.text);\n        }\n    }\n    static _createRemoveBlockCommentOperations(r, startToken, endToken) {\n        let res = [];\n        if (!Range.isEmpty(r)) {\n            // Remove block comment start\n            res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));\n            // Remove block comment end\n            res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));\n        }\n        else {\n            // Remove both continuously\n            res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));\n        }\n        return res;\n    }\n    static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {\n        let res = [];\n        if (!Range.isEmpty(r)) {\n            // Insert block comment start\n            res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + (insertSpace ? ' ' : '')));\n            // Insert block comment end\n            res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), (insertSpace ? ' ' : '') + endToken));\n        }\n        else {\n            // Insert both continuously\n            res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + '  ' + endToken));\n        }\n        return res;\n    }\n    getEditOperations(model, builder) {\n        const startLineNumber = this._selection.startLineNumber;\n        const startColumn = this._selection.startColumn;\n        model.tokenizeIfCheap(startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);\n        const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n            // Mode does not support block comments\n            return;\n        }\n        this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        if (inverseEditOperations.length === 2) {\n            const startTokenEditOperation = inverseEditOperations[0];\n            const endTokenEditOperation = inverseEditOperations[1];\n            return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);\n        }\n        else {\n            const srcRange = inverseEditOperations[0].range;\n            const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0; // minus 1 space before endToken\n            return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}