{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../../base/common/types.js';\nimport { Position } from '../core/position.js';\nimport { InjectedTextCursorStops } from '../model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\n\nexport class ModelLineProjectionData {\n  constructor(injectionOffsets,\n  /**\n   * `injectionOptions.length` must equal `injectionOffsets.length`\n   */\n  injectionOptions,\n  /**\n   * Refers to offsets after applying injections to the source.\n   * The last break offset indicates the length of the source after applying injections.\n   */\n  breakOffsets,\n  /**\n   * Refers to offsets after applying injections\n   */\n  breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n    this.injectionOffsets = injectionOffsets;\n    this.injectionOptions = injectionOptions;\n    this.breakOffsets = breakOffsets;\n    this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n    this.wrappedTextIndentLength = wrappedTextIndentLength;\n  }\n\n  getOutputLineCount() {\n    return this.breakOffsets.length;\n  }\n\n  getMinOutputOffset(outputLineIndex) {\n    if (outputLineIndex > 0) {\n      return this.wrappedTextIndentLength;\n    }\n\n    return 0;\n  }\n\n  getLineLength(outputLineIndex) {\n    // These offsets refer to model text with injected text.\n    const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n    const endOffset = this.breakOffsets[outputLineIndex];\n    let lineLength = endOffset - startOffset;\n\n    if (outputLineIndex > 0) {\n      lineLength += this.wrappedTextIndentLength;\n    }\n\n    return lineLength;\n  }\n\n  getMaxOutputOffset(outputLineIndex) {\n    return this.getLineLength(outputLineIndex);\n  }\n\n  translateToInputOffset(outputLineIndex, outputOffset) {\n    if (outputLineIndex > 0) {\n      outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n    }\n\n    const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n    let offsetInInput = offsetInInputWithInjection;\n\n    if (this.injectionOffsets !== null) {\n      for (let i = 0; i < this.injectionOffsets.length; i++) {\n        if (offsetInInput > this.injectionOffsets[i]) {\n          if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n            // `inputOffset` is within injected text\n            offsetInInput = this.injectionOffsets[i];\n          } else {\n            offsetInInput -= this.injectionOptions[i].content.length;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n\n    return offsetInInput;\n  }\n\n  translateToOutputPosition(inputOffset, affinity = 2\n  /* None */\n  ) {\n    let inputOffsetInInputWithInjection = inputOffset;\n\n    if (this.injectionOffsets !== null) {\n      for (let i = 0; i < this.injectionOffsets.length; i++) {\n        if (inputOffset < this.injectionOffsets[i]) {\n          break;\n        }\n\n        if (affinity !== 1\n        /* Right */\n        && inputOffset === this.injectionOffsets[i]) {\n          break;\n        }\n\n        inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n      }\n    }\n\n    return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n  }\n\n  offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2\n  /* None */\n  ) {\n    let low = 0;\n    let high = this.breakOffsets.length - 1;\n    let mid = 0;\n    let midStart = 0;\n\n    while (low <= high) {\n      mid = low + (high - low) / 2 | 0;\n      const midStop = this.breakOffsets[mid];\n      midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n\n      if (affinity === 0\n      /* Left */\n      ) {\n        if (offsetInInputWithInjections <= midStart) {\n          high = mid - 1;\n        } else if (offsetInInputWithInjections > midStop) {\n          low = mid + 1;\n        } else {\n          break;\n        }\n      } else {\n        if (offsetInInputWithInjections < midStart) {\n          high = mid - 1;\n        } else if (offsetInInputWithInjections >= midStop) {\n          low = mid + 1;\n        } else {\n          break;\n        }\n      }\n    }\n\n    let outputOffset = offsetInInputWithInjections - midStart;\n\n    if (mid > 0) {\n      outputOffset += this.wrappedTextIndentLength;\n    }\n\n    return new OutputPosition(mid, outputOffset);\n  }\n\n  normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n    if (this.injectionOffsets !== null) {\n      const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n      const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n\n      if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n        // injected text caused a change\n        return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n      }\n    }\n\n    if (affinity === 0\n    /* Left */\n    ) {\n      if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n        return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n      }\n    } else if (affinity === 1\n    /* Right */\n    ) {\n      const maxOutputLineIndex = this.getOutputLineCount() - 1;\n\n      if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n        return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n      }\n    }\n\n    return new OutputPosition(outputLineIndex, outputOffset);\n  }\n\n  outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n    if (outputLineIndex > 0) {\n      outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n    }\n\n    const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n    return result;\n  }\n\n  normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n    const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n\n    if (!injectedText) {\n      return offsetInInputWithInjections;\n    }\n\n    if (affinity === 2\n    /* None */\n    ) {\n      if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n        return injectedText.offsetInInputWithInjections + injectedText.length;\n      } else {\n        let result = injectedText.offsetInInputWithInjections;\n\n        if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n          return result;\n        }\n\n        let index = injectedText.injectedTextIndex - 1;\n\n        while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n          if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n            break;\n          }\n\n          result -= this.injectionOptions[index].content.length;\n\n          if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n            break;\n          }\n\n          index--;\n        }\n\n        return result;\n      }\n    } else if (affinity === 1\n    /* Right */\n    ) {\n      let result = injectedText.offsetInInputWithInjections + injectedText.length;\n      let index = injectedText.injectedTextIndex; // traverse all injected text that touch each other\n\n      while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n        result += this.injectionOptions[index + 1].content.length;\n        index++;\n      }\n\n      return result;\n    } else if (affinity === 0\n    /* Left */\n    ) {\n      // affinity is left\n      let result = injectedText.offsetInInputWithInjections;\n      let index = injectedText.injectedTextIndex; // traverse all injected text that touch each other\n\n      while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n        result -= this.injectionOptions[index - 1].content.length;\n        index--;\n      }\n\n      return result;\n    }\n\n    assertNever(affinity);\n  }\n\n  getInjectedText(outputLineIndex, outputOffset) {\n    const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n    const injectedText = this.getInjectedTextAtOffset(offset);\n\n    if (!injectedText) {\n      return null;\n    }\n\n    return {\n      options: this.injectionOptions[injectedText.injectedTextIndex]\n    };\n  }\n\n  getInjectedTextAtOffset(offsetInInputWithInjections) {\n    const injectionOffsets = this.injectionOffsets;\n    const injectionOptions = this.injectionOptions;\n\n    if (injectionOffsets !== null) {\n      let totalInjectedTextLengthBefore = 0;\n\n      for (let i = 0; i < injectionOffsets.length; i++) {\n        const length = injectionOptions[i].content.length;\n        const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n        const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n\n        if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n          // Injected text starts later.\n          break; // All later injected texts have an even larger offset.\n        }\n\n        if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n          // Injected text ends after or with the given position (but also starts with or before it).\n          return {\n            injectedTextIndex: i,\n            offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n            length\n          };\n        }\n\n        totalInjectedTextLengthBefore += length;\n      }\n    }\n\n    return undefined;\n  }\n\n}\n\nfunction hasRightCursorStop(cursorStop) {\n  if (cursorStop === null || cursorStop === undefined) {\n    return true;\n  }\n\n  return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\n\nfunction hasLeftCursorStop(cursorStop) {\n  if (cursorStop === null || cursorStop === undefined) {\n    return true;\n  }\n\n  return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\n\nexport class InjectedText {\n  constructor(options) {\n    this.options = options;\n  }\n\n}\nexport class OutputPosition {\n  constructor(outputLineIndex, outputOffset) {\n    this.outputLineIndex = outputLineIndex;\n    this.outputOffset = outputOffset;\n  }\n\n  toString() {\n    return `${this.outputLineIndex}:${this.outputOffset}`;\n  }\n\n  toPosition(baseLineNumber) {\n    return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjectionData.js"],"names":["assertNever","Position","InjectedTextCursorStops","ModelLineProjectionData","constructor","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","getOutputLineCount","length","getMinOutputOffset","outputLineIndex","getLineLength","startOffset","endOffset","lineLength","getMaxOutputOffset","translateToInputOffset","outputOffset","Math","max","offsetInInputWithInjection","offsetInInput","i","content","translateToOutputPosition","inputOffset","affinity","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","low","high","mid","midStart","midStop","OutputPosition","normalizeOutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","maxOutputLineIndex","result","injectedText","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","index","getInjectedText","offset","options","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","undefined","cursorStop","Right","Both","Left","InjectedText","toString","toPosition","baseLineNumber"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../../base/common/types.js';\nimport { Position } from '../core/position.js';\nimport { InjectedTextCursorStops } from '../model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* Right */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* Left */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}