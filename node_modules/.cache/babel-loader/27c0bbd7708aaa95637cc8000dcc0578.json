{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n\nclass PendingChanges {\n  constructor() {\n    this._hasPending = false;\n    this._inserts = [];\n    this._changes = [];\n    this._removes = [];\n  }\n\n  insert(x) {\n    this._hasPending = true;\n\n    this._inserts.push(x);\n  }\n\n  change(x) {\n    this._hasPending = true;\n\n    this._changes.push(x);\n  }\n\n  remove(x) {\n    this._hasPending = true;\n\n    this._removes.push(x);\n  }\n\n  mustCommit() {\n    return this._hasPending;\n  }\n\n  commit(linesLayout) {\n    if (!this._hasPending) {\n      return;\n    }\n\n    const inserts = this._inserts;\n    const changes = this._changes;\n    const removes = this._removes;\n    this._hasPending = false;\n    this._inserts = [];\n    this._changes = [];\n    this._removes = [];\n\n    linesLayout._commitPendingChanges(inserts, changes, removes);\n  }\n\n}\n\nexport class EditorWhitespace {\n  constructor(id, afterLineNumber, ordinal, height, minWidth) {\n    this.id = id;\n    this.afterLineNumber = afterLineNumber;\n    this.ordinal = ordinal;\n    this.height = height;\n    this.minWidth = minWidth;\n    this.prefixSum = 0;\n  }\n\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\n\nexport class LinesLayout {\n  constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n    this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n    this._pendingChanges = new PendingChanges();\n    this._lastWhitespaceId = 0;\n    this._arr = [];\n    this._prefixSumValidIndex = -1;\n    this._minWidth = -1;\n    /* marker for not being computed */\n\n    this._lineCount = lineCount;\n    this._lineHeight = lineHeight;\n    this._paddingTop = paddingTop;\n    this._paddingBottom = paddingBottom;\n  }\n  /**\n   * Find the insertion index for a new value inside a sorted array of values.\n   * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n   */\n\n\n  static findInsertionIndex(arr, afterLineNumber, ordinal) {\n    let low = 0;\n    let high = arr.length;\n\n    while (low < high) {\n      const mid = low + high >>> 1;\n\n      if (afterLineNumber === arr[mid].afterLineNumber) {\n        if (ordinal < arr[mid].ordinal) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      } else if (afterLineNumber < arr[mid].afterLineNumber) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    return low;\n  }\n  /**\n   * Change the height of a line in pixels.\n   */\n\n\n  setLineHeight(lineHeight) {\n    this._checkPendingChanges();\n\n    this._lineHeight = lineHeight;\n  }\n  /**\n   * Changes the padding used to calculate vertical offsets.\n   */\n\n\n  setPadding(paddingTop, paddingBottom) {\n    this._paddingTop = paddingTop;\n    this._paddingBottom = paddingBottom;\n  }\n  /**\n   * Set the number of lines.\n   *\n   * @param lineCount New number of lines.\n   */\n\n\n  onFlushed(lineCount) {\n    this._checkPendingChanges();\n\n    this._lineCount = lineCount;\n  }\n\n  changeWhitespace(callback) {\n    let hadAChange = false;\n\n    try {\n      const accessor = {\n        insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n          hadAChange = true;\n          afterLineNumber = afterLineNumber | 0;\n          ordinal = ordinal | 0;\n          heightInPx = heightInPx | 0;\n          minWidth = minWidth | 0;\n          const id = this._instanceId + ++this._lastWhitespaceId;\n\n          this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n\n          return id;\n        },\n        changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n          hadAChange = true;\n          newAfterLineNumber = newAfterLineNumber | 0;\n          newHeight = newHeight | 0;\n\n          this._pendingChanges.change({\n            id,\n            newAfterLineNumber,\n            newHeight\n          });\n        },\n        removeWhitespace: id => {\n          hadAChange = true;\n\n          this._pendingChanges.remove({\n            id\n          });\n        }\n      };\n      callback(accessor);\n    } finally {\n      this._pendingChanges.commit(this);\n    }\n\n    return hadAChange;\n  }\n\n  _commitPendingChanges(inserts, changes, removes) {\n    if (inserts.length > 0 || removes.length > 0) {\n      this._minWidth = -1;\n      /* marker for not being computed */\n    }\n\n    if (inserts.length + changes.length + removes.length <= 1) {\n      // when only one thing happened, handle it \"delicately\"\n      for (const insert of inserts) {\n        this._insertWhitespace(insert);\n      }\n\n      for (const change of changes) {\n        this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n      }\n\n      for (const remove of removes) {\n        const index = this._findWhitespaceIndex(remove.id);\n\n        if (index === -1) {\n          continue;\n        }\n\n        this._removeWhitespace(index);\n      }\n\n      return;\n    } // simply rebuild the entire datastructure\n\n\n    const toRemove = new Set();\n\n    for (const remove of removes) {\n      toRemove.add(remove.id);\n    }\n\n    const toChange = new Map();\n\n    for (const change of changes) {\n      toChange.set(change.id, change);\n    }\n\n    const applyRemoveAndChange = whitespaces => {\n      const result = [];\n\n      for (const whitespace of whitespaces) {\n        if (toRemove.has(whitespace.id)) {\n          continue;\n        }\n\n        if (toChange.has(whitespace.id)) {\n          const change = toChange.get(whitespace.id);\n          whitespace.afterLineNumber = change.newAfterLineNumber;\n          whitespace.height = change.newHeight;\n        }\n\n        result.push(whitespace);\n      }\n\n      return result;\n    };\n\n    const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n    result.sort((a, b) => {\n      if (a.afterLineNumber === b.afterLineNumber) {\n        return a.ordinal - b.ordinal;\n      }\n\n      return a.afterLineNumber - b.afterLineNumber;\n    });\n    this._arr = result;\n    this._prefixSumValidIndex = -1;\n  }\n\n  _checkPendingChanges() {\n    if (this._pendingChanges.mustCommit()) {\n      this._pendingChanges.commit(this);\n    }\n  }\n\n  _insertWhitespace(whitespace) {\n    const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n\n    this._arr.splice(insertIndex, 0, whitespace);\n\n    this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n  }\n\n  _findWhitespaceIndex(id) {\n    const arr = this._arr;\n\n    for (let i = 0, len = arr.length; i < len; i++) {\n      if (arr[i].id === id) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n    const index = this._findWhitespaceIndex(id);\n\n    if (index === -1) {\n      return;\n    }\n\n    if (this._arr[index].height !== newHeight) {\n      this._arr[index].height = newHeight;\n      this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n    }\n\n    if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n      // `afterLineNumber` changed for this whitespace\n      // Record old whitespace\n      const whitespace = this._arr[index]; // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n\n      this._removeWhitespace(index);\n\n      whitespace.afterLineNumber = newAfterLineNumber; // And add it again\n\n      this._insertWhitespace(whitespace);\n    }\n  }\n\n  _removeWhitespace(removeIndex) {\n    this._arr.splice(removeIndex, 1);\n\n    this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n  }\n  /**\n   * Notify the layouter that lines have been deleted (a continuous zone of lines).\n   *\n   * @param fromLineNumber The line number at which the deletion started, inclusive\n   * @param toLineNumber The line number at which the deletion ended, inclusive\n   */\n\n\n  onLinesDeleted(fromLineNumber, toLineNumber) {\n    this._checkPendingChanges();\n\n    fromLineNumber = fromLineNumber | 0;\n    toLineNumber = toLineNumber | 0;\n    this._lineCount -= toLineNumber - fromLineNumber + 1;\n\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      const afterLineNumber = this._arr[i].afterLineNumber;\n\n      if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n        // The line this whitespace was after has been deleted\n        //  => move whitespace to before first deleted line\n        this._arr[i].afterLineNumber = fromLineNumber - 1;\n      } else if (afterLineNumber > toLineNumber) {\n        // The line this whitespace was after has been moved up\n        //  => move whitespace up\n        this._arr[i].afterLineNumber -= toLineNumber - fromLineNumber + 1;\n      }\n    }\n  }\n  /**\n   * Notify the layouter that lines have been inserted (a continuous zone of lines).\n   *\n   * @param fromLineNumber The line number at which the insertion started, inclusive\n   * @param toLineNumber The line number at which the insertion ended, inclusive.\n   */\n\n\n  onLinesInserted(fromLineNumber, toLineNumber) {\n    this._checkPendingChanges();\n\n    fromLineNumber = fromLineNumber | 0;\n    toLineNumber = toLineNumber | 0;\n    this._lineCount += toLineNumber - fromLineNumber + 1;\n\n    for (let i = 0, len = this._arr.length; i < len; i++) {\n      const afterLineNumber = this._arr[i].afterLineNumber;\n\n      if (fromLineNumber <= afterLineNumber) {\n        this._arr[i].afterLineNumber += toLineNumber - fromLineNumber + 1;\n      }\n    }\n  }\n  /**\n   * Get the sum of all the whitespaces.\n   */\n\n\n  getWhitespacesTotalHeight() {\n    this._checkPendingChanges();\n\n    if (this._arr.length === 0) {\n      return 0;\n    }\n\n    return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n  }\n  /**\n   * Return the sum of the heights of the whitespaces at [0..index].\n   * This includes the whitespace at `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n   */\n\n\n  getWhitespacesAccumulatedHeight(index) {\n    this._checkPendingChanges();\n\n    index = index | 0;\n    let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n\n    if (startIndex === 0) {\n      this._arr[0].prefixSum = this._arr[0].height;\n      startIndex++;\n    }\n\n    for (let i = startIndex; i <= index; i++) {\n      this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n    }\n\n    this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n    return this._arr[index].prefixSum;\n  }\n  /**\n   * Get the sum of heights for all objects.\n   *\n   * @return The sum of heights for all objects.\n   */\n\n\n  getLinesTotalHeight() {\n    this._checkPendingChanges();\n\n    const linesHeight = this._lineHeight * this._lineCount;\n    const whitespacesHeight = this.getWhitespacesTotalHeight();\n    return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n  }\n  /**\n   * Returns the accumulated height of whitespaces before the given line number.\n   *\n   * @param lineNumber The line number\n   */\n\n\n  getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n    this._checkPendingChanges();\n\n    lineNumber = lineNumber | 0;\n\n    const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n    if (lastWhitespaceBeforeLineNumber === -1) {\n      return 0;\n    }\n\n    return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n  }\n\n  _findLastWhitespaceBeforeLineNumber(lineNumber) {\n    lineNumber = lineNumber | 0; // Find the whitespace before line number\n\n    const arr = this._arr;\n    let low = 0;\n    let high = arr.length - 1;\n\n    while (low <= high) {\n      const delta = high - low | 0;\n      const halfDelta = delta / 2 | 0;\n      const mid = low + halfDelta | 0;\n\n      if (arr[mid].afterLineNumber < lineNumber) {\n        if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n          return mid;\n        } else {\n          low = mid + 1 | 0;\n        }\n      } else {\n        high = mid - 1 | 0;\n      }\n    }\n\n    return -1;\n  }\n\n  _findFirstWhitespaceAfterLineNumber(lineNumber) {\n    lineNumber = lineNumber | 0;\n\n    const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n    const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n\n    if (firstWhitespaceAfterLineNumber < this._arr.length) {\n      return firstWhitespaceAfterLineNumber;\n    }\n\n    return -1;\n  }\n  /**\n   * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n   * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n   */\n\n\n  getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n    this._checkPendingChanges();\n\n    lineNumber = lineNumber | 0;\n    return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n  }\n  /**\n   * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n   *\n   * @param lineNumber The line number\n   * @return The sum of heights for all objects above `lineNumber`.\n   */\n\n\n  getVerticalOffsetForLineNumber(lineNumber) {\n    this._checkPendingChanges();\n\n    lineNumber = lineNumber | 0;\n    let previousLinesHeight;\n\n    if (lineNumber > 1) {\n      previousLinesHeight = this._lineHeight * (lineNumber - 1);\n    } else {\n      previousLinesHeight = 0;\n    }\n\n    const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber);\n    return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n  }\n  /**\n   * The maximum min width for all whitespaces.\n   */\n\n\n  getWhitespaceMinWidth() {\n    this._checkPendingChanges();\n\n    if (this._minWidth === -1) {\n      let minWidth = 0;\n\n      for (let i = 0, len = this._arr.length; i < len; i++) {\n        minWidth = Math.max(minWidth, this._arr[i].minWidth);\n      }\n\n      this._minWidth = minWidth;\n    }\n\n    return this._minWidth;\n  }\n  /**\n   * Check if `verticalOffset` is below all lines.\n   */\n\n\n  isAfterLines(verticalOffset) {\n    this._checkPendingChanges();\n\n    const totalHeight = this.getLinesTotalHeight();\n    return verticalOffset > totalHeight;\n  }\n\n  isInTopPadding(verticalOffset) {\n    if (this._paddingTop === 0) {\n      return false;\n    }\n\n    this._checkPendingChanges();\n\n    return verticalOffset < this._paddingTop;\n  }\n\n  isInBottomPadding(verticalOffset) {\n    if (this._paddingBottom === 0) {\n      return false;\n    }\n\n    this._checkPendingChanges();\n\n    const totalHeight = this.getLinesTotalHeight();\n    return verticalOffset >= totalHeight - this._paddingBottom;\n  }\n  /**\n   * Find the first line number that is at or after vertical offset `verticalOffset`.\n   * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n   * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n   *\n   * @param verticalOffset The vertical offset to search at.\n   * @return The line number at or after vertical offset `verticalOffset`.\n   */\n\n\n  getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n    this._checkPendingChanges();\n\n    verticalOffset = verticalOffset | 0;\n\n    if (verticalOffset < 0) {\n      return 1;\n    }\n\n    const linesCount = this._lineCount | 0;\n    const lineHeight = this._lineHeight;\n    let minLineNumber = 1;\n    let maxLineNumber = linesCount;\n\n    while (minLineNumber < maxLineNumber) {\n      const midLineNumber = (minLineNumber + maxLineNumber) / 2 | 0;\n      const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n\n      if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n        // vertical offset is after mid line number\n        minLineNumber = midLineNumber + 1;\n      } else if (verticalOffset >= midLineNumberVerticalOffset) {\n        // Hit\n        return midLineNumber;\n      } else {\n        // vertical offset is before mid line number, but mid line number could still be what we're searching for\n        maxLineNumber = midLineNumber;\n      }\n    }\n\n    if (minLineNumber > linesCount) {\n      return linesCount;\n    }\n\n    return minLineNumber;\n  }\n  /**\n   * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n   *\n   * @param verticalOffset1 The beginning of the viewport.\n   * @param verticalOffset2 The end of the viewport.\n   * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n   */\n\n\n  getLinesViewportData(verticalOffset1, verticalOffset2) {\n    this._checkPendingChanges();\n\n    verticalOffset1 = verticalOffset1 | 0;\n    verticalOffset2 = verticalOffset2 | 0;\n    const lineHeight = this._lineHeight; // Find first line number\n    // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n\n    const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n    const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n    let endLineNumber = this._lineCount | 0; // Also keep track of what whitespace we've got\n\n    let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n    const whitespaceCount = this.getWhitespacesCount() | 0;\n    let currentWhitespaceHeight;\n    let currentWhitespaceAfterLineNumber;\n\n    if (whitespaceIndex === -1) {\n      whitespaceIndex = whitespaceCount;\n      currentWhitespaceAfterLineNumber = endLineNumber + 1;\n      currentWhitespaceHeight = 0;\n    } else {\n      currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n      currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n    }\n\n    let currentVerticalOffset = startLineNumberVerticalOffset;\n    let currentLineRelativeOffset = currentVerticalOffset; // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n\n    const STEP_SIZE = 500000;\n    let bigNumbersDelta = 0;\n\n    if (startLineNumberVerticalOffset >= STEP_SIZE) {\n      // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n      bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n      bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n      currentLineRelativeOffset -= bigNumbersDelta;\n    }\n\n    const linesOffsets = [];\n    const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n    let centeredLineNumber = -1; // Figure out how far the lines go\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      if (centeredLineNumber === -1) {\n        const currentLineTop = currentVerticalOffset;\n        const currentLineBottom = currentVerticalOffset + lineHeight;\n\n        if (currentLineTop <= verticalCenter && verticalCenter < currentLineBottom || currentLineTop > verticalCenter) {\n          centeredLineNumber = lineNumber;\n        }\n      } // Count current line height in the vertical offsets\n\n\n      currentVerticalOffset += lineHeight;\n      linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset; // Next line starts immediately after this one\n\n      currentLineRelativeOffset += lineHeight;\n\n      while (currentWhitespaceAfterLineNumber === lineNumber) {\n        // Push down next line with the height of the current whitespace\n        currentLineRelativeOffset += currentWhitespaceHeight; // Count current whitespace in the vertical offsets\n\n        currentVerticalOffset += currentWhitespaceHeight;\n        whitespaceIndex++;\n\n        if (whitespaceIndex >= whitespaceCount) {\n          currentWhitespaceAfterLineNumber = endLineNumber + 1;\n        } else {\n          currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n          currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n      }\n\n      if (currentVerticalOffset >= verticalOffset2) {\n        // We have covered the entire viewport area, time to stop\n        endLineNumber = lineNumber;\n        break;\n      }\n    }\n\n    if (centeredLineNumber === -1) {\n      centeredLineNumber = endLineNumber;\n    }\n\n    const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n    let completelyVisibleStartLineNumber = startLineNumber;\n    let completelyVisibleEndLineNumber = endLineNumber;\n\n    if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n      if (startLineNumberVerticalOffset < verticalOffset1) {\n        completelyVisibleStartLineNumber++;\n      }\n    }\n\n    if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n      if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n        completelyVisibleEndLineNumber--;\n      }\n    }\n\n    return {\n      bigNumbersDelta: bigNumbersDelta,\n      startLineNumber: startLineNumber,\n      endLineNumber: endLineNumber,\n      relativeVerticalOffset: linesOffsets,\n      centeredLineNumber: centeredLineNumber,\n      completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n      completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n    };\n  }\n\n  getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n    this._checkPendingChanges();\n\n    whitespaceIndex = whitespaceIndex | 0;\n    const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n    let previousLinesHeight;\n\n    if (afterLineNumber >= 1) {\n      previousLinesHeight = this._lineHeight * afterLineNumber;\n    } else {\n      previousLinesHeight = 0;\n    }\n\n    let previousWhitespacesHeight;\n\n    if (whitespaceIndex > 0) {\n      previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n    } else {\n      previousWhitespacesHeight = 0;\n    }\n\n    return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n  }\n\n  getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n    this._checkPendingChanges();\n\n    verticalOffset = verticalOffset | 0;\n    let minWhitespaceIndex = 0;\n    let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n\n    if (maxWhitespaceIndex < 0) {\n      return -1;\n    } // Special case: nothing to be found\n\n\n    const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n    const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n\n    if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n      return -1;\n    }\n\n    while (minWhitespaceIndex < maxWhitespaceIndex) {\n      const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n      const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n      const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n\n      if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n        // vertical offset is after whitespace\n        minWhitespaceIndex = midWhitespaceIndex + 1;\n      } else if (verticalOffset >= midWhitespaceVerticalOffset) {\n        // Hit\n        return midWhitespaceIndex;\n      } else {\n        // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n        maxWhitespaceIndex = midWhitespaceIndex;\n      }\n    }\n\n    return minWhitespaceIndex;\n  }\n  /**\n   * Get exactly the whitespace that is layouted at `verticalOffset`.\n   *\n   * @param verticalOffset The vertical offset.\n   * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n   */\n\n\n  getWhitespaceAtVerticalOffset(verticalOffset) {\n    this._checkPendingChanges();\n\n    verticalOffset = verticalOffset | 0;\n    const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n\n    if (candidateIndex < 0) {\n      return null;\n    }\n\n    if (candidateIndex >= this.getWhitespacesCount()) {\n      return null;\n    }\n\n    const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n\n    if (candidateTop > verticalOffset) {\n      return null;\n    }\n\n    const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n    const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n    const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n    return {\n      id: candidateId,\n      afterLineNumber: candidateAfterLineNumber,\n      verticalOffset: candidateTop,\n      height: candidateHeight\n    };\n  }\n  /**\n   * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n   *\n   * @param verticalOffset1 The beginning of the viewport.\n   * @param verticalOffset2 The end of the viewport.\n   * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n   */\n\n\n  getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n    this._checkPendingChanges();\n\n    verticalOffset1 = verticalOffset1 | 0;\n    verticalOffset2 = verticalOffset2 | 0;\n    const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n    const endIndex = this.getWhitespacesCount() - 1;\n\n    if (startIndex < 0) {\n      return [];\n    }\n\n    const result = [];\n\n    for (let i = startIndex; i <= endIndex; i++) {\n      const top = this.getVerticalOffsetForWhitespaceIndex(i);\n      const height = this.getHeightForWhitespaceIndex(i);\n\n      if (top >= verticalOffset2) {\n        break;\n      }\n\n      result.push({\n        id: this.getIdForWhitespaceIndex(i),\n        afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n        verticalOffset: top,\n        height: height\n      });\n    }\n\n    return result;\n  }\n  /**\n   * Get all whitespaces.\n   */\n\n\n  getWhitespaces() {\n    this._checkPendingChanges();\n\n    return this._arr.slice(0);\n  }\n  /**\n   * The number of whitespaces.\n   */\n\n\n  getWhitespacesCount() {\n    this._checkPendingChanges();\n\n    return this._arr.length;\n  }\n  /**\n   * Get the `id` for whitespace at index `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return `id` of whitespace at `index`.\n   */\n\n\n  getIdForWhitespaceIndex(index) {\n    this._checkPendingChanges();\n\n    index = index | 0;\n    return this._arr[index].id;\n  }\n  /**\n   * Get the `afterLineNumber` for whitespace at index `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return `afterLineNumber` of whitespace at `index`.\n   */\n\n\n  getAfterLineNumberForWhitespaceIndex(index) {\n    this._checkPendingChanges();\n\n    index = index | 0;\n    return this._arr[index].afterLineNumber;\n  }\n  /**\n   * Get the `height` for whitespace at index `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return `height` of whitespace at `index`.\n   */\n\n\n  getHeightForWhitespaceIndex(index) {\n    this._checkPendingChanges();\n\n    index = index | 0;\n    return this._arr[index].height;\n  }\n\n}\nLinesLayout.INSTANCE_COUNT = 0;","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js"],"names":["strings","PendingChanges","constructor","_hasPending","_inserts","_changes","_removes","insert","x","push","change","remove","mustCommit","commit","linesLayout","inserts","changes","removes","_commitPendingChanges","EditorWhitespace","id","afterLineNumber","ordinal","height","minWidth","prefixSum","LinesLayout","lineCount","lineHeight","paddingTop","paddingBottom","_instanceId","singleLetterHash","INSTANCE_COUNT","_pendingChanges","_lastWhitespaceId","_arr","_prefixSumValidIndex","_minWidth","_lineCount","_lineHeight","_paddingTop","_paddingBottom","findInsertionIndex","arr","low","high","length","mid","setLineHeight","_checkPendingChanges","setPadding","onFlushed","changeWhitespace","callback","hadAChange","accessor","insertWhitespace","heightInPx","changeOneWhitespace","newAfterLineNumber","newHeight","removeWhitespace","_insertWhitespace","_changeOneWhitespace","index","_findWhitespaceIndex","_removeWhitespace","toRemove","Set","add","toChange","Map","set","applyRemoveAndChange","whitespaces","result","whitespace","has","get","concat","sort","a","b","insertIndex","splice","Math","min","i","len","removeIndex","onLinesDeleted","fromLineNumber","toLineNumber","onLinesInserted","getWhitespacesTotalHeight","getWhitespacesAccumulatedHeight","startIndex","max","getLinesTotalHeight","linesHeight","whitespacesHeight","getWhitespaceAccumulatedHeightBeforeLineNumber","lineNumber","lastWhitespaceBeforeLineNumber","_findLastWhitespaceBeforeLineNumber","delta","halfDelta","_findFirstWhitespaceAfterLineNumber","firstWhitespaceAfterLineNumber","getFirstWhitespaceIndexAfterLineNumber","getVerticalOffsetForLineNumber","previousLinesHeight","previousWhitespacesHeight","getWhitespaceMinWidth","isAfterLines","verticalOffset","totalHeight","isInTopPadding","isInBottomPadding","getLineNumberAtOrAfterVerticalOffset","linesCount","minLineNumber","maxLineNumber","midLineNumber","midLineNumberVerticalOffset","getLinesViewportData","verticalOffset1","verticalOffset2","startLineNumber","startLineNumberVerticalOffset","endLineNumber","whitespaceIndex","whitespaceCount","getWhitespacesCount","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","getAfterLineNumberForWhitespaceIndex","getHeightForWhitespaceIndex","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","bigNumbersDelta","floor","linesOffsets","verticalCenter","centeredLineNumber","currentLineTop","currentLineBottom","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","relativeVerticalOffset","getVerticalOffsetForWhitespaceIndex","getWhitespaceIndexAtOrAfterVerticallOffset","minWhitespaceIndex","maxWhitespaceIndex","maxWhitespaceVerticalOffset","maxWhitespaceHeight","midWhitespaceIndex","midWhitespaceVerticalOffset","midWhitespaceHeight","getWhitespaceAtVerticalOffset","candidateIndex","candidateTop","candidateHeight","candidateId","getIdForWhitespaceIndex","candidateAfterLineNumber","getWhitespaceViewportData","endIndex","top","getWhitespaces","slice"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    mustCommit() {\n        return this._hasPending;\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nexport class EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setLineHeight(lineHeight) {\n        this._checkPendingChanges();\n        this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount) {\n        this._checkPendingChanges();\n        this._lineCount = lineCount;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            const result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _checkPendingChanges() {\n        if (this._pendingChanges.mustCommit()) {\n            this._pendingChanges.commit(this);\n        }\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        this._checkPendingChanges();\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        this._checkPendingChanges();\n        const linesHeight = this._lineHeight * this._lineCount;\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber);\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        this._checkPendingChanges();\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        const lineHeight = this._lineHeight;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        this._checkPendingChanges();\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        const result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        this._checkPendingChanges();\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        this._checkPendingChanges();\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\nLinesLayout.INSTANCE_COUNT = 0;\n"]},"metadata":{},"sourceType":"module"}