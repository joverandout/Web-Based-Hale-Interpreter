{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue, findLast } from '../../../base/common/arrays.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nexport class GuidesTextModelPart extends TextModelPart {\n  constructor(textModel, languageConfigurationService) {\n    super();\n    this.textModel = textModel;\n    this.languageConfigurationService = languageConfigurationService;\n  }\n\n  getLanguageConfiguration(languageId) {\n    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n  }\n\n  _computeIndentLevel(lineIndex) {\n    return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n  }\n\n  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n    this.assertNotDisposed();\n    const lineCount = this.textModel.getLineCount();\n\n    if (lineNumber < 1 || lineNumber > lineCount) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n    const offSide = Boolean(foldingRules && foldingRules.offSide);\n    let up_aboveContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let up_aboveContentLineIndent = -1;\n    let up_belowContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let up_belowContentLineIndent = -1;\n\n    const up_resolveIndents = lineNumber => {\n      if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n        up_aboveContentLineIndex = -1;\n        up_aboveContentLineIndent = -1; // must find previous line with content\n\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          const indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            up_aboveContentLineIndex = lineIndex;\n            up_aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n\n      if (up_belowContentLineIndex === -2) {\n        up_belowContentLineIndex = -1;\n        up_belowContentLineIndent = -1; // must find next line with content\n\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          const indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            up_belowContentLineIndex = lineIndex;\n            up_belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n    };\n\n    let down_aboveContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let down_aboveContentLineIndent = -1;\n    let down_belowContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let down_belowContentLineIndent = -1;\n\n    const down_resolveIndents = lineNumber => {\n      if (down_aboveContentLineIndex === -2) {\n        down_aboveContentLineIndex = -1;\n        down_aboveContentLineIndent = -1; // must find previous line with content\n\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          const indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            down_aboveContentLineIndex = lineIndex;\n            down_aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n\n      if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n        down_belowContentLineIndex = -1;\n        down_belowContentLineIndent = -1; // must find next line with content\n\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          const indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            down_belowContentLineIndex = lineIndex;\n            down_belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n    };\n\n    let startLineNumber = 0;\n    let goUp = true;\n    let endLineNumber = 0;\n    let goDown = true;\n    let indent = 0;\n    let initialIndent = 0;\n\n    for (let distance = 0; goUp || goDown; distance++) {\n      const upLineNumber = lineNumber - distance;\n      const downLineNumber = lineNumber + distance;\n\n      if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n        goUp = false;\n      }\n\n      if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n        goDown = false;\n      }\n\n      if (distance > 50000) {\n        // stop processing\n        goUp = false;\n        goDown = false;\n      }\n\n      let upLineIndentLevel = -1;\n\n      if (goUp && upLineNumber >= 1) {\n        // compute indent level going up\n        const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          up_belowContentLineIndex = upLineNumber - 1;\n          up_belowContentLineIndent = currentIndent;\n          upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n        } else {\n          up_resolveIndents(upLineNumber);\n          upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n        }\n      }\n\n      let downLineIndentLevel = -1;\n\n      if (goDown && downLineNumber <= lineCount) {\n        // compute indent level going down\n        const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          down_aboveContentLineIndex = downLineNumber - 1;\n          down_aboveContentLineIndent = currentIndent;\n          downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n        } else {\n          down_resolveIndents(downLineNumber);\n          downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n        }\n      }\n\n      if (distance === 0) {\n        initialIndent = upLineIndentLevel;\n        continue;\n      }\n\n      if (distance === 1) {\n        if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {\n          // This is the beginning of a scope, we have special handling here, since we want the\n          // child scope indent to be active, not the parent scope\n          goUp = false;\n          startLineNumber = downLineNumber;\n          endLineNumber = downLineNumber;\n          indent = downLineIndentLevel;\n          continue;\n        }\n\n        if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {\n          // This is the end of a scope, just like above\n          goDown = false;\n          startLineNumber = upLineNumber;\n          endLineNumber = upLineNumber;\n          indent = upLineIndentLevel;\n          continue;\n        }\n\n        startLineNumber = lineNumber;\n        endLineNumber = lineNumber;\n        indent = initialIndent;\n\n        if (indent === 0) {\n          // No need to continue\n          return {\n            startLineNumber,\n            endLineNumber,\n            indent\n          };\n        }\n      }\n\n      if (goUp) {\n        if (upLineIndentLevel >= indent) {\n          startLineNumber = upLineNumber;\n        } else {\n          goUp = false;\n        }\n      }\n\n      if (goDown) {\n        if (downLineIndentLevel >= indent) {\n          endLineNumber = downLineNumber;\n        } else {\n          goDown = false;\n        }\n      }\n    }\n\n    return {\n      startLineNumber,\n      endLineNumber,\n      indent\n    };\n  }\n\n  getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n    var _a, _b, _c, _d, _e;\n\n    const result = [];\n    const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber)));\n    let activeBracketPairRange = undefined;\n\n    if (activePosition && bracketPairs.length > 0) {\n      const bracketsContainingActivePosition = startLineNumber <= activePosition.lineNumber && activePosition.lineNumber <= endLineNumber ? // Does active position intersect with the view port? -> Intersect bracket pairs with activePosition\n      bracketPairs.filter(bp => Range.strictContainsPosition(bp.range, activePosition)) : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition));\n      activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition,\n      /* Exclude single line bracket pairs for cases such as\n       * ```\n       * function test() {\n       * \t\tif (true) { | }\n       * }\n       * ```\n       */\n      i => i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n    }\n\n    const queue = new ArrayQueue(bracketPairs);\n    /** Indexed by nesting level */\n\n    const activeGuides = new Array();\n    const nextGuides = new Array();\n    const colorProvider = new BracketPairGuidesClassNames();\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      let guides = new Array();\n\n      if (nextGuides.length > 0) {\n        guides = guides.concat(nextGuides);\n        nextGuides.length = 0;\n      }\n\n      result.push(guides); // Update activeGuides\n\n      for (const pair of queue.takeWhile(b => b.openingBracketRange.startLineNumber <= lineNumber) || []) {\n        if (pair.range.startLineNumber === pair.range.endLineNumber) {\n          // ignore single line brackets\n          continue;\n        }\n\n        const guideVisibleColumn = Math.min(this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition()), this.getVisibleColumnFromPosition((_c = (_b = pair.closingBracketRange) === null || _b === void 0 ? void 0 : _b.getStartPosition()) !== null && _c !== void 0 ? _c : pair.range.getEndPosition()), pair.minVisibleColumnIndentation + 1);\n        let renderHorizontalEndLineAtTheBottom = false;\n\n        if (pair.closingBracketRange) {\n          const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n\n          if (firstNonWsIndex < pair.closingBracketRange.startColumn - 1) {\n            renderHorizontalEndLineAtTheBottom = true;\n          }\n        }\n\n        const start = pair.openingBracketRange.getStartPosition();\n        const end = (_e = (_d = pair.closingBracketRange) === null || _d === void 0 ? void 0 : _d.getStartPosition()) !== null && _e !== void 0 ? _e : pair.range.getEndPosition();\n\n        if (pair.closingBracketRange === undefined) {\n          // Don't show guides for bracket pairs that are not balanced.\n          // See #135125.\n          activeGuides[pair.nestingLevel] = null;\n        } else {\n          activeGuides[pair.nestingLevel] = {\n            nestingLevel: pair.nestingLevel,\n            guideVisibleColumn,\n            start,\n            visibleStartColumn: this.getVisibleColumnFromPosition(start),\n            end,\n            visibleEndColumn: this.getVisibleColumnFromPosition(end),\n            bracketPair: pair,\n            renderHorizontalEndLineAtTheBottom\n          };\n        }\n      }\n\n      for (const line of activeGuides) {\n        if (!line) {\n          continue;\n        }\n\n        const isActive = activeBracketPairRange && line.bracketPair.range.equalsRange(activeBracketPairRange);\n        const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) + (options.highlightActive && isActive ? ' ' + colorProvider.activeClassName : '');\n\n        if (isActive && options.horizontalGuides !== HorizontalGuidesState.Disabled || options.includeInactive && options.horizontalGuides === HorizontalGuidesState.Enabled) {\n          if (line.start.lineNumber === lineNumber) {\n            if (line.guideVisibleColumn < line.visibleStartColumn) {\n              guides.push(new IndentGuide(line.guideVisibleColumn, className, new IndentGuideHorizontalLine(false, line.start.column)));\n            }\n          }\n\n          if (line.end.lineNumber === lineNumber + 1) {\n            // The next line might have horizontal guides.\n            // However, the next line might also have a new bracket pair with the same indentation,\n            // so the current bracket pair might get replaced. That's why we push the guide to nextGuides one line ahead.\n            if (line.guideVisibleColumn < line.visibleEndColumn) {\n              nextGuides.push(new IndentGuide(line.guideVisibleColumn, className, new IndentGuideHorizontalLine(!line.renderHorizontalEndLineAtTheBottom, line.end.column)));\n            }\n          }\n        }\n      }\n\n      let lastVisibleColumnCount = Number.MAX_SAFE_INTEGER; // Going backwards, so the last guide potentially replaces others\n\n      for (let i = activeGuides.length - 1; i >= 0; i--) {\n        const line = activeGuides[i];\n\n        if (!line) {\n          continue;\n        }\n\n        const isActive = options.highlightActive && activeBracketPairRange && line.bracketPair.range.equalsRange(activeBracketPairRange);\n        const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) + (isActive ? ' ' + colorProvider.activeClassName : '');\n\n        if (isActive || options.includeInactive) {\n          if (line.renderHorizontalEndLineAtTheBottom && line.end.lineNumber === lineNumber + 1) {\n            nextGuides.push(new IndentGuide(line.guideVisibleColumn, className, null));\n          }\n        }\n\n        if (line.end.lineNumber <= lineNumber || line.start.lineNumber >= lineNumber) {\n          continue;\n        }\n\n        if (line.guideVisibleColumn >= lastVisibleColumnCount && !isActive) {\n          // Don't render a guide on top of an existing guide, unless it is active.\n          continue;\n        }\n\n        lastVisibleColumnCount = line.guideVisibleColumn;\n\n        if (isActive || options.includeInactive) {\n          guides.push(new IndentGuide(line.guideVisibleColumn, className, null));\n        }\n      }\n\n      guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n    }\n\n    return result;\n  }\n\n  getVisibleColumnFromPosition(position) {\n    return CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1;\n  }\n\n  getLinesIndentGuides(startLineNumber, endLineNumber) {\n    this.assertNotDisposed();\n    const lineCount = this.textModel.getLineCount();\n\n    if (startLineNumber < 1 || startLineNumber > lineCount) {\n      throw new Error('Illegal value for startLineNumber');\n    }\n\n    if (endLineNumber < 1 || endLineNumber > lineCount) {\n      throw new Error('Illegal value for endLineNumber');\n    }\n\n    const options = this.textModel.getOptions();\n    const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n    const offSide = Boolean(foldingRules && foldingRules.offSide);\n    const result = new Array(endLineNumber - startLineNumber + 1);\n    let aboveContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let aboveContentLineIndent = -1;\n    let belowContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    let belowContentLineIndent = -1;\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const resultIndex = lineNumber - startLineNumber;\n\n      const currentIndent = this._computeIndentLevel(lineNumber - 1);\n\n      if (currentIndent >= 0) {\n        // This line has content (besides whitespace)\n        // Use the line's indent\n        aboveContentLineIndex = lineNumber - 1;\n        aboveContentLineIndent = currentIndent;\n        result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n        continue;\n      }\n\n      if (aboveContentLineIndex === -2) {\n        aboveContentLineIndex = -1;\n        aboveContentLineIndent = -1; // must find previous line with content\n\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          const indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            aboveContentLineIndex = lineIndex;\n            aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n\n      if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n        belowContentLineIndex = -1;\n        belowContentLineIndent = -1; // must find next line with content\n\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          const indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            belowContentLineIndex = lineIndex;\n            belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n\n      result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n    }\n\n    return result;\n  }\n\n  _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n    const options = this.textModel.getOptions();\n\n    if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n      // At the top or bottom of the file\n      return 0;\n    } else if (aboveContentLineIndent < belowContentLineIndent) {\n      // we are inside the region above\n      return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n    } else if (aboveContentLineIndent === belowContentLineIndent) {\n      // we are in between two regions\n      return Math.ceil(belowContentLineIndent / options.indentSize);\n    } else {\n      if (offSide) {\n        // same level as region below\n        return Math.ceil(belowContentLineIndent / options.indentSize);\n      } else {\n        // we are inside the region that ends below\n        return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n      }\n    }\n  }\n\n}\nexport class BracketPairGuidesClassNames {\n  constructor() {\n    this.activeClassName = 'indent-active';\n  }\n\n  getInlineClassNameOfLevel(level) {\n    // To support a dynamic amount of colors up to 6 colors,\n    // we use a number that is a lcm of all numbers from 1 to 6.\n    return `bracket-indent-guide lvl-${level % 30}`;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js"],"names":["ArrayQueue","findLast","strings","CursorColumns","Range","TextModelPart","computeIndentLevel","HorizontalGuidesState","IndentGuide","IndentGuideHorizontalLine","GuidesTextModelPart","constructor","textModel","languageConfigurationService","getLanguageConfiguration","languageId","_computeIndentLevel","lineIndex","getLineContent","getOptions","tabSize","getActiveIndentGuide","lineNumber","minLineNumber","maxLineNumber","assertNotDisposed","lineCount","getLineCount","Error","foldingRules","getLanguageId","offSide","Boolean","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","indent","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","startLineNumber","goUp","endLineNumber","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","Math","ceil","indentSize","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","options","_a","_b","_c","_d","_e","result","bracketPairs","getBracketPairsInRangeWithMinIndentation","getLineMaxColumn","activeBracketPairRange","undefined","length","bracketsContainingActivePosition","filter","bp","strictContainsPosition","range","getBracketPairsInRange","fromPositions","i","queue","activeGuides","Array","nextGuides","colorProvider","BracketPairGuidesClassNames","guides","concat","push","pair","takeWhile","b","openingBracketRange","guideVisibleColumn","min","getVisibleColumnFromPosition","getStartPosition","closingBracketRange","getEndPosition","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","firstNonWsIndex","firstNonWhitespaceIndex","startColumn","start","end","nestingLevel","visibleStartColumn","visibleEndColumn","bracketPair","line","isActive","equalsRange","className","getInlineClassNameOfLevel","highlightActive","activeClassName","horizontalGuides","Disabled","includeInactive","Enabled","column","lastVisibleColumnCount","Number","MAX_SAFE_INTEGER","sort","a","visibleColumn","position","visibleColumnFromColumn","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","floor","level"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,UAAT,EAAqBC,QAArB,QAAqC,gCAArC;AACA,OAAO,KAAKC,OAAZ,MAAyB,iCAAzB;AACA,SAASC,aAAT,QAA8B,0BAA9B;AACA,SAASC,KAAT,QAAsB,kBAAtB;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,kBAAT,QAAmC,YAAnC;AACA,SAASC,qBAAT,EAAgCC,WAAhC,EAA6CC,yBAA7C,QAA8E,uBAA9E;AACA,OAAO,MAAMC,mBAAN,SAAkCL,aAAlC,CAAgD;AACnDM,EAAAA,WAAW,CAACC,SAAD,EAAYC,4BAAZ,EAA0C;AACjD;AACA,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKC,4BAAL,GAAoCA,4BAApC;AACH;;AACDC,EAAAA,wBAAwB,CAACC,UAAD,EAAa;AACjC,WAAO,KAAKF,4BAAL,CAAkCC,wBAAlC,CAA2DC,UAA3D,CAAP;AACH;;AACDC,EAAAA,mBAAmB,CAACC,SAAD,EAAY;AAC3B,WAAOX,kBAAkB,CAAC,KAAKM,SAAL,CAAeM,cAAf,CAA8BD,SAAS,GAAG,CAA1C,CAAD,EAA+C,KAAKL,SAAL,CAAeO,UAAf,GAA4BC,OAA3E,CAAzB;AACH;;AACDC,EAAAA,oBAAoB,CAACC,UAAD,EAAaC,aAAb,EAA4BC,aAA5B,EAA2C;AAC3D,SAAKC,iBAAL;AACA,UAAMC,SAAS,GAAG,KAAKd,SAAL,CAAee,YAAf,EAAlB;;AACA,QAAIL,UAAU,GAAG,CAAb,IAAkBA,UAAU,GAAGI,SAAnC,EAA8C;AAC1C,YAAM,IAAIE,KAAJ,CAAU,8BAAV,CAAN;AACH;;AACD,UAAMC,YAAY,GAAG,KAAKf,wBAAL,CAA8B,KAAKF,SAAL,CAAekB,aAAf,EAA9B,EAA8DD,YAAnF;AACA,UAAME,OAAO,GAAGC,OAAO,CAACH,YAAY,IAAIA,YAAY,CAACE,OAA9B,CAAvB;AACA,QAAIE,wBAAwB,GAAG,CAAC,CAAhC;AAAmC;;AACnC,QAAIC,yBAAyB,GAAG,CAAC,CAAjC;AACA,QAAIC,wBAAwB,GAAG,CAAC,CAAhC;AAAmC;;AACnC,QAAIC,yBAAyB,GAAG,CAAC,CAAjC;;AACA,UAAMC,iBAAiB,GAAIf,UAAD,IAAgB;AACtC,UAAIW,wBAAwB,KAAK,CAAC,CAA9B,KACCA,wBAAwB,KAAK,CAAC,CAA9B,IACGA,wBAAwB,GAAGX,UAAU,GAAG,CAF5C,CAAJ,EAEoD;AAChDW,QAAAA,wBAAwB,GAAG,CAAC,CAA5B;AACAC,QAAAA,yBAAyB,GAAG,CAAC,CAA7B,CAFgD,CAGhD;;AACA,aAAK,IAAIjB,SAAS,GAAGK,UAAU,GAAG,CAAlC,EAAqCL,SAAS,IAAI,CAAlD,EAAqDA,SAAS,EAA9D,EAAkE;AAC9D,gBAAMqB,MAAM,GAAG,KAAKtB,mBAAL,CAAyBC,SAAzB,CAAf;;AACA,cAAIqB,MAAM,IAAI,CAAd,EAAiB;AACbL,YAAAA,wBAAwB,GAAGhB,SAA3B;AACAiB,YAAAA,yBAAyB,GAAGI,MAA5B;AACA;AACH;AACJ;AACJ;;AACD,UAAIH,wBAAwB,KAAK,CAAC,CAAlC,EAAqC;AACjCA,QAAAA,wBAAwB,GAAG,CAAC,CAA5B;AACAC,QAAAA,yBAAyB,GAAG,CAAC,CAA7B,CAFiC,CAGjC;;AACA,aAAK,IAAInB,SAAS,GAAGK,UAArB,EAAiCL,SAAS,GAAGS,SAA7C,EAAwDT,SAAS,EAAjE,EAAqE;AACjE,gBAAMqB,MAAM,GAAG,KAAKtB,mBAAL,CAAyBC,SAAzB,CAAf;;AACA,cAAIqB,MAAM,IAAI,CAAd,EAAiB;AACbH,YAAAA,wBAAwB,GAAGlB,SAA3B;AACAmB,YAAAA,yBAAyB,GAAGE,MAA5B;AACA;AACH;AACJ;AACJ;AACJ,KA7BD;;AA8BA,QAAIC,0BAA0B,GAAG,CAAC,CAAlC;AAAqC;;AACrC,QAAIC,2BAA2B,GAAG,CAAC,CAAnC;AACA,QAAIC,0BAA0B,GAAG,CAAC,CAAlC;AAAqC;;AACrC,QAAIC,2BAA2B,GAAG,CAAC,CAAnC;;AACA,UAAMC,mBAAmB,GAAIrB,UAAD,IAAgB;AACxC,UAAIiB,0BAA0B,KAAK,CAAC,CAApC,EAAuC;AACnCA,QAAAA,0BAA0B,GAAG,CAAC,CAA9B;AACAC,QAAAA,2BAA2B,GAAG,CAAC,CAA/B,CAFmC,CAGnC;;AACA,aAAK,IAAIvB,SAAS,GAAGK,UAAU,GAAG,CAAlC,EAAqCL,SAAS,IAAI,CAAlD,EAAqDA,SAAS,EAA9D,EAAkE;AAC9D,gBAAMqB,MAAM,GAAG,KAAKtB,mBAAL,CAAyBC,SAAzB,CAAf;;AACA,cAAIqB,MAAM,IAAI,CAAd,EAAiB;AACbC,YAAAA,0BAA0B,GAAGtB,SAA7B;AACAuB,YAAAA,2BAA2B,GAAGF,MAA9B;AACA;AACH;AACJ;AACJ;;AACD,UAAIG,0BAA0B,KAAK,CAAC,CAAhC,KACCA,0BAA0B,KAAK,CAAC,CAAhC,IACGA,0BAA0B,GAAGnB,UAAU,GAAG,CAF9C,CAAJ,EAEsD;AAClDmB,QAAAA,0BAA0B,GAAG,CAAC,CAA9B;AACAC,QAAAA,2BAA2B,GAAG,CAAC,CAA/B,CAFkD,CAGlD;;AACA,aAAK,IAAIzB,SAAS,GAAGK,UAArB,EAAiCL,SAAS,GAAGS,SAA7C,EAAwDT,SAAS,EAAjE,EAAqE;AACjE,gBAAMqB,MAAM,GAAG,KAAKtB,mBAAL,CAAyBC,SAAzB,CAAf;;AACA,cAAIqB,MAAM,IAAI,CAAd,EAAiB;AACbG,YAAAA,0BAA0B,GAAGxB,SAA7B;AACAyB,YAAAA,2BAA2B,GAAGJ,MAA9B;AACA;AACH;AACJ;AACJ;AACJ,KA7BD;;AA8BA,QAAIM,eAAe,GAAG,CAAtB;AACA,QAAIC,IAAI,GAAG,IAAX;AACA,QAAIC,aAAa,GAAG,CAApB;AACA,QAAIC,MAAM,GAAG,IAAb;AACA,QAAIT,MAAM,GAAG,CAAb;AACA,QAAIU,aAAa,GAAG,CAApB;;AACA,SAAK,IAAIC,QAAQ,GAAG,CAApB,EAAuBJ,IAAI,IAAIE,MAA/B,EAAuCE,QAAQ,EAA/C,EAAmD;AAC/C,YAAMC,YAAY,GAAG5B,UAAU,GAAG2B,QAAlC;AACA,YAAME,cAAc,GAAG7B,UAAU,GAAG2B,QAApC;;AACA,UAAIA,QAAQ,GAAG,CAAX,KAAiBC,YAAY,GAAG,CAAf,IAAoBA,YAAY,GAAG3B,aAApD,CAAJ,EAAwE;AACpEsB,QAAAA,IAAI,GAAG,KAAP;AACH;;AACD,UAAII,QAAQ,GAAG,CAAX,KACCE,cAAc,GAAGzB,SAAjB,IAA8ByB,cAAc,GAAG3B,aADhD,CAAJ,EACoE;AAChEuB,QAAAA,MAAM,GAAG,KAAT;AACH;;AACD,UAAIE,QAAQ,GAAG,KAAf,EAAsB;AAClB;AACAJ,QAAAA,IAAI,GAAG,KAAP;AACAE,QAAAA,MAAM,GAAG,KAAT;AACH;;AACD,UAAIK,iBAAiB,GAAG,CAAC,CAAzB;;AACA,UAAIP,IAAI,IAAIK,YAAY,IAAI,CAA5B,EAA+B;AAC3B;AACA,cAAMG,aAAa,GAAG,KAAKrC,mBAAL,CAAyBkC,YAAY,GAAG,CAAxC,CAAtB;;AACA,YAAIG,aAAa,IAAI,CAArB,EAAwB;AACpB;AACA;AACAlB,UAAAA,wBAAwB,GAAGe,YAAY,GAAG,CAA1C;AACAd,UAAAA,yBAAyB,GAAGiB,aAA5B;AACAD,UAAAA,iBAAiB,GAAGE,IAAI,CAACC,IAAL,CAAUF,aAAa,GAAG,KAAKzC,SAAL,CAAeO,UAAf,GAA4BqC,UAAtD,CAApB;AACH,SAND,MAOK;AACDnB,UAAAA,iBAAiB,CAACa,YAAD,CAAjB;AACAE,UAAAA,iBAAiB,GAAG,KAAKK,gCAAL,CAAsC1B,OAAtC,EAA+CG,yBAA/C,EAA0EE,yBAA1E,CAApB;AACH;AACJ;;AACD,UAAIsB,mBAAmB,GAAG,CAAC,CAA3B;;AACA,UAAIX,MAAM,IAAII,cAAc,IAAIzB,SAAhC,EAA2C;AACvC;AACA,cAAM2B,aAAa,GAAG,KAAKrC,mBAAL,CAAyBmC,cAAc,GAAG,CAA1C,CAAtB;;AACA,YAAIE,aAAa,IAAI,CAArB,EAAwB;AACpB;AACA;AACAd,UAAAA,0BAA0B,GAAGY,cAAc,GAAG,CAA9C;AACAX,UAAAA,2BAA2B,GAAGa,aAA9B;AACAK,UAAAA,mBAAmB,GAAGJ,IAAI,CAACC,IAAL,CAAUF,aAAa,GAAG,KAAKzC,SAAL,CAAeO,UAAf,GAA4BqC,UAAtD,CAAtB;AACH,SAND,MAOK;AACDb,UAAAA,mBAAmB,CAACQ,cAAD,CAAnB;AACAO,UAAAA,mBAAmB,GAAG,KAAKD,gCAAL,CAAsC1B,OAAtC,EAA+CS,2BAA/C,EAA4EE,2BAA5E,CAAtB;AACH;AACJ;;AACD,UAAIO,QAAQ,KAAK,CAAjB,EAAoB;AAChBD,QAAAA,aAAa,GAAGI,iBAAhB;AACA;AACH;;AACD,UAAIH,QAAQ,KAAK,CAAjB,EAAoB;AAChB,YAAIE,cAAc,IAAIzB,SAAlB,IACAgC,mBAAmB,IAAI,CADvB,IAEAV,aAAa,GAAG,CAAhB,KAAsBU,mBAF1B,EAE+C;AAC3C;AACA;AACAb,UAAAA,IAAI,GAAG,KAAP;AACAD,UAAAA,eAAe,GAAGO,cAAlB;AACAL,UAAAA,aAAa,GAAGK,cAAhB;AACAb,UAAAA,MAAM,GAAGoB,mBAAT;AACA;AACH;;AACD,YAAIR,YAAY,IAAI,CAAhB,IACAE,iBAAiB,IAAI,CADrB,IAEAA,iBAAiB,GAAG,CAApB,KAA0BJ,aAF9B,EAE6C;AACzC;AACAD,UAAAA,MAAM,GAAG,KAAT;AACAH,UAAAA,eAAe,GAAGM,YAAlB;AACAJ,UAAAA,aAAa,GAAGI,YAAhB;AACAZ,UAAAA,MAAM,GAAGc,iBAAT;AACA;AACH;;AACDR,QAAAA,eAAe,GAAGtB,UAAlB;AACAwB,QAAAA,aAAa,GAAGxB,UAAhB;AACAgB,QAAAA,MAAM,GAAGU,aAAT;;AACA,YAAIV,MAAM,KAAK,CAAf,EAAkB;AACd;AACA,iBAAO;AAAEM,YAAAA,eAAF;AAAmBE,YAAAA,aAAnB;AAAkCR,YAAAA;AAAlC,WAAP;AACH;AACJ;;AACD,UAAIO,IAAJ,EAAU;AACN,YAAIO,iBAAiB,IAAId,MAAzB,EAAiC;AAC7BM,UAAAA,eAAe,GAAGM,YAAlB;AACH,SAFD,MAGK;AACDL,UAAAA,IAAI,GAAG,KAAP;AACH;AACJ;;AACD,UAAIE,MAAJ,EAAY;AACR,YAAIW,mBAAmB,IAAIpB,MAA3B,EAAmC;AAC/BQ,UAAAA,aAAa,GAAGK,cAAhB;AACH,SAFD,MAGK;AACDJ,UAAAA,MAAM,GAAG,KAAT;AACH;AACJ;AACJ;;AACD,WAAO;AAAEH,MAAAA,eAAF;AAAmBE,MAAAA,aAAnB;AAAkCR,MAAAA;AAAlC,KAAP;AACH;;AACDqB,EAAAA,qBAAqB,CAACf,eAAD,EAAkBE,aAAlB,EAAiCc,cAAjC,EAAiDC,OAAjD,EAA0D;AAC3E,QAAIC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBC,EAApB;;AACA,UAAMC,MAAM,GAAG,EAAf;AACA,UAAMC,YAAY,GAAG,KAAKxD,SAAL,CAAewD,YAAf,CAA4BC,wCAA5B,CAAqE,IAAIjE,KAAJ,CAAUwC,eAAV,EAA2B,CAA3B,EAA8BE,aAA9B,EAA6C,KAAKlC,SAAL,CAAe0D,gBAAf,CAAgCxB,aAAhC,CAA7C,CAArE,CAArB;AACA,QAAIyB,sBAAsB,GAAGC,SAA7B;;AACA,QAAIZ,cAAc,IAAIQ,YAAY,CAACK,MAAb,GAAsB,CAA5C,EAA+C;AAC3C,YAAMC,gCAAgC,GAAG9B,eAAe,IAAIgB,cAAc,CAACtC,UAAlC,IACrCsC,cAAc,CAACtC,UAAf,IAA6BwB,aADQ,GAEnC;AACEsB,MAAAA,YAAY,CAACO,MAAb,CAAqBC,EAAD,IAAQxE,KAAK,CAACyE,sBAAN,CAA6BD,EAAE,CAACE,KAAhC,EAAuClB,cAAvC,CAA5B,CAHiC,GAInC,KAAKhD,SAAL,CAAewD,YAAf,CAA4BW,sBAA5B,CAAmD3E,KAAK,CAAC4E,aAAN,CAAoBpB,cAApB,CAAnD,CAJN;AAKAW,MAAAA,sBAAsB,GAAG,CAACT,EAAE,GAAG7D,QAAQ,CAACyE,gCAAD;AACvC;AACZ;AACA;AACA;AACA;AACA;AACA;AACaO,MAAAA,CAAD,IAAOA,CAAC,CAACH,KAAF,CAAQlC,eAAR,KAA4BqC,CAAC,CAACH,KAAF,CAAQhC,aARJ,CAAd,MAQsC,IARtC,IAQ8CgB,EAAE,KAAK,KAAK,CAR1D,GAQ8D,KAAK,CARnE,GAQuEA,EAAE,CAACgB,KARnG;AASH;;AACD,UAAMI,KAAK,GAAG,IAAIlF,UAAJ,CAAeoE,YAAf,CAAd;AACA;;AACA,UAAMe,YAAY,GAAG,IAAIC,KAAJ,EAArB;AACA,UAAMC,UAAU,GAAG,IAAID,KAAJ,EAAnB;AACA,UAAME,aAAa,GAAG,IAAIC,2BAAJ,EAAtB;;AACA,SAAK,IAAIjE,UAAU,GAAGsB,eAAtB,EAAuCtB,UAAU,IAAIwB,aAArD,EAAoExB,UAAU,EAA9E,EAAkF;AAC9E,UAAIkE,MAAM,GAAG,IAAIJ,KAAJ,EAAb;;AACA,UAAIC,UAAU,CAACZ,MAAX,GAAoB,CAAxB,EAA2B;AACvBe,QAAAA,MAAM,GAAGA,MAAM,CAACC,MAAP,CAAcJ,UAAd,CAAT;AACAA,QAAAA,UAAU,CAACZ,MAAX,GAAoB,CAApB;AACH;;AACDN,MAAAA,MAAM,CAACuB,IAAP,CAAYF,MAAZ,EAN8E,CAO9E;;AACA,WAAK,MAAMG,IAAX,IAAmBT,KAAK,CAACU,SAAN,CAAiBC,CAAD,IAAOA,CAAC,CAACC,mBAAF,CAAsBlD,eAAtB,IAAyCtB,UAAhE,KAA+E,EAAlG,EAAsG;AAClG,YAAIqE,IAAI,CAACb,KAAL,CAAWlC,eAAX,KAA+B+C,IAAI,CAACb,KAAL,CAAWhC,aAA9C,EAA6D;AACzD;AACA;AACH;;AACD,cAAMiD,kBAAkB,GAAGzC,IAAI,CAAC0C,GAAL,CAAS,KAAKC,4BAAL,CAAkCN,IAAI,CAACG,mBAAL,CAAyBI,gBAAzB,EAAlC,CAAT,EAAyF,KAAKD,4BAAL,CAAkC,CAACjC,EAAE,GAAG,CAACD,EAAE,GAAG4B,IAAI,CAACQ,mBAAX,MAAoC,IAApC,IAA4CpC,EAAE,KAAK,KAAK,CAAxD,GAA4D,KAAK,CAAjE,GAAqEA,EAAE,CAACmC,gBAAH,EAA3E,MAAsG,IAAtG,IAA8GlC,EAAE,KAAK,KAAK,CAA1H,GAA8HA,EAA9H,GAAmI2B,IAAI,CAACb,KAAL,CAAWsB,cAAX,EAArK,CAAzF,EAA4RT,IAAI,CAACU,2BAAL,GAAmC,CAA/T,CAA3B;AACA,YAAIC,kCAAkC,GAAG,KAAzC;;AACA,YAAIX,IAAI,CAACQ,mBAAT,EAA8B;AAC1B,gBAAMI,eAAe,GAAGrG,OAAO,CAACsG,uBAAR,CAAgC,KAAK5F,SAAL,CAAeM,cAAf,CAA8ByE,IAAI,CAACQ,mBAAL,CAAyBvD,eAAvD,CAAhC,CAAxB;;AACA,cAAI2D,eAAe,GAAGZ,IAAI,CAACQ,mBAAL,CAAyBM,WAAzB,GAAuC,CAA7D,EAAgE;AAC5DH,YAAAA,kCAAkC,GAAG,IAArC;AACH;AACJ;;AACD,cAAMI,KAAK,GAAGf,IAAI,CAACG,mBAAL,CAAyBI,gBAAzB,EAAd;AACA,cAAMS,GAAG,GAAG,CAACzC,EAAE,GAAG,CAACD,EAAE,GAAG0B,IAAI,CAACQ,mBAAX,MAAoC,IAApC,IAA4ClC,EAAE,KAAK,KAAK,CAAxD,GAA4D,KAAK,CAAjE,GAAqEA,EAAE,CAACiC,gBAAH,EAA3E,MAAsG,IAAtG,IAA8GhC,EAAE,KAAK,KAAK,CAA1H,GAA8HA,EAA9H,GAAmIyB,IAAI,CAACb,KAAL,CAAWsB,cAAX,EAA/I;;AACA,YAAIT,IAAI,CAACQ,mBAAL,KAA6B3B,SAAjC,EAA4C;AACxC;AACA;AACAW,UAAAA,YAAY,CAACQ,IAAI,CAACiB,YAAN,CAAZ,GAAkC,IAAlC;AACH,SAJD,MAKK;AACDzB,UAAAA,YAAY,CAACQ,IAAI,CAACiB,YAAN,CAAZ,GAAkC;AAC9BA,YAAAA,YAAY,EAAEjB,IAAI,CAACiB,YADW;AAE9Bb,YAAAA,kBAF8B;AAG9BW,YAAAA,KAH8B;AAI9BG,YAAAA,kBAAkB,EAAE,KAAKZ,4BAAL,CAAkCS,KAAlC,CAJU;AAK9BC,YAAAA,GAL8B;AAM9BG,YAAAA,gBAAgB,EAAE,KAAKb,4BAAL,CAAkCU,GAAlC,CANY;AAO9BI,YAAAA,WAAW,EAAEpB,IAPiB;AAQ9BW,YAAAA;AAR8B,WAAlC;AAUH;AACJ;;AACD,WAAK,MAAMU,IAAX,IAAmB7B,YAAnB,EAAiC;AAC7B,YAAI,CAAC6B,IAAL,EAAW;AACP;AACH;;AACD,cAAMC,QAAQ,GAAG1C,sBAAsB,IACnCyC,IAAI,CAACD,WAAL,CAAiBjC,KAAjB,CAAuBoC,WAAvB,CAAmC3C,sBAAnC,CADJ;AAEA,cAAM4C,SAAS,GAAG7B,aAAa,CAAC8B,yBAAd,CAAwCJ,IAAI,CAACJ,YAA7C,KACb/C,OAAO,CAACwD,eAAR,IAA2BJ,QAA3B,GACK,MAAM3B,aAAa,CAACgC,eADzB,GAEK,EAHQ,CAAlB;;AAIA,YAAKL,QAAQ,IACTpD,OAAO,CAAC0D,gBAAR,KACIhH,qBAAqB,CAACiH,QAF1B,IAGC3D,OAAO,CAAC4D,eAAR,IACG5D,OAAO,CAAC0D,gBAAR,KAA6BhH,qBAAqB,CAACmH,OAJ3D,EAIqE;AACjE,cAAIV,IAAI,CAACN,KAAL,CAAWpF,UAAX,KAA0BA,UAA9B,EAA0C;AACtC,gBAAI0F,IAAI,CAACjB,kBAAL,GAA0BiB,IAAI,CAACH,kBAAnC,EAAuD;AACnDrB,cAAAA,MAAM,CAACE,IAAP,CAAY,IAAIlF,WAAJ,CAAgBwG,IAAI,CAACjB,kBAArB,EAAyCoB,SAAzC,EAAoD,IAAI1G,yBAAJ,CAA8B,KAA9B,EAAqCuG,IAAI,CAACN,KAAL,CAAWiB,MAAhD,CAApD,CAAZ;AACH;AACJ;;AACD,cAAIX,IAAI,CAACL,GAAL,CAASrF,UAAT,KAAwBA,UAAU,GAAG,CAAzC,EAA4C;AACxC;AACA;AACA;AACA,gBAAI0F,IAAI,CAACjB,kBAAL,GAA0BiB,IAAI,CAACF,gBAAnC,EAAqD;AACjDzB,cAAAA,UAAU,CAACK,IAAX,CAAgB,IAAIlF,WAAJ,CAAgBwG,IAAI,CAACjB,kBAArB,EAAyCoB,SAAzC,EAAoD,IAAI1G,yBAAJ,CAA8B,CAACuG,IAAI,CAACV,kCAApC,EAAwEU,IAAI,CAACL,GAAL,CAASgB,MAAjF,CAApD,CAAhB;AACH;AACJ;AACJ;AACJ;;AACD,UAAIC,sBAAsB,GAAGC,MAAM,CAACC,gBAApC,CAvE8E,CAwE9E;;AACA,WAAK,IAAI7C,CAAC,GAAGE,YAAY,CAACV,MAAb,GAAsB,CAAnC,EAAsCQ,CAAC,IAAI,CAA3C,EAA8CA,CAAC,EAA/C,EAAmD;AAC/C,cAAM+B,IAAI,GAAG7B,YAAY,CAACF,CAAD,CAAzB;;AACA,YAAI,CAAC+B,IAAL,EAAW;AACP;AACH;;AACD,cAAMC,QAAQ,GAAGpD,OAAO,CAACwD,eAAR,IACb9C,sBADa,IAEbyC,IAAI,CAACD,WAAL,CAAiBjC,KAAjB,CAAuBoC,WAAvB,CAAmC3C,sBAAnC,CAFJ;AAGA,cAAM4C,SAAS,GAAG7B,aAAa,CAAC8B,yBAAd,CAAwCJ,IAAI,CAACJ,YAA7C,KACbK,QAAQ,GAAG,MAAM3B,aAAa,CAACgC,eAAvB,GAAyC,EADpC,CAAlB;;AAEA,YAAIL,QAAQ,IAAIpD,OAAO,CAAC4D,eAAxB,EAAyC;AACrC,cAAIT,IAAI,CAACV,kCAAL,IACAU,IAAI,CAACL,GAAL,CAASrF,UAAT,KAAwBA,UAAU,GAAG,CADzC,EAC4C;AACxC+D,YAAAA,UAAU,CAACK,IAAX,CAAgB,IAAIlF,WAAJ,CAAgBwG,IAAI,CAACjB,kBAArB,EAAyCoB,SAAzC,EAAoD,IAApD,CAAhB;AACH;AACJ;;AACD,YAAIH,IAAI,CAACL,GAAL,CAASrF,UAAT,IAAuBA,UAAvB,IACA0F,IAAI,CAACN,KAAL,CAAWpF,UAAX,IAAyBA,UAD7B,EACyC;AACrC;AACH;;AACD,YAAI0F,IAAI,CAACjB,kBAAL,IAA2B6B,sBAA3B,IAAqD,CAACX,QAA1D,EAAoE;AAChE;AACA;AACH;;AACDW,QAAAA,sBAAsB,GAAGZ,IAAI,CAACjB,kBAA9B;;AACA,YAAIkB,QAAQ,IAAIpD,OAAO,CAAC4D,eAAxB,EAAyC;AACrCjC,UAAAA,MAAM,CAACE,IAAP,CAAY,IAAIlF,WAAJ,CAAgBwG,IAAI,CAACjB,kBAArB,EAAyCoB,SAAzC,EAAoD,IAApD,CAAZ;AACH;AACJ;;AACD3B,MAAAA,MAAM,CAACuC,IAAP,CAAY,CAACC,CAAD,EAAInC,CAAJ,KAAUmC,CAAC,CAACC,aAAF,GAAkBpC,CAAC,CAACoC,aAA1C;AACH;;AACD,WAAO9D,MAAP;AACH;;AACD8B,EAAAA,4BAA4B,CAACiC,QAAD,EAAW;AACnC,WAAQ/H,aAAa,CAACgI,uBAAd,CAAsC,KAAKvH,SAAL,CAAeM,cAAf,CAA8BgH,QAAQ,CAAC5G,UAAvC,CAAtC,EAA0F4G,QAAQ,CAACP,MAAnG,EAA2G,KAAK/G,SAAL,CAAeO,UAAf,GAA4BC,OAAvI,IAAkJ,CAA1J;AACH;;AACDgH,EAAAA,oBAAoB,CAACxF,eAAD,EAAkBE,aAAlB,EAAiC;AACjD,SAAKrB,iBAAL;AACA,UAAMC,SAAS,GAAG,KAAKd,SAAL,CAAee,YAAf,EAAlB;;AACA,QAAIiB,eAAe,GAAG,CAAlB,IAAuBA,eAAe,GAAGlB,SAA7C,EAAwD;AACpD,YAAM,IAAIE,KAAJ,CAAU,mCAAV,CAAN;AACH;;AACD,QAAIkB,aAAa,GAAG,CAAhB,IAAqBA,aAAa,GAAGpB,SAAzC,EAAoD;AAChD,YAAM,IAAIE,KAAJ,CAAU,iCAAV,CAAN;AACH;;AACD,UAAMiC,OAAO,GAAG,KAAKjD,SAAL,CAAeO,UAAf,EAAhB;AACA,UAAMU,YAAY,GAAG,KAAKf,wBAAL,CAA8B,KAAKF,SAAL,CAAekB,aAAf,EAA9B,EAA8DD,YAAnF;AACA,UAAME,OAAO,GAAGC,OAAO,CAACH,YAAY,IAAIA,YAAY,CAACE,OAA9B,CAAvB;AACA,UAAMoC,MAAM,GAAG,IAAIiB,KAAJ,CAAUtC,aAAa,GAAGF,eAAhB,GAAkC,CAA5C,CAAf;AACA,QAAIyF,qBAAqB,GAAG,CAAC,CAA7B;AAAgC;;AAChC,QAAIC,sBAAsB,GAAG,CAAC,CAA9B;AACA,QAAIC,qBAAqB,GAAG,CAAC,CAA7B;AAAgC;;AAChC,QAAIC,sBAAsB,GAAG,CAAC,CAA9B;;AACA,SAAK,IAAIlH,UAAU,GAAGsB,eAAtB,EAAuCtB,UAAU,IAAIwB,aAArD,EAAoExB,UAAU,EAA9E,EAAkF;AAC9E,YAAMmH,WAAW,GAAGnH,UAAU,GAAGsB,eAAjC;;AACA,YAAMS,aAAa,GAAG,KAAKrC,mBAAL,CAAyBM,UAAU,GAAG,CAAtC,CAAtB;;AACA,UAAI+B,aAAa,IAAI,CAArB,EAAwB;AACpB;AACA;AACAgF,QAAAA,qBAAqB,GAAG/G,UAAU,GAAG,CAArC;AACAgH,QAAAA,sBAAsB,GAAGjF,aAAzB;AACAc,QAAAA,MAAM,CAACsE,WAAD,CAAN,GAAsBnF,IAAI,CAACC,IAAL,CAAUF,aAAa,GAAGQ,OAAO,CAACL,UAAlC,CAAtB;AACA;AACH;;AACD,UAAI6E,qBAAqB,KAAK,CAAC,CAA/B,EAAkC;AAC9BA,QAAAA,qBAAqB,GAAG,CAAC,CAAzB;AACAC,QAAAA,sBAAsB,GAAG,CAAC,CAA1B,CAF8B,CAG9B;;AACA,aAAK,IAAIrH,SAAS,GAAGK,UAAU,GAAG,CAAlC,EAAqCL,SAAS,IAAI,CAAlD,EAAqDA,SAAS,EAA9D,EAAkE;AAC9D,gBAAMqB,MAAM,GAAG,KAAKtB,mBAAL,CAAyBC,SAAzB,CAAf;;AACA,cAAIqB,MAAM,IAAI,CAAd,EAAiB;AACb+F,YAAAA,qBAAqB,GAAGpH,SAAxB;AACAqH,YAAAA,sBAAsB,GAAGhG,MAAzB;AACA;AACH;AACJ;AACJ;;AACD,UAAIiG,qBAAqB,KAAK,CAAC,CAA3B,KACCA,qBAAqB,KAAK,CAAC,CAA3B,IAAgCA,qBAAqB,GAAGjH,UAAU,GAAG,CADtE,CAAJ,EAC8E;AAC1EiH,QAAAA,qBAAqB,GAAG,CAAC,CAAzB;AACAC,QAAAA,sBAAsB,GAAG,CAAC,CAA1B,CAF0E,CAG1E;;AACA,aAAK,IAAIvH,SAAS,GAAGK,UAArB,EAAiCL,SAAS,GAAGS,SAA7C,EAAwDT,SAAS,EAAjE,EAAqE;AACjE,gBAAMqB,MAAM,GAAG,KAAKtB,mBAAL,CAAyBC,SAAzB,CAAf;;AACA,cAAIqB,MAAM,IAAI,CAAd,EAAiB;AACbiG,YAAAA,qBAAqB,GAAGtH,SAAxB;AACAuH,YAAAA,sBAAsB,GAAGlG,MAAzB;AACA;AACH;AACJ;AACJ;;AACD6B,MAAAA,MAAM,CAACsE,WAAD,CAAN,GAAsB,KAAKhF,gCAAL,CAAsC1B,OAAtC,EAA+CuG,sBAA/C,EAAuEE,sBAAvE,CAAtB;AACH;;AACD,WAAOrE,MAAP;AACH;;AACDV,EAAAA,gCAAgC,CAAC1B,OAAD,EAAUuG,sBAAV,EAAkCE,sBAAlC,EAA0D;AACtF,UAAM3E,OAAO,GAAG,KAAKjD,SAAL,CAAeO,UAAf,EAAhB;;AACA,QAAImH,sBAAsB,KAAK,CAAC,CAA5B,IAAiCE,sBAAsB,KAAK,CAAC,CAAjE,EAAoE;AAChE;AACA,aAAO,CAAP;AACH,KAHD,MAIK,IAAIF,sBAAsB,GAAGE,sBAA7B,EAAqD;AACtD;AACA,aAAO,IAAIlF,IAAI,CAACoF,KAAL,CAAWJ,sBAAsB,GAAGzE,OAAO,CAACL,UAA5C,CAAX;AACH,KAHI,MAIA,IAAI8E,sBAAsB,KAAKE,sBAA/B,EAAuD;AACxD;AACA,aAAOlF,IAAI,CAACC,IAAL,CAAUiF,sBAAsB,GAAG3E,OAAO,CAACL,UAA3C,CAAP;AACH,KAHI,MAIA;AACD,UAAIzB,OAAJ,EAAa;AACT;AACA,eAAOuB,IAAI,CAACC,IAAL,CAAUiF,sBAAsB,GAAG3E,OAAO,CAACL,UAA3C,CAAP;AACH,OAHD,MAIK;AACD;AACA,eAAO,IAAIF,IAAI,CAACoF,KAAL,CAAWF,sBAAsB,GAAG3E,OAAO,CAACL,UAA5C,CAAX;AACH;AACJ;AACJ;;AA5ZkD;AA8ZvD,OAAO,MAAM+B,2BAAN,CAAkC;AACrC5E,EAAAA,WAAW,GAAG;AACV,SAAK2G,eAAL,GAAuB,eAAvB;AACH;;AACDF,EAAAA,yBAAyB,CAACuB,KAAD,EAAQ;AAC7B;AACA;AACA,WAAQ,4BAA2BA,KAAK,GAAG,EAAG,EAA9C;AACH;;AARoC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue, findLast } from '../../../base/common/arrays.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        var _a, _b, _c, _d, _e;\n        const result = [];\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber)));\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                ? // Does active position intersect with the view port? -> Intersect bracket pairs with activePosition\n                    bracketPairs.filter((bp) => Range.strictContainsPosition(bp.range, activePosition))\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition));\n            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, \n            /* Exclude single line bracket pairs for cases such as\n             * ```\n             * function test() {\n             * \t\tif (true) { | }\n             * }\n             * ```\n             */\n            (i) => i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n        }\n        const queue = new ArrayQueue(bracketPairs);\n        /** Indexed by nesting level */\n        const activeGuides = new Array();\n        const nextGuides = new Array();\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            let guides = new Array();\n            if (nextGuides.length > 0) {\n                guides = guides.concat(nextGuides);\n                nextGuides.length = 0;\n            }\n            result.push(guides);\n            // Update activeGuides\n            for (const pair of queue.takeWhile((b) => b.openingBracketRange.startLineNumber <= lineNumber) || []) {\n                if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                    // ignore single line brackets\n                    continue;\n                }\n                const guideVisibleColumn = Math.min(this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition()), this.getVisibleColumnFromPosition((_c = (_b = pair.closingBracketRange) === null || _b === void 0 ? void 0 : _b.getStartPosition()) !== null && _c !== void 0 ? _c : pair.range.getEndPosition()), pair.minVisibleColumnIndentation + 1);\n                let renderHorizontalEndLineAtTheBottom = false;\n                if (pair.closingBracketRange) {\n                    const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n                    if (firstNonWsIndex < pair.closingBracketRange.startColumn - 1) {\n                        renderHorizontalEndLineAtTheBottom = true;\n                    }\n                }\n                const start = pair.openingBracketRange.getStartPosition();\n                const end = (_e = (_d = pair.closingBracketRange) === null || _d === void 0 ? void 0 : _d.getStartPosition()) !== null && _e !== void 0 ? _e : pair.range.getEndPosition();\n                if (pair.closingBracketRange === undefined) {\n                    // Don't show guides for bracket pairs that are not balanced.\n                    // See #135125.\n                    activeGuides[pair.nestingLevel] = null;\n                }\n                else {\n                    activeGuides[pair.nestingLevel] = {\n                        nestingLevel: pair.nestingLevel,\n                        guideVisibleColumn,\n                        start,\n                        visibleStartColumn: this.getVisibleColumnFromPosition(start),\n                        end,\n                        visibleEndColumn: this.getVisibleColumnFromPosition(end),\n                        bracketPair: pair,\n                        renderHorizontalEndLineAtTheBottom,\n                    };\n                }\n            }\n            for (const line of activeGuides) {\n                if (!line) {\n                    continue;\n                }\n                const isActive = activeBracketPairRange &&\n                    line.bracketPair.range.equalsRange(activeBracketPairRange);\n                const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) +\n                    (options.highlightActive && isActive\n                        ? ' ' + colorProvider.activeClassName\n                        : '');\n                if ((isActive &&\n                    options.horizontalGuides !==\n                        HorizontalGuidesState.Disabled) ||\n                    (options.includeInactive &&\n                        options.horizontalGuides === HorizontalGuidesState.Enabled)) {\n                    if (line.start.lineNumber === lineNumber) {\n                        if (line.guideVisibleColumn < line.visibleStartColumn) {\n                            guides.push(new IndentGuide(line.guideVisibleColumn, className, new IndentGuideHorizontalLine(false, line.start.column)));\n                        }\n                    }\n                    if (line.end.lineNumber === lineNumber + 1) {\n                        // The next line might have horizontal guides.\n                        // However, the next line might also have a new bracket pair with the same indentation,\n                        // so the current bracket pair might get replaced. That's why we push the guide to nextGuides one line ahead.\n                        if (line.guideVisibleColumn < line.visibleEndColumn) {\n                            nextGuides.push(new IndentGuide(line.guideVisibleColumn, className, new IndentGuideHorizontalLine(!line.renderHorizontalEndLineAtTheBottom, line.end.column)));\n                        }\n                    }\n                }\n            }\n            let lastVisibleColumnCount = Number.MAX_SAFE_INTEGER;\n            // Going backwards, so the last guide potentially replaces others\n            for (let i = activeGuides.length - 1; i >= 0; i--) {\n                const line = activeGuides[i];\n                if (!line) {\n                    continue;\n                }\n                const isActive = options.highlightActive &&\n                    activeBracketPairRange &&\n                    line.bracketPair.range.equalsRange(activeBracketPairRange);\n                const className = colorProvider.getInlineClassNameOfLevel(line.nestingLevel) +\n                    (isActive ? ' ' + colorProvider.activeClassName : '');\n                if (isActive || options.includeInactive) {\n                    if (line.renderHorizontalEndLineAtTheBottom &&\n                        line.end.lineNumber === lineNumber + 1) {\n                        nextGuides.push(new IndentGuide(line.guideVisibleColumn, className, null));\n                    }\n                }\n                if (line.end.lineNumber <= lineNumber ||\n                    line.start.lineNumber >= lineNumber) {\n                    continue;\n                }\n                if (line.guideVisibleColumn >= lastVisibleColumnCount && !isActive) {\n                    // Don't render a guide on top of an existing guide, unless it is active.\n                    continue;\n                }\n                lastVisibleColumnCount = line.guideVisibleColumn;\n                if (isActive || options.includeInactive) {\n                    guides.push(new IndentGuide(line.guideVisibleColumn, className, null));\n                }\n            }\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}