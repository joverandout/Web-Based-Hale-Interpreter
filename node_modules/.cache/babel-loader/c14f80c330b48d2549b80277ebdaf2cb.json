{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class ContextKeyExpr {\n  static has(key) {\n    return ContextKeyDefinedExpr.create(key);\n  }\n\n  static equals(key, value) {\n    return ContextKeyEqualsExpr.create(key, value);\n  }\n\n  static regex(key, value) {\n    return ContextKeyRegexExpr.create(key, value);\n  }\n\n  static not(key) {\n    return ContextKeyNotExpr.create(key);\n  }\n\n  static and(...expr) {\n    return ContextKeyAndExpr.create(expr, null);\n  }\n\n  static or(...expr) {\n    return ContextKeyOrExpr.create(expr, null, true);\n  }\n\n  static deserialize(serialized, strict = false) {\n    if (!serialized) {\n      return undefined;\n    }\n\n    return this._deserializeOrExpression(serialized, strict);\n  }\n\n  static _deserializeOrExpression(serialized, strict) {\n    let pieces = serialized.split('||');\n    return ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)), null, true);\n  }\n\n  static _deserializeAndExpression(serialized, strict) {\n    let pieces = serialized.split('&&');\n    return ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)), null);\n  }\n\n  static _deserializeOne(serializedOne, strict) {\n    serializedOne = serializedOne.trim();\n\n    if (serializedOne.indexOf('!=') >= 0) {\n      let pieces = serializedOne.split('!=');\n      return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n    }\n\n    if (serializedOne.indexOf('==') >= 0) {\n      let pieces = serializedOne.split('==');\n      return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n    }\n\n    if (serializedOne.indexOf('=~') >= 0) {\n      let pieces = serializedOne.split('=~');\n      return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n    }\n\n    if (serializedOne.indexOf(' in ') >= 0) {\n      let pieces = serializedOne.split(' in ');\n      return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n\n    if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('>=');\n      return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n\n    if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('>');\n      return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n\n    if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('<=');\n      return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n\n    if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('<');\n      return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n\n    if (/^\\!\\s*/.test(serializedOne)) {\n      return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n    }\n\n    return ContextKeyDefinedExpr.create(serializedOne);\n  }\n\n  static _deserializeValue(serializedValue, strict) {\n    serializedValue = serializedValue.trim();\n\n    if (serializedValue === 'true') {\n      return true;\n    }\n\n    if (serializedValue === 'false') {\n      return false;\n    }\n\n    let m = /^'([^']*)'$/.exec(serializedValue);\n\n    if (m) {\n      return m[1].trim();\n    }\n\n    return serializedValue;\n  }\n\n  static _deserializeRegexValue(serializedValue, strict) {\n    if (isFalsyOrWhitespace(serializedValue)) {\n      if (strict) {\n        throw new Error('missing regexp-value for =~-expression');\n      } else {\n        console.warn('missing regexp-value for =~-expression');\n      }\n\n      return null;\n    }\n\n    let start = serializedValue.indexOf('/');\n    let end = serializedValue.lastIndexOf('/');\n\n    if (start === end || start < 0\n    /* || to < 0 */\n    ) {\n      if (strict) {\n        throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n      } else {\n        console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n      }\n\n      return null;\n    }\n\n    let value = serializedValue.slice(start + 1, end);\n    let caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n\n    try {\n      return new RegExp(value, caseIgnoreFlag);\n    } catch (e) {\n      if (strict) {\n        throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n      } else {\n        console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n      }\n\n      return null;\n    }\n  }\n\n}\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n  const aExpr = a ? a.substituteConstants() : undefined;\n  const bExpr = b ? b.substituteConstants() : undefined;\n\n  if (!aExpr && !bExpr) {\n    return true;\n  }\n\n  if (!aExpr || !bExpr) {\n    return false;\n  }\n\n  return aExpr.equals(bExpr);\n}\n\nfunction cmp(a, b) {\n  return a.cmp(b);\n}\n\nexport class ContextKeyFalseExpr {\n  constructor() {\n    this.type = 0\n    /* False */\n    ;\n  }\n\n  cmp(other) {\n    return this.type - other.type;\n  }\n\n  equals(other) {\n    return other.type === this.type;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    return false;\n  }\n\n  serialize() {\n    return 'false';\n  }\n\n  keys() {\n    return [];\n  }\n\n  negate() {\n    return ContextKeyTrueExpr.INSTANCE;\n  }\n\n}\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n  constructor() {\n    this.type = 1\n    /* True */\n    ;\n  }\n\n  cmp(other) {\n    return this.type - other.type;\n  }\n\n  equals(other) {\n    return other.type === this.type;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    return true;\n  }\n\n  serialize() {\n    return 'true';\n  }\n\n  keys() {\n    return [];\n  }\n\n  negate() {\n    return ContextKeyFalseExpr.INSTANCE;\n  }\n\n}\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n  constructor(key, negated) {\n    this.key = key;\n    this.negated = negated;\n    this.type = 2\n    /* Defined */\n    ;\n  }\n\n  static create(key, negated = null) {\n    const constantValue = CONSTANT_VALUES.get(key);\n\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n\n    return new ContextKeyDefinedExpr(key, negated);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp1(this.key, other.key);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n\n    return this;\n  }\n\n  evaluate(context) {\n    return !!context.getValue(this.key);\n  }\n\n  serialize() {\n    return this.key;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotExpr.create(this.key, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 4\n    /* Equals */\n    ;\n  }\n\n  static create(key, value, negated = null) {\n    if (typeof value === 'boolean') {\n      return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);\n    }\n\n    const constantValue = CONSTANT_VALUES.get(key);\n\n    if (typeof constantValue === 'boolean') {\n      const trueValue = constantValue ? 'true' : 'false';\n      return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n\n    return new ContextKeyEqualsExpr(key, value, negated);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n\n    if (typeof constantValue === 'boolean') {\n      const trueValue = constantValue ? 'true' : 'false';\n      return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n\n    return this;\n  }\n\n  evaluate(context) {\n    // Intentional ==\n    // eslint-disable-next-line eqeqeq\n    return context.getValue(this.key) == this.value;\n  }\n\n  serialize() {\n    return `${this.key} == '${this.value}'`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyInExpr {\n  constructor(key, valueKey) {\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 10\n    /* In */\n    ;\n    this.negated = null;\n  }\n\n  static create(key, valueKey) {\n    return new ContextKeyInExpr(key, valueKey);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.valueKey === other.valueKey;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    const source = context.getValue(this.valueKey);\n    const item = context.getValue(this.key);\n\n    if (Array.isArray(source)) {\n      return source.indexOf(item) >= 0;\n    }\n\n    if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n      return hasOwnProperty.call(source, item);\n    }\n\n    return false;\n  }\n\n  serialize() {\n    return `${this.key} in '${this.valueKey}'`;\n  }\n\n  keys() {\n    return [this.key, this.valueKey];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotInExpr.create(this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyNotInExpr {\n  constructor(_actual) {\n    this._actual = _actual;\n    this.type = 11\n    /* NotIn */\n    ; //\n  }\n\n  static create(actual) {\n    return new ContextKeyNotInExpr(actual);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return this._actual.cmp(other._actual);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this._actual.equals(other._actual);\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    return !this._actual.evaluate(context);\n  }\n\n  serialize() {\n    throw new Error('Method not implemented.');\n  }\n\n  keys() {\n    return this._actual.keys();\n  }\n\n  negate() {\n    return this._actual;\n  }\n\n}\nexport class ContextKeyNotEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 5\n    /* NotEquals */\n    ;\n  }\n\n  static create(key, value, negated = null) {\n    if (typeof value === 'boolean') {\n      if (value) {\n        return ContextKeyNotExpr.create(key, negated);\n      }\n\n      return ContextKeyDefinedExpr.create(key, negated);\n    }\n\n    const constantValue = CONSTANT_VALUES.get(key);\n\n    if (typeof constantValue === 'boolean') {\n      const falseValue = constantValue ? 'true' : 'false';\n      return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n\n    return new ContextKeyNotEqualsExpr(key, value, negated);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n\n    if (typeof constantValue === 'boolean') {\n      const falseValue = constantValue ? 'true' : 'false';\n      return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n\n    return this;\n  }\n\n  evaluate(context) {\n    // Intentional !=\n    // eslint-disable-next-line eqeqeq\n    return context.getValue(this.key) != this.value;\n  }\n\n  serialize() {\n    return `${this.key} != '${this.value}'`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyNotExpr {\n  constructor(key, negated) {\n    this.key = key;\n    this.negated = negated;\n    this.type = 3\n    /* Not */\n    ;\n  }\n\n  static create(key, negated = null) {\n    const constantValue = CONSTANT_VALUES.get(key);\n\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n\n    return new ContextKeyNotExpr(key, negated);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp1(this.key, other.key);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n\n    return this;\n  }\n\n  evaluate(context) {\n    return !context.getValue(this.key);\n  }\n\n  serialize() {\n    return `!${this.key}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyDefinedExpr.create(this.key, this);\n    }\n\n    return this.negated;\n  }\n\n}\n\nfunction withFloatOrStr(value, callback) {\n  if (typeof value === 'string') {\n    const n = parseFloat(value);\n\n    if (!isNaN(n)) {\n      value = n;\n    }\n  }\n\n  if (typeof value === 'string' || typeof value === 'number') {\n    return callback(value);\n  }\n\n  return ContextKeyFalseExpr.INSTANCE;\n}\n\nexport class ContextKeyGreaterExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 12\n    /* Greater */\n    ;\n  }\n\n  static create(key, _value, negated = null) {\n    return withFloatOrStr(_value, value => new ContextKeyGreaterExpr(key, value, negated));\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n\n    return parseFloat(context.getValue(this.key)) > this.value;\n  }\n\n  serialize() {\n    return `${this.key} > ${this.value}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyGreaterEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 13\n    /* GreaterEquals */\n    ;\n  }\n\n  static create(key, _value, negated = null) {\n    return withFloatOrStr(_value, value => new ContextKeyGreaterEqualsExpr(key, value, negated));\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n\n    return parseFloat(context.getValue(this.key)) >= this.value;\n  }\n\n  serialize() {\n    return `${this.key} >= ${this.value}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeySmallerExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 14\n    /* Smaller */\n    ;\n  }\n\n  static create(key, _value, negated = null) {\n    return withFloatOrStr(_value, value => new ContextKeySmallerExpr(key, value, negated));\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n\n    return parseFloat(context.getValue(this.key)) < this.value;\n  }\n\n  serialize() {\n    return `${this.key} < ${this.value}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeySmallerEqualsExpr {\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 15\n    /* SmallerEquals */\n    ;\n  }\n\n  static create(key, _value, negated = null) {\n    return withFloatOrStr(_value, value => new ContextKeySmallerEqualsExpr(key, value, negated));\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n\n    return parseFloat(context.getValue(this.key)) <= this.value;\n  }\n\n  serialize() {\n    return `${this.key} <= ${this.value}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyRegexExpr {\n  constructor(key, regexp) {\n    this.key = key;\n    this.regexp = regexp;\n    this.type = 7\n    /* Regex */\n    ;\n    this.negated = null; //\n  }\n\n  static create(key, regexp) {\n    return new ContextKeyRegexExpr(key, regexp);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    if (this.key < other.key) {\n      return -1;\n    }\n\n    if (this.key > other.key) {\n      return 1;\n    }\n\n    const thisSource = this.regexp ? this.regexp.source : '';\n    const otherSource = other.regexp ? other.regexp.source : '';\n\n    if (thisSource < otherSource) {\n      return -1;\n    }\n\n    if (thisSource > otherSource) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      const thisSource = this.regexp ? this.regexp.source : '';\n      const otherSource = other.regexp ? other.regexp.source : '';\n      return this.key === other.key && thisSource === otherSource;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    let value = context.getValue(this.key);\n    return this.regexp ? this.regexp.test(value) : false;\n  }\n\n  serialize() {\n    const value = this.regexp ? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}` : '/invalid/';\n    return `${this.key} =~ ${value}`;\n  }\n\n  keys() {\n    return [this.key];\n  }\n\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotRegexExpr.create(this);\n    }\n\n    return this.negated;\n  }\n\n}\nexport class ContextKeyNotRegexExpr {\n  constructor(_actual) {\n    this._actual = _actual;\n    this.type = 8\n    /* NotRegex */\n    ; //\n  }\n\n  static create(actual) {\n    return new ContextKeyNotRegexExpr(actual);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    return this._actual.cmp(other._actual);\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      return this._actual.equals(other._actual);\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    return this;\n  }\n\n  evaluate(context) {\n    return !this._actual.evaluate(context);\n  }\n\n  serialize() {\n    throw new Error('Method not implemented.');\n  }\n\n  keys() {\n    return this._actual.keys();\n  }\n\n  negate() {\n    return this._actual;\n  }\n\n}\n/**\n * @returns the same instance if nothing changed.\n */\n\nfunction eliminateConstantsInArray(arr) {\n  // Allocate array only if there is a difference\n  let newArr = null;\n\n  for (let i = 0, len = arr.length; i < len; i++) {\n    const newExpr = arr[i].substituteConstants();\n\n    if (arr[i] !== newExpr) {\n      // something has changed!\n      // allocate array on first difference\n      if (newArr === null) {\n        newArr = [];\n\n        for (let j = 0; j < i; j++) {\n          newArr[j] = arr[j];\n        }\n      }\n    }\n\n    if (newArr !== null) {\n      newArr[i] = newExpr;\n    }\n  }\n\n  if (newArr === null) {\n    return arr;\n  }\n\n  return newArr;\n}\n\nclass ContextKeyAndExpr {\n  constructor(expr, negated) {\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 6\n    /* And */\n    ;\n  }\n\n  static create(_expr, negated) {\n    return ContextKeyAndExpr._normalizeArr(_expr, negated);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n\n      if (r !== 0) {\n        return r;\n      }\n    }\n\n    return 0;\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const exprArr = eliminateConstantsInArray(this.expr);\n\n    if (exprArr === this.expr) {\n      // no change\n      return this;\n    }\n\n    return ContextKeyAndExpr.create(exprArr, this.negated);\n  }\n\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (!this.expr[i].evaluate(context)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static _normalizeArr(arr, negated) {\n    const expr = [];\n    let hasTrue = false;\n\n    for (const e of arr) {\n      if (!e) {\n        continue;\n      }\n\n      if (e.type === 1\n      /* True */\n      ) {\n        // anything && true ==> anything\n        hasTrue = true;\n        continue;\n      }\n\n      if (e.type === 0\n      /* False */\n      ) {\n        // anything && false ==> false\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n\n      if (e.type === 6\n      /* And */\n      ) {\n        expr.push(...e.expr);\n        continue;\n      }\n\n      expr.push(e);\n    }\n\n    if (expr.length === 0 && hasTrue) {\n      return ContextKeyTrueExpr.INSTANCE;\n    }\n\n    if (expr.length === 0) {\n      return undefined;\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    }\n\n    expr.sort(cmp); // eliminate duplicate terms\n\n    for (let i = 1; i < expr.length; i++) {\n      if (expr[i - 1].equals(expr[i])) {\n        expr.splice(i, 1);\n        i--;\n      }\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    } // We must distribute any OR expression because we don't support parens\n    // OR extensions will be at the end (due to sorting rules)\n\n\n    while (expr.length > 1) {\n      const lastElement = expr[expr.length - 1];\n\n      if (lastElement.type !== 9\n      /* Or */\n      ) {\n        break;\n      } // pop the last element\n\n\n      expr.pop(); // pop the second to last element\n\n      const secondToLastElement = expr.pop();\n      const isFinished = expr.length === 0; // distribute `lastElement` over `secondToLastElement`\n\n      const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null)), null, isFinished);\n\n      if (resultElement) {\n        expr.push(resultElement);\n        expr.sort(cmp);\n      }\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    }\n\n    return new ContextKeyAndExpr(expr, negated);\n  }\n\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' && ');\n  }\n\n  keys() {\n    const result = [];\n\n    for (let expr of this.expr) {\n      result.push(...expr.keys());\n    }\n\n    return result;\n  }\n\n  negate() {\n    if (!this.negated) {\n      const result = [];\n\n      for (let expr of this.expr) {\n        result.push(expr.negate());\n      }\n\n      this.negated = ContextKeyOrExpr.create(result, this, true);\n    }\n\n    return this.negated;\n  }\n\n}\n\nclass ContextKeyOrExpr {\n  constructor(expr, negated) {\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 9\n    /* Or */\n    ;\n  }\n\n  static create(_expr, negated, extraRedundantCheck) {\n    return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n  }\n\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n\n      if (r !== 0) {\n        return r;\n      }\n    }\n\n    return 0;\n  }\n\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  substituteConstants() {\n    const exprArr = eliminateConstantsInArray(this.expr);\n\n    if (exprArr === this.expr) {\n      // no change\n      return this;\n    }\n\n    return ContextKeyOrExpr.create(exprArr, this.negated, false);\n  }\n\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (this.expr[i].evaluate(context)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  static _normalizeArr(arr, negated, extraRedundantCheck) {\n    let expr = [];\n    let hasFalse = false;\n\n    if (arr) {\n      for (let i = 0, len = arr.length; i < len; i++) {\n        const e = arr[i];\n\n        if (!e) {\n          continue;\n        }\n\n        if (e.type === 0\n        /* False */\n        ) {\n          // anything || false ==> anything\n          hasFalse = true;\n          continue;\n        }\n\n        if (e.type === 1\n        /* True */\n        ) {\n          // anything || true ==> true\n          return ContextKeyTrueExpr.INSTANCE;\n        }\n\n        if (e.type === 9\n        /* Or */\n        ) {\n          expr = expr.concat(e.expr);\n          continue;\n        }\n\n        expr.push(e);\n      }\n\n      if (expr.length === 0 && hasFalse) {\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n\n      expr.sort(cmp);\n    }\n\n    if (expr.length === 0) {\n      return undefined;\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    } // eliminate duplicate terms\n\n\n    for (let i = 1; i < expr.length; i++) {\n      if (expr[i - 1].equals(expr[i])) {\n        expr.splice(i, 1);\n        i--;\n      }\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    } // eliminate redundant terms\n\n\n    if (extraRedundantCheck) {\n      for (let i = 0; i < expr.length; i++) {\n        for (let j = i + 1; j < expr.length; j++) {\n          if (implies(expr[i], expr[j])) {\n            expr.splice(j, 1);\n            j--;\n          }\n        }\n      }\n\n      if (expr.length === 1) {\n        return expr[0];\n      }\n    }\n\n    return new ContextKeyOrExpr(expr, negated);\n  }\n\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' || ');\n  }\n\n  keys() {\n    const result = [];\n\n    for (let expr of this.expr) {\n      result.push(...expr.keys());\n    }\n\n    return result;\n  }\n\n  negate() {\n    if (!this.negated) {\n      let result = [];\n\n      for (let expr of this.expr) {\n        result.push(expr.negate());\n      } // We don't support parens, so here we distribute the AND over the OR terminals\n      // We always take the first 2 AND pairs and distribute them\n\n\n      while (result.length > 1) {\n        const LEFT = result.shift();\n        const RIGHT = result.shift();\n        const all = [];\n\n        for (const left of getTerminals(LEFT)) {\n          for (const right of getTerminals(RIGHT)) {\n            all.push(ContextKeyAndExpr.create([left, right], null));\n          }\n        }\n\n        const isFinished = result.length === 0;\n        result.unshift(ContextKeyOrExpr.create(all, null, isFinished));\n      }\n\n      this.negated = result[0];\n    }\n\n    return this.negated;\n  }\n\n}\n\nexport class RawContextKey extends ContextKeyDefinedExpr {\n  constructor(key, defaultValue, metaOrHide) {\n    super(key, null);\n    this._defaultValue = defaultValue; // collect all context keys into a central place\n\n    if (typeof metaOrHide === 'object') {\n      RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), {\n        key\n      }));\n    } else if (metaOrHide !== true) {\n      RawContextKey._info.push({\n        key,\n        description: metaOrHide,\n        type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined\n      });\n    }\n  }\n\n  static all() {\n    return RawContextKey._info.values();\n  }\n\n  bindTo(target) {\n    return target.createKey(this.key, this._defaultValue);\n  }\n\n  getValue(target) {\n    return target.getContextKeyValue(this.key);\n  }\n\n  toNegated() {\n    return this.negate();\n  }\n\n  isEqualTo(value) {\n    return ContextKeyEqualsExpr.create(this.key, value);\n  }\n\n}\nRawContextKey._info = [];\nexport const IContextKeyService = createDecorator('contextKeyService');\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\n\nfunction cmp1(key1, key2) {\n  if (key1 < key2) {\n    return -1;\n  }\n\n  if (key1 > key2) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction cmp2(key1, value1, key2, value2) {\n  if (key1 < key2) {\n    return -1;\n  }\n\n  if (key1 > key2) {\n    return 1;\n  }\n\n  if (value1 < value2) {\n    return -1;\n  }\n\n  if (value1 > value2) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\n\n\nexport function implies(p, q) {\n  if (q.type === 6\n  /* And */\n  && p.type !== 9\n  /* Or */\n  && p.type !== 6\n  /* And */\n  ) {\n    // covers the case: A implies A && B\n    for (const qTerm of q.expr) {\n      if (p.equals(qTerm)) {\n        return true;\n      }\n    }\n  }\n\n  const notP = p.negate();\n  const expr = getTerminals(notP).concat(getTerminals(q));\n  expr.sort(cmp);\n\n  for (let i = 0; i < expr.length; i++) {\n    const a = expr[i];\n    const notA = a.negate();\n\n    for (let j = i + 1; j < expr.length; j++) {\n      const b = expr[j];\n\n      if (notA.equals(b)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction getTerminals(node) {\n  if (node.type === 9\n  /* Or */\n  ) {\n    return node.expr;\n  }\n\n  return [node];\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js"],"names":["isChrome","isEdge","isFirefox","isLinux","isMacintosh","isSafari","isWeb","isWindows","isFalsyOrWhitespace","createDecorator","CONSTANT_VALUES","Map","set","hasOwnProperty","Object","prototype","ContextKeyExpr","has","key","ContextKeyDefinedExpr","create","equals","value","ContextKeyEqualsExpr","regex","ContextKeyRegexExpr","not","ContextKeyNotExpr","and","expr","ContextKeyAndExpr","or","ContextKeyOrExpr","deserialize","serialized","strict","undefined","_deserializeOrExpression","pieces","split","map","p","_deserializeAndExpression","_deserializeOne","serializedOne","trim","indexOf","ContextKeyNotEqualsExpr","_deserializeValue","_deserializeRegexValue","ContextKeyInExpr","test","ContextKeyGreaterEqualsExpr","ContextKeyGreaterExpr","ContextKeySmallerEqualsExpr","ContextKeySmallerExpr","substr","serializedValue","m","exec","Error","console","warn","start","end","lastIndexOf","slice","caseIgnoreFlag","RegExp","e","expressionsAreEqualWithConstantSubstitution","a","b","aExpr","substituteConstants","bExpr","cmp","ContextKeyFalseExpr","constructor","type","other","evaluate","context","serialize","keys","negate","ContextKeyTrueExpr","INSTANCE","negated","constantValue","get","cmp1","getValue","trueValue","cmp2","valueKey","source","item","Array","isArray","call","ContextKeyNotInExpr","_actual","actual","falseValue","withFloatOrStr","callback","n","parseFloat","isNaN","_value","regexp","thisSource","otherSource","ignoreCase","ContextKeyNotRegexExpr","eliminateConstantsInArray","arr","newArr","i","len","length","newExpr","j","_expr","_normalizeArr","r","exprArr","hasTrue","push","sort","splice","lastElement","pop","secondToLastElement","isFinished","resultElement","el","join","result","extraRedundantCheck","hasFalse","concat","implies","LEFT","shift","RIGHT","all","left","getTerminals","right","unshift","RawContextKey","defaultValue","metaOrHide","_defaultValue","_info","assign","description","values","bindTo","target","createKey","getContextKeyValue","toNegated","isEqualTo","IContextKeyService","SET_CONTEXT_COMMAND_ID","key1","key2","value1","value2","q","qTerm","notP","notA","node"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class ContextKeyExpr {\n    static has(key) {\n        return ContextKeyDefinedExpr.create(key);\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static not(key) {\n        return ContextKeyNotExpr.create(key);\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr, null);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr, null, true);\n    }\n    static deserialize(serialized, strict = false) {\n        if (!serialized) {\n            return undefined;\n        }\n        return this._deserializeOrExpression(serialized, strict);\n    }\n    static _deserializeOrExpression(serialized, strict) {\n        let pieces = serialized.split('||');\n        return ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)), null, true);\n    }\n    static _deserializeAndExpression(serialized, strict) {\n        let pieces = serialized.split('&&');\n        return ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)), null);\n    }\n    static _deserializeOne(serializedOne, strict) {\n        serializedOne = serializedOne.trim();\n        if (serializedOne.indexOf('!=') >= 0) {\n            let pieces = serializedOne.split('!=');\n            return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('==') >= 0) {\n            let pieces = serializedOne.split('==');\n            return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf('=~') >= 0) {\n            let pieces = serializedOne.split('=~');\n            return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n        }\n        if (serializedOne.indexOf(' in ') >= 0) {\n            let pieces = serializedOne.split(' in ');\n            return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('>=');\n            return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('>');\n            return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('<=');\n            return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\n            const pieces = serializedOne.split('<');\n            return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\n        }\n        if (/^\\!\\s*/.test(serializedOne)) {\n            return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n        }\n        return ContextKeyDefinedExpr.create(serializedOne);\n    }\n    static _deserializeValue(serializedValue, strict) {\n        serializedValue = serializedValue.trim();\n        if (serializedValue === 'true') {\n            return true;\n        }\n        if (serializedValue === 'false') {\n            return false;\n        }\n        let m = /^'([^']*)'$/.exec(serializedValue);\n        if (m) {\n            return m[1].trim();\n        }\n        return serializedValue;\n    }\n    static _deserializeRegexValue(serializedValue, strict) {\n        if (isFalsyOrWhitespace(serializedValue)) {\n            if (strict) {\n                throw new Error('missing regexp-value for =~-expression');\n            }\n            else {\n                console.warn('missing regexp-value for =~-expression');\n            }\n            return null;\n        }\n        let start = serializedValue.indexOf('/');\n        let end = serializedValue.lastIndexOf('/');\n        if (start === end || start < 0 /* || to < 0 */) {\n            if (strict) {\n                throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n            }\n            else {\n                console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\n            }\n            return null;\n        }\n        let value = serializedValue.slice(start + 1, end);\n        let caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n        try {\n            return new RegExp(value, caseIgnoreFlag);\n        }\n        catch (e) {\n            if (strict) {\n                throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n            }\n            else {\n                console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\n            }\n            return null;\n        }\n    }\n}\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n    const aExpr = a ? a.substituteConstants() : undefined;\n    const bExpr = b ? b.substituteConstants() : undefined;\n    if (!aExpr && !bExpr) {\n        return true;\n    }\n    if (!aExpr || !bExpr) {\n        return false;\n    }\n    return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n    constructor() {\n        this.type = 0 /* False */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n    constructor() {\n        this.type = 1 /* True */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 2 /* Defined */;\n    }\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return new ContextKeyDefinedExpr(key, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 4 /* Equals */;\n    }\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            return (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return new ContextKeyEqualsExpr(key, value, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional ==\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyInExpr {\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 /* In */;\n        this.negated = null;\n    }\n    static create(key, valueKey) {\n        return new ContextKeyInExpr(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return (source.indexOf(item) >= 0);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotInExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotInExpr {\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 11 /* NotIn */;\n        //\n    }\n    static create(actual) {\n        return new ContextKeyNotInExpr(actual);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        throw new Error('Method not implemented.');\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\nexport class ContextKeyNotEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 5 /* NotEquals */;\n    }\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return ContextKeyNotExpr.create(key, negated);\n            }\n            return ContextKeyDefinedExpr.create(key, negated);\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotEqualsExpr(key, value, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional !=\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotExpr {\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 3 /* Not */;\n    }\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotExpr(key, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyDefinedExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nfunction withFloatOrStr(value, callback) {\n    if (typeof value === 'string') {\n        const n = parseFloat(value);\n        if (!isNaN(n)) {\n            value = n;\n        }\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n        return callback(value);\n    }\n    return ContextKeyFalseExpr.INSTANCE;\n}\nexport class ContextKeyGreaterExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 12 /* Greater */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) > this.value);\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyGreaterEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 13 /* GreaterEquals */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) >= this.value);\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 14 /* Smaller */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) < this.value);\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerEqualsExpr {\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 15 /* SmallerEquals */;\n    }\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) <= this.value);\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyRegexExpr {\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 /* Regex */;\n        this.negated = null;\n        //\n    }\n    static create(key, regexp) {\n        return new ContextKeyRegexExpr(key, regexp);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        let value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotRegexExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotRegexExpr {\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 /* NotRegex */;\n        //\n    }\n    static create(actual) {\n        return new ContextKeyNotRegexExpr(actual);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        throw new Error('Method not implemented.');\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n    // Allocate array only if there is a difference\n    let newArr = null;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        const newExpr = arr[i].substituteConstants();\n        if (arr[i] !== newExpr) {\n            // something has changed!\n            // allocate array on first difference\n            if (newArr === null) {\n                newArr = [];\n                for (let j = 0; j < i; j++) {\n                    newArr[j] = arr[j];\n                }\n            }\n        }\n        if (newArr !== null) {\n            newArr[i] = newExpr;\n        }\n    }\n    if (newArr === null) {\n        return arr;\n    }\n    return newArr;\n}\nclass ContextKeyAndExpr {\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 6 /* And */;\n    }\n    static create(_expr, negated) {\n        return ContextKeyAndExpr._normalizeArr(_expr, negated);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyAndExpr.create(exprArr, this.negated);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr, negated) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 /* True */) {\n                // anything && true ==> anything\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 /* False */) {\n                // anything && false ==> false\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 /* And */) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // We must distribute any OR expression because we don't support parens\n        // OR extensions will be at the end (due to sorting rules)\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 /* Or */) {\n                break;\n            }\n            // pop the last element\n            expr.pop();\n            // pop the second to last element\n            const secondToLastElement = expr.pop();\n            const isFinished = (expr.length === 0);\n            // distribute `lastElement` over `secondToLastElement`\n            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null)), null, isFinished);\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        return new ContextKeyAndExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (let expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (let expr of this.expr) {\n                result.push(expr.negate());\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyOrExpr {\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 9 /* Or */;\n    }\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 /* False */) {\n                    // anything || false ==> anything\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 /* True */) {\n                    // anything || true ==> true\n                    return ContextKeyTrueExpr.INSTANCE;\n                }\n                if (e.type === 9 /* Or */) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            expr.sort(cmp);\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate redundant terms\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (implies(expr[i], expr[j])) {\n                        expr.splice(j, 1);\n                        j--;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyOrExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (let expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            let result = [];\n            for (let expr of this.expr) {\n                result.push(expr.negate());\n            }\n            // We don't support parens, so here we distribute the AND over the OR terminals\n            // We always take the first 2 AND pairs and distribute them\n            while (result.length > 1) {\n                const LEFT = result.shift();\n                const RIGHT = result.shift();\n                const all = [];\n                for (const left of getTerminals(LEFT)) {\n                    for (const right of getTerminals(RIGHT)) {\n                        all.push(ContextKeyAndExpr.create([left, right], null));\n                    }\n                }\n                const isFinished = (result.length === 0);\n                result.unshift(ContextKeyOrExpr.create(all, null, isFinished));\n            }\n            this.negated = result[0];\n        }\n        return this.negated;\n    }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n    constructor(key, defaultValue, metaOrHide) {\n        super(key, null);\n        this._defaultValue = defaultValue;\n        // collect all context keys into a central place\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), { key }));\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    static all() {\n        return RawContextKey._info.values();\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return this.negate();\n    }\n    isEqualTo(value) {\n        return ContextKeyEqualsExpr.create(this.key, value);\n    }\n}\nRawContextKey._info = [];\nexport const IContextKeyService = createDecorator('contextKeyService');\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n    if (q.type === 6 /* And */ && (p.type !== 9 /* Or */ && p.type !== 6 /* And */)) {\n        // covers the case: A implies A && B\n        for (const qTerm of q.expr) {\n            if (p.equals(qTerm)) {\n                return true;\n            }\n        }\n    }\n    const notP = p.negate();\n    const expr = getTerminals(notP).concat(getTerminals(q));\n    expr.sort(cmp);\n    for (let i = 0; i < expr.length; i++) {\n        const a = expr[i];\n        const notA = a.negate();\n        for (let j = i + 1; j < expr.length; j++) {\n            const b = expr[j];\n            if (notA.equals(b)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction getTerminals(node) {\n    if (node.type === 9 /* Or */) {\n        return node.expr;\n    }\n    return [node];\n}\n"]},"metadata":{},"sourceType":"module"}