{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../core/editOperation.js';\nimport { Range } from '../core/range.js';\nexport class TrimTrailingWhitespaceCommand {\n  constructor(selection, cursors) {\n    this._selection = selection;\n    this._cursors = cursors;\n    this._selectionId = null;\n  }\n\n  getEditOperations(model, builder) {\n    const ops = trimTrailingWhitespace(model, this._cursors);\n\n    for (let i = 0, len = ops.length; i < len; i++) {\n      const op = ops[i];\n      builder.addEditOperation(op.range, op.text);\n    }\n\n    this._selectionId = builder.trackSelection(this._selection);\n  }\n\n  computeCursorState(model, helper) {\n    return helper.getTrackedSelection(this._selectionId);\n  }\n\n}\n/**\n * Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.\n */\n\nexport function trimTrailingWhitespace(model, cursors) {\n  // Sort cursors ascending\n  cursors.sort((a, b) => {\n    if (a.lineNumber === b.lineNumber) {\n      return a.column - b.column;\n    }\n\n    return a.lineNumber - b.lineNumber;\n  }); // Reduce multiple cursors on the same line and only keep the last one on the line\n\n  for (let i = cursors.length - 2; i >= 0; i--) {\n    if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {\n      // Remove cursor at `i`\n      cursors.splice(i, 1);\n    }\n  }\n\n  const r = [];\n  let rLen = 0;\n  let cursorIndex = 0;\n  const cursorLen = cursors.length;\n\n  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n    const lineContent = model.getLineContent(lineNumber);\n    const maxLineColumn = lineContent.length + 1;\n    let minEditColumn = 0;\n\n    if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {\n      minEditColumn = cursors[cursorIndex].column;\n      cursorIndex++;\n\n      if (minEditColumn === maxLineColumn) {\n        // The cursor is at the end of the line => no edits for sure on this line\n        continue;\n      }\n    }\n\n    if (lineContent.length === 0) {\n      continue;\n    }\n\n    const lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    let fromColumn = 0;\n\n    if (lastNonWhitespaceIndex === -1) {\n      // Entire line is whitespace\n      fromColumn = 1;\n    } else if (lastNonWhitespaceIndex !== lineContent.length - 1) {\n      // There is trailing whitespace\n      fromColumn = lastNonWhitespaceIndex + 2;\n    } else {\n      // There is no trailing whitespace\n      continue;\n    }\n\n    fromColumn = Math.max(minEditColumn, fromColumn);\n    r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));\n  }\n\n  return r;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js"],"names":["strings","EditOperation","Range","TrimTrailingWhitespaceCommand","constructor","selection","cursors","_selection","_cursors","_selectionId","getEditOperations","model","builder","ops","trimTrailingWhitespace","i","len","length","op","addEditOperation","range","text","trackSelection","computeCursorState","helper","getTrackedSelection","sort","a","b","lineNumber","column","splice","r","rLen","cursorIndex","cursorLen","lineCount","getLineCount","lineContent","getLineContent","maxLineColumn","minEditColumn","lastNonWhitespaceIndex","fromColumn","Math","max","delete"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../core/editOperation.js';\nimport { Range } from '../core/range.js';\nexport class TrimTrailingWhitespaceCommand {\n    constructor(selection, cursors) {\n        this._selection = selection;\n        this._cursors = cursors;\n        this._selectionId = null;\n    }\n    getEditOperations(model, builder) {\n        const ops = trimTrailingWhitespace(model, this._cursors);\n        for (let i = 0, len = ops.length; i < len; i++) {\n            const op = ops[i];\n            builder.addEditOperation(op.range, op.text);\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this._selectionId);\n    }\n}\n/**\n * Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.\n */\nexport function trimTrailingWhitespace(model, cursors) {\n    // Sort cursors ascending\n    cursors.sort((a, b) => {\n        if (a.lineNumber === b.lineNumber) {\n            return a.column - b.column;\n        }\n        return a.lineNumber - b.lineNumber;\n    });\n    // Reduce multiple cursors on the same line and only keep the last one on the line\n    for (let i = cursors.length - 2; i >= 0; i--) {\n        if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {\n            // Remove cursor at `i`\n            cursors.splice(i, 1);\n        }\n    }\n    const r = [];\n    let rLen = 0;\n    let cursorIndex = 0;\n    const cursorLen = cursors.length;\n    for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const maxLineColumn = lineContent.length + 1;\n        let minEditColumn = 0;\n        if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {\n            minEditColumn = cursors[cursorIndex].column;\n            cursorIndex++;\n            if (minEditColumn === maxLineColumn) {\n                // The cursor is at the end of the line => no edits for sure on this line\n                continue;\n            }\n        }\n        if (lineContent.length === 0) {\n            continue;\n        }\n        const lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n        let fromColumn = 0;\n        if (lastNonWhitespaceIndex === -1) {\n            // Entire line is whitespace\n            fromColumn = 1;\n        }\n        else if (lastNonWhitespaceIndex !== lineContent.length - 1) {\n            // There is trailing whitespace\n            fromColumn = lastNonWhitespaceIndex + 2;\n        }\n        else {\n            // There is no trailing whitespace\n            continue;\n        }\n        fromColumn = Math.max(minEditColumn, fromColumn);\n        r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));\n    }\n    return r;\n}\n"]},"metadata":{},"sourceType":"module"}