{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { LanguageConfigurationRegistry } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport class LineCommentCommand {\n  constructor(languageConfigurationService, selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n    this.languageConfigurationService = languageConfigurationService;\n    this._selection = selection;\n    this._tabSize = tabSize;\n    this._type = type;\n    this._insertSpace = insertSpace;\n    this._selectionId = null;\n    this._deltaColumn = 0;\n    this._moveEndPositionDown = false;\n    this._ignoreEmptyLines = ignoreEmptyLines;\n    this._ignoreFirstLine = ignoreFirstLine || false;\n  }\n  /**\n   * Do an initial pass over the lines and gather info about the line comment string.\n   * Returns null if any of the lines doesn't support a line comment string.\n   */\n\n\n  static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {\n    model.tokenizeIfCheap(startLineNumber);\n    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n    const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n    const commentStr = config ? config.lineCommentToken : null;\n\n    if (!commentStr) {\n      // Mode does not support line comments\n      return null;\n    }\n\n    let lines = [];\n\n    for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n      lines[i] = {\n        ignore: false,\n        commentStr: commentStr,\n        commentStrOffset: 0,\n        commentStrLength: commentStr.length\n      };\n    }\n\n    return lines;\n  }\n  /**\n   * Analyze lines and decide which lines are relevant and what the toggle should do.\n   * Also, build up several offsets and lengths useful in the generation of editor operations.\n   */\n\n\n  static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n    let onlyWhitespaceLines = true;\n    let shouldRemoveComments;\n\n    if (type === 0\n    /* Toggle */\n    ) {\n      shouldRemoveComments = true;\n    } else if (type === 1\n    /* ForceAdd */\n    ) {\n      shouldRemoveComments = false;\n    } else {\n      shouldRemoveComments = true;\n    }\n\n    for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n      const lineData = lines[i];\n      const lineNumber = startLineNumber + i;\n\n      if (lineNumber === startLineNumber && ignoreFirstLine) {\n        // first line ignored\n        lineData.ignore = true;\n        continue;\n      }\n\n      const lineContent = model.getLineContent(lineNumber);\n      const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n\n      if (lineContentStartOffset === -1) {\n        // Empty or whitespace only line\n        lineData.ignore = ignoreEmptyLines;\n        lineData.commentStrOffset = lineContent.length;\n        continue;\n      }\n\n      onlyWhitespaceLines = false;\n      lineData.ignore = false;\n      lineData.commentStrOffset = lineContentStartOffset;\n\n      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n        if (type === 0\n        /* Toggle */\n        ) {\n          // Every line so far has been a line comment, but this one is not\n          shouldRemoveComments = false;\n        } else if (type === 1\n        /* ForceAdd */\n        ) {// Will not happen\n        } else {\n          lineData.ignore = true;\n        }\n      }\n\n      if (shouldRemoveComments && insertSpace) {\n        // Remove a following space if present\n        const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n\n        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32\n        /* Space */\n        ) {\n          lineData.commentStrLength += 1;\n        }\n      }\n    }\n\n    if (type === 0\n    /* Toggle */\n    && onlyWhitespaceLines) {\n      // For only whitespace lines, we insert comments\n      shouldRemoveComments = false; // Also, no longer ignore them\n\n      for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n        lines[i].ignore = false;\n      }\n    }\n\n    return {\n      supported: true,\n      shouldRemoveComments: shouldRemoveComments,\n      lines: lines\n    };\n  }\n  /**\n   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n   */\n\n\n  static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n    const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n\n    if (lines === null) {\n      return {\n        supported: false\n      };\n    }\n\n    return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);\n  }\n  /**\n   * Given a successful analysis, execute either insert line comments, either remove line comments\n   */\n\n\n  _executeLineComments(model, builder, data, s) {\n    let ops;\n\n    if (data.shouldRemoveComments) {\n      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n    } else {\n      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n\n      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n    }\n\n    const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n\n    for (let i = 0, len = ops.length; i < len; i++) {\n      builder.addEditOperation(ops[i].range, ops[i].text);\n\n      if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n        const lineContent = model.getLineContent(cursorPosition.lineNumber);\n\n        if (lineContent.length + 1 === cursorPosition.column) {\n          this._deltaColumn = (ops[i].text || '').length;\n        }\n      }\n    }\n\n    this._selectionId = builder.trackSelection(s);\n  }\n\n  _attemptRemoveBlockComment(model, s, startToken, endToken) {\n    let startLineNumber = s.startLineNumber;\n    let endLineNumber = s.endLineNumber;\n    let startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n    let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n    let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n\n    if (startTokenIndex !== -1 && endTokenIndex === -1) {\n      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      endLineNumber = startLineNumber;\n    }\n\n    if (startTokenIndex === -1 && endTokenIndex !== -1) {\n      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n      startLineNumber = endLineNumber;\n    }\n\n    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n\n      if (startTokenIndex !== -1) {\n        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      }\n    } // We have to adjust to possible inner white space.\n    // For Space after startToken, add Space to startToken - range math will work out.\n\n\n    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32\n    /* Space */\n    ) {\n      startToken += ' ';\n    } // For Space before endToken, add Space before endToken and shift index one left.\n\n\n    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32\n    /* Space */\n    ) {\n      endToken = ' ' + endToken;\n      endTokenIndex -= 1;\n    }\n\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n    }\n\n    return null;\n  }\n  /**\n   * Given an unsuccessful analysis, delegate to the block comment command\n   */\n\n\n  _executeBlockComment(model, builder, s) {\n    model.tokenizeIfCheap(s.startLineNumber);\n    let languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n    let config = LanguageConfigurationRegistry.getComments(languageId);\n\n    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n      // Mode does not support block comments\n      return;\n    }\n\n    const startToken = config.blockCommentStartToken;\n    const endToken = config.blockCommentEndToken;\n\n    let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n\n    if (!ops) {\n      if (s.isEmpty()) {\n        const lineContent = model.getLineContent(s.startLineNumber);\n        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\n        if (firstNonWhitespaceIndex === -1) {\n          // Line is empty or contains only whitespace\n          firstNonWhitespaceIndex = lineContent.length;\n        }\n\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n      } else {\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n      }\n\n      if (ops.length === 1) {\n        // Leave cursor after token and Space\n        this._deltaColumn = startToken.length + 1;\n      }\n    }\n\n    this._selectionId = builder.trackSelection(s);\n\n    for (const op of ops) {\n      builder.addEditOperation(op.range, op.text);\n    }\n  }\n\n  getEditOperations(model, builder) {\n    let s = this._selection;\n    this._moveEndPositionDown = false;\n\n    if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n      builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n      this._selectionId = builder.trackSelection(s);\n      return;\n    }\n\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n\n    const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);\n\n    if (data.supported) {\n      return this._executeLineComments(model, builder, data, s);\n    }\n\n    return this._executeBlockComment(model, builder, s);\n  }\n\n  computeCursorState(model, helper) {\n    let result = helper.getTrackedSelection(this._selectionId);\n\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n\n    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n  }\n  /**\n   * Generate edit operations in the remove line comment case\n   */\n\n\n  static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n    let res = [];\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      const lineData = lines[i];\n\n      if (lineData.ignore) {\n        continue;\n      }\n\n      res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n    }\n\n    return res;\n  }\n  /**\n   * Generate edit operations in the add line comment case\n   */\n\n\n  _createAddLineCommentsOperations(lines, startLineNumber) {\n    let res = [];\n    const afterCommentStr = this._insertSpace ? ' ' : '';\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      const lineData = lines[i];\n\n      if (lineData.ignore) {\n        continue;\n      }\n\n      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n    }\n\n    return res;\n  }\n\n  static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\n    if (isTab) {\n      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);\n    }\n\n    return currentVisibleColumn + columnSize;\n  }\n  /**\n   * Adjust insertion points to have them vertically aligned in the add line comment case\n   */\n\n\n  static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {\n    let minVisibleColumn = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ;\n    let j;\n    let lenJ;\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n\n      const lineContent = model.getLineContent(startLineNumber + i);\n      let currentVisibleColumn = 0;\n\n      for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9\n        /* Tab */\n        , 1);\n      }\n\n      if (currentVisibleColumn < minVisibleColumn) {\n        minVisibleColumn = currentVisibleColumn;\n      }\n    }\n\n    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n\n      const lineContent = model.getLineContent(startLineNumber + i);\n      let currentVisibleColumn = 0;\n\n      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9\n        /* Tab */\n        , 1);\n      }\n\n      if (currentVisibleColumn > minVisibleColumn) {\n        lines[i].commentStrOffset = j - 1;\n      } else {\n        lines[i].commentStrOffset = j;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/lineCommentCommand.js"],"names":["strings","EditOperation","Position","Range","Selection","LanguageConfigurationRegistry","BlockCommentCommand","LineCommentCommand","constructor","languageConfigurationService","selection","tabSize","type","insertSpace","ignoreEmptyLines","ignoreFirstLine","_selection","_tabSize","_type","_insertSpace","_selectionId","_deltaColumn","_moveEndPositionDown","_ignoreEmptyLines","_ignoreFirstLine","_gatherPreflightCommentStrings","model","startLineNumber","endLineNumber","tokenizeIfCheap","languageId","getLanguageIdAtPosition","config","getLanguageConfiguration","comments","commentStr","lineCommentToken","lines","i","lineCount","ignore","commentStrOffset","commentStrLength","length","_analyzeLines","onlyWhitespaceLines","shouldRemoveComments","lineData","lineNumber","lineContent","getLineContent","lineContentStartOffset","firstNonWhitespaceIndex","_haystackHasNeedleAtOffset","commentStrEndOffset","charCodeAt","supported","_gatherPreflightData","_executeLineComments","builder","data","s","ops","_createRemoveLineCommentsOperations","_normalizeInsertionPoint","_createAddLineCommentsOperations","cursorPosition","positionLineNumber","positionColumn","len","addEditOperation","range","text","isEmpty","getStartPosition","equals","column","trackSelection","_attemptRemoveBlockComment","startToken","endToken","startTokenAllowedBeforeColumn","Math","max","getLineFirstNonWhitespaceColumn","startColumn","startTokenIndex","lastIndexOf","endTokenIndex","indexOf","endColumn","_createRemoveBlockCommentOperations","_executeBlockComment","getComments","blockCommentStartToken","blockCommentEndToken","_createAddBlockCommentOperations","getLineMaxColumn","op","getEditOperations","getLineCount","setEndPosition","computeCursorState","helper","result","getTrackedSelection","selectionStartLineNumber","selectionStartColumn","res","push","delete","afterCommentStr","insert","nextVisibleColumn","currentVisibleColumn","isTab","columnSize","minVisibleColumn","j","lenJ","floor"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { LanguageConfigurationRegistry } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport class LineCommentCommand {\n    constructor(languageConfigurationService, selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._selection = selection;\n        this._tabSize = tabSize;\n        this._type = type;\n        this._insertSpace = insertSpace;\n        this._selectionId = null;\n        this._deltaColumn = 0;\n        this._moveEndPositionDown = false;\n        this._ignoreEmptyLines = ignoreEmptyLines;\n        this._ignoreFirstLine = ignoreFirstLine || false;\n    }\n    /**\n     * Do an initial pass over the lines and gather info about the line comment string.\n     * Returns null if any of the lines doesn't support a line comment string.\n     */\n    static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {\n        model.tokenizeIfCheap(startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n        const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        const commentStr = (config ? config.lineCommentToken : null);\n        if (!commentStr) {\n            // Mode does not support line comments\n            return null;\n        }\n        let lines = [];\n        for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n            lines[i] = {\n                ignore: false,\n                commentStr: commentStr,\n                commentStrOffset: 0,\n                commentStrLength: commentStr.length\n            };\n        }\n        return lines;\n    }\n    /**\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\n     */\n    static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n        let onlyWhitespaceLines = true;\n        let shouldRemoveComments;\n        if (type === 0 /* Toggle */) {\n            shouldRemoveComments = true;\n        }\n        else if (type === 1 /* ForceAdd */) {\n            shouldRemoveComments = false;\n        }\n        else {\n            shouldRemoveComments = true;\n        }\n        for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n            const lineData = lines[i];\n            const lineNumber = startLineNumber + i;\n            if (lineNumber === startLineNumber && ignoreFirstLine) {\n                // first line ignored\n                lineData.ignore = true;\n                continue;\n            }\n            const lineContent = model.getLineContent(lineNumber);\n            const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n            if (lineContentStartOffset === -1) {\n                // Empty or whitespace only line\n                lineData.ignore = ignoreEmptyLines;\n                lineData.commentStrOffset = lineContent.length;\n                continue;\n            }\n            onlyWhitespaceLines = false;\n            lineData.ignore = false;\n            lineData.commentStrOffset = lineContentStartOffset;\n            if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n                if (type === 0 /* Toggle */) {\n                    // Every line so far has been a line comment, but this one is not\n                    shouldRemoveComments = false;\n                }\n                else if (type === 1 /* ForceAdd */) {\n                    // Will not happen\n                }\n                else {\n                    lineData.ignore = true;\n                }\n            }\n            if (shouldRemoveComments && insertSpace) {\n                // Remove a following space if present\n                const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* Space */) {\n                    lineData.commentStrLength += 1;\n                }\n            }\n        }\n        if (type === 0 /* Toggle */ && onlyWhitespaceLines) {\n            // For only whitespace lines, we insert comments\n            shouldRemoveComments = false;\n            // Also, no longer ignore them\n            for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n                lines[i].ignore = false;\n            }\n        }\n        return {\n            supported: true,\n            shouldRemoveComments: shouldRemoveComments,\n            lines: lines\n        };\n    }\n    /**\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n     */\n    static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n        const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n        if (lines === null) {\n            return {\n                supported: false\n            };\n        }\n        return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);\n    }\n    /**\n     * Given a successful analysis, execute either insert line comments, either remove line comments\n     */\n    _executeLineComments(model, builder, data, s) {\n        let ops;\n        if (data.shouldRemoveComments) {\n            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        else {\n            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n            ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n        for (let i = 0, len = ops.length; i < len; i++) {\n            builder.addEditOperation(ops[i].range, ops[i].text);\n            if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n                const lineContent = model.getLineContent(cursorPosition.lineNumber);\n                if (lineContent.length + 1 === cursorPosition.column) {\n                    this._deltaColumn = (ops[i].text || '').length;\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    _attemptRemoveBlockComment(model, s, startToken, endToken) {\n        let startLineNumber = s.startLineNumber;\n        let endLineNumber = s.endLineNumber;\n        let startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n        let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n        let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n        if (startTokenIndex !== -1 && endTokenIndex === -1) {\n            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            endLineNumber = startLineNumber;\n        }\n        if (startTokenIndex === -1 && endTokenIndex !== -1) {\n            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n            startLineNumber = endLineNumber;\n        }\n        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n            if (startTokenIndex !== -1) {\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            }\n        }\n        // We have to adjust to possible inner white space.\n        // For Space after startToken, add Space to startToken - range math will work out.\n        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {\n            startToken += ' ';\n        }\n        // For Space before endToken, add Space before endToken and shift index one left.\n        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* Space */) {\n            endToken = ' ' + endToken;\n            endTokenIndex -= 1;\n        }\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n        }\n        return null;\n    }\n    /**\n     * Given an unsuccessful analysis, delegate to the block comment command\n     */\n    _executeBlockComment(model, builder, s) {\n        model.tokenizeIfCheap(s.startLineNumber);\n        let languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n        let config = LanguageConfigurationRegistry.getComments(languageId);\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n            // Mode does not support block comments\n            return;\n        }\n        const startToken = config.blockCommentStartToken;\n        const endToken = config.blockCommentEndToken;\n        let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n        if (!ops) {\n            if (s.isEmpty()) {\n                const lineContent = model.getLineContent(s.startLineNumber);\n                let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n                if (firstNonWhitespaceIndex === -1) {\n                    // Line is empty or contains only whitespace\n                    firstNonWhitespaceIndex = lineContent.length;\n                }\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n            }\n            else {\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n            }\n            if (ops.length === 1) {\n                // Leave cursor after token and Space\n                this._deltaColumn = startToken.length + 1;\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n        for (const op of ops) {\n            builder.addEditOperation(op.range, op.text);\n        }\n    }\n    getEditOperations(model, builder) {\n        let s = this._selection;\n        this._moveEndPositionDown = false;\n        if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n            builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n            this._selectionId = builder.trackSelection(s);\n            return;\n        }\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);\n        if (data.supported) {\n            return this._executeLineComments(model, builder, data, s);\n        }\n        return this._executeBlockComment(model, builder, s);\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n    }\n    /**\n     * Generate edit operations in the remove line comment case\n     */\n    static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n        let res = [];\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n        }\n        return res;\n    }\n    /**\n     * Generate edit operations in the add line comment case\n     */\n    _createAddLineCommentsOperations(lines, startLineNumber) {\n        let res = [];\n        const afterCommentStr = this._insertSpace ? ' ' : '';\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n        }\n        return res;\n    }\n    static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\n        if (isTab) {\n            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n        }\n        return currentVisibleColumn + columnSize;\n    }\n    /**\n     * Adjust insertion points to have them vertically aligned in the add line comment case\n     */\n    static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {\n        let minVisibleColumn = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        let j;\n        let lenJ;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\n            }\n            if (currentVisibleColumn < minVisibleColumn) {\n                minVisibleColumn = currentVisibleColumn;\n            }\n        }\n        minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\n            }\n            if (currentVisibleColumn > minVisibleColumn) {\n                lines[i].commentStrOffset = j - 1;\n            }\n            else {\n                lines[i].commentStrOffset = j;\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}