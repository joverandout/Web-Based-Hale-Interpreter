{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { TokenMetadata } from '../languages.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport { SparseMultilineTokens } from '../tokens/sparseMultilineTokens.js';\nimport { ILanguageService } from './language.js';\nlet SemanticTokensProviderStyling = class SemanticTokensProviderStyling {\n  constructor(_legend, _themeService, _languageService, _logService) {\n    this._legend = _legend;\n    this._themeService = _themeService;\n    this._languageService = _languageService;\n    this._logService = _logService;\n    this._hashTable = new HashTable();\n    this._hasWarnedOverlappingTokens = false;\n  }\n\n  getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n    const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n\n    const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);\n\n    let metadata;\n\n    if (entry) {\n      metadata = entry.metadata;\n\n      if (this._logService.getLevel() === LogLevel.Trace) {\n        this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n      }\n    } else {\n      let tokenType = this._legend.tokenTypes[tokenTypeIndex];\n      const tokenModifiers = [];\n\n      if (tokenType) {\n        let modifierSet = tokenModifierSet;\n\n        for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n          if (modifierSet & 1) {\n            tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n          }\n\n          modifierSet = modifierSet >> 1;\n        }\n\n        if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n          this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\n\n          tokenModifiers.push('not-in-legend');\n        }\n\n        const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);\n\n        if (typeof tokenStyle === 'undefined') {\n          metadata = 2147483647\n          /* NO_STYLING */\n          ;\n        } else {\n          metadata = 0;\n\n          if (typeof tokenStyle.italic !== 'undefined') {\n            const italicBit = (tokenStyle.italic ? 1\n            /* Italic */\n            : 0) << 10\n            /* FONT_STYLE_OFFSET */\n            ;\n            metadata |= italicBit | 1\n            /* SEMANTIC_USE_ITALIC */\n            ;\n          }\n\n          if (typeof tokenStyle.bold !== 'undefined') {\n            const boldBit = (tokenStyle.bold ? 2\n            /* Bold */\n            : 0) << 10\n            /* FONT_STYLE_OFFSET */\n            ;\n            metadata |= boldBit | 2\n            /* SEMANTIC_USE_BOLD */\n            ;\n          }\n\n          if (typeof tokenStyle.underline !== 'undefined') {\n            const underlineBit = (tokenStyle.underline ? 4\n            /* Underline */\n            : 0) << 10\n            /* FONT_STYLE_OFFSET */\n            ;\n            metadata |= underlineBit | 4\n            /* SEMANTIC_USE_UNDERLINE */\n            ;\n          }\n\n          if (typeof tokenStyle.strikethrough !== 'undefined') {\n            const strikethroughBit = (tokenStyle.strikethrough ? 8\n            /* Strikethrough */\n            : 0) << 10\n            /* FONT_STYLE_OFFSET */\n            ;\n            metadata |= strikethroughBit | 8\n            /* SEMANTIC_USE_STRIKETHROUGH */\n            ;\n          }\n\n          if (tokenStyle.foreground) {\n            const foregroundBits = tokenStyle.foreground << 14\n            /* FOREGROUND_OFFSET */\n            ;\n            metadata |= foregroundBits | 16\n            /* SEMANTIC_USE_FOREGROUND */\n            ;\n          }\n\n          if (metadata === 0) {\n            // Nothing!\n            metadata = 2147483647\n            /* NO_STYLING */\n            ;\n          }\n        }\n      } else {\n        if (this._logService.getLevel() === LogLevel.Trace) {\n          this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\n        }\n\n        metadata = 2147483647\n        /* NO_STYLING */\n        ;\n        tokenType = 'not-in-legend';\n      }\n\n      this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);\n\n      if (this._logService.getLevel() === LogLevel.Trace) {\n        this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n      }\n    }\n\n    return metadata;\n  }\n\n  warnOverlappingSemanticTokens(lineNumber, startColumn) {\n    if (!this._hasWarnedOverlappingTokens) {\n      this._hasWarnedOverlappingTokens = true;\n      console.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);\n    }\n  }\n\n};\nSemanticTokensProviderStyling = __decorate([__param(1, IThemeService), __param(2, ILanguageService), __param(3, ILogService)], SemanticTokensProviderStyling);\nexport { SemanticTokensProviderStyling };\nexport function toMultilineTokens2(tokens, styling, languageId) {\n  const srcData = tokens.data;\n  const tokenCount = tokens.data.length / 5 | 0;\n  const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024\n  /* DesiredMaxAreas */\n  ), 400\n  /* DesiredTokensPerArea */\n  );\n  const result = [];\n  let tokenIndex = 0;\n  let lastLineNumber = 1;\n  let lastStartCharacter = 0;\n\n  while (tokenIndex < tokenCount) {\n    const tokenStartIndex = tokenIndex;\n    let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount); // Keep tokens on the same line in the same area...\n\n    if (tokenEndIndex < tokenCount) {\n      let smallTokenEndIndex = tokenEndIndex;\n\n      while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n        smallTokenEndIndex--;\n      }\n\n      if (smallTokenEndIndex - 1 === tokenStartIndex) {\n        // there are so many tokens on this line that our area would be empty, we must now go right\n        let bigTokenEndIndex = tokenEndIndex;\n\n        while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n          bigTokenEndIndex++;\n        }\n\n        tokenEndIndex = bigTokenEndIndex;\n      } else {\n        tokenEndIndex = smallTokenEndIndex;\n      }\n    }\n\n    let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n    let destOffset = 0;\n    let areaLine = 0;\n    let prevLineNumber = 0;\n    let prevStartCharacter = 0;\n    let prevEndCharacter = 0;\n\n    while (tokenIndex < tokenEndIndex) {\n      const srcOffset = 5 * tokenIndex;\n      const deltaLine = srcData[srcOffset];\n      const deltaCharacter = srcData[srcOffset + 1]; // Casting both `lineNumber` and `startCharacter` here to uint32 using `|0`\n      // to do checks below with the actual value that will be inserted in the Uint32Array result\n\n      const lineNumber = lastLineNumber + deltaLine | 0;\n      const startCharacter = deltaLine === 0 ? lastStartCharacter + deltaCharacter | 0 : deltaCharacter;\n      const length = srcData[srcOffset + 2];\n      const tokenTypeIndex = srcData[srcOffset + 3];\n      const tokenModifierSet = srcData[srcOffset + 4];\n      const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n\n      if (metadata !== 2147483647\n      /* NO_STYLING */\n      ) {\n        if (areaLine === 0) {\n          areaLine = lineNumber;\n        }\n\n        if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n          styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n\n          if (prevStartCharacter < startCharacter) {\n            // the previous token survives after the overlapping one\n            destData[destOffset - 4 + 2] = startCharacter;\n          } else {\n            // the previous token is entirely covered by the overlapping one\n            destOffset -= 4;\n          }\n        }\n\n        destData[destOffset] = lineNumber - areaLine;\n        destData[destOffset + 1] = startCharacter;\n        destData[destOffset + 2] = startCharacter + length;\n        destData[destOffset + 3] = metadata;\n        destOffset += 4;\n        prevLineNumber = lineNumber;\n        prevStartCharacter = startCharacter;\n        prevEndCharacter = startCharacter + length;\n      }\n\n      lastLineNumber = lineNumber;\n      lastStartCharacter = startCharacter;\n      tokenIndex++;\n    }\n\n    if (destOffset !== destData.length) {\n      destData = destData.subarray(0, destOffset);\n    }\n\n    const tokens = SparseMultilineTokens.create(areaLine, destData);\n    result.push(tokens);\n  }\n\n  return result;\n}\n\nclass HashTableEntry {\n  constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n    this.tokenTypeIndex = tokenTypeIndex;\n    this.tokenModifierSet = tokenModifierSet;\n    this.languageId = languageId;\n    this.metadata = metadata;\n    this.next = null;\n  }\n\n}\n\nclass HashTable {\n  constructor() {\n    this._elementsCount = 0;\n    this._currentLengthIndex = 0;\n    this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n    this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n    this._elements = [];\n\n    HashTable._nullOutEntries(this._elements, this._currentLength);\n  }\n\n  static _nullOutEntries(entries, length) {\n    for (let i = 0; i < length; i++) {\n      entries[i] = null;\n    }\n  }\n\n  _hash2(n1, n2) {\n    return (n1 << 5) - n1 + n2 | 0; // n1 * 31 + n2, keep as int32\n  }\n\n  _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n    return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n  }\n\n  get(tokenTypeIndex, tokenModifierSet, languageId) {\n    const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n\n    let p = this._elements[hash];\n\n    while (p) {\n      if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n        return p;\n      }\n\n      p = p.next;\n    }\n\n    return null;\n  }\n\n  add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n    this._elementsCount++;\n\n    if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n      // expand!\n      const oldElements = this._elements;\n      this._currentLengthIndex++;\n      this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n      this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n      this._elements = [];\n\n      HashTable._nullOutEntries(this._elements, this._currentLength);\n\n      for (const first of oldElements) {\n        let p = first;\n\n        while (p) {\n          const oldNext = p.next;\n          p.next = null;\n\n          this._add(p);\n\n          p = oldNext;\n        }\n      }\n    }\n\n    this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n  }\n\n  _add(element) {\n    const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n\n    element.next = this._elements[hash];\n    this._elements[hash] = element;\n  }\n\n}\n\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","TokenMetadata","IThemeService","ILogService","LogLevel","SparseMultilineTokens","ILanguageService","SemanticTokensProviderStyling","constructor","_legend","_themeService","_languageService","_logService","_hashTable","HashTable","_hasWarnedOverlappingTokens","getMetadata","tokenTypeIndex","tokenModifierSet","languageId","encodedLanguageId","languageIdCodec","encodeLanguageId","entry","get","metadata","getLevel","Trace","trace","getForeground","getFontStyle","toString","tokenType","tokenTypes","tokenModifiers","modifierSet","modifierIndex","push","JSON","stringify","tokenStyle","getColorTheme","getTokenStyleMetadata","italic","italicBit","bold","boldBit","underline","underlineBit","strikethrough","strikethroughBit","foreground","foregroundBits","add","join","warnOverlappingSemanticTokens","lineNumber","startColumn","console","warn","toMultilineTokens2","tokens","styling","srcData","data","tokenCount","tokensPerArea","Math","max","ceil","result","tokenIndex","lastLineNumber","lastStartCharacter","tokenStartIndex","tokenEndIndex","min","smallTokenEndIndex","bigTokenEndIndex","destData","Uint32Array","destOffset","areaLine","prevLineNumber","prevStartCharacter","prevEndCharacter","srcOffset","deltaLine","deltaCharacter","startCharacter","subarray","create","HashTableEntry","next","_elementsCount","_currentLengthIndex","_currentLength","_SIZES","_growCount","round","_elements","_nullOutEntries","entries","_hash2","n1","n2","_hashFunc","hash","p","oldElements","first","oldNext","_add","element"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { TokenMetadata } from '../languages.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport { SparseMultilineTokens } from '../tokens/sparseMultilineTokens.js';\nimport { ILanguageService } from './language.js';\nlet SemanticTokensProviderStyling = class SemanticTokensProviderStyling {\n    constructor(_legend, _themeService, _languageService, _logService) {\n        this._legend = _legend;\n        this._themeService = _themeService;\n        this._languageService = _languageService;\n        this._logService = _logService;\n        this._hashTable = new HashTable();\n        this._hasWarnedOverlappingTokens = false;\n    }\n    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n        const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n        const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);\n        let metadata;\n        if (entry) {\n            metadata = entry.metadata;\n            if (this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        else {\n            let tokenType = this._legend.tokenTypes[tokenTypeIndex];\n            const tokenModifiers = [];\n            if (tokenType) {\n                let modifierSet = tokenModifierSet;\n                for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n                    if (modifierSet & 1) {\n                        tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n                    }\n                    modifierSet = modifierSet >> 1;\n                }\n                if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\n                    tokenModifiers.push('not-in-legend');\n                }\n                const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);\n                if (typeof tokenStyle === 'undefined') {\n                    metadata = 2147483647 /* NO_STYLING */;\n                }\n                else {\n                    metadata = 0;\n                    if (typeof tokenStyle.italic !== 'undefined') {\n                        const italicBit = (tokenStyle.italic ? 1 /* Italic */ : 0) << 10 /* FONT_STYLE_OFFSET */;\n                        metadata |= italicBit | 1 /* SEMANTIC_USE_ITALIC */;\n                    }\n                    if (typeof tokenStyle.bold !== 'undefined') {\n                        const boldBit = (tokenStyle.bold ? 2 /* Bold */ : 0) << 10 /* FONT_STYLE_OFFSET */;\n                        metadata |= boldBit | 2 /* SEMANTIC_USE_BOLD */;\n                    }\n                    if (typeof tokenStyle.underline !== 'undefined') {\n                        const underlineBit = (tokenStyle.underline ? 4 /* Underline */ : 0) << 10 /* FONT_STYLE_OFFSET */;\n                        metadata |= underlineBit | 4 /* SEMANTIC_USE_UNDERLINE */;\n                    }\n                    if (typeof tokenStyle.strikethrough !== 'undefined') {\n                        const strikethroughBit = (tokenStyle.strikethrough ? 8 /* Strikethrough */ : 0) << 10 /* FONT_STYLE_OFFSET */;\n                        metadata |= strikethroughBit | 8 /* SEMANTIC_USE_STRIKETHROUGH */;\n                    }\n                    if (tokenStyle.foreground) {\n                        const foregroundBits = (tokenStyle.foreground) << 14 /* FOREGROUND_OFFSET */;\n                        metadata |= foregroundBits | 16 /* SEMANTIC_USE_FOREGROUND */;\n                    }\n                    if (metadata === 0) {\n                        // Nothing!\n                        metadata = 2147483647 /* NO_STYLING */;\n                    }\n                }\n            }\n            else {\n                if (this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\n                }\n                metadata = 2147483647 /* NO_STYLING */;\n                tokenType = 'not-in-legend';\n            }\n            this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);\n            if (this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        return metadata;\n    }\n    warnOverlappingSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedOverlappingTokens) {\n            this._hasWarnedOverlappingTokens = true;\n            console.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n};\nSemanticTokensProviderStyling = __decorate([\n    __param(1, IThemeService),\n    __param(2, ILanguageService),\n    __param(3, ILogService)\n], SemanticTokensProviderStyling);\nexport { SemanticTokensProviderStyling };\nexport function toMultilineTokens2(tokens, styling, languageId) {\n    const srcData = tokens.data;\n    const tokenCount = (tokens.data.length / 5) | 0;\n    const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* DesiredMaxAreas */), 400 /* DesiredTokensPerArea */);\n    const result = [];\n    let tokenIndex = 0;\n    let lastLineNumber = 1;\n    let lastStartCharacter = 0;\n    while (tokenIndex < tokenCount) {\n        const tokenStartIndex = tokenIndex;\n        let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n        // Keep tokens on the same line in the same area...\n        if (tokenEndIndex < tokenCount) {\n            let smallTokenEndIndex = tokenEndIndex;\n            while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n                smallTokenEndIndex--;\n            }\n            if (smallTokenEndIndex - 1 === tokenStartIndex) {\n                // there are so many tokens on this line that our area would be empty, we must now go right\n                let bigTokenEndIndex = tokenEndIndex;\n                while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n                    bigTokenEndIndex++;\n                }\n                tokenEndIndex = bigTokenEndIndex;\n            }\n            else {\n                tokenEndIndex = smallTokenEndIndex;\n            }\n        }\n        let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n        let destOffset = 0;\n        let areaLine = 0;\n        let prevLineNumber = 0;\n        let prevStartCharacter = 0;\n        let prevEndCharacter = 0;\n        while (tokenIndex < tokenEndIndex) {\n            const srcOffset = 5 * tokenIndex;\n            const deltaLine = srcData[srcOffset];\n            const deltaCharacter = srcData[srcOffset + 1];\n            // Casting both `lineNumber` and `startCharacter` here to uint32 using `|0`\n            // to do checks below with the actual value that will be inserted in the Uint32Array result\n            const lineNumber = (lastLineNumber + deltaLine) | 0;\n            const startCharacter = (deltaLine === 0 ? (lastStartCharacter + deltaCharacter) | 0 : deltaCharacter);\n            const length = srcData[srcOffset + 2];\n            const tokenTypeIndex = srcData[srcOffset + 3];\n            const tokenModifierSet = srcData[srcOffset + 4];\n            const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n            if (metadata !== 2147483647 /* NO_STYLING */) {\n                if (areaLine === 0) {\n                    areaLine = lineNumber;\n                }\n                if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n                    styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n                    if (prevStartCharacter < startCharacter) {\n                        // the previous token survives after the overlapping one\n                        destData[destOffset - 4 + 2] = startCharacter;\n                    }\n                    else {\n                        // the previous token is entirely covered by the overlapping one\n                        destOffset -= 4;\n                    }\n                }\n                destData[destOffset] = lineNumber - areaLine;\n                destData[destOffset + 1] = startCharacter;\n                destData[destOffset + 2] = startCharacter + length;\n                destData[destOffset + 3] = metadata;\n                destOffset += 4;\n                prevLineNumber = lineNumber;\n                prevStartCharacter = startCharacter;\n                prevEndCharacter = startCharacter + length;\n            }\n            lastLineNumber = lineNumber;\n            lastStartCharacter = startCharacter;\n            tokenIndex++;\n        }\n        if (destOffset !== destData.length) {\n            destData = destData.subarray(0, destOffset);\n        }\n        const tokens = SparseMultilineTokens.create(areaLine, destData);\n        result.push(tokens);\n    }\n    return result;\n}\nclass HashTableEntry {\n    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this.tokenTypeIndex = tokenTypeIndex;\n        this.tokenModifierSet = tokenModifierSet;\n        this.languageId = languageId;\n        this.metadata = metadata;\n        this.next = null;\n    }\n}\nclass HashTable {\n    constructor() {\n        this._elementsCount = 0;\n        this._currentLengthIndex = 0;\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n        this._elements = [];\n        HashTable._nullOutEntries(this._elements, this._currentLength);\n    }\n    static _nullOutEntries(entries, length) {\n        for (let i = 0; i < length; i++) {\n            entries[i] = null;\n        }\n    }\n    _hash2(n1, n2) {\n        return (((n1 << 5) - n1) + n2) | 0; // n1 * 31 + n2, keep as int32\n    }\n    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n        return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n    }\n    get(tokenTypeIndex, tokenModifierSet, languageId) {\n        const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n        let p = this._elements[hash];\n        while (p) {\n            if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n                return p;\n            }\n            p = p.next;\n        }\n        return null;\n    }\n    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this._elementsCount++;\n        if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n            // expand!\n            const oldElements = this._elements;\n            this._currentLengthIndex++;\n            this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n            this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n            this._elements = [];\n            HashTable._nullOutEntries(this._elements, this._currentLength);\n            for (const first of oldElements) {\n                let p = first;\n                while (p) {\n                    const oldNext = p.next;\n                    p.next = null;\n                    this._add(p);\n                    p = oldNext;\n                }\n            }\n        }\n        this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n    }\n    _add(element) {\n        const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n        element.next = this._elements[hash];\n        this._elements[hash] = element;\n    }\n}\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];\n"]},"metadata":{},"sourceType":"module"}