{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n  return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n  constructor(_ignorePathCasing) {\n    this._ignorePathCasing = _ignorePathCasing;\n  }\n\n  compare(uri1, uri2, ignoreFragment = false) {\n    if (uri1 === uri2) {\n      return 0;\n    }\n\n    return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n  }\n\n  isEqual(uri1, uri2, ignoreFragment = false) {\n    if (uri1 === uri2) {\n      return true;\n    }\n\n    if (!uri1 || !uri2) {\n      return false;\n    }\n\n    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n  }\n\n  getComparisonKey(uri, ignoreFragment = false) {\n    return uri.with({\n      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n      fragment: ignoreFragment ? null : undefined\n    }).toString();\n  }\n\n  isEqualOrParent(base, parentCandidate, ignoreFragment = false) {\n    if (base.scheme === parentCandidate.scheme) {\n      if (base.scheme === Schemas.file) {\n        return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n      }\n\n      if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n        return extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n      }\n    }\n\n    return false;\n  } // --- path math\n\n\n  joinPath(resource, ...pathFragment) {\n    return URI.joinPath(resource, ...pathFragment);\n  }\n\n  basenameOrAuthority(resource) {\n    return basename(resource) || resource.authority;\n  }\n\n  basename(resource) {\n    return paths.posix.basename(resource.path);\n  }\n\n  extname(resource) {\n    return paths.posix.extname(resource.path);\n  }\n\n  dirname(resource) {\n    if (resource.path.length === 0) {\n      return resource;\n    }\n\n    let dirname;\n\n    if (resource.scheme === Schemas.file) {\n      dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n    } else {\n      dirname = paths.posix.dirname(resource.path);\n\n      if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47\n      /* Slash */\n      ) {\n        console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n        dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n      }\n    }\n\n    return resource.with({\n      path: dirname\n    });\n  }\n\n  normalizePath(resource) {\n    if (!resource.path.length) {\n      return resource;\n    }\n\n    let normalizedPath;\n\n    if (resource.scheme === Schemas.file) {\n      normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n    } else {\n      normalizedPath = paths.posix.normalize(resource.path);\n    }\n\n    return resource.with({\n      path: normalizedPath\n    });\n  }\n\n  relativePath(from, to) {\n    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n      return undefined;\n    }\n\n    if (from.scheme === Schemas.file) {\n      const relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n      return isWindows ? extpath.toSlashes(relativePath) : relativePath;\n    }\n\n    let fromPath = from.path || '/',\n        toPath = to.path || '/';\n\n    if (this._ignorePathCasing(from)) {\n      // make casing of fromPath match toPath\n      let i = 0;\n\n      for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n        if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n          if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n            break;\n          }\n        }\n      }\n\n      fromPath = toPath.substr(0, i) + fromPath.substr(i);\n    }\n\n    return paths.posix.relative(fromPath, toPath);\n  }\n\n  resolvePath(base, path) {\n    if (base.scheme === Schemas.file) {\n      const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n      return base.with({\n        authority: newURI.authority,\n        path: newURI.path\n      });\n    }\n\n    path = extpath.toPosixPath(path); // we allow path to be a windows path\n\n    return base.with({\n      path: paths.posix.resolve(base.path, path)\n    });\n  } // --- misc\n\n\n  isAbsolutePath(resource) {\n    return !!resource.path && resource.path[0] === '/';\n  }\n\n  isEqualAuthority(a1, a2) {\n    return a1 === a2 || a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2);\n  }\n\n  hasTrailingPathSeparator(resource, sep = paths.sep) {\n    if (resource.scheme === Schemas.file) {\n      const fsp = originalFSPath(resource);\n      return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n    } else {\n      const p = resource.path;\n      return p.length > 1 && p.charCodeAt(p.length - 1) === 47\n      /* Slash */\n      && !/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath); // ignore the slash at offset 0\n    }\n  }\n\n  removeTrailingPathSeparator(resource, sep = paths.sep) {\n    // Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n    if (hasTrailingPathSeparator(resource, sep)) {\n      return resource.with({\n        path: resource.path.substr(0, resource.path.length - 1)\n      });\n    }\n\n    return resource;\n  }\n\n  addTrailingPathSeparator(resource, sep = paths.sep) {\n    let isRootSep = false;\n\n    if (resource.scheme === Schemas.file) {\n      const fsp = originalFSPath(resource);\n      isRootSep = fsp !== undefined && fsp.length === extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n    } else {\n      sep = '/';\n      const p = resource.path;\n      isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47\n      /* Slash */\n      ;\n    }\n\n    if (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n      return resource.with({\n        path: resource.path + '/'\n      });\n    }\n\n    return resource;\n  }\n\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\n\nexport const extUri = new ExtUri(() => false);\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\n\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n  // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n  // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n  return uri.scheme === Schemas.file ? !isLinux : true;\n});\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\n\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n/**\n * Data URI related helpers.\n */\n\nexport var DataUri;\n\n(function (DataUri) {\n  DataUri.META_DATA_LABEL = 'label';\n  DataUri.META_DATA_DESCRIPTION = 'description';\n  DataUri.META_DATA_SIZE = 'size';\n  DataUri.META_DATA_MIME = 'mime';\n\n  function parseMetaData(dataUri) {\n    const metadata = new Map(); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\n    const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n    meta.split(';').forEach(property => {\n      const [key, value] = property.split(':');\n\n      if (key && value) {\n        metadata.set(key, value);\n      }\n    }); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the mime is: image/png\n\n    const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\n    if (mime) {\n      metadata.set(DataUri.META_DATA_MIME, mime);\n    }\n\n    return metadata;\n  }\n\n  DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/resources.js"],"names":["extpath","Schemas","paths","isLinux","isWindows","compare","strCompare","equalsIgnoreCase","URI","uriToFsPath","originalFSPath","uri","ExtUri","constructor","_ignorePathCasing","uri1","uri2","ignoreFragment","getComparisonKey","isEqual","with","path","toLowerCase","undefined","fragment","toString","isEqualOrParent","base","parentCandidate","scheme","file","query","isEqualAuthority","authority","joinPath","resource","pathFragment","basenameOrAuthority","basename","posix","extname","dirname","length","charCodeAt","console","error","normalizePath","normalizedPath","normalize","relativePath","from","to","relative","toSlashes","fromPath","toPath","i","len","Math","min","charAt","substr","resolvePath","newURI","resolve","toPosixPath","isAbsolutePath","a1","a2","hasTrailingPathSeparator","sep","fsp","getRoot","p","test","fsPath","removeTrailingPathSeparator","addTrailingPathSeparator","isRootSep","extUri","extUriBiasedIgnorePathCase","extUriIgnorePathCase","_","bind","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","meta","substring","indexOf","lastIndexOf","split","forEach","property","key","value","set","mime"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n    return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n    constructor(_ignorePathCasing) {\n        this._ignorePathCasing = _ignorePathCasing;\n    }\n    compare(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return 0;\n        }\n        return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n    }\n    isEqual(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return true;\n        }\n        if (!uri1 || !uri2) {\n            return false;\n        }\n        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n    }\n    getComparisonKey(uri, ignoreFragment = false) {\n        return uri.with({\n            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n            fragment: ignoreFragment ? null : undefined\n        }).toString();\n    }\n    isEqualOrParent(base, parentCandidate, ignoreFragment = false) {\n        if (base.scheme === parentCandidate.scheme) {\n            if (base.scheme === Schemas.file) {\n                return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n            if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n                return extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n        }\n        return false;\n    }\n    // --- path math\n    joinPath(resource, ...pathFragment) {\n        return URI.joinPath(resource, ...pathFragment);\n    }\n    basenameOrAuthority(resource) {\n        return basename(resource) || resource.authority;\n    }\n    basename(resource) {\n        return paths.posix.basename(resource.path);\n    }\n    extname(resource) {\n        return paths.posix.extname(resource.path);\n    }\n    dirname(resource) {\n        if (resource.path.length === 0) {\n            return resource;\n        }\n        let dirname;\n        if (resource.scheme === Schemas.file) {\n            dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n        }\n        else {\n            dirname = paths.posix.dirname(resource.path);\n            if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* Slash */) {\n                console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n                dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n            }\n        }\n        return resource.with({\n            path: dirname\n        });\n    }\n    normalizePath(resource) {\n        if (!resource.path.length) {\n            return resource;\n        }\n        let normalizedPath;\n        if (resource.scheme === Schemas.file) {\n            normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n        }\n        else {\n            normalizedPath = paths.posix.normalize(resource.path);\n        }\n        return resource.with({\n            path: normalizedPath\n        });\n    }\n    relativePath(from, to) {\n        if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n            return undefined;\n        }\n        if (from.scheme === Schemas.file) {\n            const relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n            return isWindows ? extpath.toSlashes(relativePath) : relativePath;\n        }\n        let fromPath = from.path || '/', toPath = to.path || '/';\n        if (this._ignorePathCasing(from)) {\n            // make casing of fromPath match toPath\n            let i = 0;\n            for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n                if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n                    if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n                        break;\n                    }\n                }\n            }\n            fromPath = toPath.substr(0, i) + fromPath.substr(i);\n        }\n        return paths.posix.relative(fromPath, toPath);\n    }\n    resolvePath(base, path) {\n        if (base.scheme === Schemas.file) {\n            const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n            return base.with({\n                authority: newURI.authority,\n                path: newURI.path\n            });\n        }\n        path = extpath.toPosixPath(path); // we allow path to be a windows path\n        return base.with({\n            path: paths.posix.resolve(base.path, path)\n        });\n    }\n    // --- misc\n    isAbsolutePath(resource) {\n        return !!resource.path && resource.path[0] === '/';\n    }\n    isEqualAuthority(a1, a2) {\n        return a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n    }\n    hasTrailingPathSeparator(resource, sep = paths.sep) {\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n        }\n        else {\n            const p = resource.path;\n            return (p.length > 1 && p.charCodeAt(p.length - 1) === 47 /* Slash */) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n        }\n    }\n    removeTrailingPathSeparator(resource, sep = paths.sep) {\n        // Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n        if (hasTrailingPathSeparator(resource, sep)) {\n            return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n        }\n        return resource;\n    }\n    addTrailingPathSeparator(resource, sep = paths.sep) {\n        let isRootSep = false;\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            isRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n        }\n        else {\n            sep = '/';\n            const p = resource.path;\n            isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47 /* Slash */;\n        }\n        if (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n            return resource.with({ path: resource.path + '/' });\n        }\n        return resource;\n    }\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n    // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n    // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n    return uri.scheme === Schemas.file ? !isLinux : true;\n});\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n/**\n * Data URI related helpers.\n */\nexport var DataUri;\n(function (DataUri) {\n    DataUri.META_DATA_LABEL = 'label';\n    DataUri.META_DATA_DESCRIPTION = 'description';\n    DataUri.META_DATA_SIZE = 'size';\n    DataUri.META_DATA_MIME = 'mime';\n    function parseMetaData(dataUri) {\n        const metadata = new Map();\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n        const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n        meta.split(';').forEach(property => {\n            const [key, value] = property.split(':');\n            if (key && value) {\n                metadata.set(key, value);\n            }\n        });\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the mime is: image/png\n        const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n        if (mime) {\n            metadata.set(DataUri.META_DATA_MIME, mime);\n        }\n        return metadata;\n    }\n    DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));\n"]},"metadata":{},"sourceType":"module"}