{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nconst HIGH_FREQ_COMMANDS = /^(cursor|delete)/;\nexport class AbstractKeybindingService extends Disposable {\n  constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n    super();\n    this._contextKeyService = _contextKeyService;\n    this._commandService = _commandService;\n    this._telemetryService = _telemetryService;\n    this._notificationService = _notificationService;\n    this._logService = _logService;\n    this._onDidUpdateKeybindings = this._register(new Emitter());\n    this._currentChord = null;\n    this._currentChordChecker = new IntervalTimer();\n    this._currentChordStatusMessage = null;\n    this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n    this._currentSingleModifier = null;\n    this._currentSingleModifierClearTimeout = new TimeoutTimer();\n    this._logging = false;\n  }\n\n  get onDidUpdateKeybindings() {\n    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n  }\n\n  dispose() {\n    super.dispose();\n  }\n\n  _log(str) {\n    if (this._logging) {\n      this._logService.info(`[KeybindingService]: ${str}`);\n    }\n  }\n\n  getKeybindings() {\n    return this._getResolver().getKeybindings();\n  }\n\n  lookupKeybinding(commandId, context) {\n    const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);\n\n    if (!result) {\n      return undefined;\n    }\n\n    return result.resolvedKeybinding;\n  }\n\n  dispatchEvent(e, target) {\n    return this._dispatch(e, target);\n  }\n\n  softDispatch(e, target) {\n    const keybinding = this.resolveKeyboardEvent(e);\n\n    if (keybinding.isChord()) {\n      console.warn('Unexpected keyboard event mapped to a chord');\n      return null;\n    }\n\n    const [firstPart] = keybinding.getDispatchParts();\n\n    if (firstPart === null) {\n      // cannot be dispatched, probably only modifier keys\n      return null;\n    }\n\n    const contextValue = this._contextKeyService.getContext(target);\n\n    const currentChord = this._currentChord ? this._currentChord.keypress : null;\n    return this._getResolver().resolve(contextValue, currentChord, firstPart);\n  }\n\n  _enterChordMode(firstPart, keypressLabel) {\n    this._currentChord = {\n      keypress: firstPart,\n      label: keypressLabel\n    };\n    this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n    const chordEnterTime = Date.now();\n\n    this._currentChordChecker.cancelAndSet(() => {\n      if (!this._documentHasFocus()) {\n        // Focus has been lost => leave chord mode\n        this._leaveChordMode();\n\n        return;\n      }\n\n      if (Date.now() - chordEnterTime > 5000) {\n        // 5 seconds elapsed => leave chord mode\n        this._leaveChordMode();\n      }\n    }, 500);\n  }\n\n  _leaveChordMode() {\n    if (this._currentChordStatusMessage) {\n      this._currentChordStatusMessage.dispose();\n\n      this._currentChordStatusMessage = null;\n    }\n\n    this._currentChordChecker.cancel();\n\n    this._currentChord = null;\n  }\n\n  _dispatch(e, target) {\n    return this._doDispatch(this.resolveKeyboardEvent(e), target,\n    /*isSingleModiferChord*/\n    false);\n  }\n\n  _singleModifierDispatch(e, target) {\n    const keybinding = this.resolveKeyboardEvent(e);\n    const [singleModifier] = keybinding.getSingleModifierDispatchParts();\n\n    if (singleModifier) {\n      if (this._ignoreSingleModifiers.has(singleModifier)) {\n        this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);\n\n        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n\n        this._currentSingleModifierClearTimeout.cancel();\n\n        this._currentSingleModifier = null;\n        return false;\n      }\n\n      this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n\n      if (this._currentSingleModifier === null) {\n        // we have a valid `singleModifier`, store it for the next keyup, but clear it in 300ms\n        this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);\n\n        this._currentSingleModifier = singleModifier;\n\n        this._currentSingleModifierClearTimeout.cancelAndSet(() => {\n          this._log(`+ Clearing single modifier due to 300ms elapsed.`);\n\n          this._currentSingleModifier = null;\n        }, 300);\n\n        return false;\n      }\n\n      if (singleModifier === this._currentSingleModifier) {\n        // bingo!\n        this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);\n\n        this._currentSingleModifierClearTimeout.cancel();\n\n        this._currentSingleModifier = null;\n        return this._doDispatch(keybinding, target,\n        /*isSingleModiferChord*/\n        true);\n      }\n\n      this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);\n\n      this._currentSingleModifierClearTimeout.cancel();\n\n      this._currentSingleModifier = null;\n      return false;\n    } // When pressing a modifier and holding it pressed with any other modifier or key combination,\n    // the pressed modifiers should no longer be considered for single modifier dispatch.\n\n\n    const [firstPart] = keybinding.getParts();\n    this._ignoreSingleModifiers = new KeybindingModifierSet(firstPart);\n\n    if (this._currentSingleModifier !== null) {\n      this._log(`+ Clearing single modifier due to other key up.`);\n    }\n\n    this._currentSingleModifierClearTimeout.cancel();\n\n    this._currentSingleModifier = null;\n    return false;\n  }\n\n  _doDispatch(keybinding, target, isSingleModiferChord = false) {\n    let shouldPreventDefault = false;\n\n    if (keybinding.isChord()) {\n      console.warn('Unexpected keyboard event mapped to a chord');\n      return false;\n    }\n\n    let firstPart = null; // the first keybinding i.e. Ctrl+K\n\n    let currentChord = null; // the \"second\" keybinding i.e. Ctrl+K \"Ctrl+D\"\n\n    if (isSingleModiferChord) {\n      const [dispatchKeyname] = keybinding.getSingleModifierDispatchParts();\n      firstPart = dispatchKeyname;\n      currentChord = dispatchKeyname;\n    } else {\n      [firstPart] = keybinding.getDispatchParts();\n      currentChord = this._currentChord ? this._currentChord.keypress : null;\n    }\n\n    if (firstPart === null) {\n      this._log(`\\\\ Keyboard event cannot be dispatched in keydown phase.`); // cannot be dispatched, probably only modifier keys\n\n\n      return shouldPreventDefault;\n    }\n\n    const contextValue = this._contextKeyService.getContext(target);\n\n    const keypressLabel = keybinding.getLabel();\n\n    const resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\n\n    this._logService.trace('KeybindingService#dispatch', keypressLabel, resolveResult === null || resolveResult === void 0 ? void 0 : resolveResult.commandId);\n\n    if (resolveResult && resolveResult.enterChord) {\n      shouldPreventDefault = true;\n\n      this._enterChordMode(firstPart, keypressLabel);\n\n      return shouldPreventDefault;\n    }\n\n    if (this._currentChord) {\n      if (!resolveResult || !resolveResult.commandId) {\n        this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), {\n          hideAfter: 10 * 1000\n          /* 10s */\n\n        });\n\n        shouldPreventDefault = true;\n      }\n    }\n\n    this._leaveChordMode();\n\n    if (resolveResult && resolveResult.commandId) {\n      if (!resolveResult.bubble) {\n        shouldPreventDefault = true;\n      }\n\n      if (typeof resolveResult.commandArgs === 'undefined') {\n        this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n      } else {\n        this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n      }\n\n      if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {\n        this._telemetryService.publicLog2('workbenchActionExecuted', {\n          id: resolveResult.commandId,\n          from: 'keybinding'\n        });\n      }\n    }\n\n    return shouldPreventDefault;\n  }\n\n  mightProducePrintableCharacter(event) {\n    if (event.ctrlKey || event.metaKey) {\n      // ignore ctrl/cmd-combination but not shift/alt-combinatios\n      return false;\n    } // weak check for certain ranges. this is properly implemented in a subclass\n    // with access to the KeyboardMapperFactory.\n\n\n    if (event.keyCode >= 31\n    /* KeyA */\n    && event.keyCode <= 56\n    /* KeyZ */\n    || event.keyCode >= 21\n    /* Digit0 */\n    && event.keyCode <= 30\n    /* Digit9 */\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nclass KeybindingModifierSet {\n  constructor(source) {\n    this._ctrlKey = source ? source.ctrlKey : false;\n    this._shiftKey = source ? source.shiftKey : false;\n    this._altKey = source ? source.altKey : false;\n    this._metaKey = source ? source.metaKey : false;\n  }\n\n  has(modifier) {\n    switch (modifier) {\n      case 'ctrl':\n        return this._ctrlKey;\n\n      case 'shift':\n        return this._shiftKey;\n\n      case 'alt':\n        return this._altKey;\n\n      case 'meta':\n        return this._metaKey;\n    }\n  }\n\n}\n\nKeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js"],"names":["IntervalTimer","TimeoutTimer","Emitter","Event","Disposable","nls","HIGH_FREQ_COMMANDS","AbstractKeybindingService","constructor","_contextKeyService","_commandService","_telemetryService","_notificationService","_logService","_onDidUpdateKeybindings","_register","_currentChord","_currentChordChecker","_currentChordStatusMessage","_ignoreSingleModifiers","KeybindingModifierSet","EMPTY","_currentSingleModifier","_currentSingleModifierClearTimeout","_logging","onDidUpdateKeybindings","event","None","dispose","_log","str","info","getKeybindings","_getResolver","lookupKeybinding","commandId","context","result","lookupPrimaryKeybinding","undefined","resolvedKeybinding","dispatchEvent","e","target","_dispatch","softDispatch","keybinding","resolveKeyboardEvent","isChord","console","warn","firstPart","getDispatchParts","contextValue","getContext","currentChord","keypress","resolve","_enterChordMode","keypressLabel","label","status","localize","chordEnterTime","Date","now","cancelAndSet","_documentHasFocus","_leaveChordMode","cancel","_doDispatch","_singleModifierDispatch","singleModifier","getSingleModifierDispatchParts","has","getParts","isSingleModiferChord","shouldPreventDefault","dispatchKeyname","getLabel","resolveResult","trace","enterChord","hideAfter","bubble","commandArgs","executeCommand","then","err","test","publicLog2","id","from","mightProducePrintableCharacter","ctrlKey","metaKey","keyCode","source","_ctrlKey","_shiftKey","shiftKey","_altKey","altKey","_metaKey","modifier"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nconst HIGH_FREQ_COMMANDS = /^(cursor|delete)/;\nexport class AbstractKeybindingService extends Disposable {\n    constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n        super();\n        this._contextKeyService = _contextKeyService;\n        this._commandService = _commandService;\n        this._telemetryService = _telemetryService;\n        this._notificationService = _notificationService;\n        this._logService = _logService;\n        this._onDidUpdateKeybindings = this._register(new Emitter());\n        this._currentChord = null;\n        this._currentChordChecker = new IntervalTimer();\n        this._currentChordStatusMessage = null;\n        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n        this._currentSingleModifier = null;\n        this._currentSingleModifierClearTimeout = new TimeoutTimer();\n        this._logging = false;\n    }\n    get onDidUpdateKeybindings() {\n        return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n    }\n    dispose() {\n        super.dispose();\n    }\n    _log(str) {\n        if (this._logging) {\n            this._logService.info(`[KeybindingService]: ${str}`);\n        }\n    }\n    getKeybindings() {\n        return this._getResolver().getKeybindings();\n    }\n    lookupKeybinding(commandId, context) {\n        const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);\n        if (!result) {\n            return undefined;\n        }\n        return result.resolvedKeybinding;\n    }\n    dispatchEvent(e, target) {\n        return this._dispatch(e, target);\n    }\n    softDispatch(e, target) {\n        const keybinding = this.resolveKeyboardEvent(e);\n        if (keybinding.isChord()) {\n            console.warn('Unexpected keyboard event mapped to a chord');\n            return null;\n        }\n        const [firstPart,] = keybinding.getDispatchParts();\n        if (firstPart === null) {\n            // cannot be dispatched, probably only modifier keys\n            return null;\n        }\n        const contextValue = this._contextKeyService.getContext(target);\n        const currentChord = this._currentChord ? this._currentChord.keypress : null;\n        return this._getResolver().resolve(contextValue, currentChord, firstPart);\n    }\n    _enterChordMode(firstPart, keypressLabel) {\n        this._currentChord = {\n            keypress: firstPart,\n            label: keypressLabel\n        };\n        this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n        const chordEnterTime = Date.now();\n        this._currentChordChecker.cancelAndSet(() => {\n            if (!this._documentHasFocus()) {\n                // Focus has been lost => leave chord mode\n                this._leaveChordMode();\n                return;\n            }\n            if (Date.now() - chordEnterTime > 5000) {\n                // 5 seconds elapsed => leave chord mode\n                this._leaveChordMode();\n            }\n        }, 500);\n    }\n    _leaveChordMode() {\n        if (this._currentChordStatusMessage) {\n            this._currentChordStatusMessage.dispose();\n            this._currentChordStatusMessage = null;\n        }\n        this._currentChordChecker.cancel();\n        this._currentChord = null;\n    }\n    _dispatch(e, target) {\n        return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/ false);\n    }\n    _singleModifierDispatch(e, target) {\n        const keybinding = this.resolveKeyboardEvent(e);\n        const [singleModifier,] = keybinding.getSingleModifierDispatchParts();\n        if (singleModifier) {\n            if (this._ignoreSingleModifiers.has(singleModifier)) {\n                this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);\n                this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n                this._currentSingleModifierClearTimeout.cancel();\n                this._currentSingleModifier = null;\n                return false;\n            }\n            this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n            if (this._currentSingleModifier === null) {\n                // we have a valid `singleModifier`, store it for the next keyup, but clear it in 300ms\n                this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);\n                this._currentSingleModifier = singleModifier;\n                this._currentSingleModifierClearTimeout.cancelAndSet(() => {\n                    this._log(`+ Clearing single modifier due to 300ms elapsed.`);\n                    this._currentSingleModifier = null;\n                }, 300);\n                return false;\n            }\n            if (singleModifier === this._currentSingleModifier) {\n                // bingo!\n                this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);\n                this._currentSingleModifierClearTimeout.cancel();\n                this._currentSingleModifier = null;\n                return this._doDispatch(keybinding, target, /*isSingleModiferChord*/ true);\n            }\n            this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);\n            this._currentSingleModifierClearTimeout.cancel();\n            this._currentSingleModifier = null;\n            return false;\n        }\n        // When pressing a modifier and holding it pressed with any other modifier or key combination,\n        // the pressed modifiers should no longer be considered for single modifier dispatch.\n        const [firstPart,] = keybinding.getParts();\n        this._ignoreSingleModifiers = new KeybindingModifierSet(firstPart);\n        if (this._currentSingleModifier !== null) {\n            this._log(`+ Clearing single modifier due to other key up.`);\n        }\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return false;\n    }\n    _doDispatch(keybinding, target, isSingleModiferChord = false) {\n        let shouldPreventDefault = false;\n        if (keybinding.isChord()) {\n            console.warn('Unexpected keyboard event mapped to a chord');\n            return false;\n        }\n        let firstPart = null; // the first keybinding i.e. Ctrl+K\n        let currentChord = null; // the \"second\" keybinding i.e. Ctrl+K \"Ctrl+D\"\n        if (isSingleModiferChord) {\n            const [dispatchKeyname,] = keybinding.getSingleModifierDispatchParts();\n            firstPart = dispatchKeyname;\n            currentChord = dispatchKeyname;\n        }\n        else {\n            [firstPart,] = keybinding.getDispatchParts();\n            currentChord = this._currentChord ? this._currentChord.keypress : null;\n        }\n        if (firstPart === null) {\n            this._log(`\\\\ Keyboard event cannot be dispatched in keydown phase.`);\n            // cannot be dispatched, probably only modifier keys\n            return shouldPreventDefault;\n        }\n        const contextValue = this._contextKeyService.getContext(target);\n        const keypressLabel = keybinding.getLabel();\n        const resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\n        this._logService.trace('KeybindingService#dispatch', keypressLabel, resolveResult === null || resolveResult === void 0 ? void 0 : resolveResult.commandId);\n        if (resolveResult && resolveResult.enterChord) {\n            shouldPreventDefault = true;\n            this._enterChordMode(firstPart, keypressLabel);\n            return shouldPreventDefault;\n        }\n        if (this._currentChord) {\n            if (!resolveResult || !resolveResult.commandId) {\n                this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });\n                shouldPreventDefault = true;\n            }\n        }\n        this._leaveChordMode();\n        if (resolveResult && resolveResult.commandId) {\n            if (!resolveResult.bubble) {\n                shouldPreventDefault = true;\n            }\n            if (typeof resolveResult.commandArgs === 'undefined') {\n                this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n            }\n            else {\n                this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n            }\n            if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {\n                this._telemetryService.publicLog2('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding' });\n            }\n        }\n        return shouldPreventDefault;\n    }\n    mightProducePrintableCharacter(event) {\n        if (event.ctrlKey || event.metaKey) {\n            // ignore ctrl/cmd-combination but not shift/alt-combinatios\n            return false;\n        }\n        // weak check for certain ranges. this is properly implemented in a subclass\n        // with access to the KeyboardMapperFactory.\n        if ((event.keyCode >= 31 /* KeyA */ && event.keyCode <= 56 /* KeyZ */)\n            || (event.keyCode >= 21 /* Digit0 */ && event.keyCode <= 30 /* Digit9 */)) {\n            return true;\n        }\n        return false;\n    }\n}\nclass KeybindingModifierSet {\n    constructor(source) {\n        this._ctrlKey = source ? source.ctrlKey : false;\n        this._shiftKey = source ? source.shiftKey : false;\n        this._altKey = source ? source.altKey : false;\n        this._metaKey = source ? source.metaKey : false;\n    }\n    has(modifier) {\n        switch (modifier) {\n            case 'ctrl': return this._ctrlKey;\n            case 'shift': return this._shiftKey;\n            case 'alt': return this._altKey;\n            case 'meta': return this._metaKey;\n        }\n    }\n}\nKeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);\n"]},"metadata":{},"sourceType":"module"}