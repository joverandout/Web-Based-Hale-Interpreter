{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { DocumentSymbolProviderRegistry, SymbolKinds } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nlet AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n  constructor(_outlineModelService, options = Object.create(null)) {\n    super(options);\n    this._outlineModelService = _outlineModelService;\n    this.options = options;\n    this.options.canAcceptInBackground = true;\n  }\n\n  provideWithoutTextEditor(picker) {\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n    return Disposable.None;\n  }\n\n  provideWithTextEditor(context, picker, token) {\n    const editor = context.editor;\n    const model = this.getModel(editor);\n\n    if (!model) {\n      return Disposable.None;\n    } // Provide symbols from model if available in registry\n\n\n    if (DocumentSymbolProviderRegistry.has(model)) {\n      return this.doProvideWithEditorSymbols(context, model, picker, token);\n    } // Otherwise show an entry for a model without registry\n    // But give a chance to resolve the symbols at a later\n    // point if possible\n\n\n    return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n  }\n\n  doProvideWithoutEditorSymbols(context, model, picker, token) {\n    const disposables = new DisposableStore(); // Generic pick for not having any symbol information\n\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\")); // Wait for changes to the registry and see if eventually\n    // we do get symbols. This can happen if the picker is opened\n    // very early after the model has loaded but before the\n    // language registry is ready.\n    // https://github.com/microsoft/vscode/issues/70607\n\n    (() => __awaiter(this, void 0, void 0, function* () {\n      const result = yield this.waitForLanguageSymbolRegistry(model, disposables);\n\n      if (!result || token.isCancellationRequested) {\n        return;\n      }\n\n      disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n    }))();\n\n    return disposables;\n  }\n\n  provideLabelPick(picker, label) {\n    picker.items = [{\n      label,\n      index: 0,\n      kind: 14\n      /* String */\n\n    }];\n    picker.ariaLabel = label;\n  }\n\n  waitForLanguageSymbolRegistry(model, disposables) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (DocumentSymbolProviderRegistry.has(model)) {\n        return true;\n      }\n\n      const symbolProviderRegistryPromise = new DeferredPromise(); // Resolve promise when registry knows model\n\n      const symbolProviderListener = disposables.add(DocumentSymbolProviderRegistry.onDidChange(() => {\n        if (DocumentSymbolProviderRegistry.has(model)) {\n          symbolProviderListener.dispose();\n          symbolProviderRegistryPromise.complete(true);\n        }\n      })); // Resolve promise when we get disposed too\n\n      disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n      return symbolProviderRegistryPromise.p;\n    });\n  }\n\n  doProvideWithEditorSymbols(context, model, picker, token) {\n    const editor = context.editor;\n    const disposables = new DisposableStore(); // Goto symbol once picked\n\n    disposables.add(picker.onDidAccept(event => {\n      const [item] = picker.selectedItems;\n\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          preserveFocus: event.inBackground\n        });\n\n        if (!event.inBackground) {\n          picker.hide();\n        }\n      }\n    })); // Goto symbol side by side if enabled\n\n    disposables.add(picker.onDidTriggerItemButton(({\n      item\n    }) => {\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          forceSideBySide: true\n        });\n        picker.hide();\n      }\n    })); // Resolve symbols from document once and reuse this\n    // request for all filtering and typing then on\n\n    const symbolsPromise = this.getDocumentSymbols(model, token); // Set initial picks and update on type\n\n    let picksCts = undefined;\n\n    const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {\n      // Cancel any previous ask for picks and busy\n      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n      picker.busy = false; // Create new cancellation source for this run\n\n      picksCts = new CancellationTokenSource(token); // Collect symbol picks\n\n      picker.busy = true;\n\n      try {\n        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());\n        const items = yield this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);\n\n        if (token.isCancellationRequested) {\n          return;\n        }\n\n        if (items.length > 0) {\n          picker.items = items;\n        } else {\n          if (query.original.length > 0) {\n            this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n          } else {\n            this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n          }\n        }\n      } finally {\n        if (!token.isCancellationRequested) {\n          picker.busy = false;\n        }\n      }\n    });\n\n    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n    updatePickerItems(); // Reveal and decorate when active item changes\n    // However, ignore the very first event so that\n    // opening the picker is not immediately revealing\n    // and decorating the first entry.\n\n    let ignoreFirstActiveEvent = true;\n    disposables.add(picker.onDidChangeActive(() => {\n      const [item] = picker.activeItems;\n\n      if (item && item.range) {\n        if (ignoreFirstActiveEvent) {\n          ignoreFirstActiveEvent = false;\n          return;\n        } // Reveal\n\n\n        editor.revealRangeInCenter(item.range.selection, 0\n        /* Smooth */\n        ); // Decorate\n\n        this.addDecorations(editor, item.range.decoration);\n      }\n    }));\n    return disposables;\n  }\n\n  doGetSymbolPicks(symbolsPromise, query, options, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const symbols = yield symbolsPromise;\n\n      if (token.isCancellationRequested) {\n        return [];\n      }\n\n      const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;\n      const filterPos = filterBySymbolKind ? 1 : 0; // Split between symbol and container query\n\n      let symbolQuery;\n      let containerQuery;\n\n      if (query.values && query.values.length > 1) {\n        symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n\n        containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n      } else {\n        symbolQuery = query;\n      } // Convert to symbol picks and apply filtering\n\n\n      const filteredSymbolPicks = [];\n\n      for (let index = 0; index < symbols.length; index++) {\n        const symbol = symbols[index];\n        const symbolLabel = trim(symbol.name);\n        const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n        const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n        let containerLabel = symbol.containerName;\n\n        if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\n          if (containerLabel) {\n            containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n          } else {\n            containerLabel = options.extraContainerLabel;\n          }\n        }\n\n        let symbolScore = undefined;\n        let symbolMatches = undefined;\n        let containerScore = undefined;\n        let containerMatches = undefined;\n\n        if (query.original.length > filterPos) {\n          // First: try to score on the entire query, it is possible that\n          // the symbol matches perfectly (e.g. searching for \"change log\"\n          // can be a match on a markdown symbol \"change log\"). In that\n          // case we want to skip the container query altogether.\n          let skipContainerQuery = false;\n\n          if (symbolQuery !== query) {\n            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), {\n              values: undefined\n              /* disable multi-query support */\n\n            }), filterPos, symbolLabelIconOffset);\n\n            if (typeof symbolScore === 'number') {\n              skipContainerQuery = true; // since we consumed the query, skip any container matching\n            }\n          } // Otherwise: score on the symbol query and match on the container later\n\n\n          if (typeof symbolScore !== 'number') {\n            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n\n            if (typeof symbolScore !== 'number') {\n              continue;\n            }\n          } // Score by container if specified\n\n\n          if (!skipContainerQuery && containerQuery) {\n            if (containerLabel && containerQuery.original.length > 0) {\n              [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n            }\n\n            if (typeof containerScore !== 'number') {\n              continue;\n            }\n\n            if (typeof symbolScore === 'number') {\n              symbolScore += containerScore; // boost symbolScore by containerScore\n            }\n          }\n        }\n\n        const deprecated = symbol.tags && symbol.tags.indexOf(1\n        /* Deprecated */\n        ) >= 0;\n        filteredSymbolPicks.push({\n          index,\n          kind: symbol.kind,\n          score: symbolScore,\n          label: symbolLabelWithIcon,\n          ariaLabel: symbolLabel,\n          description: containerLabel,\n          highlights: deprecated ? undefined : {\n            label: symbolMatches,\n            description: containerMatches\n          },\n          range: {\n            selection: Range.collapseToStart(symbol.selectionRange),\n            decoration: symbol.range\n          },\n          strikethrough: deprecated,\n          buttons: (() => {\n            var _a, _b;\n\n            const openSideBySideDirection = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) ? (_b = this.options) === null || _b === void 0 ? void 0 : _b.openSideBySideDirection() : undefined;\n\n            if (!openSideBySideDirection) {\n              return undefined;\n            }\n\n            return [{\n              iconClass: openSideBySideDirection === 'right' ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,\n              tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n            }];\n          })()\n        });\n      } // Sort by score\n\n\n      const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB)); // Add separator for types\n      // - @  only total number of symbols\n      // - @: grouped by symbol kind\n\n      let symbolPicks = [];\n\n      if (filterBySymbolKind) {\n        let lastSymbolKind = undefined;\n        let lastSeparator = undefined;\n        let lastSymbolKindCounter = 0;\n\n        function updateLastSeparatorLabel() {\n          if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n            lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n          }\n        }\n\n        for (const symbolPick of sortedFilteredSymbolPicks) {\n          // Found new kind\n          if (lastSymbolKind !== symbolPick.kind) {\n            // Update last separator with number of symbols we found for kind\n            updateLastSeparatorLabel();\n            lastSymbolKind = symbolPick.kind;\n            lastSymbolKindCounter = 1; // Add new separator for new kind\n\n            lastSeparator = {\n              type: 'separator'\n            };\n            symbolPicks.push(lastSeparator);\n          } // Existing kind, keep counting\n          else {\n            lastSymbolKindCounter++;\n          } // Add to final result\n\n\n          symbolPicks.push(symbolPick);\n        } // Update last separator with number of symbols we found for kind\n\n\n        updateLastSeparatorLabel();\n      } else if (sortedFilteredSymbolPicks.length > 0) {\n        symbolPicks = [{\n          label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length),\n          type: 'separator'\n        }, ...sortedFilteredSymbolPicks];\n      }\n\n      return symbolPicks;\n    });\n  }\n\n  compareByScore(symbolA, symbolB) {\n    if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n      return 1;\n    } else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n      return -1;\n    }\n\n    if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n      if (symbolA.score > symbolB.score) {\n        return -1;\n      } else if (symbolA.score < symbolB.score) {\n        return 1;\n      }\n    }\n\n    if (symbolA.index < symbolB.index) {\n      return -1;\n    } else if (symbolA.index > symbolB.index) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  compareByKindAndScore(symbolA, symbolB) {\n    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND; // Sort by type first if scoped search\n\n    const result = kindA.localeCompare(kindB);\n\n    if (result === 0) {\n      return this.compareByScore(symbolA, symbolB);\n    }\n\n    return result;\n  }\n\n  getDocumentSymbols(document, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = yield this._outlineModelService.getOrCreate(document, token);\n      return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n    });\n  }\n\n};\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;\nAbstractGotoSymbolQuickAccessProvider = __decorate([__param(0, IOutlineModelService)], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider }; // #region NLS Helpers\n\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n  [5\n  /* Method */\n  ]: localize('method', \"methods ({0})\"),\n  [11\n  /* Function */\n  ]: localize('function', \"functions ({0})\"),\n  [8\n  /* Constructor */\n  ]: localize('_constructor', \"constructors ({0})\"),\n  [12\n  /* Variable */\n  ]: localize('variable', \"variables ({0})\"),\n  [4\n  /* Class */\n  ]: localize('class', \"classes ({0})\"),\n  [22\n  /* Struct */\n  ]: localize('struct', \"structs ({0})\"),\n  [23\n  /* Event */\n  ]: localize('event', \"events ({0})\"),\n  [24\n  /* Operator */\n  ]: localize('operator', \"operators ({0})\"),\n  [10\n  /* Interface */\n  ]: localize('interface', \"interfaces ({0})\"),\n  [2\n  /* Namespace */\n  ]: localize('namespace', \"namespaces ({0})\"),\n  [3\n  /* Package */\n  ]: localize('package', \"packages ({0})\"),\n  [25\n  /* TypeParameter */\n  ]: localize('typeParameter', \"type parameters ({0})\"),\n  [1\n  /* Module */\n  ]: localize('modules', \"modules ({0})\"),\n  [6\n  /* Property */\n  ]: localize('property', \"properties ({0})\"),\n  [9\n  /* Enum */\n  ]: localize('enum', \"enumerations ({0})\"),\n  [21\n  /* EnumMember */\n  ]: localize('enumMember', \"enumeration members ({0})\"),\n  [14\n  /* String */\n  ]: localize('string', \"strings ({0})\"),\n  [0\n  /* File */\n  ]: localize('file', \"files ({0})\"),\n  [17\n  /* Array */\n  ]: localize('array', \"arrays ({0})\"),\n  [15\n  /* Number */\n  ]: localize('number', \"numbers ({0})\"),\n  [16\n  /* Boolean */\n  ]: localize('boolean', \"booleans ({0})\"),\n  [18\n  /* Object */\n  ]: localize('object', \"objects ({0})\"),\n  [19\n  /* Key */\n  ]: localize('key', \"keys ({0})\"),\n  [7\n  /* Field */\n  ]: localize('field', \"fields ({0})\"),\n  [13\n  /* Constant */\n  ]: localize('constant', \"constants ({0})\")\n}; //#endregion","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","DeferredPromise","CancellationTokenSource","Codicon","pieceToQuery","prepareQuery","scoreFuzzy2","Disposable","DisposableStore","toDisposable","format","trim","Range","DocumentSymbolProviderRegistry","SymbolKinds","IOutlineModelService","AbstractEditorNavigationQuickAccessProvider","localize","AbstractGotoSymbolQuickAccessProvider","constructor","_outlineModelService","options","create","canAcceptInBackground","provideWithoutTextEditor","picker","provideLabelPick","None","provideWithTextEditor","context","token","editor","model","getModel","has","doProvideWithEditorSymbols","doProvideWithoutEditorSymbols","disposables","waitForLanguageSymbolRegistry","isCancellationRequested","add","label","items","index","kind","ariaLabel","symbolProviderRegistryPromise","symbolProviderListener","onDidChange","dispose","complete","p","onDidAccept","event","item","selectedItems","range","gotoLocation","selection","keyMods","preserveFocus","inBackground","hide","onDidTriggerItemButton","forceSideBySide","symbolsPromise","getDocumentSymbols","picksCts","undefined","updatePickerItems","busy","query","substr","PREFIX","doGetSymbolPicks","original","onDidChangeValue","ignoreFirstActiveEvent","onDidChangeActive","activeItems","revealRangeInCenter","addDecorations","decoration","symbols","filterBySymbolKind","indexOf","SCOPE_PREFIX","filterPos","symbolQuery","containerQuery","values","slice","filteredSymbolPicks","symbol","symbolLabel","name","symbolLabelWithIcon","toIcon","id","symbolLabelIconOffset","containerLabel","containerName","extraContainerLabel","symbolScore","symbolMatches","containerScore","containerMatches","skipContainerQuery","assign","deprecated","tags","push","score","description","highlights","collapseToStart","selectionRange","strikethrough","buttons","_a","_b","openSideBySideDirection","iconClass","splitHorizontal","classNames","splitVertical","tooltip","sortedFilteredSymbolPicks","sort","symbolA","symbolB","compareByKindAndScore","compareByScore","symbolPicks","lastSymbolKind","lastSeparator","lastSymbolKindCounter","updateLastSeparatorLabel","NLS_SYMBOL_KIND_CACHE","FALLBACK_NLS_SYMBOL_KIND","symbolPick","type","kindA","kindB","localeCompare","document","getOrCreate","asListOfDocumentSymbols","PREFIX_BY_CATEGORY"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { DocumentSymbolProviderRegistry, SymbolKinds } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nlet AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n    constructor(_outlineModelService, options = Object.create(null)) {\n        super(options);\n        this._outlineModelService = _outlineModelService;\n        this.options = options;\n        this.options.canAcceptInBackground = true;\n    }\n    provideWithoutTextEditor(picker) {\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n        return Disposable.None;\n    }\n    provideWithTextEditor(context, picker, token) {\n        const editor = context.editor;\n        const model = this.getModel(editor);\n        if (!model) {\n            return Disposable.None;\n        }\n        // Provide symbols from model if available in registry\n        if (DocumentSymbolProviderRegistry.has(model)) {\n            return this.doProvideWithEditorSymbols(context, model, picker, token);\n        }\n        // Otherwise show an entry for a model without registry\n        // But give a chance to resolve the symbols at a later\n        // point if possible\n        return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n    }\n    doProvideWithoutEditorSymbols(context, model, picker, token) {\n        const disposables = new DisposableStore();\n        // Generic pick for not having any symbol information\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n        // Wait for changes to the registry and see if eventually\n        // we do get symbols. This can happen if the picker is opened\n        // very early after the model has loaded but before the\n        // language registry is ready.\n        // https://github.com/microsoft/vscode/issues/70607\n        (() => __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.waitForLanguageSymbolRegistry(model, disposables);\n            if (!result || token.isCancellationRequested) {\n                return;\n            }\n            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n        }))();\n        return disposables;\n    }\n    provideLabelPick(picker, label) {\n        picker.items = [{ label, index: 0, kind: 14 /* String */ }];\n        picker.ariaLabel = label;\n    }\n    waitForLanguageSymbolRegistry(model, disposables) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (DocumentSymbolProviderRegistry.has(model)) {\n                return true;\n            }\n            const symbolProviderRegistryPromise = new DeferredPromise();\n            // Resolve promise when registry knows model\n            const symbolProviderListener = disposables.add(DocumentSymbolProviderRegistry.onDidChange(() => {\n                if (DocumentSymbolProviderRegistry.has(model)) {\n                    symbolProviderListener.dispose();\n                    symbolProviderRegistryPromise.complete(true);\n                }\n            }));\n            // Resolve promise when we get disposed too\n            disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n            return symbolProviderRegistryPromise.p;\n        });\n    }\n    doProvideWithEditorSymbols(context, model, picker, token) {\n        const editor = context.editor;\n        const disposables = new DisposableStore();\n        // Goto symbol once picked\n        disposables.add(picker.onDidAccept(event => {\n            const [item] = picker.selectedItems;\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });\n                if (!event.inBackground) {\n                    picker.hide();\n                }\n            }\n        }));\n        // Goto symbol side by side if enabled\n        disposables.add(picker.onDidTriggerItemButton(({ item }) => {\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });\n                picker.hide();\n            }\n        }));\n        // Resolve symbols from document once and reuse this\n        // request for all filtering and typing then on\n        const symbolsPromise = this.getDocumentSymbols(model, token);\n        // Set initial picks and update on type\n        let picksCts = undefined;\n        const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {\n            // Cancel any previous ask for picks and busy\n            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n            picker.busy = false;\n            // Create new cancellation source for this run\n            picksCts = new CancellationTokenSource(token);\n            // Collect symbol picks\n            picker.busy = true;\n            try {\n                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());\n                const items = yield this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (items.length > 0) {\n                    picker.items = items;\n                }\n                else {\n                    if (query.original.length > 0) {\n                        this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n                    }\n                    else {\n                        this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n                    }\n                }\n            }\n            finally {\n                if (!token.isCancellationRequested) {\n                    picker.busy = false;\n                }\n            }\n        });\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n        updatePickerItems();\n        // Reveal and decorate when active item changes\n        // However, ignore the very first event so that\n        // opening the picker is not immediately revealing\n        // and decorating the first entry.\n        let ignoreFirstActiveEvent = true;\n        disposables.add(picker.onDidChangeActive(() => {\n            const [item] = picker.activeItems;\n            if (item && item.range) {\n                if (ignoreFirstActiveEvent) {\n                    ignoreFirstActiveEvent = false;\n                    return;\n                }\n                // Reveal\n                editor.revealRangeInCenter(item.range.selection, 0 /* Smooth */);\n                // Decorate\n                this.addDecorations(editor, item.range.decoration);\n            }\n        }));\n        return disposables;\n    }\n    doGetSymbolPicks(symbolsPromise, query, options, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const symbols = yield symbolsPromise;\n            if (token.isCancellationRequested) {\n                return [];\n            }\n            const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;\n            const filterPos = filterBySymbolKind ? 1 : 0;\n            // Split between symbol and container query\n            let symbolQuery;\n            let containerQuery;\n            if (query.values && query.values.length > 1) {\n                symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n                containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n            }\n            else {\n                symbolQuery = query;\n            }\n            // Convert to symbol picks and apply filtering\n            const filteredSymbolPicks = [];\n            for (let index = 0; index < symbols.length; index++) {\n                const symbol = symbols[index];\n                const symbolLabel = trim(symbol.name);\n                const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n                const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n                let containerLabel = symbol.containerName;\n                if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\n                    if (containerLabel) {\n                        containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n                    }\n                    else {\n                        containerLabel = options.extraContainerLabel;\n                    }\n                }\n                let symbolScore = undefined;\n                let symbolMatches = undefined;\n                let containerScore = undefined;\n                let containerMatches = undefined;\n                if (query.original.length > filterPos) {\n                    // First: try to score on the entire query, it is possible that\n                    // the symbol matches perfectly (e.g. searching for \"change log\"\n                    // can be a match on a markdown symbol \"change log\"). In that\n                    // case we want to skip the container query altogether.\n                    let skipContainerQuery = false;\n                    if (symbolQuery !== query) {\n                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), { values: undefined /* disable multi-query support */ }), filterPos, symbolLabelIconOffset);\n                        if (typeof symbolScore === 'number') {\n                            skipContainerQuery = true; // since we consumed the query, skip any container matching\n                        }\n                    }\n                    // Otherwise: score on the symbol query and match on the container later\n                    if (typeof symbolScore !== 'number') {\n                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n                        if (typeof symbolScore !== 'number') {\n                            continue;\n                        }\n                    }\n                    // Score by container if specified\n                    if (!skipContainerQuery && containerQuery) {\n                        if (containerLabel && containerQuery.original.length > 0) {\n                            [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n                        }\n                        if (typeof containerScore !== 'number') {\n                            continue;\n                        }\n                        if (typeof symbolScore === 'number') {\n                            symbolScore += containerScore; // boost symbolScore by containerScore\n                        }\n                    }\n                }\n                const deprecated = symbol.tags && symbol.tags.indexOf(1 /* Deprecated */) >= 0;\n                filteredSymbolPicks.push({\n                    index,\n                    kind: symbol.kind,\n                    score: symbolScore,\n                    label: symbolLabelWithIcon,\n                    ariaLabel: symbolLabel,\n                    description: containerLabel,\n                    highlights: deprecated ? undefined : {\n                        label: symbolMatches,\n                        description: containerMatches\n                    },\n                    range: {\n                        selection: Range.collapseToStart(symbol.selectionRange),\n                        decoration: symbol.range\n                    },\n                    strikethrough: deprecated,\n                    buttons: (() => {\n                        var _a, _b;\n                        const openSideBySideDirection = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) ? (_b = this.options) === null || _b === void 0 ? void 0 : _b.openSideBySideDirection() : undefined;\n                        if (!openSideBySideDirection) {\n                            return undefined;\n                        }\n                        return [\n                            {\n                                iconClass: openSideBySideDirection === 'right' ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,\n                                tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n                            }\n                        ];\n                    })()\n                });\n            }\n            // Sort by score\n            const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?\n                this.compareByKindAndScore(symbolA, symbolB) :\n                this.compareByScore(symbolA, symbolB));\n            // Add separator for types\n            // - @  only total number of symbols\n            // - @: grouped by symbol kind\n            let symbolPicks = [];\n            if (filterBySymbolKind) {\n                let lastSymbolKind = undefined;\n                let lastSeparator = undefined;\n                let lastSymbolKindCounter = 0;\n                function updateLastSeparatorLabel() {\n                    if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n                        lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n                    }\n                }\n                for (const symbolPick of sortedFilteredSymbolPicks) {\n                    // Found new kind\n                    if (lastSymbolKind !== symbolPick.kind) {\n                        // Update last separator with number of symbols we found for kind\n                        updateLastSeparatorLabel();\n                        lastSymbolKind = symbolPick.kind;\n                        lastSymbolKindCounter = 1;\n                        // Add new separator for new kind\n                        lastSeparator = { type: 'separator' };\n                        symbolPicks.push(lastSeparator);\n                    }\n                    // Existing kind, keep counting\n                    else {\n                        lastSymbolKindCounter++;\n                    }\n                    // Add to final result\n                    symbolPicks.push(symbolPick);\n                }\n                // Update last separator with number of symbols we found for kind\n                updateLastSeparatorLabel();\n            }\n            else if (sortedFilteredSymbolPicks.length > 0) {\n                symbolPicks = [\n                    { label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length), type: 'separator' },\n                    ...sortedFilteredSymbolPicks\n                ];\n            }\n            return symbolPicks;\n        });\n    }\n    compareByScore(symbolA, symbolB) {\n        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n            return 1;\n        }\n        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n            return -1;\n        }\n        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n            if (symbolA.score > symbolB.score) {\n                return -1;\n            }\n            else if (symbolA.score < symbolB.score) {\n                return 1;\n            }\n        }\n        if (symbolA.index < symbolB.index) {\n            return -1;\n        }\n        else if (symbolA.index > symbolB.index) {\n            return 1;\n        }\n        return 0;\n    }\n    compareByKindAndScore(symbolA, symbolB) {\n        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        // Sort by type first if scoped search\n        const result = kindA.localeCompare(kindB);\n        if (result === 0) {\n            return this.compareByScore(symbolA, symbolB);\n        }\n        return result;\n    }\n    getDocumentSymbols(document, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = yield this._outlineModelService.getOrCreate(document, token);\n            return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n        });\n    }\n};\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;\nAbstractGotoSymbolQuickAccessProvider = __decorate([\n    __param(0, IOutlineModelService)\n], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n    [5 /* Method */]: localize('method', \"methods ({0})\"),\n    [11 /* Function */]: localize('function', \"functions ({0})\"),\n    [8 /* Constructor */]: localize('_constructor', \"constructors ({0})\"),\n    [12 /* Variable */]: localize('variable', \"variables ({0})\"),\n    [4 /* Class */]: localize('class', \"classes ({0})\"),\n    [22 /* Struct */]: localize('struct', \"structs ({0})\"),\n    [23 /* Event */]: localize('event', \"events ({0})\"),\n    [24 /* Operator */]: localize('operator', \"operators ({0})\"),\n    [10 /* Interface */]: localize('interface', \"interfaces ({0})\"),\n    [2 /* Namespace */]: localize('namespace', \"namespaces ({0})\"),\n    [3 /* Package */]: localize('package', \"packages ({0})\"),\n    [25 /* TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n    [1 /* Module */]: localize('modules', \"modules ({0})\"),\n    [6 /* Property */]: localize('property', \"properties ({0})\"),\n    [9 /* Enum */]: localize('enum', \"enumerations ({0})\"),\n    [21 /* EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n    [14 /* String */]: localize('string', \"strings ({0})\"),\n    [0 /* File */]: localize('file', \"files ({0})\"),\n    [17 /* Array */]: localize('array', \"arrays ({0})\"),\n    [15 /* Number */]: localize('number', \"numbers ({0})\"),\n    [16 /* Boolean */]: localize('boolean', \"booleans ({0})\"),\n    [18 /* Object */]: localize('object', \"objects ({0})\"),\n    [19 /* Key */]: localize('key', \"keys ({0})\"),\n    [7 /* Field */]: localize('field', \"fields ({0})\"),\n    [13 /* Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion\n"]},"metadata":{},"sourceType":"module"}