{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './textAreaHandler.css';\nimport * as nls from '../../../nls.js';\nimport * as browser from '../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { CopyOptions, TextAreaInput, TextAreaWrapper } from './textAreaInput.js';\nimport { PagedScreenReaderStrategy, TextAreaState, _debugComposition } from './textAreaState.js';\nimport { PartFingerprints, ViewPart } from '../view/viewPart.js';\nimport { LineNumbersOverlay } from '../viewParts/lineNumbers/lineNumbers.js';\nimport { Margin } from '../viewParts/margin/margin.js';\nimport { EditorOptions } from '../../common/config/editorOptions.js';\nimport { getMapForWordSeparators } from '../../common/core/wordCharacterClassifier.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { TokenizationRegistry } from '../../common/languages.js';\nimport { Color } from '../../../base/common/color.js';\n\nclass VisibleTextAreaData {\n  constructor(_context, modelLineNumber, distanceToModelLineStart, widthOfHiddenLineTextBefore, distanceToModelLineEnd) {\n    this._context = _context;\n    this.modelLineNumber = modelLineNumber;\n    this.distanceToModelLineStart = distanceToModelLineStart;\n    this.widthOfHiddenLineTextBefore = widthOfHiddenLineTextBefore;\n    this.distanceToModelLineEnd = distanceToModelLineEnd;\n    this._visibleTextAreaBrand = undefined;\n    this.startPosition = null;\n    this.endPosition = null;\n    this.visibleTextareaStart = null;\n    this.visibleTextareaEnd = null;\n  }\n\n  prepareRender(visibleRangeProvider) {\n    const startModelPosition = new Position(this.modelLineNumber, this.distanceToModelLineStart + 1);\n    const endModelPosition = new Position(this.modelLineNumber, this._context.model.getModelLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);\n    this.startPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(startModelPosition);\n    this.endPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(endModelPosition);\n\n    if (this.startPosition.lineNumber === this.endPosition.lineNumber) {\n      this.visibleTextareaStart = visibleRangeProvider.visibleRangeForPosition(this.startPosition);\n      this.visibleTextareaEnd = visibleRangeProvider.visibleRangeForPosition(this.endPosition);\n    } else {\n      // TODO: what if the view positions are not on the same line?\n      this.visibleTextareaStart = null;\n      this.visibleTextareaEnd = null;\n    }\n  }\n\n}\n\nconst canUseZeroSizeTextarea = browser.isFirefox;\nexport class TextAreaHandler extends ViewPart {\n  constructor(context, viewController, visibleRangeProvider) {\n    super(context); // --- end view API\n\n    this._primaryCursorPosition = new Position(1, 1);\n    this._primaryCursorVisibleRange = null;\n    this._viewController = viewController;\n    this._visibleRangeProvider = visibleRangeProvider;\n    this._scrollLeft = 0;\n    this._scrollTop = 0;\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(131\n    /* layoutInfo */\n    );\n\n    this._setAccessibilityOptions(options);\n\n    this._contentLeft = layoutInfo.contentLeft;\n    this._contentWidth = layoutInfo.contentWidth;\n    this._contentHeight = layoutInfo.height;\n    this._fontInfo = options.get(44\n    /* fontInfo */\n    );\n    this._lineHeight = options.get(59\n    /* lineHeight */\n    );\n    this._emptySelectionClipboard = options.get(32\n    /* emptySelectionClipboard */\n    );\n    this._copyWithSyntaxHighlighting = options.get(21\n    /* copyWithSyntaxHighlighting */\n    );\n    this._visibleTextArea = null;\n    this._selections = [new Selection(1, 1, 1, 1)];\n    this._modelSelections = [new Selection(1, 1, 1, 1)];\n    this._lastRenderPosition = null; // Text Area (The focus will always be in the textarea when the cursor is blinking)\n\n    this.textArea = createFastDomNode(document.createElement('textarea'));\n    PartFingerprints.write(this.textArea, 6\n    /* TextArea */\n    );\n    this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n    this.textArea.setAttribute('wrap', 'off');\n    this.textArea.setAttribute('autocorrect', 'off');\n    this.textArea.setAttribute('autocapitalize', 'off');\n    this.textArea.setAttribute('autocomplete', 'off');\n    this.textArea.setAttribute('spellcheck', 'false');\n    this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n    this.textArea.setAttribute('tabindex', String(options.get(112\n    /* tabIndex */\n    )));\n    this.textArea.setAttribute('role', 'textbox');\n    this.textArea.setAttribute('aria-roledescription', nls.localize('editor', \"editor\"));\n    this.textArea.setAttribute('aria-multiline', 'true');\n    this.textArea.setAttribute('aria-haspopup', 'false');\n    this.textArea.setAttribute('aria-autocomplete', 'both');\n\n    if (options.get(30\n    /* domReadOnly */\n    ) && options.get(81\n    /* readOnly */\n    )) {\n      this.textArea.setAttribute('readonly', 'true');\n    }\n\n    this.textAreaCover = createFastDomNode(document.createElement('div'));\n    this.textAreaCover.setPosition('absolute');\n    const simpleModel = {\n      getLineCount: () => {\n        return this._context.model.getLineCount();\n      },\n      getLineMaxColumn: lineNumber => {\n        return this._context.model.getLineMaxColumn(lineNumber);\n      },\n      getValueInRange: (range, eol) => {\n        return this._context.model.getValueInRange(range, eol);\n      }\n    };\n    const textAreaInputHost = {\n      getDataToCopy: () => {\n        const rawTextToCopy = this._context.model.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, platform.isWindows);\n\n        const newLineCharacter = this._context.model.getEOL();\n\n        const isFromEmptySelection = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty();\n\n        const multicursorText = Array.isArray(rawTextToCopy) ? rawTextToCopy : null;\n        const text = Array.isArray(rawTextToCopy) ? rawTextToCopy.join(newLineCharacter) : rawTextToCopy;\n        let html = undefined;\n        let mode = null;\n\n        if (CopyOptions.forceCopyWithSyntaxHighlighting || this._copyWithSyntaxHighlighting && text.length < 65536) {\n          const richText = this._context.model.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);\n\n          if (richText) {\n            html = richText.html;\n            mode = richText.mode;\n          }\n        }\n\n        return {\n          isFromEmptySelection,\n          multicursorText,\n          text,\n          html,\n          mode\n        };\n      },\n      getScreenReaderContent: currentState => {\n        if (this._accessibilitySupport === 1\n        /* Disabled */\n        ) {\n          // We know for a fact that a screen reader is not attached\n          // On OSX, we write the character before the cursor to allow for \"long-press\" composition\n          // Also on OSX, we write the word before the cursor to allow for the Accessibility Keyboard to give good hints\n          if (platform.isMacintosh) {\n            const selection = this._selections[0];\n\n            if (selection.isEmpty()) {\n              const position = selection.getStartPosition();\n\n              let textBefore = this._getWordBeforePosition(position);\n\n              if (textBefore.length === 0) {\n                textBefore = this._getCharacterBeforePosition(position);\n              }\n\n              if (textBefore.length > 0) {\n                return new TextAreaState(textBefore, textBefore.length, textBefore.length, position, position);\n              }\n            }\n          }\n\n          return TextAreaState.EMPTY;\n        }\n\n        if (browser.isAndroid) {\n          // when tapping in the editor on a word, Android enters composition mode.\n          // in the `compositionstart` event we cannot clear the textarea, because\n          // it then forgets to ever send a `compositionend`.\n          // we therefore only write the current word in the textarea\n          const selection = this._selections[0];\n\n          if (selection.isEmpty()) {\n            const position = selection.getStartPosition();\n\n            const [wordAtPosition, positionOffsetInWord] = this._getAndroidWordAtPosition(position);\n\n            if (wordAtPosition.length > 0) {\n              return new TextAreaState(wordAtPosition, positionOffsetInWord, positionOffsetInWord, position, position);\n            }\n          }\n\n          return TextAreaState.EMPTY;\n        }\n\n        return PagedScreenReaderStrategy.fromEditorSelection(currentState, simpleModel, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0\n        /* Unknown */\n        );\n      },\n      deduceModelPosition: (viewAnchorPosition, deltaOffset, lineFeedCnt) => {\n        return this._context.model.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt);\n      }\n    };\n\n    const textAreaWrapper = this._register(new TextAreaWrapper(this.textArea.domNode));\n\n    this._textAreaInput = this._register(new TextAreaInput(textAreaInputHost, textAreaWrapper, platform.OS, browser));\n\n    this._register(this._textAreaInput.onKeyDown(e => {\n      this._viewController.emitKeyDown(e);\n    }));\n\n    this._register(this._textAreaInput.onKeyUp(e => {\n      this._viewController.emitKeyUp(e);\n    }));\n\n    this._register(this._textAreaInput.onPaste(e => {\n      let pasteOnNewLine = false;\n      let multicursorText = null;\n      let mode = null;\n\n      if (e.metadata) {\n        pasteOnNewLine = this._emptySelectionClipboard && !!e.metadata.isFromEmptySelection;\n        multicursorText = typeof e.metadata.multicursorText !== 'undefined' ? e.metadata.multicursorText : null;\n        mode = e.metadata.mode;\n      }\n\n      this._viewController.paste(e.text, pasteOnNewLine, multicursorText, mode);\n    }));\n\n    this._register(this._textAreaInput.onCut(() => {\n      this._viewController.cut();\n    }));\n\n    this._register(this._textAreaInput.onType(e => {\n      if (e.replacePrevCharCnt || e.replaceNextCharCnt || e.positionDelta) {\n        // must be handled through the new command\n        if (_debugComposition) {\n          console.log(` => compositionType: <<${e.text}>>, ${e.replacePrevCharCnt}, ${e.replaceNextCharCnt}, ${e.positionDelta}`);\n        }\n\n        this._viewController.compositionType(e.text, e.replacePrevCharCnt, e.replaceNextCharCnt, e.positionDelta);\n      } else {\n        if (_debugComposition) {\n          console.log(` => type: <<${e.text}>>`);\n        }\n\n        this._viewController.type(e.text);\n      }\n    }));\n\n    this._register(this._textAreaInput.onSelectionChangeRequest(modelSelection => {\n      this._viewController.setSelection(modelSelection);\n    }));\n\n    this._register(this._textAreaInput.onCompositionStart(e => {\n      // The textarea might contain some content when composition starts.\n      //\n      // When we make the textarea visible, it always has a height of 1 line,\n      // so we don't need to worry too much about content on lines above or below\n      // the selection.\n      //\n      // However, the text on the current line needs to be made visible because\n      // some IME methods allow to glyphs on the current line (by pressing arrow keys).\n      //\n      // (1) The textarea might contain only some parts of the current line,\n      // like the word before the selection. Also, the content inside the textarea\n      // can grow or shrink as composition occurs. We therefore anchor the textarea\n      // in terms of distance to a certain line start and line end.\n      //\n      // (2) Also, we should not make \\t characters visible, because their rendering\n      // inside the <textarea> will not align nicely with our rendering. We therefore\n      // can hide some of the leading text on the current line.\n      const ta = this.textArea.domNode;\n      const modelSelection = this._modelSelections[0];\n\n      const {\n        distanceToModelLineStart,\n        widthOfHiddenTextBefore\n      } = (() => {\n        // Find the text that is on the current line before the selection\n        const textBeforeSelection = ta.value.substring(0, Math.min(ta.selectionStart, ta.selectionEnd));\n        const lineFeedOffset1 = textBeforeSelection.lastIndexOf('\\n');\n        const lineTextBeforeSelection = textBeforeSelection.substring(lineFeedOffset1 + 1); // We now search to see if we should hide some part of it (if it contains \\t)\n\n        const tabOffset1 = lineTextBeforeSelection.lastIndexOf('\\t');\n        const desiredVisibleBeforeCharCount = lineTextBeforeSelection.length - tabOffset1 - 1;\n        const startModelPosition = modelSelection.getStartPosition();\n        const visibleBeforeCharCount = Math.min(startModelPosition.column - 1, desiredVisibleBeforeCharCount);\n        const distanceToModelLineStart = startModelPosition.column - 1 - visibleBeforeCharCount;\n        const hiddenLineTextBefore = lineTextBeforeSelection.substring(0, lineTextBeforeSelection.length - visibleBeforeCharCount);\n        const widthOfHiddenTextBefore = measureText(hiddenLineTextBefore, this._fontInfo);\n        return {\n          distanceToModelLineStart,\n          widthOfHiddenTextBefore\n        };\n      })();\n\n      const {\n        distanceToModelLineEnd\n      } = (() => {\n        // Find the text that is on the current line after the selection\n        const textAfterSelection = ta.value.substring(Math.max(ta.selectionStart, ta.selectionEnd));\n        const lineFeedOffset2 = textAfterSelection.indexOf('\\n');\n        const lineTextAfterSelection = lineFeedOffset2 === -1 ? textAfterSelection : textAfterSelection.substring(0, lineFeedOffset2);\n        const tabOffset2 = lineTextAfterSelection.indexOf('\\t');\n        const desiredVisibleAfterCharCount = tabOffset2 === -1 ? lineTextAfterSelection.length : lineTextAfterSelection.length - tabOffset2 - 1;\n        const endModelPosition = modelSelection.getEndPosition();\n        const visibleAfterCharCount = Math.min(this._context.model.getModelLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column, desiredVisibleAfterCharCount);\n        const distanceToModelLineEnd = this._context.model.getModelLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column - visibleAfterCharCount;\n        return {\n          distanceToModelLineEnd\n        };\n      })(); // Scroll to reveal the location in the editor\n\n\n      this._context.model.revealRange('keyboard', true, Range.fromPositions(this._selections[0].getStartPosition()), 0\n      /* Simple */\n      , 1\n      /* Immediate */\n      );\n\n      this._visibleTextArea = new VisibleTextAreaData(this._context, modelSelection.startLineNumber, distanceToModelLineStart, widthOfHiddenTextBefore, distanceToModelLineEnd);\n\n      this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n\n      this._render(); // Show the textarea\n\n\n      this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME} ime-input`);\n\n      this._viewController.compositionStart();\n\n      this._context.model.onCompositionStart();\n    }));\n\n    this._register(this._textAreaInput.onCompositionUpdate(e => {\n      if (!this._visibleTextArea) {\n        return;\n      }\n\n      this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n\n      this._render();\n    }));\n\n    this._register(this._textAreaInput.onCompositionEnd(() => {\n      this._visibleTextArea = null;\n\n      this._render();\n\n      this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n\n      this._viewController.compositionEnd();\n\n      this._context.model.onCompositionEnd();\n    }));\n\n    this._register(this._textAreaInput.onFocus(() => {\n      this._context.model.setHasFocus(true);\n    }));\n\n    this._register(this._textAreaInput.onBlur(() => {\n      this._context.model.setHasFocus(false);\n    }));\n  }\n\n  dispose() {\n    super.dispose();\n  }\n\n  _getAndroidWordAtPosition(position) {\n    const ANDROID_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\",.<>/?';\n\n    const lineContent = this._context.model.getLineContent(position.lineNumber);\n\n    const wordSeparators = getMapForWordSeparators(ANDROID_WORD_SEPARATORS);\n    let goingLeft = true;\n    let startColumn = position.column;\n    let goingRight = true;\n    let endColumn = position.column;\n    let distance = 0;\n\n    while (distance < 50 && (goingLeft || goingRight)) {\n      if (goingLeft && startColumn <= 1) {\n        goingLeft = false;\n      }\n\n      if (goingLeft) {\n        const charCode = lineContent.charCodeAt(startColumn - 2);\n        const charClass = wordSeparators.get(charCode);\n\n        if (charClass !== 0\n        /* Regular */\n        ) {\n          goingLeft = false;\n        } else {\n          startColumn--;\n        }\n      }\n\n      if (goingRight && endColumn > lineContent.length) {\n        goingRight = false;\n      }\n\n      if (goingRight) {\n        const charCode = lineContent.charCodeAt(endColumn - 1);\n        const charClass = wordSeparators.get(charCode);\n\n        if (charClass !== 0\n        /* Regular */\n        ) {\n          goingRight = false;\n        } else {\n          endColumn++;\n        }\n      }\n\n      distance++;\n    }\n\n    return [lineContent.substring(startColumn - 1, endColumn - 1), position.column - startColumn];\n  }\n\n  _getWordBeforePosition(position) {\n    const lineContent = this._context.model.getLineContent(position.lineNumber);\n\n    const wordSeparators = getMapForWordSeparators(this._context.configuration.options.get(117\n    /* wordSeparators */\n    ));\n    let column = position.column;\n    let distance = 0;\n\n    while (column > 1) {\n      const charCode = lineContent.charCodeAt(column - 2);\n      const charClass = wordSeparators.get(charCode);\n\n      if (charClass !== 0\n      /* Regular */\n      || distance > 50) {\n        return lineContent.substring(column - 1, position.column - 1);\n      }\n\n      distance++;\n      column--;\n    }\n\n    return lineContent.substring(0, position.column - 1);\n  }\n\n  _getCharacterBeforePosition(position) {\n    if (position.column > 1) {\n      const lineContent = this._context.model.getLineContent(position.lineNumber);\n\n      const charBefore = lineContent.charAt(position.column - 2);\n\n      if (!strings.isHighSurrogate(charBefore.charCodeAt(0))) {\n        return charBefore;\n      }\n    }\n\n    return '';\n  }\n\n  _getAriaLabel(options) {\n    const accessibilitySupport = options.get(2\n    /* accessibilitySupport */\n    );\n\n    if (accessibilitySupport === 1\n    /* Disabled */\n    ) {\n      return nls.localize('accessibilityOffAriaLabel', \"The editor is not accessible at this time. Press {0} for options.\", platform.isLinux ? 'Shift+Alt+F1' : 'Alt+F1');\n    }\n\n    return options.get(4\n    /* ariaLabel */\n    );\n  }\n\n  _setAccessibilityOptions(options) {\n    this._accessibilitySupport = options.get(2\n    /* accessibilitySupport */\n    );\n    const accessibilityPageSize = options.get(3\n    /* accessibilityPageSize */\n    );\n\n    if (this._accessibilitySupport === 2\n    /* Enabled */\n    && accessibilityPageSize === EditorOptions.accessibilityPageSize.defaultValue) {\n      // If a screen reader is attached and the default value is not set we shuold automatically increase the page size to 500 for a better experience\n      this._accessibilityPageSize = 500;\n    } else {\n      this._accessibilityPageSize = accessibilityPageSize;\n    }\n  } // --- begin event handlers\n\n\n  onConfigurationChanged(e) {\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(131\n    /* layoutInfo */\n    );\n\n    this._setAccessibilityOptions(options);\n\n    this._contentLeft = layoutInfo.contentLeft;\n    this._contentWidth = layoutInfo.contentWidth;\n    this._contentHeight = layoutInfo.height;\n    this._fontInfo = options.get(44\n    /* fontInfo */\n    );\n    this._lineHeight = options.get(59\n    /* lineHeight */\n    );\n    this._emptySelectionClipboard = options.get(32\n    /* emptySelectionClipboard */\n    );\n    this._copyWithSyntaxHighlighting = options.get(21\n    /* copyWithSyntaxHighlighting */\n    );\n    this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n    this.textArea.setAttribute('tabindex', String(options.get(112\n    /* tabIndex */\n    )));\n\n    if (e.hasChanged(30\n    /* domReadOnly */\n    ) || e.hasChanged(81\n    /* readOnly */\n    )) {\n      if (options.get(30\n      /* domReadOnly */\n      ) && options.get(81\n      /* readOnly */\n      )) {\n        this.textArea.setAttribute('readonly', 'true');\n      } else {\n        this.textArea.removeAttribute('readonly');\n      }\n    }\n\n    if (e.hasChanged(2\n    /* accessibilitySupport */\n    )) {\n      this._textAreaInput.writeScreenReaderContent('strategy changed');\n    }\n\n    return true;\n  }\n\n  onCursorStateChanged(e) {\n    this._selections = e.selections.slice(0);\n    this._modelSelections = e.modelSelections.slice(0);\n\n    this._textAreaInput.writeScreenReaderContent('selection changed');\n\n    return true;\n  }\n\n  onDecorationsChanged(e) {\n    // true for inline decorations that can end up relayouting text\n    return true;\n  }\n\n  onFlushed(e) {\n    return true;\n  }\n\n  onLinesChanged(e) {\n    return true;\n  }\n\n  onLinesDeleted(e) {\n    return true;\n  }\n\n  onLinesInserted(e) {\n    return true;\n  }\n\n  onScrollChanged(e) {\n    this._scrollLeft = e.scrollLeft;\n    this._scrollTop = e.scrollTop;\n    return true;\n  }\n\n  onZonesChanged(e) {\n    return true;\n  } // --- end event handlers\n  // --- begin view API\n\n\n  isFocused() {\n    return this._textAreaInput.isFocused();\n  }\n\n  focusTextArea() {\n    this._textAreaInput.focusTextArea();\n  }\n\n  getLastRenderData() {\n    return this._lastRenderPosition;\n  }\n\n  setAriaOptions(options) {\n    if (options.activeDescendant) {\n      this.textArea.setAttribute('aria-haspopup', 'true');\n      this.textArea.setAttribute('aria-autocomplete', 'list');\n      this.textArea.setAttribute('aria-activedescendant', options.activeDescendant);\n    } else {\n      this.textArea.setAttribute('aria-haspopup', 'false');\n      this.textArea.setAttribute('aria-autocomplete', 'both');\n      this.textArea.removeAttribute('aria-activedescendant');\n    }\n\n    if (options.role) {\n      this.textArea.setAttribute('role', options.role);\n    }\n  }\n\n  prepareRender(ctx) {\n    this._primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);\n    this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(this._primaryCursorPosition);\n\n    if (this._visibleTextArea) {\n      this._visibleTextArea.prepareRender(ctx);\n    }\n  }\n\n  render(ctx) {\n    this._textAreaInput.writeScreenReaderContent('render');\n\n    this._render();\n  }\n\n  _render() {\n    if (this._visibleTextArea) {\n      // The text area is visible for composition reasons\n      const visibleStart = this._visibleTextArea.visibleTextareaStart;\n      const visibleEnd = this._visibleTextArea.visibleTextareaEnd;\n      const startPosition = this._visibleTextArea.startPosition;\n      const endPosition = this._visibleTextArea.endPosition;\n\n      if (startPosition && endPosition && visibleStart && visibleEnd && visibleEnd.left >= this._scrollLeft && visibleStart.left <= this._scrollLeft + this._contentWidth) {\n        const top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop;\n\n        const lineCount = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n\n        this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n        let scrollLeft = this._visibleTextArea.widthOfHiddenLineTextBefore;\n        let left = this._contentLeft + visibleStart.left - this._scrollLeft;\n        let width = visibleEnd.left - visibleStart.left;\n\n        if (left < this._contentLeft) {\n          // the textarea would be rendered on top of the margin,\n          // so reduce its width. We use the same technique as\n          // for hiding text before\n          const delta = this._contentLeft - left;\n          left += delta;\n          scrollLeft += delta;\n          width -= delta;\n        }\n\n        if (width > this._contentWidth) {\n          // the textarea would be wider than the content width,\n          // so reduce its width.\n          width = this._contentWidth;\n        }\n\n        this.textArea.domNode.scrollLeft = scrollLeft;\n\n        this._renderInsideEditor(null, top, left, width, this._lineHeight); // Try to render the textarea with the color/font style to match the text under it\n\n\n        const viewLineData = this._context.model.getViewLineData(startPosition.lineNumber);\n\n        const startTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(startPosition.column - 1);\n        const endTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(endPosition.column - 1);\n        let presentation;\n\n        if (startTokenIndex === endTokenIndex) {\n          presentation = viewLineData.tokens.getPresentation(startTokenIndex);\n        } else {\n          // if the textarea spans multiple tokens, then use default styles\n          presentation = {\n            foreground: 1\n            /* DefaultForeground */\n            ,\n            italic: false,\n            bold: false,\n            underline: false,\n            strikethrough: false\n          };\n        }\n\n        const color = (TokenizationRegistry.getColorMap() || [])[presentation.foreground];\n        this.textArea.domNode.style.color = color ? Color.Format.CSS.formatHex(color) : 'inherit';\n        this.textArea.domNode.style.fontStyle = presentation.italic ? 'italic' : 'inherit';\n\n        if (presentation.bold) {\n          // fontWeight is also set by `applyFontInfo`, so only overwrite it if necessary\n          this.textArea.domNode.style.fontWeight = 'bold';\n        }\n\n        this.textArea.domNode.style.textDecoration = `${presentation.underline ? ' underline' : ''}${presentation.strikethrough ? ' line-through' : ''}`;\n      }\n\n      return;\n    }\n\n    if (!this._primaryCursorVisibleRange) {\n      // The primary cursor is outside the viewport => place textarea to the top left\n      this._renderAtTopLeft();\n\n      return;\n    }\n\n    const left = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;\n\n    if (left < this._contentLeft || left > this._contentLeft + this._contentWidth) {\n      // cursor is outside the viewport\n      this._renderAtTopLeft();\n\n      return;\n    }\n\n    const top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;\n\n    if (top < 0 || top > this._contentHeight) {\n      // cursor is outside the viewport\n      this._renderAtTopLeft();\n\n      return;\n    } // The primary cursor is in the viewport (at least vertically) => place textarea on the cursor\n\n\n    if (platform.isMacintosh) {\n      // For the popup emoji input, we will make the text area as high as the line height\n      // We will also make the fontSize and lineHeight the correct dimensions to help with the placement of these pickers\n      this._renderInsideEditor(this._primaryCursorPosition, top, left, canUseZeroSizeTextarea ? 0 : 1, this._lineHeight); // In case the textarea contains a word, we're going to try to align the textarea's cursor\n      // with our cursor by scrolling the textarea as much as possible\n\n\n      this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;\n\n      const lineCount = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n\n      this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n      return;\n    }\n\n    this._renderInsideEditor(this._primaryCursorPosition, top, left, canUseZeroSizeTextarea ? 0 : 1, canUseZeroSizeTextarea ? 0 : 1);\n  }\n\n  _newlinecount(text) {\n    let result = 0;\n    let startIndex = -1;\n\n    do {\n      startIndex = text.indexOf('\\n', startIndex + 1);\n\n      if (startIndex === -1) {\n        break;\n      }\n\n      result++;\n    } while (true);\n\n    return result;\n  }\n\n  _renderInsideEditor(renderedPosition, top, left, width, height) {\n    this._lastRenderPosition = renderedPosition;\n    const ta = this.textArea;\n    const tac = this.textAreaCover;\n    applyFontInfo(ta, this._fontInfo);\n    ta.setTop(top);\n    ta.setLeft(left);\n    ta.setWidth(width);\n    ta.setHeight(height);\n    tac.setTop(0);\n    tac.setLeft(0);\n    tac.setWidth(0);\n    tac.setHeight(0);\n  }\n\n  _renderAtTopLeft() {\n    this._lastRenderPosition = null;\n    const ta = this.textArea;\n    const tac = this.textAreaCover;\n    applyFontInfo(ta, this._fontInfo);\n    ta.setTop(0);\n    ta.setLeft(0);\n    tac.setTop(0);\n    tac.setLeft(0);\n\n    if (canUseZeroSizeTextarea) {\n      ta.setWidth(0);\n      ta.setHeight(0);\n      tac.setWidth(0);\n      tac.setHeight(0);\n      return;\n    } // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)\n    // specifically, when doing Korean IME, setting the textarea to 0x0 breaks IME badly.\n\n\n    ta.setWidth(1);\n    ta.setHeight(1);\n    tac.setWidth(1);\n    tac.setHeight(1);\n    const options = this._context.configuration.options;\n\n    if (options.get(50\n    /* glyphMargin */\n    )) {\n      tac.setClassName('monaco-editor-background textAreaCover ' + Margin.OUTER_CLASS_NAME);\n    } else {\n      if (options.get(60\n      /* lineNumbers */\n      ).renderType !== 0\n      /* Off */\n      ) {\n        tac.setClassName('monaco-editor-background textAreaCover ' + LineNumbersOverlay.CLASS_NAME);\n      } else {\n        tac.setClassName('monaco-editor-background textAreaCover');\n      }\n    }\n  }\n\n}\n\nfunction measureText(text, fontInfo) {\n  if (text.length === 0) {\n    return 0;\n  }\n\n  const container = document.createElement('div');\n  container.style.position = 'absolute';\n  container.style.top = '-50000px';\n  container.style.width = '50000px';\n  const regularDomNode = document.createElement('span');\n  applyFontInfo(regularDomNode, fontInfo);\n  regularDomNode.style.whiteSpace = 'pre'; // just like the textarea\n\n  regularDomNode.append(text);\n  container.appendChild(regularDomNode);\n  document.body.appendChild(container);\n  const res = regularDomNode.offsetWidth;\n  document.body.removeChild(container);\n  return res;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaHandler.js"],"names":["nls","browser","createFastDomNode","platform","strings","applyFontInfo","CopyOptions","TextAreaInput","TextAreaWrapper","PagedScreenReaderStrategy","TextAreaState","_debugComposition","PartFingerprints","ViewPart","LineNumbersOverlay","Margin","EditorOptions","getMapForWordSeparators","Position","Range","Selection","MOUSE_CURSOR_TEXT_CSS_CLASS_NAME","TokenizationRegistry","Color","VisibleTextAreaData","constructor","_context","modelLineNumber","distanceToModelLineStart","widthOfHiddenLineTextBefore","distanceToModelLineEnd","_visibleTextAreaBrand","undefined","startPosition","endPosition","visibleTextareaStart","visibleTextareaEnd","prepareRender","visibleRangeProvider","startModelPosition","endModelPosition","model","getModelLineMaxColumn","coordinatesConverter","convertModelPositionToViewPosition","lineNumber","visibleRangeForPosition","canUseZeroSizeTextarea","isFirefox","TextAreaHandler","context","viewController","_primaryCursorPosition","_primaryCursorVisibleRange","_viewController","_visibleRangeProvider","_scrollLeft","_scrollTop","options","configuration","layoutInfo","get","_setAccessibilityOptions","_contentLeft","contentLeft","_contentWidth","contentWidth","_contentHeight","height","_fontInfo","_lineHeight","_emptySelectionClipboard","_copyWithSyntaxHighlighting","_visibleTextArea","_selections","_modelSelections","_lastRenderPosition","textArea","document","createElement","write","setClassName","setAttribute","_getAriaLabel","String","localize","textAreaCover","setPosition","simpleModel","getLineCount","getLineMaxColumn","getValueInRange","range","eol","textAreaInputHost","getDataToCopy","rawTextToCopy","getPlainTextToCopy","isWindows","newLineCharacter","getEOL","isFromEmptySelection","length","isEmpty","multicursorText","Array","isArray","text","join","html","mode","forceCopyWithSyntaxHighlighting","richText","getRichTextToCopy","getScreenReaderContent","currentState","_accessibilitySupport","isMacintosh","selection","position","getStartPosition","textBefore","_getWordBeforePosition","_getCharacterBeforePosition","EMPTY","isAndroid","wordAtPosition","positionOffsetInWord","_getAndroidWordAtPosition","fromEditorSelection","_accessibilityPageSize","deduceModelPosition","viewAnchorPosition","deltaOffset","lineFeedCnt","deduceModelPositionRelativeToViewPosition","textAreaWrapper","_register","domNode","_textAreaInput","OS","onKeyDown","e","emitKeyDown","onKeyUp","emitKeyUp","onPaste","pasteOnNewLine","metadata","paste","onCut","cut","onType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","console","log","compositionType","type","onSelectionChangeRequest","modelSelection","setSelection","onCompositionStart","ta","widthOfHiddenTextBefore","textBeforeSelection","value","substring","Math","min","selectionStart","selectionEnd","lineFeedOffset1","lastIndexOf","lineTextBeforeSelection","tabOffset1","desiredVisibleBeforeCharCount","visibleBeforeCharCount","column","hiddenLineTextBefore","measureText","textAfterSelection","max","lineFeedOffset2","indexOf","lineTextAfterSelection","tabOffset2","desiredVisibleAfterCharCount","getEndPosition","visibleAfterCharCount","revealRange","fromPositions","startLineNumber","_render","compositionStart","onCompositionUpdate","onCompositionEnd","compositionEnd","onFocus","setHasFocus","onBlur","dispose","ANDROID_WORD_SEPARATORS","lineContent","getLineContent","wordSeparators","goingLeft","startColumn","goingRight","endColumn","distance","charCode","charCodeAt","charClass","charBefore","charAt","isHighSurrogate","accessibilitySupport","isLinux","accessibilityPageSize","defaultValue","onConfigurationChanged","hasChanged","removeAttribute","writeScreenReaderContent","onCursorStateChanged","selections","slice","modelSelections","onDecorationsChanged","onFlushed","onLinesChanged","onLinesDeleted","onLinesInserted","onScrollChanged","scrollLeft","scrollTop","onZonesChanged","isFocused","focusTextArea","getLastRenderData","setAriaOptions","activeDescendant","role","ctx","positionLineNumber","positionColumn","render","visibleStart","visibleEnd","left","top","viewLayout","getVerticalOffsetForLineNumber","lineCount","_newlinecount","substr","width","delta","_renderInsideEditor","viewLineData","getViewLineData","startTokenIndex","tokens","findTokenIndexAtOffset","endTokenIndex","presentation","getPresentation","foreground","italic","bold","underline","strikethrough","color","getColorMap","style","Format","CSS","formatHex","fontStyle","fontWeight","textDecoration","_renderAtTopLeft","result","startIndex","renderedPosition","tac","setTop","setLeft","setWidth","setHeight","OUTER_CLASS_NAME","renderType","CLASS_NAME","fontInfo","container","regularDomNode","whiteSpace","append","appendChild","body","res","offsetWidth","removeChild"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './textAreaHandler.css';\nimport * as nls from '../../../nls.js';\nimport * as browser from '../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { CopyOptions, TextAreaInput, TextAreaWrapper } from './textAreaInput.js';\nimport { PagedScreenReaderStrategy, TextAreaState, _debugComposition } from './textAreaState.js';\nimport { PartFingerprints, ViewPart } from '../view/viewPart.js';\nimport { LineNumbersOverlay } from '../viewParts/lineNumbers/lineNumbers.js';\nimport { Margin } from '../viewParts/margin/margin.js';\nimport { EditorOptions } from '../../common/config/editorOptions.js';\nimport { getMapForWordSeparators } from '../../common/core/wordCharacterClassifier.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { TokenizationRegistry } from '../../common/languages.js';\nimport { Color } from '../../../base/common/color.js';\nclass VisibleTextAreaData {\n    constructor(_context, modelLineNumber, distanceToModelLineStart, widthOfHiddenLineTextBefore, distanceToModelLineEnd) {\n        this._context = _context;\n        this.modelLineNumber = modelLineNumber;\n        this.distanceToModelLineStart = distanceToModelLineStart;\n        this.widthOfHiddenLineTextBefore = widthOfHiddenLineTextBefore;\n        this.distanceToModelLineEnd = distanceToModelLineEnd;\n        this._visibleTextAreaBrand = undefined;\n        this.startPosition = null;\n        this.endPosition = null;\n        this.visibleTextareaStart = null;\n        this.visibleTextareaEnd = null;\n    }\n    prepareRender(visibleRangeProvider) {\n        const startModelPosition = new Position(this.modelLineNumber, this.distanceToModelLineStart + 1);\n        const endModelPosition = new Position(this.modelLineNumber, this._context.model.getModelLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);\n        this.startPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(startModelPosition);\n        this.endPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(endModelPosition);\n        if (this.startPosition.lineNumber === this.endPosition.lineNumber) {\n            this.visibleTextareaStart = visibleRangeProvider.visibleRangeForPosition(this.startPosition);\n            this.visibleTextareaEnd = visibleRangeProvider.visibleRangeForPosition(this.endPosition);\n        }\n        else {\n            // TODO: what if the view positions are not on the same line?\n            this.visibleTextareaStart = null;\n            this.visibleTextareaEnd = null;\n        }\n    }\n}\nconst canUseZeroSizeTextarea = (browser.isFirefox);\nexport class TextAreaHandler extends ViewPart {\n    constructor(context, viewController, visibleRangeProvider) {\n        super(context);\n        // --- end view API\n        this._primaryCursorPosition = new Position(1, 1);\n        this._primaryCursorVisibleRange = null;\n        this._viewController = viewController;\n        this._visibleRangeProvider = visibleRangeProvider;\n        this._scrollLeft = 0;\n        this._scrollTop = 0;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(131 /* layoutInfo */);\n        this._setAccessibilityOptions(options);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentHeight = layoutInfo.height;\n        this._fontInfo = options.get(44 /* fontInfo */);\n        this._lineHeight = options.get(59 /* lineHeight */);\n        this._emptySelectionClipboard = options.get(32 /* emptySelectionClipboard */);\n        this._copyWithSyntaxHighlighting = options.get(21 /* copyWithSyntaxHighlighting */);\n        this._visibleTextArea = null;\n        this._selections = [new Selection(1, 1, 1, 1)];\n        this._modelSelections = [new Selection(1, 1, 1, 1)];\n        this._lastRenderPosition = null;\n        // Text Area (The focus will always be in the textarea when the cursor is blinking)\n        this.textArea = createFastDomNode(document.createElement('textarea'));\n        PartFingerprints.write(this.textArea, 6 /* TextArea */);\n        this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n        this.textArea.setAttribute('wrap', 'off');\n        this.textArea.setAttribute('autocorrect', 'off');\n        this.textArea.setAttribute('autocapitalize', 'off');\n        this.textArea.setAttribute('autocomplete', 'off');\n        this.textArea.setAttribute('spellcheck', 'false');\n        this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n        this.textArea.setAttribute('tabindex', String(options.get(112 /* tabIndex */)));\n        this.textArea.setAttribute('role', 'textbox');\n        this.textArea.setAttribute('aria-roledescription', nls.localize('editor', \"editor\"));\n        this.textArea.setAttribute('aria-multiline', 'true');\n        this.textArea.setAttribute('aria-haspopup', 'false');\n        this.textArea.setAttribute('aria-autocomplete', 'both');\n        if (options.get(30 /* domReadOnly */) && options.get(81 /* readOnly */)) {\n            this.textArea.setAttribute('readonly', 'true');\n        }\n        this.textAreaCover = createFastDomNode(document.createElement('div'));\n        this.textAreaCover.setPosition('absolute');\n        const simpleModel = {\n            getLineCount: () => {\n                return this._context.model.getLineCount();\n            },\n            getLineMaxColumn: (lineNumber) => {\n                return this._context.model.getLineMaxColumn(lineNumber);\n            },\n            getValueInRange: (range, eol) => {\n                return this._context.model.getValueInRange(range, eol);\n            }\n        };\n        const textAreaInputHost = {\n            getDataToCopy: () => {\n                const rawTextToCopy = this._context.model.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, platform.isWindows);\n                const newLineCharacter = this._context.model.getEOL();\n                const isFromEmptySelection = (this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty());\n                const multicursorText = (Array.isArray(rawTextToCopy) ? rawTextToCopy : null);\n                const text = (Array.isArray(rawTextToCopy) ? rawTextToCopy.join(newLineCharacter) : rawTextToCopy);\n                let html = undefined;\n                let mode = null;\n                if (CopyOptions.forceCopyWithSyntaxHighlighting || (this._copyWithSyntaxHighlighting && text.length < 65536)) {\n                    const richText = this._context.model.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);\n                    if (richText) {\n                        html = richText.html;\n                        mode = richText.mode;\n                    }\n                }\n                return {\n                    isFromEmptySelection,\n                    multicursorText,\n                    text,\n                    html,\n                    mode\n                };\n            },\n            getScreenReaderContent: (currentState) => {\n                if (this._accessibilitySupport === 1 /* Disabled */) {\n                    // We know for a fact that a screen reader is not attached\n                    // On OSX, we write the character before the cursor to allow for \"long-press\" composition\n                    // Also on OSX, we write the word before the cursor to allow for the Accessibility Keyboard to give good hints\n                    if (platform.isMacintosh) {\n                        const selection = this._selections[0];\n                        if (selection.isEmpty()) {\n                            const position = selection.getStartPosition();\n                            let textBefore = this._getWordBeforePosition(position);\n                            if (textBefore.length === 0) {\n                                textBefore = this._getCharacterBeforePosition(position);\n                            }\n                            if (textBefore.length > 0) {\n                                return new TextAreaState(textBefore, textBefore.length, textBefore.length, position, position);\n                            }\n                        }\n                    }\n                    return TextAreaState.EMPTY;\n                }\n                if (browser.isAndroid) {\n                    // when tapping in the editor on a word, Android enters composition mode.\n                    // in the `compositionstart` event we cannot clear the textarea, because\n                    // it then forgets to ever send a `compositionend`.\n                    // we therefore only write the current word in the textarea\n                    const selection = this._selections[0];\n                    if (selection.isEmpty()) {\n                        const position = selection.getStartPosition();\n                        const [wordAtPosition, positionOffsetInWord] = this._getAndroidWordAtPosition(position);\n                        if (wordAtPosition.length > 0) {\n                            return new TextAreaState(wordAtPosition, positionOffsetInWord, positionOffsetInWord, position, position);\n                        }\n                    }\n                    return TextAreaState.EMPTY;\n                }\n                return PagedScreenReaderStrategy.fromEditorSelection(currentState, simpleModel, this._selections[0], this._accessibilityPageSize, this._accessibilitySupport === 0 /* Unknown */);\n            },\n            deduceModelPosition: (viewAnchorPosition, deltaOffset, lineFeedCnt) => {\n                return this._context.model.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt);\n            }\n        };\n        const textAreaWrapper = this._register(new TextAreaWrapper(this.textArea.domNode));\n        this._textAreaInput = this._register(new TextAreaInput(textAreaInputHost, textAreaWrapper, platform.OS, browser));\n        this._register(this._textAreaInput.onKeyDown((e) => {\n            this._viewController.emitKeyDown(e);\n        }));\n        this._register(this._textAreaInput.onKeyUp((e) => {\n            this._viewController.emitKeyUp(e);\n        }));\n        this._register(this._textAreaInput.onPaste((e) => {\n            let pasteOnNewLine = false;\n            let multicursorText = null;\n            let mode = null;\n            if (e.metadata) {\n                pasteOnNewLine = (this._emptySelectionClipboard && !!e.metadata.isFromEmptySelection);\n                multicursorText = (typeof e.metadata.multicursorText !== 'undefined' ? e.metadata.multicursorText : null);\n                mode = e.metadata.mode;\n            }\n            this._viewController.paste(e.text, pasteOnNewLine, multicursorText, mode);\n        }));\n        this._register(this._textAreaInput.onCut(() => {\n            this._viewController.cut();\n        }));\n        this._register(this._textAreaInput.onType((e) => {\n            if (e.replacePrevCharCnt || e.replaceNextCharCnt || e.positionDelta) {\n                // must be handled through the new command\n                if (_debugComposition) {\n                    console.log(` => compositionType: <<${e.text}>>, ${e.replacePrevCharCnt}, ${e.replaceNextCharCnt}, ${e.positionDelta}`);\n                }\n                this._viewController.compositionType(e.text, e.replacePrevCharCnt, e.replaceNextCharCnt, e.positionDelta);\n            }\n            else {\n                if (_debugComposition) {\n                    console.log(` => type: <<${e.text}>>`);\n                }\n                this._viewController.type(e.text);\n            }\n        }));\n        this._register(this._textAreaInput.onSelectionChangeRequest((modelSelection) => {\n            this._viewController.setSelection(modelSelection);\n        }));\n        this._register(this._textAreaInput.onCompositionStart((e) => {\n            // The textarea might contain some content when composition starts.\n            //\n            // When we make the textarea visible, it always has a height of 1 line,\n            // so we don't need to worry too much about content on lines above or below\n            // the selection.\n            //\n            // However, the text on the current line needs to be made visible because\n            // some IME methods allow to glyphs on the current line (by pressing arrow keys).\n            //\n            // (1) The textarea might contain only some parts of the current line,\n            // like the word before the selection. Also, the content inside the textarea\n            // can grow or shrink as composition occurs. We therefore anchor the textarea\n            // in terms of distance to a certain line start and line end.\n            //\n            // (2) Also, we should not make \\t characters visible, because their rendering\n            // inside the <textarea> will not align nicely with our rendering. We therefore\n            // can hide some of the leading text on the current line.\n            const ta = this.textArea.domNode;\n            const modelSelection = this._modelSelections[0];\n            const { distanceToModelLineStart, widthOfHiddenTextBefore } = (() => {\n                // Find the text that is on the current line before the selection\n                const textBeforeSelection = ta.value.substring(0, Math.min(ta.selectionStart, ta.selectionEnd));\n                const lineFeedOffset1 = textBeforeSelection.lastIndexOf('\\n');\n                const lineTextBeforeSelection = textBeforeSelection.substring(lineFeedOffset1 + 1);\n                // We now search to see if we should hide some part of it (if it contains \\t)\n                const tabOffset1 = lineTextBeforeSelection.lastIndexOf('\\t');\n                const desiredVisibleBeforeCharCount = lineTextBeforeSelection.length - tabOffset1 - 1;\n                const startModelPosition = modelSelection.getStartPosition();\n                const visibleBeforeCharCount = Math.min(startModelPosition.column - 1, desiredVisibleBeforeCharCount);\n                const distanceToModelLineStart = startModelPosition.column - 1 - visibleBeforeCharCount;\n                const hiddenLineTextBefore = lineTextBeforeSelection.substring(0, lineTextBeforeSelection.length - visibleBeforeCharCount);\n                const widthOfHiddenTextBefore = measureText(hiddenLineTextBefore, this._fontInfo);\n                return { distanceToModelLineStart, widthOfHiddenTextBefore };\n            })();\n            const { distanceToModelLineEnd } = (() => {\n                // Find the text that is on the current line after the selection\n                const textAfterSelection = ta.value.substring(Math.max(ta.selectionStart, ta.selectionEnd));\n                const lineFeedOffset2 = textAfterSelection.indexOf('\\n');\n                const lineTextAfterSelection = lineFeedOffset2 === -1 ? textAfterSelection : textAfterSelection.substring(0, lineFeedOffset2);\n                const tabOffset2 = lineTextAfterSelection.indexOf('\\t');\n                const desiredVisibleAfterCharCount = (tabOffset2 === -1 ? lineTextAfterSelection.length : lineTextAfterSelection.length - tabOffset2 - 1);\n                const endModelPosition = modelSelection.getEndPosition();\n                const visibleAfterCharCount = Math.min(this._context.model.getModelLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column, desiredVisibleAfterCharCount);\n                const distanceToModelLineEnd = this._context.model.getModelLineMaxColumn(endModelPosition.lineNumber) - endModelPosition.column - visibleAfterCharCount;\n                return { distanceToModelLineEnd };\n            })();\n            // Scroll to reveal the location in the editor\n            this._context.model.revealRange('keyboard', true, Range.fromPositions(this._selections[0].getStartPosition()), 0 /* Simple */, 1 /* Immediate */);\n            this._visibleTextArea = new VisibleTextAreaData(this._context, modelSelection.startLineNumber, distanceToModelLineStart, widthOfHiddenTextBefore, distanceToModelLineEnd);\n            this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n            this._render();\n            // Show the textarea\n            this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME} ime-input`);\n            this._viewController.compositionStart();\n            this._context.model.onCompositionStart();\n        }));\n        this._register(this._textAreaInput.onCompositionUpdate((e) => {\n            if (!this._visibleTextArea) {\n                return;\n            }\n            this._visibleTextArea.prepareRender(this._visibleRangeProvider);\n            this._render();\n        }));\n        this._register(this._textAreaInput.onCompositionEnd(() => {\n            this._visibleTextArea = null;\n            this._render();\n            this.textArea.setClassName(`inputarea ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n            this._viewController.compositionEnd();\n            this._context.model.onCompositionEnd();\n        }));\n        this._register(this._textAreaInput.onFocus(() => {\n            this._context.model.setHasFocus(true);\n        }));\n        this._register(this._textAreaInput.onBlur(() => {\n            this._context.model.setHasFocus(false);\n        }));\n    }\n    dispose() {\n        super.dispose();\n    }\n    _getAndroidWordAtPosition(position) {\n        const ANDROID_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\",.<>/?';\n        const lineContent = this._context.model.getLineContent(position.lineNumber);\n        const wordSeparators = getMapForWordSeparators(ANDROID_WORD_SEPARATORS);\n        let goingLeft = true;\n        let startColumn = position.column;\n        let goingRight = true;\n        let endColumn = position.column;\n        let distance = 0;\n        while (distance < 50 && (goingLeft || goingRight)) {\n            if (goingLeft && startColumn <= 1) {\n                goingLeft = false;\n            }\n            if (goingLeft) {\n                const charCode = lineContent.charCodeAt(startColumn - 2);\n                const charClass = wordSeparators.get(charCode);\n                if (charClass !== 0 /* Regular */) {\n                    goingLeft = false;\n                }\n                else {\n                    startColumn--;\n                }\n            }\n            if (goingRight && endColumn > lineContent.length) {\n                goingRight = false;\n            }\n            if (goingRight) {\n                const charCode = lineContent.charCodeAt(endColumn - 1);\n                const charClass = wordSeparators.get(charCode);\n                if (charClass !== 0 /* Regular */) {\n                    goingRight = false;\n                }\n                else {\n                    endColumn++;\n                }\n            }\n            distance++;\n        }\n        return [lineContent.substring(startColumn - 1, endColumn - 1), position.column - startColumn];\n    }\n    _getWordBeforePosition(position) {\n        const lineContent = this._context.model.getLineContent(position.lineNumber);\n        const wordSeparators = getMapForWordSeparators(this._context.configuration.options.get(117 /* wordSeparators */));\n        let column = position.column;\n        let distance = 0;\n        while (column > 1) {\n            const charCode = lineContent.charCodeAt(column - 2);\n            const charClass = wordSeparators.get(charCode);\n            if (charClass !== 0 /* Regular */ || distance > 50) {\n                return lineContent.substring(column - 1, position.column - 1);\n            }\n            distance++;\n            column--;\n        }\n        return lineContent.substring(0, position.column - 1);\n    }\n    _getCharacterBeforePosition(position) {\n        if (position.column > 1) {\n            const lineContent = this._context.model.getLineContent(position.lineNumber);\n            const charBefore = lineContent.charAt(position.column - 2);\n            if (!strings.isHighSurrogate(charBefore.charCodeAt(0))) {\n                return charBefore;\n            }\n        }\n        return '';\n    }\n    _getAriaLabel(options) {\n        const accessibilitySupport = options.get(2 /* accessibilitySupport */);\n        if (accessibilitySupport === 1 /* Disabled */) {\n            return nls.localize('accessibilityOffAriaLabel', \"The editor is not accessible at this time. Press {0} for options.\", platform.isLinux ? 'Shift+Alt+F1' : 'Alt+F1');\n        }\n        return options.get(4 /* ariaLabel */);\n    }\n    _setAccessibilityOptions(options) {\n        this._accessibilitySupport = options.get(2 /* accessibilitySupport */);\n        const accessibilityPageSize = options.get(3 /* accessibilityPageSize */);\n        if (this._accessibilitySupport === 2 /* Enabled */ && accessibilityPageSize === EditorOptions.accessibilityPageSize.defaultValue) {\n            // If a screen reader is attached and the default value is not set we shuold automatically increase the page size to 500 for a better experience\n            this._accessibilityPageSize = 500;\n        }\n        else {\n            this._accessibilityPageSize = accessibilityPageSize;\n        }\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(131 /* layoutInfo */);\n        this._setAccessibilityOptions(options);\n        this._contentLeft = layoutInfo.contentLeft;\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentHeight = layoutInfo.height;\n        this._fontInfo = options.get(44 /* fontInfo */);\n        this._lineHeight = options.get(59 /* lineHeight */);\n        this._emptySelectionClipboard = options.get(32 /* emptySelectionClipboard */);\n        this._copyWithSyntaxHighlighting = options.get(21 /* copyWithSyntaxHighlighting */);\n        this.textArea.setAttribute('aria-label', this._getAriaLabel(options));\n        this.textArea.setAttribute('tabindex', String(options.get(112 /* tabIndex */)));\n        if (e.hasChanged(30 /* domReadOnly */) || e.hasChanged(81 /* readOnly */)) {\n            if (options.get(30 /* domReadOnly */) && options.get(81 /* readOnly */)) {\n                this.textArea.setAttribute('readonly', 'true');\n            }\n            else {\n                this.textArea.removeAttribute('readonly');\n            }\n        }\n        if (e.hasChanged(2 /* accessibilitySupport */)) {\n            this._textAreaInput.writeScreenReaderContent('strategy changed');\n        }\n        return true;\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections.slice(0);\n        this._modelSelections = e.modelSelections.slice(0);\n        this._textAreaInput.writeScreenReaderContent('selection changed');\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        this._scrollLeft = e.scrollLeft;\n        this._scrollTop = e.scrollTop;\n        return true;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    // --- begin view API\n    isFocused() {\n        return this._textAreaInput.isFocused();\n    }\n    focusTextArea() {\n        this._textAreaInput.focusTextArea();\n    }\n    getLastRenderData() {\n        return this._lastRenderPosition;\n    }\n    setAriaOptions(options) {\n        if (options.activeDescendant) {\n            this.textArea.setAttribute('aria-haspopup', 'true');\n            this.textArea.setAttribute('aria-autocomplete', 'list');\n            this.textArea.setAttribute('aria-activedescendant', options.activeDescendant);\n        }\n        else {\n            this.textArea.setAttribute('aria-haspopup', 'false');\n            this.textArea.setAttribute('aria-autocomplete', 'both');\n            this.textArea.removeAttribute('aria-activedescendant');\n        }\n        if (options.role) {\n            this.textArea.setAttribute('role', options.role);\n        }\n    }\n    prepareRender(ctx) {\n        this._primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);\n        this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(this._primaryCursorPosition);\n        if (this._visibleTextArea) {\n            this._visibleTextArea.prepareRender(ctx);\n        }\n    }\n    render(ctx) {\n        this._textAreaInput.writeScreenReaderContent('render');\n        this._render();\n    }\n    _render() {\n        if (this._visibleTextArea) {\n            // The text area is visible for composition reasons\n            const visibleStart = this._visibleTextArea.visibleTextareaStart;\n            const visibleEnd = this._visibleTextArea.visibleTextareaEnd;\n            const startPosition = this._visibleTextArea.startPosition;\n            const endPosition = this._visibleTextArea.endPosition;\n            if (startPosition && endPosition && visibleStart && visibleEnd && visibleEnd.left >= this._scrollLeft && visibleStart.left <= this._scrollLeft + this._contentWidth) {\n                const top = (this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop);\n                const lineCount = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n                this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n                let scrollLeft = this._visibleTextArea.widthOfHiddenLineTextBefore;\n                let left = (this._contentLeft + visibleStart.left - this._scrollLeft);\n                let width = visibleEnd.left - visibleStart.left;\n                if (left < this._contentLeft) {\n                    // the textarea would be rendered on top of the margin,\n                    // so reduce its width. We use the same technique as\n                    // for hiding text before\n                    const delta = (this._contentLeft - left);\n                    left += delta;\n                    scrollLeft += delta;\n                    width -= delta;\n                }\n                if (width > this._contentWidth) {\n                    // the textarea would be wider than the content width,\n                    // so reduce its width.\n                    width = this._contentWidth;\n                }\n                this.textArea.domNode.scrollLeft = scrollLeft;\n                this._renderInsideEditor(null, top, left, width, this._lineHeight);\n                // Try to render the textarea with the color/font style to match the text under it\n                const viewLineData = this._context.model.getViewLineData(startPosition.lineNumber);\n                const startTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(startPosition.column - 1);\n                const endTokenIndex = viewLineData.tokens.findTokenIndexAtOffset(endPosition.column - 1);\n                let presentation;\n                if (startTokenIndex === endTokenIndex) {\n                    presentation = viewLineData.tokens.getPresentation(startTokenIndex);\n                }\n                else {\n                    // if the textarea spans multiple tokens, then use default styles\n                    presentation = {\n                        foreground: 1 /* DefaultForeground */,\n                        italic: false,\n                        bold: false,\n                        underline: false,\n                        strikethrough: false,\n                    };\n                }\n                const color = (TokenizationRegistry.getColorMap() || [])[presentation.foreground];\n                this.textArea.domNode.style.color = (color ? Color.Format.CSS.formatHex(color) : 'inherit');\n                this.textArea.domNode.style.fontStyle = (presentation.italic ? 'italic' : 'inherit');\n                if (presentation.bold) {\n                    // fontWeight is also set by `applyFontInfo`, so only overwrite it if necessary\n                    this.textArea.domNode.style.fontWeight = 'bold';\n                }\n                this.textArea.domNode.style.textDecoration = `${presentation.underline ? ' underline' : ''}${presentation.strikethrough ? ' line-through' : ''}`;\n            }\n            return;\n        }\n        if (!this._primaryCursorVisibleRange) {\n            // The primary cursor is outside the viewport => place textarea to the top left\n            this._renderAtTopLeft();\n            return;\n        }\n        const left = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;\n        if (left < this._contentLeft || left > this._contentLeft + this._contentWidth) {\n            // cursor is outside the viewport\n            this._renderAtTopLeft();\n            return;\n        }\n        const top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;\n        if (top < 0 || top > this._contentHeight) {\n            // cursor is outside the viewport\n            this._renderAtTopLeft();\n            return;\n        }\n        // The primary cursor is in the viewport (at least vertically) => place textarea on the cursor\n        if (platform.isMacintosh) {\n            // For the popup emoji input, we will make the text area as high as the line height\n            // We will also make the fontSize and lineHeight the correct dimensions to help with the placement of these pickers\n            this._renderInsideEditor(this._primaryCursorPosition, top, left, canUseZeroSizeTextarea ? 0 : 1, this._lineHeight);\n            // In case the textarea contains a word, we're going to try to align the textarea's cursor\n            // with our cursor by scrolling the textarea as much as possible\n            this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;\n            const lineCount = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));\n            this.textArea.domNode.scrollTop = lineCount * this._lineHeight;\n            return;\n        }\n        this._renderInsideEditor(this._primaryCursorPosition, top, left, canUseZeroSizeTextarea ? 0 : 1, canUseZeroSizeTextarea ? 0 : 1);\n    }\n    _newlinecount(text) {\n        let result = 0;\n        let startIndex = -1;\n        do {\n            startIndex = text.indexOf('\\n', startIndex + 1);\n            if (startIndex === -1) {\n                break;\n            }\n            result++;\n        } while (true);\n        return result;\n    }\n    _renderInsideEditor(renderedPosition, top, left, width, height) {\n        this._lastRenderPosition = renderedPosition;\n        const ta = this.textArea;\n        const tac = this.textAreaCover;\n        applyFontInfo(ta, this._fontInfo);\n        ta.setTop(top);\n        ta.setLeft(left);\n        ta.setWidth(width);\n        ta.setHeight(height);\n        tac.setTop(0);\n        tac.setLeft(0);\n        tac.setWidth(0);\n        tac.setHeight(0);\n    }\n    _renderAtTopLeft() {\n        this._lastRenderPosition = null;\n        const ta = this.textArea;\n        const tac = this.textAreaCover;\n        applyFontInfo(ta, this._fontInfo);\n        ta.setTop(0);\n        ta.setLeft(0);\n        tac.setTop(0);\n        tac.setLeft(0);\n        if (canUseZeroSizeTextarea) {\n            ta.setWidth(0);\n            ta.setHeight(0);\n            tac.setWidth(0);\n            tac.setHeight(0);\n            return;\n        }\n        // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)\n        // specifically, when doing Korean IME, setting the textarea to 0x0 breaks IME badly.\n        ta.setWidth(1);\n        ta.setHeight(1);\n        tac.setWidth(1);\n        tac.setHeight(1);\n        const options = this._context.configuration.options;\n        if (options.get(50 /* glyphMargin */)) {\n            tac.setClassName('monaco-editor-background textAreaCover ' + Margin.OUTER_CLASS_NAME);\n        }\n        else {\n            if (options.get(60 /* lineNumbers */).renderType !== 0 /* Off */) {\n                tac.setClassName('monaco-editor-background textAreaCover ' + LineNumbersOverlay.CLASS_NAME);\n            }\n            else {\n                tac.setClassName('monaco-editor-background textAreaCover');\n            }\n        }\n    }\n}\nfunction measureText(text, fontInfo) {\n    if (text.length === 0) {\n        return 0;\n    }\n    const container = document.createElement('div');\n    container.style.position = 'absolute';\n    container.style.top = '-50000px';\n    container.style.width = '50000px';\n    const regularDomNode = document.createElement('span');\n    applyFontInfo(regularDomNode, fontInfo);\n    regularDomNode.style.whiteSpace = 'pre'; // just like the textarea\n    regularDomNode.append(text);\n    container.appendChild(regularDomNode);\n    document.body.appendChild(container);\n    const res = regularDomNode.offsetWidth;\n    document.body.removeChild(container);\n    return res;\n}\n"]},"metadata":{},"sourceType":"module"}