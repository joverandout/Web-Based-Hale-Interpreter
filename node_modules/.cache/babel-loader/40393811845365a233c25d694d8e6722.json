{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../languages.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n  constructor(length, kind,\n  /**\n   * If this token is an opening bracket, this is the id of the opening bracket.\n   * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n   * Otherwise, it is -1.\n   */\n  bracketId,\n  /**\n   * If this token is an opening bracket, this just contains `bracketId`.\n   * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n   * Otherwise, it is empty.\n   */\n  bracketIds, astNode) {\n    this.length = length;\n    this.kind = kind;\n    this.bracketId = bracketId;\n    this.bracketIds = bracketIds;\n    this.astNode = astNode;\n  }\n\n}\nexport class TextBufferTokenizer {\n  constructor(textModel, bracketTokens) {\n    this.textModel = textModel;\n    this.bracketTokens = bracketTokens;\n    this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n    this._offset = lengthZero;\n    this.didPeek = false;\n    this.peeked = null;\n    this.textBufferLineCount = textModel.getLineCount();\n    this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  get length() {\n    return toLength(this.textBufferLineCount, this.textBufferLastLineLength);\n  }\n\n  skip(length) {\n    this.didPeek = false;\n    this._offset = lengthAdd(this._offset, length);\n    const obj = lengthToObj(this._offset);\n    this.reader.setPosition(obj.lineCount, obj.columnCount);\n  }\n\n  read() {\n    let token;\n\n    if (this.peeked) {\n      this.didPeek = false;\n      token = this.peeked;\n    } else {\n      token = this.reader.read();\n    }\n\n    if (token) {\n      this._offset = lengthAdd(this._offset, token.length);\n    }\n\n    return token;\n  }\n\n  peek() {\n    if (!this.didPeek) {\n      this.peeked = this.reader.read();\n      this.didPeek = true;\n    }\n\n    return this.peeked;\n  }\n\n}\n/**\n * Does not support peek.\n*/\n\nclass NonPeekableTextBufferTokenizer {\n  constructor(textModel, bracketTokens) {\n    this.textModel = textModel;\n    this.bracketTokens = bracketTokens;\n    this.lineIdx = 0;\n    this.line = null;\n    this.lineCharOffset = 0;\n    this.lineTokens = null;\n    this.lineTokenOffset = 0;\n    /** Must be a zero line token. The end of the document cannot be peeked. */\n\n    this.peekedToken = null;\n    this.textBufferLineCount = textModel.getLineCount();\n    this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n  }\n\n  setPosition(lineIdx, column) {\n    // We must not jump into a token!\n    if (lineIdx === this.lineIdx) {\n      this.lineCharOffset = column;\n      this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n    } else {\n      this.lineIdx = lineIdx;\n      this.lineCharOffset = column;\n      this.line = null;\n    }\n\n    this.peekedToken = null;\n  }\n\n  read() {\n    if (this.peekedToken) {\n      const token = this.peekedToken;\n      this.peekedToken = null;\n      this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n      return token;\n    }\n\n    if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength) {\n      // We are after the end\n      return null;\n    }\n\n    if (this.line === null) {\n      this.lineTokens = this.textModel.getLineTokens(this.lineIdx + 1);\n      this.line = this.lineTokens.getLineContent();\n      this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n    }\n\n    const startLineIdx = this.lineIdx;\n    const startLineCharOffset = this.lineCharOffset; // limits the length of text tokens.\n    // If text tokens get too long, incremental updates will be slow\n\n    let lengthHeuristic = 0;\n\n    while (true) {\n      const lineTokens = this.lineTokens;\n      const tokenCount = lineTokens.getCount();\n      let peekedBracketToken = null;\n\n      if (this.lineTokenOffset < tokenCount) {\n        const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n\n        while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n          // Skip tokens that are identical.\n          // Sometimes, (bracket) identifiers are split up into multiple tokens.\n          this.lineTokenOffset++;\n        }\n\n        const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0\n        /* Other */\n        ;\n        const endOffset = lineTokens.getEndOffset(this.lineTokenOffset); // Is there a bracket token next? Only consume text.\n\n        if (isOther && endOffset !== this.lineCharOffset) {\n          const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n          const text = this.line.substring(this.lineCharOffset, endOffset);\n          const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n          const regexp = brackets.regExpGlobal;\n\n          if (regexp) {\n            regexp.lastIndex = 0;\n            const match = regexp.exec(text);\n\n            if (match) {\n              peekedBracketToken = brackets.getToken(match[0]);\n\n              if (peekedBracketToken) {\n                // Consume leading text of the token\n                this.lineCharOffset += match.index;\n              }\n            }\n          }\n        }\n\n        lengthHeuristic += endOffset - this.lineCharOffset;\n\n        if (peekedBracketToken) {\n          // Don't skip the entire token, as a single token could contain multiple brackets.\n          if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n            // There is text before the bracket\n            this.peekedToken = peekedBracketToken;\n            break;\n          } else {\n            // Consume the peeked token\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n            return peekedBracketToken;\n          }\n        } else {\n          // Skip the entire token, as the token contains no brackets at all.\n          this.lineTokenOffset++;\n          this.lineCharOffset = endOffset;\n        }\n      } else {\n        if (this.lineIdx === this.textBufferLineCount - 1) {\n          break;\n        }\n\n        this.lineIdx++;\n        this.lineTokens = this.textModel.getLineTokens(this.lineIdx + 1);\n        this.lineTokenOffset = 0;\n        this.line = this.lineTokens.getLineContent();\n        this.lineCharOffset = 0;\n        lengthHeuristic += 33; // max 1000/33 = 30 lines\n        // This limits the amount of work to recompute min-indentation\n\n        if (lengthHeuristic > 1000) {\n          // only break (automatically) at the end of line.\n          break;\n        }\n      }\n\n      if (lengthHeuristic > 1500) {\n        // Eventually break regardless of the line length so that\n        // very long lines do not cause bad performance.\n        // This effective limits max indentation to 500, as\n        // indentation is not computed across multiple text nodes.\n        break;\n      }\n    } // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n    // unless the line is too long.\n    // Thus, the min indentation of the document is the minimum min indentation of every text node.\n\n\n    const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n    return new Token(length, 0\n    /* Text */\n    , -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n  }\n\n}\n\nexport class FastTokenizer {\n  constructor(text, brackets) {\n    this.text = text;\n    this._offset = lengthZero;\n    this.idx = 0;\n    const regExpStr = brackets.getRegExpStr();\n    const regexp = regExpStr ? new RegExp(brackets.getRegExpStr() + '|\\n', 'g') : null;\n    const tokens = [];\n    let match;\n    let curLineCount = 0;\n    let lastLineBreakOffset = 0;\n    let lastTokenEndOffset = 0;\n    let lastTokenEndLine = 0;\n    const smallTextTokens0Line = new Array();\n\n    for (let i = 0; i < 60; i++) {\n      smallTextTokens0Line.push(new Token(toLength(0, i), 0\n      /* Text */\n      , -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n    }\n\n    const smallTextTokens1Line = new Array();\n\n    for (let i = 0; i < 60; i++) {\n      smallTextTokens1Line.push(new Token(toLength(1, i), 0\n      /* Text */\n      , -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n    }\n\n    if (regexp) {\n      regexp.lastIndex = 0; // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n\n      while ((match = regexp.exec(text)) !== null) {\n        const curOffset = match.index;\n        const value = match[0];\n\n        if (value === '\\n') {\n          curLineCount++;\n          lastLineBreakOffset = curOffset + 1;\n        } else {\n          if (lastTokenEndOffset !== curOffset) {\n            let token;\n\n            if (lastTokenEndLine === curLineCount) {\n              const colCount = curOffset - lastTokenEndOffset;\n\n              if (colCount < smallTextTokens0Line.length) {\n                token = smallTextTokens0Line[colCount];\n              } else {\n                const length = toLength(0, colCount);\n                token = new Token(length, 0\n                /* Text */\n                , -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n              }\n            } else {\n              const lineCount = curLineCount - lastTokenEndLine;\n              const colCount = curOffset - lastLineBreakOffset;\n\n              if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                token = smallTextTokens1Line[colCount];\n              } else {\n                const length = toLength(lineCount, colCount);\n                token = new Token(length, 0\n                /* Text */\n                , -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n              }\n            }\n\n            tokens.push(token);\n          } // value is matched by regexp, so the token must exist\n\n\n          tokens.push(brackets.getToken(value));\n          lastTokenEndOffset = curOffset + value.length;\n          lastTokenEndLine = curLineCount;\n        }\n      }\n    }\n\n    const offset = text.length;\n\n    if (lastTokenEndOffset !== offset) {\n      const length = lastTokenEndLine === curLineCount ? toLength(0, offset - lastTokenEndOffset) : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n      tokens.push(new Token(length, 0\n      /* Text */\n      , -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n    }\n\n    this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n    this.tokens = tokens;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  read() {\n    return this.tokens[this.idx++] || null;\n  }\n\n  peek() {\n    return this.tokens[this.idx] || null;\n  }\n\n  skip(length) {\n    throw new NotSupportedError();\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js"],"names":["NotSupportedError","TokenMetadata","TextAstNode","lengthAdd","lengthDiff","lengthGetColumnCountIfZeroLineCount","lengthToObj","lengthZero","toLength","SmallImmutableSet","Token","constructor","length","kind","bracketId","bracketIds","astNode","TextBufferTokenizer","textModel","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","getLineCount","textBufferLastLineLength","getLineLength","offset","skip","obj","setPosition","lineCount","columnCount","read","token","peek","lineIdx","line","lineCharOffset","lineTokens","lineTokenOffset","peekedToken","column","findTokenIndexAtOffset","getLineTokens","getLineContent","startLineIdx","startLineCharOffset","lengthHeuristic","tokenCount","getCount","peekedBracketToken","tokenMetadata","getMetadata","isOther","getTokenType","endOffset","getEndOffset","languageId","getLanguageId","text","substring","brackets","getSingleLanguageBracketTokens","regexp","regExpGlobal","lastIndex","match","exec","getToken","index","getEmpty","FastTokenizer","idx","regExpStr","getRegExpStr","RegExp","tokens","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","Array","i","push","smallTextTokens1Line","curOffset","value","colCount"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../languages.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* Other */;\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (isOther && endOffset !== this.lineCharOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(brackets.getRegExpStr() + '|\\n', 'g') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = new Array();\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = new Array();\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}