{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { validateConstraints } from '../../../base/common/types.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const ICommandService = createDecorator('commandService');\nexport const CommandsRegistry = new class {\n  constructor() {\n    this._commands = new Map();\n    this._onDidRegisterCommand = new Emitter();\n    this.onDidRegisterCommand = this._onDidRegisterCommand.event;\n  }\n\n  registerCommand(idOrCommand, handler) {\n    if (!idOrCommand) {\n      throw new Error(`invalid command`);\n    }\n\n    if (typeof idOrCommand === 'string') {\n      if (!handler) {\n        throw new Error(`invalid command`);\n      }\n\n      return this.registerCommand({\n        id: idOrCommand,\n        handler\n      });\n    } // add argument validation if rich command metadata is provided\n\n\n    if (idOrCommand.description) {\n      const constraints = [];\n\n      for (let arg of idOrCommand.description.args) {\n        constraints.push(arg.constraint);\n      }\n\n      const actualHandler = idOrCommand.handler;\n\n      idOrCommand.handler = function (accessor, ...args) {\n        validateConstraints(args, constraints);\n        return actualHandler(accessor, ...args);\n      };\n    } // find a place to store the command\n\n\n    const {\n      id\n    } = idOrCommand;\n\n    let commands = this._commands.get(id);\n\n    if (!commands) {\n      commands = new LinkedList();\n\n      this._commands.set(id, commands);\n    }\n\n    let removeFn = commands.unshift(idOrCommand);\n    let ret = toDisposable(() => {\n      removeFn();\n\n      const command = this._commands.get(id);\n\n      if (command === null || command === void 0 ? void 0 : command.isEmpty()) {\n        this._commands.delete(id);\n      }\n    }); // tell the world about this command\n\n    this._onDidRegisterCommand.fire(id);\n\n    return ret;\n  }\n\n  registerCommandAlias(oldId, newId) {\n    return CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(ICommandService).executeCommand(newId, ...args));\n  }\n\n  getCommand(id) {\n    const list = this._commands.get(id);\n\n    if (!list || list.isEmpty()) {\n      return undefined;\n    }\n\n    return Iterable.first(list);\n  }\n\n  getCommands() {\n    const result = new Map();\n\n    for (const key of this._commands.keys()) {\n      const command = this.getCommand(key);\n\n      if (command) {\n        result.set(key, command);\n      }\n    }\n\n    return result;\n  }\n\n}();\nexport const NullCommandService = {\n  _serviceBrand: undefined,\n  onWillExecuteCommand: () => Disposable.None,\n  onDidExecuteCommand: () => Disposable.None,\n\n  executeCommand() {\n    return Promise.resolve(undefined);\n  }\n\n};\nCommandsRegistry.registerCommand('noop', () => {});","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/platform/commands/common/commands.js"],"names":["Emitter","Iterable","Disposable","toDisposable","LinkedList","validateConstraints","createDecorator","ICommandService","CommandsRegistry","constructor","_commands","Map","_onDidRegisterCommand","onDidRegisterCommand","event","registerCommand","idOrCommand","handler","Error","id","description","constraints","arg","args","push","constraint","actualHandler","accessor","commands","get","set","removeFn","unshift","ret","command","isEmpty","delete","fire","registerCommandAlias","oldId","newId","executeCommand","getCommand","list","undefined","first","getCommands","result","key","keys","NullCommandService","_serviceBrand","onWillExecuteCommand","None","onDidExecuteCommand","Promise","resolve"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { validateConstraints } from '../../../base/common/types.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const ICommandService = createDecorator('commandService');\nexport const CommandsRegistry = new class {\n    constructor() {\n        this._commands = new Map();\n        this._onDidRegisterCommand = new Emitter();\n        this.onDidRegisterCommand = this._onDidRegisterCommand.event;\n    }\n    registerCommand(idOrCommand, handler) {\n        if (!idOrCommand) {\n            throw new Error(`invalid command`);\n        }\n        if (typeof idOrCommand === 'string') {\n            if (!handler) {\n                throw new Error(`invalid command`);\n            }\n            return this.registerCommand({ id: idOrCommand, handler });\n        }\n        // add argument validation if rich command metadata is provided\n        if (idOrCommand.description) {\n            const constraints = [];\n            for (let arg of idOrCommand.description.args) {\n                constraints.push(arg.constraint);\n            }\n            const actualHandler = idOrCommand.handler;\n            idOrCommand.handler = function (accessor, ...args) {\n                validateConstraints(args, constraints);\n                return actualHandler(accessor, ...args);\n            };\n        }\n        // find a place to store the command\n        const { id } = idOrCommand;\n        let commands = this._commands.get(id);\n        if (!commands) {\n            commands = new LinkedList();\n            this._commands.set(id, commands);\n        }\n        let removeFn = commands.unshift(idOrCommand);\n        let ret = toDisposable(() => {\n            removeFn();\n            const command = this._commands.get(id);\n            if (command === null || command === void 0 ? void 0 : command.isEmpty()) {\n                this._commands.delete(id);\n            }\n        });\n        // tell the world about this command\n        this._onDidRegisterCommand.fire(id);\n        return ret;\n    }\n    registerCommandAlias(oldId, newId) {\n        return CommandsRegistry.registerCommand(oldId, (accessor, ...args) => accessor.get(ICommandService).executeCommand(newId, ...args));\n    }\n    getCommand(id) {\n        const list = this._commands.get(id);\n        if (!list || list.isEmpty()) {\n            return undefined;\n        }\n        return Iterable.first(list);\n    }\n    getCommands() {\n        const result = new Map();\n        for (const key of this._commands.keys()) {\n            const command = this.getCommand(key);\n            if (command) {\n                result.set(key, command);\n            }\n        }\n        return result;\n    }\n};\nexport const NullCommandService = {\n    _serviceBrand: undefined,\n    onWillExecuteCommand: () => Disposable.None,\n    onDidExecuteCommand: () => Disposable.None,\n    executeCommand() {\n        return Promise.resolve(undefined);\n    }\n};\nCommandsRegistry.registerCommand('noop', () => { });\n"]},"metadata":{},"sourceType":"module"}