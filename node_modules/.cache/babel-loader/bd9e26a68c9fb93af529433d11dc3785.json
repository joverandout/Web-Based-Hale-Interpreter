{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { implies, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\nexport class KeybindingResolver {\n  constructor(defaultKeybindings, overrides, log) {\n    this._log = log;\n    this._defaultKeybindings = defaultKeybindings;\n    this._defaultBoundCommands = new Map();\n\n    for (const defaultKeybinding of defaultKeybindings) {\n      const command = defaultKeybinding.command;\n\n      if (command && command.charAt(0) !== '-') {\n        this._defaultBoundCommands.set(command, true);\n      }\n    }\n\n    this._map = new Map();\n    this._lookupMap = new Map();\n    this._keybindings = KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));\n\n    for (let i = 0, len = this._keybindings.length; i < len; i++) {\n      let k = this._keybindings[i];\n\n      if (k.keypressParts.length === 0) {\n        // unbound\n        continue;\n      }\n\n      if (k.when && k.when.type === 0\n      /* False */\n      ) {\n        // when condition is false\n        continue;\n      } // TODO@chords\n\n\n      this._addKeyPress(k.keypressParts[0], k);\n    }\n  }\n\n  static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, when) {\n    // TODO@chords\n    if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n      return false;\n    } // TODO@chords\n\n\n    if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n      return false;\n    }\n\n    if (when) {\n      if (!defaultKb.when) {\n        return false;\n      }\n\n      if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Looks for rules containing \"-commandId\" and removes them.\n   */\n\n\n  static handleRemovals(rules) {\n    // Do a first pass and construct a hash-map for removals\n    const removals = new Map();\n\n    for (let i = 0, len = rules.length; i < len; i++) {\n      const rule = rules[i];\n\n      if (rule.command && rule.command.charAt(0) === '-') {\n        const command = rule.command.substring(1);\n\n        if (!removals.has(command)) {\n          removals.set(command, [rule]);\n        } else {\n          removals.get(command).push(rule);\n        }\n      }\n    }\n\n    if (removals.size === 0) {\n      // There are no removals\n      return rules;\n    } // Do a second pass and keep only non-removed keybindings\n\n\n    const result = [];\n\n    for (let i = 0, len = rules.length; i < len; i++) {\n      const rule = rules[i];\n\n      if (!rule.command || rule.command.length === 0) {\n        result.push(rule);\n        continue;\n      }\n\n      if (rule.command.charAt(0) === '-') {\n        continue;\n      }\n\n      const commandRemovals = removals.get(rule.command);\n\n      if (!commandRemovals || !rule.isDefault) {\n        result.push(rule);\n        continue;\n      }\n\n      let isRemoved = false;\n\n      for (const commandRemoval of commandRemovals) {\n        // TODO@chords\n        const keypressFirstPart = commandRemoval.keypressParts[0];\n        const keypressChordPart = commandRemoval.keypressParts[1];\n        const when = commandRemoval.when;\n\n        if (this._isTargetedForRemoval(rule, keypressFirstPart, keypressChordPart, when)) {\n          isRemoved = true;\n          break;\n        }\n      }\n\n      if (!isRemoved) {\n        result.push(rule);\n        continue;\n      }\n    }\n\n    return result;\n  }\n\n  _addKeyPress(keypress, item) {\n    const conflicts = this._map.get(keypress);\n\n    if (typeof conflicts === 'undefined') {\n      // There is no conflict so far\n      this._map.set(keypress, [item]);\n\n      this._addToLookupMap(item);\n\n      return;\n    }\n\n    for (let i = conflicts.length - 1; i >= 0; i--) {\n      let conflict = conflicts[i];\n\n      if (conflict.command === item.command) {\n        continue;\n      }\n\n      const conflictIsChord = conflict.keypressParts.length > 1;\n      const itemIsChord = item.keypressParts.length > 1; // TODO@chords\n\n      if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n        // The conflict only shares the chord start with this command\n        continue;\n      }\n\n      if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n        // `item` completely overwrites `conflict`\n        // Remove conflict from the lookupMap\n        this._removeFromLookupMap(conflict);\n      }\n    }\n\n    conflicts.push(item);\n\n    this._addToLookupMap(item);\n  }\n\n  _addToLookupMap(item) {\n    if (!item.command) {\n      return;\n    }\n\n    let arr = this._lookupMap.get(item.command);\n\n    if (typeof arr === 'undefined') {\n      arr = [item];\n\n      this._lookupMap.set(item.command, arr);\n    } else {\n      arr.push(item);\n    }\n  }\n\n  _removeFromLookupMap(item) {\n    if (!item.command) {\n      return;\n    }\n\n    let arr = this._lookupMap.get(item.command);\n\n    if (typeof arr === 'undefined') {\n      return;\n    }\n\n    for (let i = 0, len = arr.length; i < len; i++) {\n      if (arr[i] === item) {\n        arr.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Returns true if it is provable `a` implies `b`.\n   */\n\n\n  static whenIsEntirelyIncluded(a, b) {\n    if (!b || b.type === 1\n    /* True */\n    ) {\n      return true;\n    }\n\n    if (!a || a.type === 1\n    /* True */\n    ) {\n      return false;\n    }\n\n    return implies(a, b);\n  }\n\n  getKeybindings() {\n    return this._keybindings;\n  }\n\n  lookupPrimaryKeybinding(commandId, context) {\n    const items = this._lookupMap.get(commandId);\n\n    if (typeof items === 'undefined' || items.length === 0) {\n      return null;\n    }\n\n    if (items.length === 1) {\n      return items[0];\n    }\n\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n\n      if (context.contextMatchesRules(item.when)) {\n        return item;\n      }\n    }\n\n    return items[items.length - 1];\n  }\n\n  resolve(context, currentChord, keypress) {\n    this._log(`| Resolving ${keypress}${currentChord ? ` chorded from ${currentChord}` : ``}`);\n\n    let lookupMap = null;\n\n    if (currentChord !== null) {\n      // Fetch all chord bindings for `currentChord`\n      const candidates = this._map.get(currentChord);\n\n      if (typeof candidates === 'undefined') {\n        // No chords starting with `currentChord`\n        this._log(`\\\\ No keybinding entries.`);\n\n        return null;\n      }\n\n      lookupMap = [];\n\n      for (let i = 0, len = candidates.length; i < len; i++) {\n        let candidate = candidates[i]; // TODO@chords\n\n        if (candidate.keypressParts[1] === keypress) {\n          lookupMap.push(candidate);\n        }\n      }\n    } else {\n      const candidates = this._map.get(keypress);\n\n      if (typeof candidates === 'undefined') {\n        // No bindings with `keypress`\n        this._log(`\\\\ No keybinding entries.`);\n\n        return null;\n      }\n\n      lookupMap = candidates;\n    }\n\n    let result = this._findCommand(context, lookupMap);\n\n    if (!result) {\n      this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n\n      return null;\n    } // TODO@chords\n\n\n    if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n      this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\n      return {\n        enterChord: true,\n        leaveChord: false,\n        commandId: null,\n        commandArgs: null,\n        bubble: false\n      };\n    }\n\n    this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n\n    return {\n      enterChord: false,\n      leaveChord: result.keypressParts.length > 1,\n      commandId: result.command,\n      commandArgs: result.commandArgs,\n      bubble: result.bubble\n    };\n  }\n\n  _findCommand(context, matches) {\n    for (let i = matches.length - 1; i >= 0; i--) {\n      let k = matches[i];\n\n      if (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n        continue;\n      }\n\n      return k;\n    }\n\n    return null;\n  }\n\n  static _contextMatchesRules(context, rules) {\n    if (!rules) {\n      return true;\n    }\n\n    return rules.evaluate(context);\n  }\n\n}\n\nfunction printWhenExplanation(when) {\n  if (!when) {\n    return `no when condition`;\n  }\n\n  return `${when.serialize()}`;\n}\n\nfunction printSourceExplanation(kb) {\n  return kb.extensionId ? kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}` : kb.isDefault ? `built-in` : `user`;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js"],"names":["implies","expressionsAreEqualWithConstantSubstitution","KeybindingResolver","constructor","defaultKeybindings","overrides","log","_log","_defaultKeybindings","_defaultBoundCommands","Map","defaultKeybinding","command","charAt","set","_map","_lookupMap","_keybindings","handleRemovals","concat","i","len","length","k","keypressParts","when","type","_addKeyPress","_isTargetedForRemoval","defaultKb","keypressFirstPart","keypressChordPart","rules","removals","rule","substring","has","get","push","size","result","commandRemovals","isDefault","isRemoved","commandRemoval","keypress","item","conflicts","_addToLookupMap","conflict","conflictIsChord","itemIsChord","whenIsEntirelyIncluded","_removeFromLookupMap","arr","splice","a","b","getKeybindings","lookupPrimaryKeybinding","commandId","context","items","contextMatchesRules","resolve","currentChord","lookupMap","candidates","candidate","_findCommand","printWhenExplanation","printSourceExplanation","enterChord","leaveChord","commandArgs","bubble","matches","_contextMatchesRules","evaluate","serialize","kb","extensionId","isBuiltinExtension"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,OAAT,EAAkBC,2CAAlB,QAAqE,uCAArE;AACA,OAAO,MAAMC,kBAAN,CAAyB;AAC5BC,EAAAA,WAAW,CAACC,kBAAD,EAAqBC,SAArB,EAAgCC,GAAhC,EAAqC;AAC5C,SAAKC,IAAL,GAAYD,GAAZ;AACA,SAAKE,mBAAL,GAA2BJ,kBAA3B;AACA,SAAKK,qBAAL,GAA6B,IAAIC,GAAJ,EAA7B;;AACA,SAAK,MAAMC,iBAAX,IAAgCP,kBAAhC,EAAoD;AAChD,YAAMQ,OAAO,GAAGD,iBAAiB,CAACC,OAAlC;;AACA,UAAIA,OAAO,IAAIA,OAAO,CAACC,MAAR,CAAe,CAAf,MAAsB,GAArC,EAA0C;AACtC,aAAKJ,qBAAL,CAA2BK,GAA3B,CAA+BF,OAA/B,EAAwC,IAAxC;AACH;AACJ;;AACD,SAAKG,IAAL,GAAY,IAAIL,GAAJ,EAAZ;AACA,SAAKM,UAAL,GAAkB,IAAIN,GAAJ,EAAlB;AACA,SAAKO,YAAL,GAAoBf,kBAAkB,CAACgB,cAAnB,CAAkC,GAAGC,MAAH,CAAUf,kBAAV,EAA8Be,MAA9B,CAAqCd,SAArC,CAAlC,CAApB;;AACA,SAAK,IAAIe,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG,KAAKJ,YAAL,CAAkBK,MAAxC,EAAgDF,CAAC,GAAGC,GAApD,EAAyDD,CAAC,EAA1D,EAA8D;AAC1D,UAAIG,CAAC,GAAG,KAAKN,YAAL,CAAkBG,CAAlB,CAAR;;AACA,UAAIG,CAAC,CAACC,aAAF,CAAgBF,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B;AACA;AACH;;AACD,UAAIC,CAAC,CAACE,IAAF,IAAUF,CAAC,CAACE,IAAF,CAAOC,IAAP,KAAgB;AAAE;AAAhC,QAA6C;AACzC;AACA;AACH,OATyD,CAU1D;;;AACA,WAAKC,YAAL,CAAkBJ,CAAC,CAACC,aAAF,CAAgB,CAAhB,CAAlB,EAAsCD,CAAtC;AACH;AACJ;;AAC2B,SAArBK,qBAAqB,CAACC,SAAD,EAAYC,iBAAZ,EAA+BC,iBAA/B,EAAkDN,IAAlD,EAAwD;AAChF;AACA,QAAIK,iBAAiB,IAAID,SAAS,CAACL,aAAV,CAAwB,CAAxB,MAA+BM,iBAAxD,EAA2E;AACvE,aAAO,KAAP;AACH,KAJ+E,CAKhF;;;AACA,QAAIC,iBAAiB,IAAIF,SAAS,CAACL,aAAV,CAAwB,CAAxB,MAA+BO,iBAAxD,EAA2E;AACvE,aAAO,KAAP;AACH;;AACD,QAAIN,IAAJ,EAAU;AACN,UAAI,CAACI,SAAS,CAACJ,IAAf,EAAqB;AACjB,eAAO,KAAP;AACH;;AACD,UAAI,CAACxB,2CAA2C,CAACwB,IAAD,EAAOI,SAAS,CAACJ,IAAjB,CAAhD,EAAwE;AACpE,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;AACD;AACJ;AACA;;;AACyB,SAAdP,cAAc,CAACc,KAAD,EAAQ;AACzB;AACA,UAAMC,QAAQ,GAAG,IAAIvB,GAAJ,EAAjB;;AACA,SAAK,IAAIU,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGW,KAAK,CAACV,MAA5B,EAAoCF,CAAC,GAAGC,GAAxC,EAA6CD,CAAC,EAA9C,EAAkD;AAC9C,YAAMc,IAAI,GAAGF,KAAK,CAACZ,CAAD,CAAlB;;AACA,UAAIc,IAAI,CAACtB,OAAL,IAAgBsB,IAAI,CAACtB,OAAL,CAAaC,MAAb,CAAoB,CAApB,MAA2B,GAA/C,EAAoD;AAChD,cAAMD,OAAO,GAAGsB,IAAI,CAACtB,OAAL,CAAauB,SAAb,CAAuB,CAAvB,CAAhB;;AACA,YAAI,CAACF,QAAQ,CAACG,GAAT,CAAaxB,OAAb,CAAL,EAA4B;AACxBqB,UAAAA,QAAQ,CAACnB,GAAT,CAAaF,OAAb,EAAsB,CAACsB,IAAD,CAAtB;AACH,SAFD,MAGK;AACDD,UAAAA,QAAQ,CAACI,GAAT,CAAazB,OAAb,EAAsB0B,IAAtB,CAA2BJ,IAA3B;AACH;AACJ;AACJ;;AACD,QAAID,QAAQ,CAACM,IAAT,KAAkB,CAAtB,EAAyB;AACrB;AACA,aAAOP,KAAP;AACH,KAlBwB,CAmBzB;;;AACA,UAAMQ,MAAM,GAAG,EAAf;;AACA,SAAK,IAAIpB,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGW,KAAK,CAACV,MAA5B,EAAoCF,CAAC,GAAGC,GAAxC,EAA6CD,CAAC,EAA9C,EAAkD;AAC9C,YAAMc,IAAI,GAAGF,KAAK,CAACZ,CAAD,CAAlB;;AACA,UAAI,CAACc,IAAI,CAACtB,OAAN,IAAiBsB,IAAI,CAACtB,OAAL,CAAaU,MAAb,KAAwB,CAA7C,EAAgD;AAC5CkB,QAAAA,MAAM,CAACF,IAAP,CAAYJ,IAAZ;AACA;AACH;;AACD,UAAIA,IAAI,CAACtB,OAAL,CAAaC,MAAb,CAAoB,CAApB,MAA2B,GAA/B,EAAoC;AAChC;AACH;;AACD,YAAM4B,eAAe,GAAGR,QAAQ,CAACI,GAAT,CAAaH,IAAI,CAACtB,OAAlB,CAAxB;;AACA,UAAI,CAAC6B,eAAD,IAAoB,CAACP,IAAI,CAACQ,SAA9B,EAAyC;AACrCF,QAAAA,MAAM,CAACF,IAAP,CAAYJ,IAAZ;AACA;AACH;;AACD,UAAIS,SAAS,GAAG,KAAhB;;AACA,WAAK,MAAMC,cAAX,IAA6BH,eAA7B,EAA8C;AAC1C;AACA,cAAMX,iBAAiB,GAAGc,cAAc,CAACpB,aAAf,CAA6B,CAA7B,CAA1B;AACA,cAAMO,iBAAiB,GAAGa,cAAc,CAACpB,aAAf,CAA6B,CAA7B,CAA1B;AACA,cAAMC,IAAI,GAAGmB,cAAc,CAACnB,IAA5B;;AACA,YAAI,KAAKG,qBAAL,CAA2BM,IAA3B,EAAiCJ,iBAAjC,EAAoDC,iBAApD,EAAuEN,IAAvE,CAAJ,EAAkF;AAC9EkB,UAAAA,SAAS,GAAG,IAAZ;AACA;AACH;AACJ;;AACD,UAAI,CAACA,SAAL,EAAgB;AACZH,QAAAA,MAAM,CAACF,IAAP,CAAYJ,IAAZ;AACA;AACH;AACJ;;AACD,WAAOM,MAAP;AACH;;AACDb,EAAAA,YAAY,CAACkB,QAAD,EAAWC,IAAX,EAAiB;AACzB,UAAMC,SAAS,GAAG,KAAKhC,IAAL,CAAUsB,GAAV,CAAcQ,QAAd,CAAlB;;AACA,QAAI,OAAOE,SAAP,KAAqB,WAAzB,EAAsC;AAClC;AACA,WAAKhC,IAAL,CAAUD,GAAV,CAAc+B,QAAd,EAAwB,CAACC,IAAD,CAAxB;;AACA,WAAKE,eAAL,CAAqBF,IAArB;;AACA;AACH;;AACD,SAAK,IAAI1B,CAAC,GAAG2B,SAAS,CAACzB,MAAV,GAAmB,CAAhC,EAAmCF,CAAC,IAAI,CAAxC,EAA2CA,CAAC,EAA5C,EAAgD;AAC5C,UAAI6B,QAAQ,GAAGF,SAAS,CAAC3B,CAAD,CAAxB;;AACA,UAAI6B,QAAQ,CAACrC,OAAT,KAAqBkC,IAAI,CAAClC,OAA9B,EAAuC;AACnC;AACH;;AACD,YAAMsC,eAAe,GAAID,QAAQ,CAACzB,aAAT,CAAuBF,MAAvB,GAAgC,CAAzD;AACA,YAAM6B,WAAW,GAAIL,IAAI,CAACtB,aAAL,CAAmBF,MAAnB,GAA4B,CAAjD,CAN4C,CAO5C;;AACA,UAAI4B,eAAe,IAAIC,WAAnB,IAAkCF,QAAQ,CAACzB,aAAT,CAAuB,CAAvB,MAA8BsB,IAAI,CAACtB,aAAL,CAAmB,CAAnB,CAApE,EAA2F;AACvF;AACA;AACH;;AACD,UAAItB,kBAAkB,CAACkD,sBAAnB,CAA0CH,QAAQ,CAACxB,IAAnD,EAAyDqB,IAAI,CAACrB,IAA9D,CAAJ,EAAyE;AACrE;AACA;AACA,aAAK4B,oBAAL,CAA0BJ,QAA1B;AACH;AACJ;;AACDF,IAAAA,SAAS,CAACT,IAAV,CAAeQ,IAAf;;AACA,SAAKE,eAAL,CAAqBF,IAArB;AACH;;AACDE,EAAAA,eAAe,CAACF,IAAD,EAAO;AAClB,QAAI,CAACA,IAAI,CAAClC,OAAV,EAAmB;AACf;AACH;;AACD,QAAI0C,GAAG,GAAG,KAAKtC,UAAL,CAAgBqB,GAAhB,CAAoBS,IAAI,CAAClC,OAAzB,CAAV;;AACA,QAAI,OAAO0C,GAAP,KAAe,WAAnB,EAAgC;AAC5BA,MAAAA,GAAG,GAAG,CAACR,IAAD,CAAN;;AACA,WAAK9B,UAAL,CAAgBF,GAAhB,CAAoBgC,IAAI,CAAClC,OAAzB,EAAkC0C,GAAlC;AACH,KAHD,MAIK;AACDA,MAAAA,GAAG,CAAChB,IAAJ,CAASQ,IAAT;AACH;AACJ;;AACDO,EAAAA,oBAAoB,CAACP,IAAD,EAAO;AACvB,QAAI,CAACA,IAAI,CAAClC,OAAV,EAAmB;AACf;AACH;;AACD,QAAI0C,GAAG,GAAG,KAAKtC,UAAL,CAAgBqB,GAAhB,CAAoBS,IAAI,CAAClC,OAAzB,CAAV;;AACA,QAAI,OAAO0C,GAAP,KAAe,WAAnB,EAAgC;AAC5B;AACH;;AACD,SAAK,IAAIlC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGiC,GAAG,CAAChC,MAA1B,EAAkCF,CAAC,GAAGC,GAAtC,EAA2CD,CAAC,EAA5C,EAAgD;AAC5C,UAAIkC,GAAG,CAAClC,CAAD,CAAH,KAAW0B,IAAf,EAAqB;AACjBQ,QAAAA,GAAG,CAACC,MAAJ,CAAWnC,CAAX,EAAc,CAAd;AACA;AACH;AACJ;AACJ;AACD;AACJ;AACA;;;AACiC,SAAtBgC,sBAAsB,CAACI,CAAD,EAAIC,CAAJ,EAAO;AAChC,QAAI,CAACA,CAAD,IAAMA,CAAC,CAAC/B,IAAF,KAAW;AAAE;AAAvB,MAAmC;AAC/B,aAAO,IAAP;AACH;;AACD,QAAI,CAAC8B,CAAD,IAAMA,CAAC,CAAC9B,IAAF,KAAW;AAAE;AAAvB,MAAmC;AAC/B,aAAO,KAAP;AACH;;AACD,WAAO1B,OAAO,CAACwD,CAAD,EAAIC,CAAJ,CAAd;AACH;;AACDC,EAAAA,cAAc,GAAG;AACb,WAAO,KAAKzC,YAAZ;AACH;;AACD0C,EAAAA,uBAAuB,CAACC,SAAD,EAAYC,OAAZ,EAAqB;AACxC,UAAMC,KAAK,GAAG,KAAK9C,UAAL,CAAgBqB,GAAhB,CAAoBuB,SAApB,CAAd;;AACA,QAAI,OAAOE,KAAP,KAAiB,WAAjB,IAAgCA,KAAK,CAACxC,MAAN,KAAiB,CAArD,EAAwD;AACpD,aAAO,IAAP;AACH;;AACD,QAAIwC,KAAK,CAACxC,MAAN,KAAiB,CAArB,EAAwB;AACpB,aAAOwC,KAAK,CAAC,CAAD,CAAZ;AACH;;AACD,SAAK,IAAI1C,CAAC,GAAG0C,KAAK,CAACxC,MAAN,GAAe,CAA5B,EAA+BF,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EAA4C;AACxC,YAAM0B,IAAI,GAAGgB,KAAK,CAAC1C,CAAD,CAAlB;;AACA,UAAIyC,OAAO,CAACE,mBAAR,CAA4BjB,IAAI,CAACrB,IAAjC,CAAJ,EAA4C;AACxC,eAAOqB,IAAP;AACH;AACJ;;AACD,WAAOgB,KAAK,CAACA,KAAK,CAACxC,MAAN,GAAe,CAAhB,CAAZ;AACH;;AACD0C,EAAAA,OAAO,CAACH,OAAD,EAAUI,YAAV,EAAwBpB,QAAxB,EAAkC;AACrC,SAAKtC,IAAL,CAAW,eAAcsC,QAAS,GAAEoB,YAAY,GAAI,iBAAgBA,YAAa,EAAjC,GAAsC,EAAE,EAAxF;;AACA,QAAIC,SAAS,GAAG,IAAhB;;AACA,QAAID,YAAY,KAAK,IAArB,EAA2B;AACvB;AACA,YAAME,UAAU,GAAG,KAAKpD,IAAL,CAAUsB,GAAV,CAAc4B,YAAd,CAAnB;;AACA,UAAI,OAAOE,UAAP,KAAsB,WAA1B,EAAuC;AACnC;AACA,aAAK5D,IAAL,CAAW,2BAAX;;AACA,eAAO,IAAP;AACH;;AACD2D,MAAAA,SAAS,GAAG,EAAZ;;AACA,WAAK,IAAI9C,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG8C,UAAU,CAAC7C,MAAjC,EAAyCF,CAAC,GAAGC,GAA7C,EAAkDD,CAAC,EAAnD,EAAuD;AACnD,YAAIgD,SAAS,GAAGD,UAAU,CAAC/C,CAAD,CAA1B,CADmD,CAEnD;;AACA,YAAIgD,SAAS,CAAC5C,aAAV,CAAwB,CAAxB,MAA+BqB,QAAnC,EAA6C;AACzCqB,UAAAA,SAAS,CAAC5B,IAAV,CAAe8B,SAAf;AACH;AACJ;AACJ,KAhBD,MAiBK;AACD,YAAMD,UAAU,GAAG,KAAKpD,IAAL,CAAUsB,GAAV,CAAcQ,QAAd,CAAnB;;AACA,UAAI,OAAOsB,UAAP,KAAsB,WAA1B,EAAuC;AACnC;AACA,aAAK5D,IAAL,CAAW,2BAAX;;AACA,eAAO,IAAP;AACH;;AACD2D,MAAAA,SAAS,GAAGC,UAAZ;AACH;;AACD,QAAI3B,MAAM,GAAG,KAAK6B,YAAL,CAAkBR,OAAlB,EAA2BK,SAA3B,CAAb;;AACA,QAAI,CAAC1B,MAAL,EAAa;AACT,WAAKjC,IAAL,CAAW,WAAU2D,SAAS,CAAC5C,MAAO,2DAAtC;;AACA,aAAO,IAAP;AACH,KAjCoC,CAkCrC;;;AACA,QAAI2C,YAAY,KAAK,IAAjB,IAAyBzB,MAAM,CAAChB,aAAP,CAAqBF,MAArB,GAA8B,CAAvD,IAA4DkB,MAAM,CAAChB,aAAP,CAAqB,CAArB,MAA4B,IAA5F,EAAkG;AAC9F,WAAKjB,IAAL,CAAW,WAAU2D,SAAS,CAAC5C,MAAO,6CAA4CgD,oBAAoB,CAAC9B,MAAM,CAACf,IAAR,CAAc,aAAY8C,sBAAsB,CAAC/B,MAAD,CAAS,GAA/J;;AACA,aAAO;AACHgC,QAAAA,UAAU,EAAE,IADT;AAEHC,QAAAA,UAAU,EAAE,KAFT;AAGHb,QAAAA,SAAS,EAAE,IAHR;AAIHc,QAAAA,WAAW,EAAE,IAJV;AAKHC,QAAAA,MAAM,EAAE;AALL,OAAP;AAOH;;AACD,SAAKpE,IAAL,CAAW,WAAU2D,SAAS,CAAC5C,MAAO,gCAA+BkB,MAAM,CAAC5B,OAAQ,WAAU0D,oBAAoB,CAAC9B,MAAM,CAACf,IAAR,CAAc,aAAY8C,sBAAsB,CAAC/B,MAAD,CAAS,GAA3K;;AACA,WAAO;AACHgC,MAAAA,UAAU,EAAE,KADT;AAEHC,MAAAA,UAAU,EAAEjC,MAAM,CAAChB,aAAP,CAAqBF,MAArB,GAA8B,CAFvC;AAGHsC,MAAAA,SAAS,EAAEpB,MAAM,CAAC5B,OAHf;AAIH8D,MAAAA,WAAW,EAAElC,MAAM,CAACkC,WAJjB;AAKHC,MAAAA,MAAM,EAAEnC,MAAM,CAACmC;AALZ,KAAP;AAOH;;AACDN,EAAAA,YAAY,CAACR,OAAD,EAAUe,OAAV,EAAmB;AAC3B,SAAK,IAAIxD,CAAC,GAAGwD,OAAO,CAACtD,MAAR,GAAiB,CAA9B,EAAiCF,CAAC,IAAI,CAAtC,EAAyCA,CAAC,EAA1C,EAA8C;AAC1C,UAAIG,CAAC,GAAGqD,OAAO,CAACxD,CAAD,CAAf;;AACA,UAAI,CAAClB,kBAAkB,CAAC2E,oBAAnB,CAAwChB,OAAxC,EAAiDtC,CAAC,CAACE,IAAnD,CAAL,EAA+D;AAC3D;AACH;;AACD,aAAOF,CAAP;AACH;;AACD,WAAO,IAAP;AACH;;AAC0B,SAApBsD,oBAAoB,CAAChB,OAAD,EAAU7B,KAAV,EAAiB;AACxC,QAAI,CAACA,KAAL,EAAY;AACR,aAAO,IAAP;AACH;;AACD,WAAOA,KAAK,CAAC8C,QAAN,CAAejB,OAAf,CAAP;AACH;;AApQ2B;;AAsQhC,SAASS,oBAAT,CAA8B7C,IAA9B,EAAoC;AAChC,MAAI,CAACA,IAAL,EAAW;AACP,WAAQ,mBAAR;AACH;;AACD,SAAQ,GAAEA,IAAI,CAACsD,SAAL,EAAiB,EAA3B;AACH;;AACD,SAASR,sBAAT,CAAgCS,EAAhC,EAAoC;AAChC,SAAQA,EAAE,CAACC,WAAH,GACDD,EAAE,CAACE,kBAAH,GAAyB,sBAAqBF,EAAE,CAACC,WAAY,EAA7D,GAAkE,kBAAiBD,EAAE,CAACC,WAAY,EADjG,GAEDD,EAAE,CAACtC,SAAH,GAAgB,UAAhB,GAA6B,MAFpC;AAGH","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { implies, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\nexport class KeybindingResolver {\n    constructor(defaultKeybindings, overrides, log) {\n        this._log = log;\n        this._defaultKeybindings = defaultKeybindings;\n        this._defaultBoundCommands = new Map();\n        for (const defaultKeybinding of defaultKeybindings) {\n            const command = defaultKeybinding.command;\n            if (command && command.charAt(0) !== '-') {\n                this._defaultBoundCommands.set(command, true);\n            }\n        }\n        this._map = new Map();\n        this._lookupMap = new Map();\n        this._keybindings = KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));\n        for (let i = 0, len = this._keybindings.length; i < len; i++) {\n            let k = this._keybindings[i];\n            if (k.keypressParts.length === 0) {\n                // unbound\n                continue;\n            }\n            if (k.when && k.when.type === 0 /* False */) {\n                // when condition is false\n                continue;\n            }\n            // TODO@chords\n            this._addKeyPress(k.keypressParts[0], k);\n        }\n    }\n    static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, when) {\n        // TODO@chords\n        if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n            return false;\n        }\n        // TODO@chords\n        if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n            return false;\n        }\n        if (when) {\n            if (!defaultKb.when) {\n                return false;\n            }\n            if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Looks for rules containing \"-commandId\" and removes them.\n     */\n    static handleRemovals(rules) {\n        // Do a first pass and construct a hash-map for removals\n        const removals = new Map();\n        for (let i = 0, len = rules.length; i < len; i++) {\n            const rule = rules[i];\n            if (rule.command && rule.command.charAt(0) === '-') {\n                const command = rule.command.substring(1);\n                if (!removals.has(command)) {\n                    removals.set(command, [rule]);\n                }\n                else {\n                    removals.get(command).push(rule);\n                }\n            }\n        }\n        if (removals.size === 0) {\n            // There are no removals\n            return rules;\n        }\n        // Do a second pass and keep only non-removed keybindings\n        const result = [];\n        for (let i = 0, len = rules.length; i < len; i++) {\n            const rule = rules[i];\n            if (!rule.command || rule.command.length === 0) {\n                result.push(rule);\n                continue;\n            }\n            if (rule.command.charAt(0) === '-') {\n                continue;\n            }\n            const commandRemovals = removals.get(rule.command);\n            if (!commandRemovals || !rule.isDefault) {\n                result.push(rule);\n                continue;\n            }\n            let isRemoved = false;\n            for (const commandRemoval of commandRemovals) {\n                // TODO@chords\n                const keypressFirstPart = commandRemoval.keypressParts[0];\n                const keypressChordPart = commandRemoval.keypressParts[1];\n                const when = commandRemoval.when;\n                if (this._isTargetedForRemoval(rule, keypressFirstPart, keypressChordPart, when)) {\n                    isRemoved = true;\n                    break;\n                }\n            }\n            if (!isRemoved) {\n                result.push(rule);\n                continue;\n            }\n        }\n        return result;\n    }\n    _addKeyPress(keypress, item) {\n        const conflicts = this._map.get(keypress);\n        if (typeof conflicts === 'undefined') {\n            // There is no conflict so far\n            this._map.set(keypress, [item]);\n            this._addToLookupMap(item);\n            return;\n        }\n        for (let i = conflicts.length - 1; i >= 0; i--) {\n            let conflict = conflicts[i];\n            if (conflict.command === item.command) {\n                continue;\n            }\n            const conflictIsChord = (conflict.keypressParts.length > 1);\n            const itemIsChord = (item.keypressParts.length > 1);\n            // TODO@chords\n            if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n                // The conflict only shares the chord start with this command\n                continue;\n            }\n            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n                // `item` completely overwrites `conflict`\n                // Remove conflict from the lookupMap\n                this._removeFromLookupMap(conflict);\n            }\n        }\n        conflicts.push(item);\n        this._addToLookupMap(item);\n    }\n    _addToLookupMap(item) {\n        if (!item.command) {\n            return;\n        }\n        let arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            arr = [item];\n            this._lookupMap.set(item.command, arr);\n        }\n        else {\n            arr.push(item);\n        }\n    }\n    _removeFromLookupMap(item) {\n        if (!item.command) {\n            return;\n        }\n        let arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            return;\n        }\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i] === item) {\n                arr.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Returns true if it is provable `a` implies `b`.\n     */\n    static whenIsEntirelyIncluded(a, b) {\n        if (!b || b.type === 1 /* True */) {\n            return true;\n        }\n        if (!a || a.type === 1 /* True */) {\n            return false;\n        }\n        return implies(a, b);\n    }\n    getKeybindings() {\n        return this._keybindings;\n    }\n    lookupPrimaryKeybinding(commandId, context) {\n        const items = this._lookupMap.get(commandId);\n        if (typeof items === 'undefined' || items.length === 0) {\n            return null;\n        }\n        if (items.length === 1) {\n            return items[0];\n        }\n        for (let i = items.length - 1; i >= 0; i--) {\n            const item = items[i];\n            if (context.contextMatchesRules(item.when)) {\n                return item;\n            }\n        }\n        return items[items.length - 1];\n    }\n    resolve(context, currentChord, keypress) {\n        this._log(`| Resolving ${keypress}${currentChord ? ` chorded from ${currentChord}` : ``}`);\n        let lookupMap = null;\n        if (currentChord !== null) {\n            // Fetch all chord bindings for `currentChord`\n            const candidates = this._map.get(currentChord);\n            if (typeof candidates === 'undefined') {\n                // No chords starting with `currentChord`\n                this._log(`\\\\ No keybinding entries.`);\n                return null;\n            }\n            lookupMap = [];\n            for (let i = 0, len = candidates.length; i < len; i++) {\n                let candidate = candidates[i];\n                // TODO@chords\n                if (candidate.keypressParts[1] === keypress) {\n                    lookupMap.push(candidate);\n                }\n            }\n        }\n        else {\n            const candidates = this._map.get(keypress);\n            if (typeof candidates === 'undefined') {\n                // No bindings with `keypress`\n                this._log(`\\\\ No keybinding entries.`);\n                return null;\n            }\n            lookupMap = candidates;\n        }\n        let result = this._findCommand(context, lookupMap);\n        if (!result) {\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n            return null;\n        }\n        // TODO@chords\n        if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n            return {\n                enterChord: true,\n                leaveChord: false,\n                commandId: null,\n                commandArgs: null,\n                bubble: false\n            };\n        }\n        this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n        return {\n            enterChord: false,\n            leaveChord: result.keypressParts.length > 1,\n            commandId: result.command,\n            commandArgs: result.commandArgs,\n            bubble: result.bubble\n        };\n    }\n    _findCommand(context, matches) {\n        for (let i = matches.length - 1; i >= 0; i--) {\n            let k = matches[i];\n            if (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n                continue;\n            }\n            return k;\n        }\n        return null;\n    }\n    static _contextMatchesRules(context, rules) {\n        if (!rules) {\n            return true;\n        }\n        return rules.evaluate(context);\n    }\n}\nfunction printWhenExplanation(when) {\n    if (!when) {\n        return `no when condition`;\n    }\n    return `${when.serialize()}`;\n}\nfunction printSourceExplanation(kb) {\n    return (kb.extensionId\n        ? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\n        : (kb.isDefault ? `built-in` : `user`));\n}\n"]},"metadata":{},"sourceType":"module"}