{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CSSIcon } from './codicons.js';\nimport { matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nexport const iconStartMarker = '$(';\nconst iconsRegex = new RegExp(`\\\\$\\\\(${CSSIcon.iconNameExpression}(?:${CSSIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\n\nconst iconNameCharacterRegexp = new RegExp(CSSIcon.iconNameCharacter);\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text) {\n  return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text) {\n  // Need to add an extra \\ for escaping in markdown\n  return text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\nexport function stripIcons(text) {\n  if (text.indexOf(iconStartMarker) === -1) {\n    return text;\n  }\n\n  return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\nexport function parseLabelWithIcons(text) {\n  const firstIconIndex = text.indexOf(iconStartMarker);\n\n  if (firstIconIndex === -1) {\n    return {\n      text\n    }; // return early if the word does not include an icon\n  }\n\n  return doParseLabelWithIcons(text, firstIconIndex);\n}\n\nfunction doParseLabelWithIcons(text, firstIconIndex) {\n  const iconOffsets = [];\n  let textWithoutIcons = '';\n\n  function appendChars(chars) {\n    if (chars) {\n      textWithoutIcons += chars;\n\n      for (const _ of chars) {\n        iconOffsets.push(iconsOffset); // make sure to fill in icon offsets\n      }\n    }\n  }\n\n  let currentIconStart = -1;\n  let currentIconValue = '';\n  let iconsOffset = 0;\n  let char;\n  let nextChar;\n  let offset = firstIconIndex;\n  const length = text.length; // Append all characters until the first icon\n\n  appendChars(text.substr(0, firstIconIndex)); // example: $(file-symlink-file) my cool $(other-icon) entry\n\n  while (offset < length) {\n    char = text[offset];\n    nextChar = text[offset + 1]; // beginning of icon: some value $( <--\n\n    if (char === iconStartMarker[0] && nextChar === iconStartMarker[1]) {\n      currentIconStart = offset; // if we had a previous potential icon value without\n      // the closing ')', it was actually not an icon and\n      // so we have to add it to the actual value\n\n      appendChars(currentIconValue);\n      currentIconValue = iconStartMarker;\n      offset++; // jump over '('\n    } // end of icon: some value $(some-icon) <--\n    else if (char === ')' && currentIconStart !== -1) {\n      const currentIconLength = offset - currentIconStart + 1; // +1 to include the closing ')'\n\n      iconsOffset += currentIconLength;\n      currentIconStart = -1;\n      currentIconValue = '';\n    } // within icon\n    else if (currentIconStart !== -1) {\n      // Make sure this is a real icon name\n      if (iconNameCharacterRegexp.test(char)) {\n        currentIconValue += char;\n      } else {\n        // This is not a real icon, treat it as text\n        appendChars(currentIconValue);\n        currentIconStart = -1;\n        currentIconValue = '';\n      }\n    } // any value outside of icon\n    else {\n      appendChars(char);\n    }\n\n    offset++;\n  } // if we had a previous potential icon value without\n  // the closing ')', it was actually not an icon and\n  // so we have to add it to the actual value\n\n\n  appendChars(currentIconValue);\n  return {\n    text: textWithoutIcons,\n    iconOffsets\n  };\n}\n\nexport function matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = false) {\n  const {\n    text,\n    iconOffsets\n  } = target; // Return early if there are no icon markers in the word to match against\n\n  if (!iconOffsets || iconOffsets.length === 0) {\n    return matchesFuzzy(query, text, enableSeparateSubstringMatching);\n  } // Trim the word to match against because it could have leading\n  // whitespace now if the word started with an icon\n\n\n  const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n  const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length; // match on value without icon\n\n  const matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching); // Map matches back to offsets with icon and trimming\n\n  if (matches) {\n    for (const match of matches) {\n      const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset]\n      /* icon offsets at index */\n      + leadingWhitespaceOffset\n      /* overall leading whitespace offset */\n      ;\n      match.start += iconOffset;\n      match.end += iconOffset;\n    }\n  }\n\n  return matches;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/iconLabels.js"],"names":["CSSIcon","matchesFuzzy","ltrim","iconStartMarker","iconsRegex","RegExp","iconNameExpression","iconModifierExpression","iconNameCharacterRegexp","iconNameCharacter","escapeIconsRegex","source","escapeIcons","text","replace","match","escaped","markdownEscapedIconsRegex","markdownEscapeEscapedIcons","stripIconsRegex","stripIcons","indexOf","preWhitespace","postWhitespace","parseLabelWithIcons","firstIconIndex","doParseLabelWithIcons","iconOffsets","textWithoutIcons","appendChars","chars","_","push","iconsOffset","currentIconStart","currentIconValue","char","nextChar","offset","length","substr","currentIconLength","test","matchesFuzzyIconAware","query","target","enableSeparateSubstringMatching","wordToMatchAgainstWithoutIconsTrimmed","leadingWhitespaceOffset","matches","iconOffset","start","end"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CSSIcon } from './codicons.js';\nimport { matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nexport const iconStartMarker = '$(';\nconst iconsRegex = new RegExp(`\\\\$\\\\(${CSSIcon.iconNameExpression}(?:${CSSIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\nconst iconNameCharacterRegexp = new RegExp(CSSIcon.iconNameCharacter);\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text) {\n    return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text) {\n    // Need to add an extra \\ for escaping in markdown\n    return text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\nexport function stripIcons(text) {\n    if (text.indexOf(iconStartMarker) === -1) {\n        return text;\n    }\n    return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\nexport function parseLabelWithIcons(text) {\n    const firstIconIndex = text.indexOf(iconStartMarker);\n    if (firstIconIndex === -1) {\n        return { text }; // return early if the word does not include an icon\n    }\n    return doParseLabelWithIcons(text, firstIconIndex);\n}\nfunction doParseLabelWithIcons(text, firstIconIndex) {\n    const iconOffsets = [];\n    let textWithoutIcons = '';\n    function appendChars(chars) {\n        if (chars) {\n            textWithoutIcons += chars;\n            for (const _ of chars) {\n                iconOffsets.push(iconsOffset); // make sure to fill in icon offsets\n            }\n        }\n    }\n    let currentIconStart = -1;\n    let currentIconValue = '';\n    let iconsOffset = 0;\n    let char;\n    let nextChar;\n    let offset = firstIconIndex;\n    const length = text.length;\n    // Append all characters until the first icon\n    appendChars(text.substr(0, firstIconIndex));\n    // example: $(file-symlink-file) my cool $(other-icon) entry\n    while (offset < length) {\n        char = text[offset];\n        nextChar = text[offset + 1];\n        // beginning of icon: some value $( <--\n        if (char === iconStartMarker[0] && nextChar === iconStartMarker[1]) {\n            currentIconStart = offset;\n            // if we had a previous potential icon value without\n            // the closing ')', it was actually not an icon and\n            // so we have to add it to the actual value\n            appendChars(currentIconValue);\n            currentIconValue = iconStartMarker;\n            offset++; // jump over '('\n        }\n        // end of icon: some value $(some-icon) <--\n        else if (char === ')' && currentIconStart !== -1) {\n            const currentIconLength = offset - currentIconStart + 1; // +1 to include the closing ')'\n            iconsOffset += currentIconLength;\n            currentIconStart = -1;\n            currentIconValue = '';\n        }\n        // within icon\n        else if (currentIconStart !== -1) {\n            // Make sure this is a real icon name\n            if (iconNameCharacterRegexp.test(char)) {\n                currentIconValue += char;\n            }\n            else {\n                // This is not a real icon, treat it as text\n                appendChars(currentIconValue);\n                currentIconStart = -1;\n                currentIconValue = '';\n            }\n        }\n        // any value outside of icon\n        else {\n            appendChars(char);\n        }\n        offset++;\n    }\n    // if we had a previous potential icon value without\n    // the closing ')', it was actually not an icon and\n    // so we have to add it to the actual value\n    appendChars(currentIconValue);\n    return { text: textWithoutIcons, iconOffsets };\n}\nexport function matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = false) {\n    const { text, iconOffsets } = target;\n    // Return early if there are no icon markers in the word to match against\n    if (!iconOffsets || iconOffsets.length === 0) {\n        return matchesFuzzy(query, text, enableSeparateSubstringMatching);\n    }\n    // Trim the word to match against because it could have leading\n    // whitespace now if the word started with an icon\n    const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n    const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n    // match on value without icon\n    const matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n    // Map matches back to offsets with icon and trimming\n    if (matches) {\n        for (const match of matches) {\n            const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n            match.start += iconOffset;\n            match.end += iconOffset;\n        }\n    }\n    return matches;\n}\n"]},"metadata":{},"sourceType":"module"}