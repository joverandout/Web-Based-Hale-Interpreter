{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\nconst MASK_INDENT = 0xFF000000;\nexport class FoldingRegions {\n  constructor(startIndexes, endIndexes, types) {\n    if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n      throw new Error('invalid startIndexes or endIndexes size');\n    }\n\n    this._startIndexes = startIndexes;\n    this._endIndexes = endIndexes;\n    this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));\n    this._types = types;\n    this._parentsComputed = false;\n  }\n\n  ensureParentIndices() {\n    if (!this._parentsComputed) {\n      this._parentsComputed = true;\n      let parentIndexes = [];\n\n      let isInsideLast = (startLineNumber, endLineNumber) => {\n        let index = parentIndexes[parentIndexes.length - 1];\n        return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n      };\n\n      for (let i = 0, len = this._startIndexes.length; i < len; i++) {\n        let startLineNumber = this._startIndexes[i];\n        let endLineNumber = this._endIndexes[i];\n\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n          throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n        }\n\n        while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n          parentIndexes.pop();\n        }\n\n        let parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n        parentIndexes.push(i);\n        this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n        this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n      }\n    }\n  }\n\n  get length() {\n    return this._startIndexes.length;\n  }\n\n  getStartLineNumber(index) {\n    return this._startIndexes[index] & MAX_LINE_NUMBER;\n  }\n\n  getEndLineNumber(index) {\n    return this._endIndexes[index] & MAX_LINE_NUMBER;\n  }\n\n  getType(index) {\n    return this._types ? this._types[index] : undefined;\n  }\n\n  hasTypes() {\n    return !!this._types;\n  }\n\n  isCollapsed(index) {\n    let arrayIndex = index / 32 | 0;\n    let bit = index % 32;\n    return (this._collapseStates[arrayIndex] & 1 << bit) !== 0;\n  }\n\n  setCollapsed(index, newState) {\n    let arrayIndex = index / 32 | 0;\n    let bit = index % 32;\n    let value = this._collapseStates[arrayIndex];\n\n    if (newState) {\n      this._collapseStates[arrayIndex] = value | 1 << bit;\n    } else {\n      this._collapseStates[arrayIndex] = value & ~(1 << bit);\n    }\n  }\n\n  setCollapsedAllOfType(type, newState) {\n    let hasChanged = false;\n\n    if (this._types) {\n      for (let i = 0; i < this._types.length; i++) {\n        if (this._types[i] === type) {\n          this.setCollapsed(i, newState);\n          hasChanged = true;\n        }\n      }\n    }\n\n    return hasChanged;\n  }\n\n  toRegion(index) {\n    return new FoldingRegion(this, index);\n  }\n\n  getParentIndex(index) {\n    this.ensureParentIndices();\n    let parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n\n    if (parent === MAX_FOLDING_REGIONS) {\n      return -1;\n    }\n\n    return parent;\n  }\n\n  contains(index, line) {\n    return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n  }\n\n  findIndex(line) {\n    let low = 0,\n        high = this._startIndexes.length;\n\n    if (high === 0) {\n      return -1; // no children\n    }\n\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n\n      if (line < this.getStartLineNumber(mid)) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    return low - 1;\n  }\n\n  findRange(line) {\n    let index = this.findIndex(line);\n\n    if (index >= 0) {\n      let endLineNumber = this.getEndLineNumber(index);\n\n      if (endLineNumber >= line) {\n        return index;\n      }\n\n      index = this.getParentIndex(index);\n\n      while (index !== -1) {\n        if (this.contains(index, line)) {\n          return index;\n        }\n\n        index = this.getParentIndex(index);\n      }\n    }\n\n    return -1;\n  }\n\n  toString() {\n    let res = [];\n\n    for (let i = 0; i < this.length; i++) {\n      res[i] = `[${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n    }\n\n    return res.join(', ');\n  }\n\n}\nexport class FoldingRegion {\n  constructor(ranges, index) {\n    this.ranges = ranges;\n    this.index = index;\n  }\n\n  get startLineNumber() {\n    return this.ranges.getStartLineNumber(this.index);\n  }\n\n  get endLineNumber() {\n    return this.ranges.getEndLineNumber(this.index);\n  }\n\n  get regionIndex() {\n    return this.index;\n  }\n\n  get parentIndex() {\n    return this.ranges.getParentIndex(this.index);\n  }\n\n  get isCollapsed() {\n    return this.ranges.isCollapsed(this.index);\n  }\n\n  containedBy(range) {\n    return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n  }\n\n  containsLine(lineNumber) {\n    return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingRanges.js"],"names":["MAX_FOLDING_REGIONS","MAX_LINE_NUMBER","MASK_INDENT","FoldingRegions","constructor","startIndexes","endIndexes","types","length","Error","_startIndexes","_endIndexes","_collapseStates","Uint32Array","Math","ceil","_types","_parentsComputed","ensureParentIndices","parentIndexes","isInsideLast","startLineNumber","endLineNumber","index","getStartLineNumber","getEndLineNumber","i","len","pop","parentIndex","push","getType","undefined","hasTypes","isCollapsed","arrayIndex","bit","setCollapsed","newState","value","setCollapsedAllOfType","type","hasChanged","toRegion","FoldingRegion","getParentIndex","parent","contains","line","findIndex","low","high","mid","floor","findRange","toString","res","join","ranges","regionIndex","containedBy","range","containsLine","lineNumber"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\nconst MASK_INDENT = 0xFF000000;\nexport class FoldingRegions {\n    constructor(startIndexes, endIndexes, types) {\n        if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n            throw new Error('invalid startIndexes or endIndexes size');\n        }\n        this._startIndexes = startIndexes;\n        this._endIndexes = endIndexes;\n        this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));\n        this._types = types;\n        this._parentsComputed = false;\n    }\n    ensureParentIndices() {\n        if (!this._parentsComputed) {\n            this._parentsComputed = true;\n            let parentIndexes = [];\n            let isInsideLast = (startLineNumber, endLineNumber) => {\n                let index = parentIndexes[parentIndexes.length - 1];\n                return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n            };\n            for (let i = 0, len = this._startIndexes.length; i < len; i++) {\n                let startLineNumber = this._startIndexes[i];\n                let endLineNumber = this._endIndexes[i];\n                if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n                    throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n                }\n                while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n                    parentIndexes.pop();\n                }\n                let parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n                parentIndexes.push(i);\n                this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n                this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n            }\n        }\n    }\n    get length() {\n        return this._startIndexes.length;\n    }\n    getStartLineNumber(index) {\n        return this._startIndexes[index] & MAX_LINE_NUMBER;\n    }\n    getEndLineNumber(index) {\n        return this._endIndexes[index] & MAX_LINE_NUMBER;\n    }\n    getType(index) {\n        return this._types ? this._types[index] : undefined;\n    }\n    hasTypes() {\n        return !!this._types;\n    }\n    isCollapsed(index) {\n        let arrayIndex = (index / 32) | 0;\n        let bit = index % 32;\n        return (this._collapseStates[arrayIndex] & (1 << bit)) !== 0;\n    }\n    setCollapsed(index, newState) {\n        let arrayIndex = (index / 32) | 0;\n        let bit = index % 32;\n        let value = this._collapseStates[arrayIndex];\n        if (newState) {\n            this._collapseStates[arrayIndex] = value | (1 << bit);\n        }\n        else {\n            this._collapseStates[arrayIndex] = value & ~(1 << bit);\n        }\n    }\n    setCollapsedAllOfType(type, newState) {\n        let hasChanged = false;\n        if (this._types) {\n            for (let i = 0; i < this._types.length; i++) {\n                if (this._types[i] === type) {\n                    this.setCollapsed(i, newState);\n                    hasChanged = true;\n                }\n            }\n        }\n        return hasChanged;\n    }\n    toRegion(index) {\n        return new FoldingRegion(this, index);\n    }\n    getParentIndex(index) {\n        this.ensureParentIndices();\n        let parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n        if (parent === MAX_FOLDING_REGIONS) {\n            return -1;\n        }\n        return parent;\n    }\n    contains(index, line) {\n        return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n    }\n    findIndex(line) {\n        let low = 0, high = this._startIndexes.length;\n        if (high === 0) {\n            return -1; // no children\n        }\n        while (low < high) {\n            let mid = Math.floor((low + high) / 2);\n            if (line < this.getStartLineNumber(mid)) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low - 1;\n    }\n    findRange(line) {\n        let index = this.findIndex(line);\n        if (index >= 0) {\n            let endLineNumber = this.getEndLineNumber(index);\n            if (endLineNumber >= line) {\n                return index;\n            }\n            index = this.getParentIndex(index);\n            while (index !== -1) {\n                if (this.contains(index, line)) {\n                    return index;\n                }\n                index = this.getParentIndex(index);\n            }\n        }\n        return -1;\n    }\n    toString() {\n        let res = [];\n        for (let i = 0; i < this.length; i++) {\n            res[i] = `[${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n        }\n        return res.join(', ');\n    }\n}\nexport class FoldingRegion {\n    constructor(ranges, index) {\n        this.ranges = ranges;\n        this.index = index;\n    }\n    get startLineNumber() {\n        return this.ranges.getStartLineNumber(this.index);\n    }\n    get endLineNumber() {\n        return this.ranges.getEndLineNumber(this.index);\n    }\n    get regionIndex() {\n        return this.index;\n    }\n    get parentIndex() {\n        return this.ranges.getParentIndex(this.index);\n    }\n    get isCollapsed() {\n        return this.ranges.isCollapsed(this.index);\n    }\n    containedBy(range) {\n        return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n    }\n    containsLine(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}