{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\n\nclass BaseAstNode {\n  constructor(length) {\n    this._length = length;\n  }\n  /**\n   * The length of the entire node, which should equal the sum of lengths of all children.\n  */\n\n\n  get length() {\n    return this._length;\n  }\n\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\n\n\nexport class PairAstNode extends BaseAstNode {\n  constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n    super(length);\n    this.openingBracket = openingBracket;\n    this.child = child;\n    this.closingBracket = closingBracket;\n    this.missingOpeningBracketIds = missingOpeningBracketIds;\n  }\n\n  static create(openingBracket, child, closingBracket) {\n    let length = openingBracket.length;\n\n    if (child) {\n      length = lengthAdd(length, child.length);\n    }\n\n    if (closingBracket) {\n      length = lengthAdd(length, closingBracket.length);\n    }\n\n    return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n  }\n\n  get kind() {\n    return 2\n    /* Pair */\n    ;\n  }\n\n  get listHeight() {\n    return 0;\n  }\n\n  get childrenLength() {\n    return 3;\n  }\n\n  getChild(idx) {\n    switch (idx) {\n      case 0:\n        return this.openingBracket;\n\n      case 1:\n        return this.child;\n\n      case 2:\n        return this.closingBracket;\n    }\n\n    throw new Error('Invalid child index');\n  }\n  /**\n   * Avoid using this property, it allocates an array!\n  */\n\n\n  get children() {\n    const result = new Array();\n    result.push(this.openingBracket);\n\n    if (this.child) {\n      result.push(this.child);\n    }\n\n    if (this.closingBracket) {\n      result.push(this.closingBracket);\n    }\n\n    return result;\n  }\n\n  canBeReused(openBracketIds) {\n    if (this.closingBracket === null) {\n      // Unclosed pair ast nodes only\n      // end at the end of the document\n      // or when a parent node is closed.\n      // This could be improved:\n      // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n      return false;\n    }\n\n    if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  deepClone() {\n    return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n  }\n\n  computeMinIndentation(offset, textModel) {\n    return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n  }\n\n}\nexport class ListAstNode extends BaseAstNode {\n  /**\n   * Use ListAstNode.create.\n  */\n  constructor(length, listHeight, _missingOpeningBracketIds) {\n    super(length);\n    this.listHeight = listHeight;\n    this._missingOpeningBracketIds = _missingOpeningBracketIds;\n    this.cachedMinIndentation = -1;\n  }\n  /**\n   * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n  */\n\n\n  static create23(item1, item2, item3, immutable = false) {\n    let length = item1.length;\n    let missingBracketIds = item1.missingOpeningBracketIds;\n\n    if (item1.listHeight !== item2.listHeight) {\n      throw new Error('Invalid list heights');\n    }\n\n    length = lengthAdd(length, item2.length);\n    missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n\n    if (item3) {\n      if (item1.listHeight !== item3.listHeight) {\n        throw new Error('Invalid list heights');\n      }\n\n      length = lengthAdd(length, item3.length);\n      missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n    }\n\n    return immutable ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds) : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n  }\n\n  static getEmpty() {\n    return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n  }\n\n  get kind() {\n    return 4\n    /* List */\n    ;\n  }\n\n  get missingOpeningBracketIds() {\n    return this._missingOpeningBracketIds;\n  }\n\n  throwIfImmutable() {// NOOP\n  }\n\n  makeLastElementMutable() {\n    this.throwIfImmutable();\n    const childCount = this.childrenLength;\n\n    if (childCount === 0) {\n      return undefined;\n    }\n\n    const lastChild = this.getChild(childCount - 1);\n    const mutable = lastChild.kind === 4\n    /* List */\n    ? lastChild.toMutable() : lastChild;\n\n    if (lastChild !== mutable) {\n      this.setChild(childCount - 1, mutable);\n    }\n\n    return mutable;\n  }\n\n  makeFirstElementMutable() {\n    this.throwIfImmutable();\n    const childCount = this.childrenLength;\n\n    if (childCount === 0) {\n      return undefined;\n    }\n\n    const firstChild = this.getChild(0);\n    const mutable = firstChild.kind === 4\n    /* List */\n    ? firstChild.toMutable() : firstChild;\n\n    if (firstChild !== mutable) {\n      this.setChild(0, mutable);\n    }\n\n    return mutable;\n  }\n\n  canBeReused(openBracketIds) {\n    if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n      return false;\n    }\n\n    let lastChild = this;\n    let lastLength;\n\n    while (lastChild.kind === 4\n    /* List */\n    && (lastLength = lastChild.childrenLength) > 0) {\n      lastChild = lastChild.getChild(lastLength - 1);\n    }\n\n    return lastChild.canBeReused(openBracketIds);\n  }\n\n  handleChildrenChanged() {\n    this.throwIfImmutable();\n    const count = this.childrenLength;\n    let length = this.getChild(0).length;\n    let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n\n    for (let i = 1; i < count; i++) {\n      const child = this.getChild(i);\n      length = lengthAdd(length, child.length);\n      unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n    }\n\n    this._length = length;\n    this._missingOpeningBracketIds = unopenedBrackets;\n    this.cachedMinIndentation = -1;\n  }\n\n  computeMinIndentation(offset, textModel) {\n    if (this.cachedMinIndentation !== -1) {\n      return this.cachedMinIndentation;\n    }\n\n    let minIndentation = Number.MAX_SAFE_INTEGER;\n    let childOffset = offset;\n\n    for (let i = 0; i < this.childrenLength; i++) {\n      const child = this.getChild(i);\n\n      if (child) {\n        minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n        childOffset = lengthAdd(childOffset, child.length);\n      }\n    }\n\n    this.cachedMinIndentation = minIndentation;\n    return minIndentation;\n  }\n\n}\n\nclass TwoThreeListAstNode extends ListAstNode {\n  constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n    super(length, listHeight, missingOpeningBracketIds);\n    this._item1 = _item1;\n    this._item2 = _item2;\n    this._item3 = _item3;\n  }\n\n  get childrenLength() {\n    return this._item3 !== null ? 3 : 2;\n  }\n\n  getChild(idx) {\n    switch (idx) {\n      case 0:\n        return this._item1;\n\n      case 1:\n        return this._item2;\n\n      case 2:\n        return this._item3;\n    }\n\n    throw new Error('Invalid child index');\n  }\n\n  setChild(idx, node) {\n    switch (idx) {\n      case 0:\n        this._item1 = node;\n        return;\n\n      case 1:\n        this._item2 = node;\n        return;\n\n      case 2:\n        this._item3 = node;\n        return;\n    }\n\n    throw new Error('Invalid child index');\n  }\n\n  get children() {\n    return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n  }\n\n  get item1() {\n    return this._item1;\n  }\n\n  get item2() {\n    return this._item2;\n  }\n\n  get item3() {\n    return this._item3;\n  }\n\n  deepClone() {\n    return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n  }\n\n  appendChildOfSameHeight(node) {\n    if (this._item3) {\n      throw new Error('Cannot append to a full (2,3) tree node');\n    }\n\n    this.throwIfImmutable();\n    this._item3 = node;\n    this.handleChildrenChanged();\n  }\n\n  unappendChild() {\n    if (!this._item3) {\n      throw new Error('Cannot remove from a non-full (2,3) tree node');\n    }\n\n    this.throwIfImmutable();\n    const result = this._item3;\n    this._item3 = null;\n    this.handleChildrenChanged();\n    return result;\n  }\n\n  prependChildOfSameHeight(node) {\n    if (this._item3) {\n      throw new Error('Cannot prepend to a full (2,3) tree node');\n    }\n\n    this.throwIfImmutable();\n    this._item3 = this._item2;\n    this._item2 = this._item1;\n    this._item1 = node;\n    this.handleChildrenChanged();\n  }\n\n  unprependChild() {\n    if (!this._item3) {\n      throw new Error('Cannot remove from a non-full (2,3) tree node');\n    }\n\n    this.throwIfImmutable();\n    const result = this._item1;\n    this._item1 = this._item2;\n    this._item2 = this._item3;\n    this._item3 = null;\n    this.handleChildrenChanged();\n    return result;\n  }\n\n  toMutable() {\n    return this;\n  }\n\n}\n/**\n * Immutable, if all children are immutable.\n*/\n\n\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n  toMutable() {\n    return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n  }\n\n  throwIfImmutable() {\n    throw new Error('this instance is immutable');\n  }\n\n}\n/**\n * For debugging.\n*/\n\n\nclass ArrayListAstNode extends ListAstNode {\n  constructor(length, listHeight, _children, missingOpeningBracketIds) {\n    super(length, listHeight, missingOpeningBracketIds);\n    this._children = _children;\n  }\n\n  get childrenLength() {\n    return this._children.length;\n  }\n\n  getChild(idx) {\n    return this._children[idx];\n  }\n\n  setChild(idx, child) {\n    this._children[idx] = child;\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  deepClone() {\n    const children = new Array(this._children.length);\n\n    for (let i = 0; i < this._children.length; i++) {\n      children[i] = this._children[i].deepClone();\n    }\n\n    return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n  }\n\n  appendChildOfSameHeight(node) {\n    this.throwIfImmutable();\n\n    this._children.push(node);\n\n    this.handleChildrenChanged();\n  }\n\n  unappendChild() {\n    this.throwIfImmutable();\n\n    const item = this._children.pop();\n\n    this.handleChildrenChanged();\n    return item;\n  }\n\n  prependChildOfSameHeight(node) {\n    this.throwIfImmutable();\n\n    this._children.unshift(node);\n\n    this.handleChildrenChanged();\n  }\n\n  unprependChild() {\n    this.throwIfImmutable();\n\n    const item = this._children.shift();\n\n    this.handleChildrenChanged();\n    return item;\n  }\n\n  toMutable() {\n    return this;\n  }\n\n}\n/**\n * Immutable, if all children are immutable.\n*/\n\n\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n  toMutable() {\n    return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n  }\n\n  throwIfImmutable() {\n    throw new Error('this instance is immutable');\n  }\n\n}\n\nconst emptyArray = [];\n\nclass ImmutableLeafAstNode extends BaseAstNode {\n  get listHeight() {\n    return 0;\n  }\n\n  get childrenLength() {\n    return 0;\n  }\n\n  getChild(idx) {\n    return null;\n  }\n\n  get children() {\n    return emptyArray;\n  }\n\n  deepClone() {\n    return this;\n  }\n\n}\n\nexport class TextAstNode extends ImmutableLeafAstNode {\n  get kind() {\n    return 0\n    /* Text */\n    ;\n  }\n\n  get missingOpeningBracketIds() {\n    return SmallImmutableSet.getEmpty();\n  }\n\n  canBeReused(_openedBracketIds) {\n    return true;\n  }\n\n  computeMinIndentation(offset, textModel) {\n    const start = lengthToObj(offset); // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n    // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n\n    const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n    const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n    let result = Number.MAX_SAFE_INTEGER;\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n      const lineContent = textModel.getLineContent(lineNumber);\n\n      if (firstNonWsColumn === 0) {\n        continue;\n      }\n\n      const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n      result = Math.min(result, visibleColumn);\n    }\n\n    return result;\n  }\n\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n  constructor(length, languageId,\n  /**\n   * In case of a opening bracket, this is the id of the opening bracket.\n   * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n  */\n  bracketIds) {\n    super(length);\n    this.languageId = languageId;\n    this.bracketIds = bracketIds;\n  }\n\n  static create(length, languageId, bracketIds) {\n    const node = new BracketAstNode(length, languageId, bracketIds);\n    return node;\n  }\n\n  get kind() {\n    return 1\n    /* Bracket */\n    ;\n  }\n\n  get missingOpeningBracketIds() {\n    return SmallImmutableSet.getEmpty();\n  }\n\n  canBeReused(_openedBracketIds) {\n    // These nodes could be reused,\n    // but not in a general way.\n    // Their parent may be reused.\n    return false;\n  }\n\n  computeMinIndentation(offset, textModel) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n  constructor(closingBrackets, length) {\n    super(length);\n    this.missingOpeningBracketIds = closingBrackets;\n  }\n\n  get kind() {\n    return 3\n    /* UnexpectedClosingBracket */\n    ;\n  }\n\n  canBeReused(openedBracketIds) {\n    return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n  }\n\n  computeMinIndentation(offset, textModel) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js"],"names":["CursorColumns","lengthAdd","lengthGetLineCount","lengthToObj","lengthZero","SmallImmutableSet","BaseAstNode","constructor","length","_length","PairAstNode","openingBracket","child","closingBracket","missingOpeningBracketIds","create","getEmpty","kind","listHeight","childrenLength","getChild","idx","Error","children","result","Array","push","canBeReused","openBracketIds","intersects","deepClone","computeMinIndentation","offset","textModel","Number","MAX_SAFE_INTEGER","ListAstNode","_missingOpeningBracketIds","cachedMinIndentation","create23","item1","item2","item3","immutable","missingBracketIds","merge","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","throwIfImmutable","makeLastElementMutable","childCount","undefined","lastChild","mutable","toMutable","setChild","makeFirstElementMutable","firstChild","lastLength","handleChildrenChanged","count","unopenedBrackets","i","minIndentation","childOffset","Math","min","_item1","_item2","_item3","node","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","_children","item","pop","unshift","shift","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","start","startLineNumber","columnCount","lineCount","endLineNumber","lineNumber","firstNonWsColumn","getLineFirstNonWhitespaceColumn","lineContent","getLineContent","visibleColumn","visibleColumnFromColumn","getOptions","tabSize","BracketAstNode","languageId","bracketIds","InvalidBracketAstNode","closingBrackets","openedBracketIds"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,aAAT,QAA8B,gCAA9B;AACA,SAASC,SAAT,EAAoBC,kBAApB,EAAwCC,WAAxC,EAAqDC,UAArD,QAAuE,aAAvE;AACA,SAASC,iBAAT,QAAkC,wBAAlC;AACA;AACA;AACA;;AACA,MAAMC,WAAN,CAAkB;AACdC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,SAAKC,OAAL,GAAeD,MAAf;AACH;AACD;AACJ;AACA;;;AACc,MAANA,MAAM,GAAG;AACT,WAAO,KAAKC,OAAZ;AACH;;AATa;AAWlB;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMC,WAAN,SAA0BJ,WAA1B,CAAsC;AACzCC,EAAAA,WAAW,CAACC,MAAD,EAASG,cAAT,EAAyBC,KAAzB,EAAgCC,cAAhC,EAAgDC,wBAAhD,EAA0E;AACjF,UAAMN,MAAN;AACA,SAAKG,cAAL,GAAsBA,cAAtB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,wBAAL,GAAgCA,wBAAhC;AACH;;AACY,SAANC,MAAM,CAACJ,cAAD,EAAiBC,KAAjB,EAAwBC,cAAxB,EAAwC;AACjD,QAAIL,MAAM,GAAGG,cAAc,CAACH,MAA5B;;AACA,QAAII,KAAJ,EAAW;AACPJ,MAAAA,MAAM,GAAGP,SAAS,CAACO,MAAD,EAASI,KAAK,CAACJ,MAAf,CAAlB;AACH;;AACD,QAAIK,cAAJ,EAAoB;AAChBL,MAAAA,MAAM,GAAGP,SAAS,CAACO,MAAD,EAASK,cAAc,CAACL,MAAxB,CAAlB;AACH;;AACD,WAAO,IAAIE,WAAJ,CAAgBF,MAAhB,EAAwBG,cAAxB,EAAwCC,KAAxC,EAA+CC,cAA/C,EAA+DD,KAAK,GAAGA,KAAK,CAACE,wBAAT,GAAoCT,iBAAiB,CAACW,QAAlB,EAAxG,CAAP;AACH;;AACO,MAAJC,IAAI,GAAG;AACP,WAAO;AAAE;AAAT;AACH;;AACa,MAAVC,UAAU,GAAG;AACb,WAAO,CAAP;AACH;;AACiB,MAAdC,cAAc,GAAG;AACjB,WAAO,CAAP;AACH;;AACDC,EAAAA,QAAQ,CAACC,GAAD,EAAM;AACV,YAAQA,GAAR;AACI,WAAK,CAAL;AAAQ,eAAO,KAAKV,cAAZ;;AACR,WAAK,CAAL;AAAQ,eAAO,KAAKC,KAAZ;;AACR,WAAK,CAAL;AAAQ,eAAO,KAAKC,cAAZ;AAHZ;;AAKA,UAAM,IAAIS,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD;AACJ;AACA;;;AACgB,MAARC,QAAQ,GAAG;AACX,UAAMC,MAAM,GAAG,IAAIC,KAAJ,EAAf;AACAD,IAAAA,MAAM,CAACE,IAAP,CAAY,KAAKf,cAAjB;;AACA,QAAI,KAAKC,KAAT,EAAgB;AACZY,MAAAA,MAAM,CAACE,IAAP,CAAY,KAAKd,KAAjB;AACH;;AACD,QAAI,KAAKC,cAAT,EAAyB;AACrBW,MAAAA,MAAM,CAACE,IAAP,CAAY,KAAKb,cAAjB;AACH;;AACD,WAAOW,MAAP;AACH;;AACDG,EAAAA,WAAW,CAACC,cAAD,EAAiB;AACxB,QAAI,KAAKf,cAAL,KAAwB,IAA5B,EAAkC;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAO,KAAP;AACH;;AACD,QAAIe,cAAc,CAACC,UAAf,CAA0B,KAAKf,wBAA/B,CAAJ,EAA8D;AAC1D,aAAO,KAAP;AACH;;AACD,WAAO,IAAP;AACH;;AACDgB,EAAAA,SAAS,GAAG;AACR,WAAO,IAAIpB,WAAJ,CAAgB,KAAKF,MAArB,EAA6B,KAAKG,cAAL,CAAoBmB,SAApB,EAA7B,EAA8D,KAAKlB,KAAL,IAAc,KAAKA,KAAL,CAAWkB,SAAX,EAA5E,EAAoG,KAAKjB,cAAL,IAAuB,KAAKA,cAAL,CAAoBiB,SAApB,EAA3H,EAA4J,KAAKhB,wBAAjK,CAAP;AACH;;AACDiB,EAAAA,qBAAqB,CAACC,MAAD,EAASC,SAAT,EAAoB;AACrC,WAAO,KAAKrB,KAAL,GAAa,KAAKA,KAAL,CAAWmB,qBAAX,CAAiC9B,SAAS,CAAC+B,MAAD,EAAS,KAAKrB,cAAL,CAAoBH,MAA7B,CAA1C,EAAgFyB,SAAhF,CAAb,GAA0GC,MAAM,CAACC,gBAAxH;AACH;;AApEwC;AAsE7C,OAAO,MAAMC,WAAN,SAA0B9B,WAA1B,CAAsC;AACzC;AACJ;AACA;AACIC,EAAAA,WAAW,CAACC,MAAD,EAASU,UAAT,EAAqBmB,yBAArB,EAAgD;AACvD,UAAM7B,MAAN;AACA,SAAKU,UAAL,GAAkBA,UAAlB;AACA,SAAKmB,yBAAL,GAAiCA,yBAAjC;AACA,SAAKC,oBAAL,GAA4B,CAAC,CAA7B;AACH;AACD;AACJ;AACA;;;AACmB,SAARC,QAAQ,CAACC,KAAD,EAAQC,KAAR,EAAeC,KAAf,EAAsBC,SAAS,GAAG,KAAlC,EAAyC;AACpD,QAAInC,MAAM,GAAGgC,KAAK,CAAChC,MAAnB;AACA,QAAIoC,iBAAiB,GAAGJ,KAAK,CAAC1B,wBAA9B;;AACA,QAAI0B,KAAK,CAACtB,UAAN,KAAqBuB,KAAK,CAACvB,UAA/B,EAA2C;AACvC,YAAM,IAAII,KAAJ,CAAU,sBAAV,CAAN;AACH;;AACDd,IAAAA,MAAM,GAAGP,SAAS,CAACO,MAAD,EAASiC,KAAK,CAACjC,MAAf,CAAlB;AACAoC,IAAAA,iBAAiB,GAAGA,iBAAiB,CAACC,KAAlB,CAAwBJ,KAAK,CAAC3B,wBAA9B,CAApB;;AACA,QAAI4B,KAAJ,EAAW;AACP,UAAIF,KAAK,CAACtB,UAAN,KAAqBwB,KAAK,CAACxB,UAA/B,EAA2C;AACvC,cAAM,IAAII,KAAJ,CAAU,sBAAV,CAAN;AACH;;AACDd,MAAAA,MAAM,GAAGP,SAAS,CAACO,MAAD,EAASkC,KAAK,CAAClC,MAAf,CAAlB;AACAoC,MAAAA,iBAAiB,GAAGA,iBAAiB,CAACC,KAAlB,CAAwBH,KAAK,CAAC5B,wBAA9B,CAApB;AACH;;AACD,WAAO6B,SAAS,GACV,IAAIG,sBAAJ,CAA2BtC,MAA3B,EAAmCgC,KAAK,CAACtB,UAAN,GAAmB,CAAtD,EAAyDsB,KAAzD,EAAgEC,KAAhE,EAAuEC,KAAvE,EAA8EE,iBAA9E,CADU,GAEV,IAAIG,mBAAJ,CAAwBvC,MAAxB,EAAgCgC,KAAK,CAACtB,UAAN,GAAmB,CAAnD,EAAsDsB,KAAtD,EAA6DC,KAA7D,EAAoEC,KAApE,EAA2EE,iBAA3E,CAFN;AAGH;;AACc,SAAR5B,QAAQ,GAAG;AACd,WAAO,IAAIgC,yBAAJ,CAA8B5C,UAA9B,EAA0C,CAA1C,EAA6C,EAA7C,EAAiDC,iBAAiB,CAACW,QAAlB,EAAjD,CAAP;AACH;;AACO,MAAJC,IAAI,GAAG;AACP,WAAO;AAAE;AAAT;AACH;;AAC2B,MAAxBH,wBAAwB,GAAG;AAC3B,WAAO,KAAKuB,yBAAZ;AACH;;AACDY,EAAAA,gBAAgB,GAAG,CACf;AACH;;AACDC,EAAAA,sBAAsB,GAAG;AACrB,SAAKD,gBAAL;AACA,UAAME,UAAU,GAAG,KAAKhC,cAAxB;;AACA,QAAIgC,UAAU,KAAK,CAAnB,EAAsB;AAClB,aAAOC,SAAP;AACH;;AACD,UAAMC,SAAS,GAAG,KAAKjC,QAAL,CAAc+B,UAAU,GAAG,CAA3B,CAAlB;AACA,UAAMG,OAAO,GAAGD,SAAS,CAACpC,IAAV,KAAmB;AAAE;AAArB,MAAkCoC,SAAS,CAACE,SAAV,EAAlC,GAA0DF,SAA1E;;AACA,QAAIA,SAAS,KAAKC,OAAlB,EAA2B;AACvB,WAAKE,QAAL,CAAcL,UAAU,GAAG,CAA3B,EAA8BG,OAA9B;AACH;;AACD,WAAOA,OAAP;AACH;;AACDG,EAAAA,uBAAuB,GAAG;AACtB,SAAKR,gBAAL;AACA,UAAME,UAAU,GAAG,KAAKhC,cAAxB;;AACA,QAAIgC,UAAU,KAAK,CAAnB,EAAsB;AAClB,aAAOC,SAAP;AACH;;AACD,UAAMM,UAAU,GAAG,KAAKtC,QAAL,CAAc,CAAd,CAAnB;AACA,UAAMkC,OAAO,GAAGI,UAAU,CAACzC,IAAX,KAAoB;AAAE;AAAtB,MAAmCyC,UAAU,CAACH,SAAX,EAAnC,GAA4DG,UAA5E;;AACA,QAAIA,UAAU,KAAKJ,OAAnB,EAA4B;AACxB,WAAKE,QAAL,CAAc,CAAd,EAAiBF,OAAjB;AACH;;AACD,WAAOA,OAAP;AACH;;AACD3B,EAAAA,WAAW,CAACC,cAAD,EAAiB;AACxB,QAAIA,cAAc,CAACC,UAAf,CAA0B,KAAKf,wBAA/B,CAAJ,EAA8D;AAC1D,aAAO,KAAP;AACH;;AACD,QAAIuC,SAAS,GAAG,IAAhB;AACA,QAAIM,UAAJ;;AACA,WAAON,SAAS,CAACpC,IAAV,KAAmB;AAAE;AAArB,OAAmC,CAAC0C,UAAU,GAAGN,SAAS,CAAClC,cAAxB,IAA0C,CAApF,EAAuF;AACnFkC,MAAAA,SAAS,GAAGA,SAAS,CAACjC,QAAV,CAAmBuC,UAAU,GAAG,CAAhC,CAAZ;AACH;;AACD,WAAON,SAAS,CAAC1B,WAAV,CAAsBC,cAAtB,CAAP;AACH;;AACDgC,EAAAA,qBAAqB,GAAG;AACpB,SAAKX,gBAAL;AACA,UAAMY,KAAK,GAAG,KAAK1C,cAAnB;AACA,QAAIX,MAAM,GAAG,KAAKY,QAAL,CAAc,CAAd,EAAiBZ,MAA9B;AACA,QAAIsD,gBAAgB,GAAG,KAAK1C,QAAL,CAAc,CAAd,EAAiBN,wBAAxC;;AACA,SAAK,IAAIiD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAApB,EAA2BE,CAAC,EAA5B,EAAgC;AAC5B,YAAMnD,KAAK,GAAG,KAAKQ,QAAL,CAAc2C,CAAd,CAAd;AACAvD,MAAAA,MAAM,GAAGP,SAAS,CAACO,MAAD,EAASI,KAAK,CAACJ,MAAf,CAAlB;AACAsD,MAAAA,gBAAgB,GAAGA,gBAAgB,CAACjB,KAAjB,CAAuBjC,KAAK,CAACE,wBAA7B,CAAnB;AACH;;AACD,SAAKL,OAAL,GAAeD,MAAf;AACA,SAAK6B,yBAAL,GAAiCyB,gBAAjC;AACA,SAAKxB,oBAAL,GAA4B,CAAC,CAA7B;AACH;;AACDP,EAAAA,qBAAqB,CAACC,MAAD,EAASC,SAAT,EAAoB;AACrC,QAAI,KAAKK,oBAAL,KAA8B,CAAC,CAAnC,EAAsC;AAClC,aAAO,KAAKA,oBAAZ;AACH;;AACD,QAAI0B,cAAc,GAAG9B,MAAM,CAACC,gBAA5B;AACA,QAAI8B,WAAW,GAAGjC,MAAlB;;AACA,SAAK,IAAI+B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5C,cAAzB,EAAyC4C,CAAC,EAA1C,EAA8C;AAC1C,YAAMnD,KAAK,GAAG,KAAKQ,QAAL,CAAc2C,CAAd,CAAd;;AACA,UAAInD,KAAJ,EAAW;AACPoD,QAAAA,cAAc,GAAGE,IAAI,CAACC,GAAL,CAASH,cAAT,EAAyBpD,KAAK,CAACmB,qBAAN,CAA4BkC,WAA5B,EAAyChC,SAAzC,CAAzB,CAAjB;AACAgC,QAAAA,WAAW,GAAGhE,SAAS,CAACgE,WAAD,EAAcrD,KAAK,CAACJ,MAApB,CAAvB;AACH;AACJ;;AACD,SAAK8B,oBAAL,GAA4B0B,cAA5B;AACA,WAAOA,cAAP;AACH;;AA9GwC;;AAgH7C,MAAMjB,mBAAN,SAAkCX,WAAlC,CAA8C;AAC1C7B,EAAAA,WAAW,CAACC,MAAD,EAASU,UAAT,EAAqBkD,MAArB,EAA6BC,MAA7B,EAAqCC,MAArC,EAA6CxD,wBAA7C,EAAuE;AAC9E,UAAMN,MAAN,EAAcU,UAAd,EAA0BJ,wBAA1B;AACA,SAAKsD,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAcA,MAAd;AACH;;AACiB,MAAdnD,cAAc,GAAG;AACjB,WAAO,KAAKmD,MAAL,KAAgB,IAAhB,GAAuB,CAAvB,GAA2B,CAAlC;AACH;;AACDlD,EAAAA,QAAQ,CAACC,GAAD,EAAM;AACV,YAAQA,GAAR;AACI,WAAK,CAAL;AAAQ,eAAO,KAAK+C,MAAZ;;AACR,WAAK,CAAL;AAAQ,eAAO,KAAKC,MAAZ;;AACR,WAAK,CAAL;AAAQ,eAAO,KAAKC,MAAZ;AAHZ;;AAKA,UAAM,IAAIhD,KAAJ,CAAU,qBAAV,CAAN;AACH;;AACDkC,EAAAA,QAAQ,CAACnC,GAAD,EAAMkD,IAAN,EAAY;AAChB,YAAQlD,GAAR;AACI,WAAK,CAAL;AACI,aAAK+C,MAAL,GAAcG,IAAd;AACA;;AACJ,WAAK,CAAL;AACI,aAAKF,MAAL,GAAcE,IAAd;AACA;;AACJ,WAAK,CAAL;AACI,aAAKD,MAAL,GAAcC,IAAd;AACA;AATR;;AAWA,UAAM,IAAIjD,KAAJ,CAAU,qBAAV,CAAN;AACH;;AACW,MAARC,QAAQ,GAAG;AACX,WAAO,KAAK+C,MAAL,GAAc,CAAC,KAAKF,MAAN,EAAc,KAAKC,MAAnB,EAA2B,KAAKC,MAAhC,CAAd,GAAwD,CAAC,KAAKF,MAAN,EAAc,KAAKC,MAAnB,CAA/D;AACH;;AACQ,MAAL7B,KAAK,GAAG;AACR,WAAO,KAAK4B,MAAZ;AACH;;AACQ,MAAL3B,KAAK,GAAG;AACR,WAAO,KAAK4B,MAAZ;AACH;;AACQ,MAAL3B,KAAK,GAAG;AACR,WAAO,KAAK4B,MAAZ;AACH;;AACDxC,EAAAA,SAAS,GAAG;AACR,WAAO,IAAIiB,mBAAJ,CAAwB,KAAKvC,MAA7B,EAAqC,KAAKU,UAA1C,EAAsD,KAAKkD,MAAL,CAAYtC,SAAZ,EAAtD,EAA+E,KAAKuC,MAAL,CAAYvC,SAAZ,EAA/E,EAAwG,KAAKwC,MAAL,GAAc,KAAKA,MAAL,CAAYxC,SAAZ,EAAd,GAAwC,IAAhJ,EAAsJ,KAAKhB,wBAA3J,CAAP;AACH;;AACD0D,EAAAA,uBAAuB,CAACD,IAAD,EAAO;AAC1B,QAAI,KAAKD,MAAT,EAAiB;AACb,YAAM,IAAIhD,KAAJ,CAAU,yCAAV,CAAN;AACH;;AACD,SAAK2B,gBAAL;AACA,SAAKqB,MAAL,GAAcC,IAAd;AACA,SAAKX,qBAAL;AACH;;AACDa,EAAAA,aAAa,GAAG;AACZ,QAAI,CAAC,KAAKH,MAAV,EAAkB;AACd,YAAM,IAAIhD,KAAJ,CAAU,+CAAV,CAAN;AACH;;AACD,SAAK2B,gBAAL;AACA,UAAMzB,MAAM,GAAG,KAAK8C,MAApB;AACA,SAAKA,MAAL,GAAc,IAAd;AACA,SAAKV,qBAAL;AACA,WAAOpC,MAAP;AACH;;AACDkD,EAAAA,wBAAwB,CAACH,IAAD,EAAO;AAC3B,QAAI,KAAKD,MAAT,EAAiB;AACb,YAAM,IAAIhD,KAAJ,CAAU,0CAAV,CAAN;AACH;;AACD,SAAK2B,gBAAL;AACA,SAAKqB,MAAL,GAAc,KAAKD,MAAnB;AACA,SAAKA,MAAL,GAAc,KAAKD,MAAnB;AACA,SAAKA,MAAL,GAAcG,IAAd;AACA,SAAKX,qBAAL;AACH;;AACDe,EAAAA,cAAc,GAAG;AACb,QAAI,CAAC,KAAKL,MAAV,EAAkB;AACd,YAAM,IAAIhD,KAAJ,CAAU,+CAAV,CAAN;AACH;;AACD,SAAK2B,gBAAL;AACA,UAAMzB,MAAM,GAAG,KAAK4C,MAApB;AACA,SAAKA,MAAL,GAAc,KAAKC,MAAnB;AACA,SAAKA,MAAL,GAAc,KAAKC,MAAnB;AACA,SAAKA,MAAL,GAAc,IAAd;AACA,SAAKV,qBAAL;AACA,WAAOpC,MAAP;AACH;;AACD+B,EAAAA,SAAS,GAAG;AACR,WAAO,IAAP;AACH;;AAzFyC;AA2F9C;AACA;AACA;;;AACA,MAAMT,sBAAN,SAAqCC,mBAArC,CAAyD;AACrDQ,EAAAA,SAAS,GAAG;AACR,WAAO,IAAIR,mBAAJ,CAAwB,KAAKvC,MAA7B,EAAqC,KAAKU,UAA1C,EAAsD,KAAKsB,KAA3D,EAAkE,KAAKC,KAAvE,EAA8E,KAAKC,KAAnF,EAA0F,KAAK5B,wBAA/F,CAAP;AACH;;AACDmC,EAAAA,gBAAgB,GAAG;AACf,UAAM,IAAI3B,KAAJ,CAAU,4BAAV,CAAN;AACH;;AANoD;AAQzD;AACA;AACA;;;AACA,MAAMsD,gBAAN,SAA+BxC,WAA/B,CAA2C;AACvC7B,EAAAA,WAAW,CAACC,MAAD,EAASU,UAAT,EAAqB2D,SAArB,EAAgC/D,wBAAhC,EAA0D;AACjE,UAAMN,MAAN,EAAcU,UAAd,EAA0BJ,wBAA1B;AACA,SAAK+D,SAAL,GAAiBA,SAAjB;AACH;;AACiB,MAAd1D,cAAc,GAAG;AACjB,WAAO,KAAK0D,SAAL,CAAerE,MAAtB;AACH;;AACDY,EAAAA,QAAQ,CAACC,GAAD,EAAM;AACV,WAAO,KAAKwD,SAAL,CAAexD,GAAf,CAAP;AACH;;AACDmC,EAAAA,QAAQ,CAACnC,GAAD,EAAMT,KAAN,EAAa;AACjB,SAAKiE,SAAL,CAAexD,GAAf,IAAsBT,KAAtB;AACH;;AACW,MAARW,QAAQ,GAAG;AACX,WAAO,KAAKsD,SAAZ;AACH;;AACD/C,EAAAA,SAAS,GAAG;AACR,UAAMP,QAAQ,GAAG,IAAIE,KAAJ,CAAU,KAAKoD,SAAL,CAAerE,MAAzB,CAAjB;;AACA,SAAK,IAAIuD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKc,SAAL,CAAerE,MAAnC,EAA2CuD,CAAC,EAA5C,EAAgD;AAC5CxC,MAAAA,QAAQ,CAACwC,CAAD,CAAR,GAAc,KAAKc,SAAL,CAAed,CAAf,EAAkBjC,SAAlB,EAAd;AACH;;AACD,WAAO,IAAI8C,gBAAJ,CAAqB,KAAKpE,MAA1B,EAAkC,KAAKU,UAAvC,EAAmDK,QAAnD,EAA6D,KAAKT,wBAAlE,CAAP;AACH;;AACD0D,EAAAA,uBAAuB,CAACD,IAAD,EAAO;AAC1B,SAAKtB,gBAAL;;AACA,SAAK4B,SAAL,CAAenD,IAAf,CAAoB6C,IAApB;;AACA,SAAKX,qBAAL;AACH;;AACDa,EAAAA,aAAa,GAAG;AACZ,SAAKxB,gBAAL;;AACA,UAAM6B,IAAI,GAAG,KAAKD,SAAL,CAAeE,GAAf,EAAb;;AACA,SAAKnB,qBAAL;AACA,WAAOkB,IAAP;AACH;;AACDJ,EAAAA,wBAAwB,CAACH,IAAD,EAAO;AAC3B,SAAKtB,gBAAL;;AACA,SAAK4B,SAAL,CAAeG,OAAf,CAAuBT,IAAvB;;AACA,SAAKX,qBAAL;AACH;;AACDe,EAAAA,cAAc,GAAG;AACb,SAAK1B,gBAAL;;AACA,UAAM6B,IAAI,GAAG,KAAKD,SAAL,CAAeI,KAAf,EAAb;;AACA,SAAKrB,qBAAL;AACA,WAAOkB,IAAP;AACH;;AACDvB,EAAAA,SAAS,GAAG;AACR,WAAO,IAAP;AACH;;AAhDsC;AAkD3C;AACA;AACA;;;AACA,MAAMP,yBAAN,SAAwC4B,gBAAxC,CAAyD;AACrDrB,EAAAA,SAAS,GAAG;AACR,WAAO,IAAIqB,gBAAJ,CAAqB,KAAKpE,MAA1B,EAAkC,KAAKU,UAAvC,EAAmD,CAAC,GAAG,KAAKK,QAAT,CAAnD,EAAuE,KAAKT,wBAA5E,CAAP;AACH;;AACDmC,EAAAA,gBAAgB,GAAG;AACf,UAAM,IAAI3B,KAAJ,CAAU,4BAAV,CAAN;AACH;;AANoD;;AAQzD,MAAM4D,UAAU,GAAG,EAAnB;;AACA,MAAMC,oBAAN,SAAmC7E,WAAnC,CAA+C;AAC7B,MAAVY,UAAU,GAAG;AACb,WAAO,CAAP;AACH;;AACiB,MAAdC,cAAc,GAAG;AACjB,WAAO,CAAP;AACH;;AACDC,EAAAA,QAAQ,CAACC,GAAD,EAAM;AACV,WAAO,IAAP;AACH;;AACW,MAARE,QAAQ,GAAG;AACX,WAAO2D,UAAP;AACH;;AACDpD,EAAAA,SAAS,GAAG;AACR,WAAO,IAAP;AACH;;AAf0C;;AAiB/C,OAAO,MAAMsD,WAAN,SAA0BD,oBAA1B,CAA+C;AAC1C,MAAJlE,IAAI,GAAG;AACP,WAAO;AAAE;AAAT;AACH;;AAC2B,MAAxBH,wBAAwB,GAAG;AAC3B,WAAOT,iBAAiB,CAACW,QAAlB,EAAP;AACH;;AACDW,EAAAA,WAAW,CAAC0D,iBAAD,EAAoB;AAC3B,WAAO,IAAP;AACH;;AACDtD,EAAAA,qBAAqB,CAACC,MAAD,EAASC,SAAT,EAAoB;AACrC,UAAMqD,KAAK,GAAGnF,WAAW,CAAC6B,MAAD,CAAzB,CADqC,CAErC;AACA;;AACA,UAAMuD,eAAe,GAAG,CAACD,KAAK,CAACE,WAAN,KAAsB,CAAtB,GAA0BF,KAAK,CAACG,SAAhC,GAA4CH,KAAK,CAACG,SAAN,GAAkB,CAA/D,IAAoE,CAA5F;AACA,UAAMC,aAAa,GAAGxF,kBAAkB,CAACD,SAAS,CAAC+B,MAAD,EAAS,KAAKxB,MAAd,CAAV,CAAlB,GAAqD,CAA3E;AACA,QAAIgB,MAAM,GAAGU,MAAM,CAACC,gBAApB;;AACA,SAAK,IAAIwD,UAAU,GAAGJ,eAAtB,EAAuCI,UAAU,IAAID,aAArD,EAAoEC,UAAU,EAA9E,EAAkF;AAC9E,YAAMC,gBAAgB,GAAG3D,SAAS,CAAC4D,+BAAV,CAA0CF,UAA1C,CAAzB;AACA,YAAMG,WAAW,GAAG7D,SAAS,CAAC8D,cAAV,CAAyBJ,UAAzB,CAApB;;AACA,UAAIC,gBAAgB,KAAK,CAAzB,EAA4B;AACxB;AACH;;AACD,YAAMI,aAAa,GAAGhG,aAAa,CAACiG,uBAAd,CAAsCH,WAAtC,EAAmDF,gBAAnD,EAAqE3D,SAAS,CAACiE,UAAV,GAAuBC,OAA5F,CAAtB;AACA3E,MAAAA,MAAM,GAAG0C,IAAI,CAACC,GAAL,CAAS3C,MAAT,EAAiBwE,aAAjB,CAAT;AACH;;AACD,WAAOxE,MAAP;AACH;;AA3BiD;AA6BtD,OAAO,MAAM4E,cAAN,SAA6BjB,oBAA7B,CAAkD;AACrD5E,EAAAA,WAAW,CAACC,MAAD,EAAS6F,UAAT;AACX;AACJ;AACA;AACA;AACIC,EAAAA,UALW,EAKC;AACR,UAAM9F,MAAN;AACA,SAAK6F,UAAL,GAAkBA,UAAlB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACH;;AACY,SAANvF,MAAM,CAACP,MAAD,EAAS6F,UAAT,EAAqBC,UAArB,EAAiC;AAC1C,UAAM/B,IAAI,GAAG,IAAI6B,cAAJ,CAAmB5F,MAAnB,EAA2B6F,UAA3B,EAAuCC,UAAvC,CAAb;AACA,WAAO/B,IAAP;AACH;;AACO,MAAJtD,IAAI,GAAG;AACP,WAAO;AAAE;AAAT;AACH;;AAC2B,MAAxBH,wBAAwB,GAAG;AAC3B,WAAOT,iBAAiB,CAACW,QAAlB,EAAP;AACH;;AACDW,EAAAA,WAAW,CAAC0D,iBAAD,EAAoB;AAC3B;AACA;AACA;AACA,WAAO,KAAP;AACH;;AACDtD,EAAAA,qBAAqB,CAACC,MAAD,EAASC,SAAT,EAAoB;AACrC,WAAOC,MAAM,CAACC,gBAAd;AACH;;AA7BoD;AA+BzD,OAAO,MAAMoE,qBAAN,SAAoCpB,oBAApC,CAAyD;AAC5D5E,EAAAA,WAAW,CAACiG,eAAD,EAAkBhG,MAAlB,EAA0B;AACjC,UAAMA,MAAN;AACA,SAAKM,wBAAL,GAAgC0F,eAAhC;AACH;;AACO,MAAJvF,IAAI,GAAG;AACP,WAAO;AAAE;AAAT;AACH;;AACDU,EAAAA,WAAW,CAAC8E,gBAAD,EAAmB;AAC1B,WAAO,CAACA,gBAAgB,CAAC5E,UAAjB,CAA4B,KAAKf,wBAAjC,CAAR;AACH;;AACDiB,EAAAA,qBAAqB,CAACC,MAAD,EAASC,SAAT,EAAoB;AACrC,WAAOC,MAAM,CAACC,gBAAd;AACH;;AAb2D","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    constructor(length) {\n        this._length = length;\n    }\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = new Array();\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        let lastChild = this;\n        let lastLength;\n        while (lastChild.kind === 4 /* List */ && (lastLength = lastChild.childrenLength) > 0) {\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    constructor(length, languageId, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.languageId = languageId;\n        this.bracketIds = bracketIds;\n    }\n    static create(length, languageId, bracketIds) {\n        const node = new BracketAstNode(length, languageId, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    get kind() {\n        return 3 /* UnexpectedClosingBracket */;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}