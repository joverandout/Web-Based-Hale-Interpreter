{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport { asArray, isNonEmptyArray } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { isCodeEditor } from '../../../browser/editorBrowser.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { DocumentFormattingEditProviderRegistry, DocumentRangeFormattingEditProviderRegistry, OnTypeFormattingEditProviderRegistry } from '../../../common/languages.js';\nimport { IEditorWorkerService } from '../../../common/services/editorWorker.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport * as nls from '../../../../nls.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { ExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nexport function alertFormattingEdits(edits) {\n  edits = edits.filter(edit => edit.range);\n\n  if (!edits.length) {\n    return;\n  }\n\n  let {\n    range\n  } = edits[0];\n\n  for (let i = 1; i < edits.length; i++) {\n    range = Range.plusRange(range, edits[i].range);\n  }\n\n  const {\n    startLineNumber,\n    endLineNumber\n  } = range;\n\n  if (startLineNumber === endLineNumber) {\n    if (edits.length === 1) {\n      alert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\n    } else {\n      alert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\n    }\n  } else {\n    if (edits.length === 1) {\n      alert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\n    } else {\n      alert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\n    }\n  }\n}\nexport function getRealAndSyntheticDocumentFormattersOrdered(model) {\n  const result = [];\n  const seen = new Set(); // (1) add all document formatter\n\n  const docFormatter = DocumentFormattingEditProviderRegistry.ordered(model);\n\n  for (const formatter of docFormatter) {\n    result.push(formatter);\n\n    if (formatter.extensionId) {\n      seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n    }\n  } // (2) add all range formatter as document formatter (unless the same extension already did that)\n\n\n  const rangeFormatter = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n\n  for (const formatter of rangeFormatter) {\n    if (formatter.extensionId) {\n      if (seen.has(ExtensionIdentifier.toKey(formatter.extensionId))) {\n        continue;\n      }\n\n      seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n    }\n\n    result.push({\n      displayName: formatter.displayName,\n      extensionId: formatter.extensionId,\n\n      provideDocumentFormattingEdits(model, options, token) {\n        return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n      }\n\n    });\n  }\n\n  return result;\n}\nexport class FormattingConflicts {\n  static setFormatterSelector(selector) {\n    const remove = FormattingConflicts._selectors.unshift(selector);\n\n    return {\n      dispose: remove\n    };\n  }\n\n  static select(formatter, document, mode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (formatter.length === 0) {\n        return undefined;\n      }\n\n      const selector = Iterable.first(FormattingConflicts._selectors);\n\n      if (selector) {\n        return yield selector(formatter, document, mode);\n      }\n\n      return undefined;\n    });\n  }\n\n}\nFormattingConflicts._selectors = new LinkedList();\nexport function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const instaService = accessor.get(IInstantiationService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n    const selected = yield FormattingConflicts.select(provider, model, mode);\n\n    if (selected) {\n      progress.report(selected);\n      yield instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token);\n    }\n  });\n}\nexport function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const workerService = accessor.get(IEditorWorkerService);\n    let model;\n    let cts;\n\n    if (isCodeEditor(editorOrModel)) {\n      model = editorOrModel.getModel();\n      cts = new EditorStateCancellationTokenSource(editorOrModel, 1\n      /* Value */\n      | 4\n      /* Position */\n      , undefined, token);\n    } else {\n      model = editorOrModel;\n      cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    } // make sure that ranges don't overlap nor touch each other\n\n\n    let ranges = [];\n    let len = 0;\n\n    for (let range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n      if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n        ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n      } else {\n        len = ranges.push(range);\n      }\n    }\n\n    const computeEdits = range => __awaiter(this, void 0, void 0, function* () {\n      return (yield provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];\n    });\n\n    const hasIntersectingEdit = (a, b) => {\n      if (!a.length || !b.length) {\n        return false;\n      } // quick exit if the list of ranges are completely unrelated [O(n)]\n\n\n      const mergedA = a.reduce((acc, val) => {\n        return Range.plusRange(acc, val.range);\n      }, a[0].range);\n\n      if (!b.some(x => {\n        return Range.intersectRanges(mergedA, x.range);\n      })) {\n        return false;\n      } // fallback to a complete check [O(n^2)]\n\n\n      for (let edit of a) {\n        for (let otherEdit of b) {\n          if (Range.intersectRanges(edit.range, otherEdit.range)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    const allEdits = [];\n    const rawEditsList = [];\n\n    try {\n      for (let range of ranges) {\n        if (cts.token.isCancellationRequested) {\n          return true;\n        }\n\n        rawEditsList.push(yield computeEdits(range));\n      }\n\n      for (let i = 0; i < ranges.length; ++i) {\n        for (let j = i + 1; j < ranges.length; ++j) {\n          if (cts.token.isCancellationRequested) {\n            return true;\n          }\n\n          if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {\n            // Merge ranges i and j into a single range, recompute the associated edits\n            const mergedRange = Range.plusRange(ranges[i], ranges[j]);\n            const edits = yield computeEdits(mergedRange);\n            ranges.splice(j, 1);\n            ranges.splice(i, 1);\n            ranges.push(mergedRange);\n            rawEditsList.splice(j, 1);\n            rawEditsList.splice(i, 1);\n            rawEditsList.push(edits); // Restart scanning\n\n            i = 0;\n            j = 0;\n          }\n        }\n      }\n\n      for (let rawEdits of rawEditsList) {\n        if (cts.token.isCancellationRequested) {\n          return true;\n        }\n\n        const minimalEdits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\n        if (minimalEdits) {\n          allEdits.push(...minimalEdits);\n        }\n      }\n    } finally {\n      cts.dispose();\n    }\n\n    if (allEdits.length === 0) {\n      return false;\n    }\n\n    if (isCodeEditor(editorOrModel)) {\n      // use editor to apply edits\n      FormattingEdit.execute(editorOrModel, allEdits, true);\n      alertFormattingEdits(allEdits);\n      editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1\n      /* Immediate */\n      );\n    } else {\n      // use model to apply edits\n      const [{\n        range\n      }] = allEdits;\n      const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n      model.pushEditOperations([initialSelection], allEdits.map(edit => {\n        return {\n          text: edit.text,\n          range: Range.lift(edit.range),\n          forceMoveMarkers: true\n        };\n      }), undoEdits => {\n        for (const {\n          range\n        } of undoEdits) {\n          if (Range.areIntersectingOrTouching(range, initialSelection)) {\n            return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n          }\n        }\n\n        return null;\n      });\n    }\n\n    return true;\n  });\n}\nexport function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const instaService = accessor.get(IInstantiationService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = getRealAndSyntheticDocumentFormattersOrdered(model);\n    const selected = yield FormattingConflicts.select(provider, model, mode);\n\n    if (selected) {\n      progress.report(selected);\n      yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);\n    }\n  });\n}\nexport function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const workerService = accessor.get(IEditorWorkerService);\n    let model;\n    let cts;\n\n    if (isCodeEditor(editorOrModel)) {\n      model = editorOrModel.getModel();\n      cts = new EditorStateCancellationTokenSource(editorOrModel, 1\n      /* Value */\n      | 4\n      /* Position */\n      , undefined, token);\n    } else {\n      model = editorOrModel;\n      cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n\n    let edits;\n\n    try {\n      const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\n      edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n\n      if (cts.token.isCancellationRequested) {\n        return true;\n      }\n    } finally {\n      cts.dispose();\n    }\n\n    if (!edits || edits.length === 0) {\n      return false;\n    }\n\n    if (isCodeEditor(editorOrModel)) {\n      // use editor to apply edits\n      FormattingEdit.execute(editorOrModel, edits, mode !== 2\n      /* Silent */\n      );\n\n      if (mode !== 2\n      /* Silent */\n      ) {\n        alertFormattingEdits(edits);\n        editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1\n        /* Immediate */\n        );\n      }\n    } else {\n      // use model to apply edits\n      const [{\n        range\n      }] = edits;\n      const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n      model.pushEditOperations([initialSelection], edits.map(edit => {\n        return {\n          text: edit.text,\n          range: Range.lift(edit.range),\n          forceMoveMarkers: true\n        };\n      }), undoEdits => {\n        for (const {\n          range\n        } of undoEdits) {\n          if (Range.areIntersectingOrTouching(range, initialSelection)) {\n            return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n          }\n        }\n\n        return null;\n      });\n    }\n\n    return true;\n  });\n}\nexport function getDocumentRangeFormattingEditsUntilResult(workerService, model, range, options, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n\n    for (const provider of providers) {\n      let rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n\n      if (isNonEmptyArray(rawEdits)) {\n        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      }\n    }\n\n    return undefined;\n  });\n}\nexport function getDocumentFormattingEditsUntilResult(workerService, model, options, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getRealAndSyntheticDocumentFormattersOrdered(model);\n\n    for (const provider of providers) {\n      let rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n\n      if (isNonEmptyArray(rawEdits)) {\n        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      }\n    }\n\n    return undefined;\n  });\n}\nexport function getOnTypeFormattingEdits(workerService, model, position, ch, options, token) {\n  const providers = OnTypeFormattingEditProviderRegistry.ordered(model);\n\n  if (providers.length === 0) {\n    return Promise.resolve(undefined);\n  }\n\n  if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n    return Promise.resolve(undefined);\n  }\n\n  return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(onUnexpectedExternalError).then(edits => {\n    return workerService.computeMoreMinimalEdits(model.uri, edits);\n  });\n}\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', function (accessor, ...args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [resource, range, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Range.isIRange(range));\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const reference = yield resolverService.createModelReference(resource);\n\n    try {\n      return getDocumentRangeFormattingEditsUntilResult(workerService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);\n    } finally {\n      reference.dispose();\n    }\n  });\n});\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', function (accessor, ...args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [resource, options] = args;\n    assertType(URI.isUri(resource));\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const reference = yield resolverService.createModelReference(resource);\n\n    try {\n      return getDocumentFormattingEditsUntilResult(workerService, reference.object.textEditorModel, options, CancellationToken.None);\n    } finally {\n      reference.dispose();\n    }\n  });\n});\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', function (accessor, ...args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [resource, position, ch, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Position.isIPosition(position));\n    assertType(typeof ch === 'string');\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const reference = yield resolverService.createModelReference(resource);\n\n    try {\n      return getOnTypeFormattingEdits(workerService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);\n    } finally {\n      reference.dispose();\n    }\n  });\n});","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/format.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","alert","asArray","isNonEmptyArray","CancellationToken","onUnexpectedExternalError","Iterable","LinkedList","assertType","URI","EditorStateCancellationTokenSource","TextModelCancellationTokenSource","isCodeEditor","Position","Range","Selection","DocumentFormattingEditProviderRegistry","DocumentRangeFormattingEditProviderRegistry","OnTypeFormattingEditProviderRegistry","IEditorWorkerService","ITextModelService","FormattingEdit","nls","CommandsRegistry","ExtensionIdentifier","IInstantiationService","alertFormattingEdits","edits","filter","edit","range","length","i","plusRange","startLineNumber","endLineNumber","localize","getRealAndSyntheticDocumentFormattersOrdered","model","seen","Set","docFormatter","ordered","formatter","push","extensionId","add","toKey","rangeFormatter","has","displayName","provideDocumentFormattingEdits","options","token","provideDocumentRangeFormattingEdits","getFullModelRange","FormattingConflicts","setFormatterSelector","selector","remove","_selectors","unshift","dispose","select","document","mode","undefined","first","formatDocumentRangesWithSelectedProvider","accessor","editorOrModel","rangeOrRanges","progress","instaService","get","getModel","provider","selected","report","invokeFunction","formatDocumentRangesWithProvider","workerService","cts","ranges","len","sort","compareRangesUsingStarts","areIntersectingOrTouching","fromPositions","getStartPosition","getEndPosition","computeEdits","getFormattingOptions","hasIntersectingEdit","a","b","mergedA","reduce","acc","val","some","x","intersectRanges","otherEdit","allEdits","rawEditsList","isCancellationRequested","j","mergedRange","splice","rawEdits","minimalEdits","computeMoreMinimalEdits","uri","execute","revealPositionInCenterIfOutsideViewport","getPosition","initialSelection","startColumn","endColumn","pushEditOperations","map","text","lift","forceMoveMarkers","undoEdits","formatDocumentWithSelectedProvider","formatDocumentWithProvider","getDocumentRangeFormattingEditsUntilResult","providers","catch","getDocumentFormattingEditsUntilResult","getOnTypeFormattingEdits","position","ch","autoFormatTriggerCharacters","indexOf","provideOnTypeFormattingEdits","registerCommand","args","resource","isUri","isIRange","resolverService","reference","createModelReference","object","textEditorModel","None","isIPosition"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport { asArray, isNonEmptyArray } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { isCodeEditor } from '../../../browser/editorBrowser.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { DocumentFormattingEditProviderRegistry, DocumentRangeFormattingEditProviderRegistry, OnTypeFormattingEditProviderRegistry } from '../../../common/languages.js';\nimport { IEditorWorkerService } from '../../../common/services/editorWorker.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport * as nls from '../../../../nls.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { ExtensionIdentifier } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nexport function alertFormattingEdits(edits) {\n    edits = edits.filter(edit => edit.range);\n    if (!edits.length) {\n        return;\n    }\n    let { range } = edits[0];\n    for (let i = 1; i < edits.length; i++) {\n        range = Range.plusRange(range, edits[i].range);\n    }\n    const { startLineNumber, endLineNumber } = range;\n    if (startLineNumber === endLineNumber) {\n        if (edits.length === 1) {\n            alert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\n        }\n        else {\n            alert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\n        }\n    }\n    else {\n        if (edits.length === 1) {\n            alert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\n        }\n        else {\n            alert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\n        }\n    }\n}\nexport function getRealAndSyntheticDocumentFormattersOrdered(model) {\n    const result = [];\n    const seen = new Set();\n    // (1) add all document formatter\n    const docFormatter = DocumentFormattingEditProviderRegistry.ordered(model);\n    for (const formatter of docFormatter) {\n        result.push(formatter);\n        if (formatter.extensionId) {\n            seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n        }\n    }\n    // (2) add all range formatter as document formatter (unless the same extension already did that)\n    const rangeFormatter = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n    for (const formatter of rangeFormatter) {\n        if (formatter.extensionId) {\n            if (seen.has(ExtensionIdentifier.toKey(formatter.extensionId))) {\n                continue;\n            }\n            seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n        }\n        result.push({\n            displayName: formatter.displayName,\n            extensionId: formatter.extensionId,\n            provideDocumentFormattingEdits(model, options, token) {\n                return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n            }\n        });\n    }\n    return result;\n}\nexport class FormattingConflicts {\n    static setFormatterSelector(selector) {\n        const remove = FormattingConflicts._selectors.unshift(selector);\n        return { dispose: remove };\n    }\n    static select(formatter, document, mode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (formatter.length === 0) {\n                return undefined;\n            }\n            const selector = Iterable.first(FormattingConflicts._selectors);\n            if (selector) {\n                return yield selector(formatter, document, mode);\n            }\n            return undefined;\n        });\n    }\n}\nFormattingConflicts._selectors = new LinkedList();\nexport function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const instaService = accessor.get(IInstantiationService);\n        const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n        const provider = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n        const selected = yield FormattingConflicts.select(provider, model, mode);\n        if (selected) {\n            progress.report(selected);\n            yield instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token);\n        }\n    });\n}\nexport function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const workerService = accessor.get(IEditorWorkerService);\n        let model;\n        let cts;\n        if (isCodeEditor(editorOrModel)) {\n            model = editorOrModel.getModel();\n            cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* Value */ | 4 /* Position */, undefined, token);\n        }\n        else {\n            model = editorOrModel;\n            cts = new TextModelCancellationTokenSource(editorOrModel, token);\n        }\n        // make sure that ranges don't overlap nor touch each other\n        let ranges = [];\n        let len = 0;\n        for (let range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n            if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n                ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n            }\n            else {\n                len = ranges.push(range);\n            }\n        }\n        const computeEdits = (range) => __awaiter(this, void 0, void 0, function* () {\n            return (yield provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];\n        });\n        const hasIntersectingEdit = (a, b) => {\n            if (!a.length || !b.length) {\n                return false;\n            }\n            // quick exit if the list of ranges are completely unrelated [O(n)]\n            const mergedA = a.reduce((acc, val) => { return Range.plusRange(acc, val.range); }, a[0].range);\n            if (!b.some(x => { return Range.intersectRanges(mergedA, x.range); })) {\n                return false;\n            }\n            // fallback to a complete check [O(n^2)]\n            for (let edit of a) {\n                for (let otherEdit of b) {\n                    if (Range.intersectRanges(edit.range, otherEdit.range)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        const allEdits = [];\n        const rawEditsList = [];\n        try {\n            for (let range of ranges) {\n                if (cts.token.isCancellationRequested) {\n                    return true;\n                }\n                rawEditsList.push(yield computeEdits(range));\n            }\n            for (let i = 0; i < ranges.length; ++i) {\n                for (let j = i + 1; j < ranges.length; ++j) {\n                    if (cts.token.isCancellationRequested) {\n                        return true;\n                    }\n                    if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {\n                        // Merge ranges i and j into a single range, recompute the associated edits\n                        const mergedRange = Range.plusRange(ranges[i], ranges[j]);\n                        const edits = yield computeEdits(mergedRange);\n                        ranges.splice(j, 1);\n                        ranges.splice(i, 1);\n                        ranges.push(mergedRange);\n                        rawEditsList.splice(j, 1);\n                        rawEditsList.splice(i, 1);\n                        rawEditsList.push(edits);\n                        // Restart scanning\n                        i = 0;\n                        j = 0;\n                    }\n                }\n            }\n            for (let rawEdits of rawEditsList) {\n                if (cts.token.isCancellationRequested) {\n                    return true;\n                }\n                const minimalEdits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n                if (minimalEdits) {\n                    allEdits.push(...minimalEdits);\n                }\n            }\n        }\n        finally {\n            cts.dispose();\n        }\n        if (allEdits.length === 0) {\n            return false;\n        }\n        if (isCodeEditor(editorOrModel)) {\n            // use editor to apply edits\n            FormattingEdit.execute(editorOrModel, allEdits, true);\n            alertFormattingEdits(allEdits);\n            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* Immediate */);\n        }\n        else {\n            // use model to apply edits\n            const [{ range }] = allEdits;\n            const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n            model.pushEditOperations([initialSelection], allEdits.map(edit => {\n                return {\n                    text: edit.text,\n                    range: Range.lift(edit.range),\n                    forceMoveMarkers: true\n                };\n            }), undoEdits => {\n                for (const { range } of undoEdits) {\n                    if (Range.areIntersectingOrTouching(range, initialSelection)) {\n                        return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                    }\n                }\n                return null;\n            });\n        }\n        return true;\n    });\n}\nexport function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const instaService = accessor.get(IInstantiationService);\n        const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n        const provider = getRealAndSyntheticDocumentFormattersOrdered(model);\n        const selected = yield FormattingConflicts.select(provider, model, mode);\n        if (selected) {\n            progress.report(selected);\n            yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);\n        }\n    });\n}\nexport function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const workerService = accessor.get(IEditorWorkerService);\n        let model;\n        let cts;\n        if (isCodeEditor(editorOrModel)) {\n            model = editorOrModel.getModel();\n            cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* Value */ | 4 /* Position */, undefined, token);\n        }\n        else {\n            model = editorOrModel;\n            cts = new TextModelCancellationTokenSource(editorOrModel, token);\n        }\n        let edits;\n        try {\n            const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\n            edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            if (cts.token.isCancellationRequested) {\n                return true;\n            }\n        }\n        finally {\n            cts.dispose();\n        }\n        if (!edits || edits.length === 0) {\n            return false;\n        }\n        if (isCodeEditor(editorOrModel)) {\n            // use editor to apply edits\n            FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* Silent */);\n            if (mode !== 2 /* Silent */) {\n                alertFormattingEdits(edits);\n                editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* Immediate */);\n            }\n        }\n        else {\n            // use model to apply edits\n            const [{ range }] = edits;\n            const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n            model.pushEditOperations([initialSelection], edits.map(edit => {\n                return {\n                    text: edit.text,\n                    range: Range.lift(edit.range),\n                    forceMoveMarkers: true\n                };\n            }), undoEdits => {\n                for (const { range } of undoEdits) {\n                    if (Range.areIntersectingOrTouching(range, initialSelection)) {\n                        return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                    }\n                }\n                return null;\n            });\n        }\n        return true;\n    });\n}\nexport function getDocumentRangeFormattingEditsUntilResult(workerService, model, range, options, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n        for (const provider of providers) {\n            let rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n            if (isNonEmptyArray(rawEdits)) {\n                return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            }\n        }\n        return undefined;\n    });\n}\nexport function getDocumentFormattingEditsUntilResult(workerService, model, options, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getRealAndSyntheticDocumentFormattersOrdered(model);\n        for (const provider of providers) {\n            let rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n            if (isNonEmptyArray(rawEdits)) {\n                return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            }\n        }\n        return undefined;\n    });\n}\nexport function getOnTypeFormattingEdits(workerService, model, position, ch, options, token) {\n    const providers = OnTypeFormattingEditProviderRegistry.ordered(model);\n    if (providers.length === 0) {\n        return Promise.resolve(undefined);\n    }\n    if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n        return Promise.resolve(undefined);\n    }\n    return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(onUnexpectedExternalError).then(edits => {\n        return workerService.computeMoreMinimalEdits(model.uri, edits);\n    });\n}\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', function (accessor, ...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [resource, range, options] = args;\n        assertType(URI.isUri(resource));\n        assertType(Range.isIRange(range));\n        const resolverService = accessor.get(ITextModelService);\n        const workerService = accessor.get(IEditorWorkerService);\n        const reference = yield resolverService.createModelReference(resource);\n        try {\n            return getDocumentRangeFormattingEditsUntilResult(workerService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);\n        }\n        finally {\n            reference.dispose();\n        }\n    });\n});\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', function (accessor, ...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [resource, options] = args;\n        assertType(URI.isUri(resource));\n        const resolverService = accessor.get(ITextModelService);\n        const workerService = accessor.get(IEditorWorkerService);\n        const reference = yield resolverService.createModelReference(resource);\n        try {\n            return getDocumentFormattingEditsUntilResult(workerService, reference.object.textEditorModel, options, CancellationToken.None);\n        }\n        finally {\n            reference.dispose();\n        }\n    });\n});\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', function (accessor, ...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [resource, position, ch, options] = args;\n        assertType(URI.isUri(resource));\n        assertType(Position.isIPosition(position));\n        assertType(typeof ch === 'string');\n        const resolverService = accessor.get(ITextModelService);\n        const workerService = accessor.get(IEditorWorkerService);\n        const reference = yield resolverService.createModelReference(resource);\n        try {\n            return getOnTypeFormattingEdits(workerService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);\n        }\n        finally {\n            reference.dispose();\n        }\n    });\n});\n"]},"metadata":{},"sourceType":"module"}