{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport * as strings from '../../../base/common/strings.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n  return diffAlgo.ComputeDiff(pretty);\n}\n\nclass LineSequence {\n  constructor(lines) {\n    const startColumns = [];\n    const endColumns = [];\n\n    for (let i = 0, length = lines.length; i < length; i++) {\n      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n      endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n    }\n\n    this.lines = lines;\n    this._startColumns = startColumns;\n    this._endColumns = endColumns;\n  }\n\n  getElements() {\n    const elements = [];\n\n    for (let i = 0, len = this.lines.length; i < len; i++) {\n      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n    }\n\n    return elements;\n  }\n\n  getStrictElement(index) {\n    return this.lines[index];\n  }\n\n  getStartLineNumber(i) {\n    return i + 1;\n  }\n\n  getEndLineNumber(i) {\n    return i + 1;\n  }\n\n  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n    const charCodes = [];\n    const lineNumbers = [];\n    const columns = [];\n    let len = 0;\n\n    for (let index = startIndex; index <= endIndex; index++) {\n      const lineContent = this.lines[index];\n      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;\n      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;\n\n      for (let col = startColumn; col < endColumn; col++) {\n        charCodes[len] = lineContent.charCodeAt(col - 1);\n        lineNumbers[len] = index + 1;\n        columns[len] = col;\n        len++;\n      }\n    }\n\n    return new CharSequence(charCodes, lineNumbers, columns);\n  }\n\n}\n\nclass CharSequence {\n  constructor(charCodes, lineNumbers, columns) {\n    this._charCodes = charCodes;\n    this._lineNumbers = lineNumbers;\n    this._columns = columns;\n  }\n\n  getElements() {\n    return this._charCodes;\n  }\n\n  getStartLineNumber(i) {\n    return this._lineNumbers[i];\n  }\n\n  getStartColumn(i) {\n    return this._columns[i];\n  }\n\n  getEndLineNumber(i) {\n    return this._lineNumbers[i];\n  }\n\n  getEndColumn(i) {\n    return this._columns[i] + 1;\n  }\n\n}\n\nclass CharChange {\n  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalStartColumn = originalStartColumn;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.originalEndColumn = originalEndColumn;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedStartColumn = modifiedStartColumn;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.modifiedEndColumn = modifiedEndColumn;\n  }\n\n  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n    let originalStartLineNumber;\n    let originalStartColumn;\n    let originalEndLineNumber;\n    let originalEndColumn;\n    let modifiedStartLineNumber;\n    let modifiedStartColumn;\n    let modifiedEndLineNumber;\n    let modifiedEndColumn;\n\n    if (diffChange.originalLength === 0) {\n      originalStartLineNumber = 0;\n      originalStartColumn = 0;\n      originalEndLineNumber = 0;\n      originalEndColumn = 0;\n    } else {\n      originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n      originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n      originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n      originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n    }\n\n    if (diffChange.modifiedLength === 0) {\n      modifiedStartLineNumber = 0;\n      modifiedStartColumn = 0;\n      modifiedEndLineNumber = 0;\n      modifiedEndColumn = 0;\n    } else {\n      modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n      modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n      modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    }\n\n    return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n  }\n\n}\n\nfunction postProcessCharChanges(rawChanges) {\n  if (rawChanges.length <= 1) {\n    return rawChanges;\n  }\n\n  const result = [rawChanges[0]];\n  let prevChange = result[0];\n\n  for (let i = 1, len = rawChanges.length; i < len; i++) {\n    const currChange = rawChanges[i];\n    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength); // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\n    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n      // Merge the current change into the previous one\n      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;\n      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;\n    } else {\n      // Add the current change\n      result.push(currChange);\n      prevChange = currChange;\n    }\n  }\n\n  return result;\n}\n\nclass LineChange {\n  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.charChanges = charChanges;\n  }\n\n  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n    let originalStartLineNumber;\n    let originalEndLineNumber;\n    let modifiedStartLineNumber;\n    let modifiedEndLineNumber;\n    let charChanges = undefined;\n\n    if (diffChange.originalLength === 0) {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n      originalEndLineNumber = 0;\n    } else {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n    }\n\n    if (diffChange.modifiedLength === 0) {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n      modifiedEndLineNumber = 0;\n    } else {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    }\n\n    if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n      // Compute character changes for diff chunks of at most 20 lines...\n      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n\n      if (shouldPostProcessCharChanges) {\n        rawChanges = postProcessCharChanges(rawChanges);\n      }\n\n      charChanges = [];\n\n      for (let i = 0, length = rawChanges.length; i < length; i++) {\n        charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n      }\n    }\n\n    return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n  }\n\n}\n\nexport class DiffComputer {\n  constructor(originalLines, modifiedLines, opts) {\n    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n    this.originalLines = originalLines;\n    this.modifiedLines = modifiedLines;\n    this.original = new LineSequence(originalLines);\n    this.modified = new LineSequence(modifiedLines);\n    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n  }\n\n  computeDiff() {\n    if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n      // empty original => fast path\n      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n        return {\n          quitEarly: false,\n          changes: []\n        };\n      }\n\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: 1,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: this.modified.lines.length,\n          charChanges: [{\n            modifiedEndColumn: 0,\n            modifiedEndLineNumber: 0,\n            modifiedStartColumn: 0,\n            modifiedStartLineNumber: 0,\n            originalEndColumn: 0,\n            originalEndLineNumber: 0,\n            originalStartColumn: 0,\n            originalStartLineNumber: 0\n          }]\n        }]\n      };\n    }\n\n    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n      // empty modified => fast path\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: this.original.lines.length,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: 1,\n          charChanges: [{\n            modifiedEndColumn: 0,\n            modifiedEndLineNumber: 0,\n            modifiedStartColumn: 0,\n            modifiedStartLineNumber: 0,\n            originalEndColumn: 0,\n            originalEndLineNumber: 0,\n            originalStartColumn: 0,\n            originalStartLineNumber: 0\n          }]\n        }]\n      };\n    }\n\n    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n    const rawChanges = diffResult.changes;\n    const quitEarly = diffResult.quitEarly; // The diff is always computed with ignoring trim whitespace\n    // This ensures we get the prettiest diff\n\n    if (this.shouldIgnoreTrimWhitespace) {\n      const lineChanges = [];\n\n      for (let i = 0, length = rawChanges.length; i < length; i++) {\n        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n      }\n\n      return {\n        quitEarly: quitEarly,\n        changes: lineChanges\n      };\n    } // Need to post-process and introduce changes where the trim whitespace is different\n    // Note that we are looping starting at -1 to also cover the lines before the first change\n\n\n    const result = [];\n    let originalLineIndex = 0;\n    let modifiedLineIndex = 0;\n\n    for (let i = -1\n    /* !!!! */\n    , len = rawChanges.length; i < len; i++) {\n      const nextChange = i + 1 < len ? rawChanges[i + 1] : null;\n      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;\n      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;\n\n      while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n        const originalLine = this.originalLines[originalLineIndex];\n        const modifiedLine = this.modifiedLines[modifiedLineIndex];\n\n        if (originalLine !== modifiedLine) {\n          // These lines differ only in trim whitespace\n          // Check the leading whitespace\n          {\n            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n\n            while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n\n              originalStartColumn--;\n              modifiedStartColumn--;\n            }\n\n            if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n            }\n          } // Check the trailing whitespace\n\n          {\n            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n            const originalMaxColumn = originalLine.length + 1;\n            const modifiedMaxColumn = modifiedLine.length + 1;\n\n            while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n\n              originalEndColumn++;\n              modifiedEndColumn++;\n            }\n\n            if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n            }\n          }\n        }\n\n        originalLineIndex++;\n        modifiedLineIndex++;\n      }\n\n      if (nextChange) {\n        // Emit the actual change\n        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n        originalLineIndex += nextChange.originalLength;\n        modifiedLineIndex += nextChange.modifiedLength;\n      }\n    }\n\n    return {\n      quitEarly: quitEarly,\n      changes: result\n    };\n  }\n\n  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n      // Merged into previous\n      return;\n    }\n\n    let charChanges = undefined;\n\n    if (this.shouldComputeCharChanges) {\n      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n    }\n\n    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n  }\n\n  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    const len = result.length;\n\n    if (len === 0) {\n      return false;\n    }\n\n    const prevChange = result[len - 1];\n\n    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n      // Don't merge with inserts/deletes\n      return false;\n    }\n\n    if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n      prevChange.originalEndLineNumber = originalLineNumber;\n      prevChange.modifiedEndLineNumber = modifiedLineNumber;\n\n      if (this.shouldComputeCharChanges && prevChange.charChanges) {\n        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n  const r = strings.firstNonWhitespaceIndex(txt);\n\n  if (r === -1) {\n    return defaultValue;\n  }\n\n  return r + 1;\n}\n\nfunction getLastNonBlankColumn(txt, defaultValue) {\n  const r = strings.lastNonWhitespaceIndex(txt);\n\n  if (r === -1) {\n    return defaultValue;\n  }\n\n  return r + 2;\n}\n\nfunction createContinueProcessingPredicate(maximumRuntime) {\n  if (maximumRuntime === 0) {\n    return () => true;\n  }\n\n  const startTime = Date.now();\n  return () => {\n    return Date.now() - startTime < maximumRuntime;\n  };\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js"],"names":["LcsDiff","strings","MINIMUM_MATCHING_CHARACTER_LENGTH","computeDiff","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","diffAlgo","ComputeDiff","LineSequence","constructor","lines","startColumns","endColumns","i","length","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","getElements","elements","len","substring","getStrictElement","index","getStartLineNumber","getEndLineNumber","createCharSequence","shouldIgnoreTrimWhitespace","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","startColumn","endColumn","col","charCodeAt","CharSequence","_charCodes","_lineNumbers","_columns","getStartColumn","getEndColumn","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","createFromDiffChange","diffChange","originalCharSequence","modifiedCharSequence","originalLength","originalStart","modifiedLength","modifiedStart","postProcessCharChanges","rawChanges","result","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","matchingLength","Math","min","push","LineChange","charChanges","createFromDiffResult","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","undefined","changes","DiffComputer","originalLines","modifiedLines","opts","shouldMakePrettyDiff","original","modified","continueLineDiff","createContinueProcessingPredicate","maxComputationTime","quitEarly","diffResult","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","originalChar","modifiedChar","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","firstNonWhitespaceIndex","lastNonWhitespaceIndex","maximumRuntime","startTime","Date","now"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport * as strings from '../../../base/common/strings.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        return this._columns[i];\n    }\n    getEndLineNumber(i) {\n        return this._lineNumbers[i];\n    }\n    getEndColumn(i) {\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        let originalStartLineNumber;\n        let originalStartColumn;\n        let originalEndLineNumber;\n        let originalEndColumn;\n        let modifiedStartLineNumber;\n        let modifiedStartColumn;\n        let modifiedEndLineNumber;\n        let modifiedEndColumn;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = 0;\n            originalStartColumn = 0;\n            originalEndLineNumber = 0;\n            originalEndColumn = 0;\n        }\n        else {\n            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = 0;\n            modifiedStartColumn = 0;\n            modifiedEndLineNumber = 0;\n            modifiedEndColumn = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n            if (shouldPostProcessCharChanges) {\n                rawChanges = postProcessCharChanges(rawChanges);\n            }\n            charChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n"]},"metadata":{},"sourceType":"module"}