{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js'; // const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\n\nexport const AverageBufferSize = 65535;\nexport function createUintArray(arr) {\n  let r;\n\n  if (arr[arr.length - 1] < 65536) {\n    r = new Uint16Array(arr.length);\n  } else {\n    r = new Uint32Array(arr.length);\n  }\n\n  r.set(arr, 0);\n  return r;\n}\nexport class LineStarts {\n  constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n    this.lineStarts = lineStarts;\n    this.cr = cr;\n    this.lf = lf;\n    this.crlf = crlf;\n    this.isBasicASCII = isBasicASCII;\n  }\n\n}\nexport function createLineStartsFast(str, readonly = true) {\n  const r = [0];\n  let rLength = 1;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    const chr = str.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n      if (i + 1 < len && str.charCodeAt(i + 1) === 10\n      /* LineFeed */\n      ) {\n        // \\r\\n... case\n        r[rLength++] = i + 2;\n        i++; // skip \\n\n      } else {\n        // \\r... case\n        r[rLength++] = i + 1;\n      }\n    } else if (chr === 10\n    /* LineFeed */\n    ) {\n      r[rLength++] = i + 1;\n    }\n  }\n\n  if (readonly) {\n    return createUintArray(r);\n  } else {\n    return r;\n  }\n}\nexport function createLineStarts(r, str) {\n  r.length = 0;\n  r[0] = 0;\n  let rLength = 1;\n  let cr = 0,\n      lf = 0,\n      crlf = 0;\n  let isBasicASCII = true;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    const chr = str.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n      if (i + 1 < len && str.charCodeAt(i + 1) === 10\n      /* LineFeed */\n      ) {\n        // \\r\\n... case\n        crlf++;\n        r[rLength++] = i + 2;\n        i++; // skip \\n\n      } else {\n        cr++; // \\r... case\n\n        r[rLength++] = i + 1;\n      }\n    } else if (chr === 10\n    /* LineFeed */\n    ) {\n      lf++;\n      r[rLength++] = i + 1;\n    } else {\n      if (isBasicASCII) {\n        if (chr !== 9\n        /* Tab */\n        && (chr < 32 || chr > 126)) {\n          isBasicASCII = false;\n        }\n      }\n    }\n  }\n\n  const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n  r.length = 0;\n  return result;\n}\nexport class Piece {\n  constructor(bufferIndex, start, end, lineFeedCnt, length) {\n    this.bufferIndex = bufferIndex;\n    this.start = start;\n    this.end = end;\n    this.lineFeedCnt = lineFeedCnt;\n    this.length = length;\n  }\n\n}\nexport class StringBuffer {\n  constructor(buffer, lineStarts) {\n    this.buffer = buffer;\n    this.lineStarts = lineStarts;\n  }\n\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\n\nclass PieceTreeSnapshot {\n  constructor(tree, BOM) {\n    this._pieces = [];\n    this._tree = tree;\n    this._BOM = BOM;\n    this._index = 0;\n\n    if (tree.root !== SENTINEL) {\n      tree.iterate(tree.root, node => {\n        if (node !== SENTINEL) {\n          this._pieces.push(node.piece);\n        }\n\n        return true;\n      });\n    }\n  }\n\n  read() {\n    if (this._pieces.length === 0) {\n      if (this._index === 0) {\n        this._index++;\n        return this._BOM;\n      } else {\n        return null;\n      }\n    }\n\n    if (this._index > this._pieces.length - 1) {\n      return null;\n    }\n\n    if (this._index === 0) {\n      return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n\n    return this._tree.getPieceContent(this._pieces[this._index++]);\n  }\n\n}\n\nclass PieceTreeSearchCache {\n  constructor(limit) {\n    this._limit = limit;\n    this._cache = [];\n  }\n\n  get(offset) {\n    for (let i = this._cache.length - 1; i >= 0; i--) {\n      const nodePos = this._cache[i];\n\n      if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n        return nodePos;\n      }\n    }\n\n    return null;\n  }\n\n  get2(lineNumber) {\n    for (let i = this._cache.length - 1; i >= 0; i--) {\n      const nodePos = this._cache[i];\n\n      if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n        return nodePos;\n      }\n    }\n\n    return null;\n  }\n\n  set(nodePosition) {\n    if (this._cache.length >= this._limit) {\n      this._cache.shift();\n    }\n\n    this._cache.push(nodePosition);\n  }\n\n  validate(offset) {\n    let hasInvalidVal = false;\n    const tmp = this._cache;\n\n    for (let i = 0; i < tmp.length; i++) {\n      const nodePos = tmp[i];\n\n      if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n        tmp[i] = null;\n        hasInvalidVal = true;\n        continue;\n      }\n    }\n\n    if (hasInvalidVal) {\n      const newArr = [];\n\n      for (const entry of tmp) {\n        if (entry !== null) {\n          newArr.push(entry);\n        }\n      }\n\n      this._cache = newArr;\n    }\n  }\n\n}\n\nexport class PieceTreeBase {\n  constructor(chunks, eol, eolNormalized) {\n    this.create(chunks, eol, eolNormalized);\n  }\n\n  create(chunks, eol, eolNormalized) {\n    this._buffers = [new StringBuffer('', [0])];\n    this._lastChangeBufferPos = {\n      line: 0,\n      column: 0\n    };\n    this.root = SENTINEL;\n    this._lineCnt = 1;\n    this._length = 0;\n    this._EOL = eol;\n    this._EOLLength = eol.length;\n    this._EOLNormalized = eolNormalized;\n    let lastNode = null;\n\n    for (let i = 0, len = chunks.length; i < len; i++) {\n      if (chunks[i].buffer.length > 0) {\n        if (!chunks[i].lineStarts) {\n          chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n        }\n\n        const piece = new Piece(i + 1, {\n          line: 0,\n          column: 0\n        }, {\n          line: chunks[i].lineStarts.length - 1,\n          column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1]\n        }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n\n        this._buffers.push(chunks[i]);\n\n        lastNode = this.rbInsertRight(lastNode, piece);\n      }\n    }\n\n    this._searchCache = new PieceTreeSearchCache(1);\n    this._lastVisitedLine = {\n      lineNumber: 0,\n      value: ''\n    };\n    this.computeBufferMetadata();\n  }\n\n  normalizeEOL(eol) {\n    const averageBufferSize = AverageBufferSize;\n    const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n    const max = min * 2;\n    let tempChunk = '';\n    let tempChunkLen = 0;\n    const chunks = [];\n    this.iterate(this.root, node => {\n      const str = this.getNodeContent(node);\n      const len = str.length;\n\n      if (tempChunkLen <= min || tempChunkLen + len < max) {\n        tempChunk += str;\n        tempChunkLen += len;\n        return true;\n      } // flush anyways\n\n\n      const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n      chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n      tempChunk = str;\n      tempChunkLen = len;\n      return true;\n    });\n\n    if (tempChunkLen > 0) {\n      const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n      chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n    }\n\n    this.create(chunks, eol, true);\n  } // #region Buffer API\n\n\n  getEOL() {\n    return this._EOL;\n  }\n\n  setEOL(newEOL) {\n    this._EOL = newEOL;\n    this._EOLLength = this._EOL.length;\n    this.normalizeEOL(newEOL);\n  }\n\n  createSnapshot(BOM) {\n    return new PieceTreeSnapshot(this, BOM);\n  }\n\n  getOffsetAt(lineNumber, column) {\n    let leftLen = 0; // inorder\n\n    let x = this.root;\n\n    while (x !== SENTINEL) {\n      if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n        x = x.left;\n      } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n        leftLen += x.size_left; // lineNumber >= 2\n\n        const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n        return leftLen += accumualtedValInCurrentIndex + column - 1;\n      } else {\n        lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n        leftLen += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    }\n\n    return leftLen;\n  }\n\n  getPositionAt(offset) {\n    offset = Math.floor(offset);\n    offset = Math.max(0, offset);\n    let x = this.root;\n    let lfCnt = 0;\n    const originalOffset = offset;\n\n    while (x !== SENTINEL) {\n      if (x.size_left !== 0 && x.size_left >= offset) {\n        x = x.left;\n      } else if (x.size_left + x.piece.length >= offset) {\n        const out = this.getIndexOf(x, offset - x.size_left);\n        lfCnt += x.lf_left + out.index;\n\n        if (out.index === 0) {\n          const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n          const column = originalOffset - lineStartOffset;\n          return new Position(lfCnt + 1, column + 1);\n        }\n\n        return new Position(lfCnt + 1, out.remainder + 1);\n      } else {\n        offset -= x.size_left + x.piece.length;\n        lfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n        if (x.right === SENTINEL) {\n          // last node\n          const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n          const column = originalOffset - offset - lineStartOffset;\n          return new Position(lfCnt + 1, column + 1);\n        } else {\n          x = x.right;\n        }\n      }\n    }\n\n    return new Position(1, 1);\n  }\n\n  getValueInRange(range, eol) {\n    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n      return '';\n    }\n\n    const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n    const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n    const value = this.getValueInRange2(startPosition, endPosition);\n\n    if (eol) {\n      if (eol !== this._EOL || !this._EOLNormalized) {\n        return value.replace(/\\r\\n|\\r|\\n/g, eol);\n      }\n\n      if (eol === this.getEOL() && this._EOLNormalized) {\n        if (eol === '\\r\\n') {}\n\n        return value;\n      }\n\n      return value.replace(/\\r\\n|\\r|\\n/g, eol);\n    }\n\n    return value;\n  }\n\n  getValueInRange2(startPosition, endPosition) {\n    if (startPosition.node === endPosition.node) {\n      const node = startPosition.node;\n      const buffer = this._buffers[node.piece.bufferIndex].buffer;\n      const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n      return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n    }\n\n    let x = startPosition.node;\n    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n    let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n    x = x.next();\n\n    while (x !== SENTINEL) {\n      const buffer = this._buffers[x.piece.bufferIndex].buffer;\n      const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n      if (x === endPosition.node) {\n        ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n        break;\n      } else {\n        ret += buffer.substr(startOffset, x.piece.length);\n      }\n\n      x = x.next();\n    }\n\n    return ret;\n  }\n\n  getLinesContent() {\n    const lines = [];\n    let linesLength = 0;\n    let currentLine = '';\n    let danglingCR = false;\n    this.iterate(this.root, node => {\n      if (node === SENTINEL) {\n        return true;\n      }\n\n      const piece = node.piece;\n      let pieceLength = piece.length;\n\n      if (pieceLength === 0) {\n        return true;\n      }\n\n      const buffer = this._buffers[piece.bufferIndex].buffer;\n      const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n      const pieceStartLine = piece.start.line;\n      const pieceEndLine = piece.end.line;\n      let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n\n      if (danglingCR) {\n        if (buffer.charCodeAt(pieceStartOffset) === 10\n        /* LineFeed */\n        ) {\n          // pretend the \\n was in the previous piece..\n          pieceStartOffset++;\n          pieceLength--;\n        }\n\n        lines[linesLength++] = currentLine;\n        currentLine = '';\n        danglingCR = false;\n\n        if (pieceLength === 0) {\n          return true;\n        }\n      }\n\n      if (pieceStartLine === pieceEndLine) {\n        // this piece has no new lines\n        if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13\n        /* CarriageReturn */\n        ) {\n          danglingCR = true;\n          currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n        } else {\n          currentLine += buffer.substr(pieceStartOffset, pieceLength);\n        }\n\n        return true;\n      } // add the text before the first line start in this piece\n\n\n      currentLine += this._EOLNormalized ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength)) : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, '');\n      lines[linesLength++] = currentLine;\n\n      for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n        currentLine = this._EOLNormalized ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength) : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, '');\n        lines[linesLength++] = currentLine;\n      }\n\n      if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13\n      /* CarriageReturn */\n      ) {\n        danglingCR = true;\n\n        if (piece.end.column === 0) {\n          // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n          linesLength--;\n        } else {\n          currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n        }\n      } else {\n        currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n      }\n\n      return true;\n    });\n\n    if (danglingCR) {\n      lines[linesLength++] = currentLine;\n      currentLine = '';\n    }\n\n    lines[linesLength++] = currentLine;\n    return lines;\n  }\n\n  getLength() {\n    return this._length;\n  }\n\n  getLineCount() {\n    return this._lineCnt;\n  }\n\n  getLineContent(lineNumber) {\n    if (this._lastVisitedLine.lineNumber === lineNumber) {\n      return this._lastVisitedLine.value;\n    }\n\n    this._lastVisitedLine.lineNumber = lineNumber;\n\n    if (lineNumber === this._lineCnt) {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n    } else if (this._EOLNormalized) {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n    } else {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n    }\n\n    return this._lastVisitedLine.value;\n  }\n\n  _getCharCode(nodePos) {\n    if (nodePos.remainder === nodePos.node.piece.length) {\n      // the char we want to fetch is at the head of next node.\n      const matchingNode = nodePos.node.next();\n\n      if (!matchingNode) {\n        return 0;\n      }\n\n      const buffer = this._buffers[matchingNode.piece.bufferIndex];\n      const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n      return buffer.buffer.charCodeAt(startOffset);\n    } else {\n      const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n      const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n      const targetOffset = startOffset + nodePos.remainder;\n      return buffer.buffer.charCodeAt(targetOffset);\n    }\n  }\n\n  getLineCharCode(lineNumber, index) {\n    const nodePos = this.nodeAt2(lineNumber, index + 1);\n    return this._getCharCode(nodePos);\n  }\n\n  getLineLength(lineNumber) {\n    if (lineNumber === this.getLineCount()) {\n      const startOffset = this.getOffsetAt(lineNumber, 1);\n      return this.getLength() - startOffset;\n    }\n\n    return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n  }\n\n  findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n    const buffer = this._buffers[node.piece.bufferIndex];\n    const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n    const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n    const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n    let m; // Reset regex to search from the beginning\n\n    const ret = {\n      line: 0,\n      column: 0\n    };\n    let searchText;\n    let offsetInBuffer;\n\n    if (searcher._wordSeparators) {\n      searchText = buffer.buffer.substring(start, end);\n\n      offsetInBuffer = offset => offset + start;\n\n      searcher.reset(0);\n    } else {\n      searchText = buffer.buffer;\n\n      offsetInBuffer = offset => offset;\n\n      searcher.reset(start);\n    }\n\n    do {\n      m = searcher.next(searchText);\n\n      if (m) {\n        if (offsetInBuffer(m.index) >= end) {\n          return resultLen;\n        }\n\n        this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n        const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n        const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n        const retEndColumn = retStartColumn + m[0].length;\n        result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n\n        if (offsetInBuffer(m.index) + m[0].length >= end) {\n          return resultLen;\n        }\n\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n\n    return resultLen;\n  }\n\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    const result = [];\n    let resultLen = 0;\n    const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n    let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n\n    if (startPosition === null) {\n      return [];\n    }\n\n    const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n\n    if (endPosition === null) {\n      return [];\n    }\n\n    let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n    const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n\n    if (startPosition.node === endPosition.node) {\n      this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n      return result;\n    }\n\n    let startLineNumber = searchRange.startLineNumber;\n    let currentNode = startPosition.node;\n\n    while (currentNode !== endPosition.node) {\n      const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n\n      if (lineBreakCnt >= 1) {\n        // last line break position\n        const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n        const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n        const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n\n        if (resultLen >= limitResultCount) {\n          return result;\n        }\n\n        startLineNumber += lineBreakCnt;\n      }\n\n      const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0; // search for the remaining content\n\n      if (startLineNumber === searchRange.endLineNumber) {\n        const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n        return result;\n      }\n\n      resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\n      if (resultLen >= limitResultCount) {\n        return result;\n      }\n\n      startLineNumber++;\n      startPosition = this.nodeAt2(startLineNumber, 1);\n      currentNode = startPosition.node;\n      start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n    }\n\n    if (startLineNumber === searchRange.endLineNumber) {\n      const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n      const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n      return result;\n    }\n\n    const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n    resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n    return result;\n  }\n\n  _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n    const wordSeparators = searchData.wordSeparators;\n\n    if (!captureMatches && searchData.simpleSearch) {\n      const searchString = searchData.simpleSearch;\n      const searchStringLen = searchString.length;\n      const textLength = text.length;\n      let lastMatchIndex = -searchStringLen;\n\n      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      }\n\n      return resultLen;\n    }\n\n    let m; // Reset regex to search from the beginning\n\n    searcher.reset(0);\n\n    do {\n      m = searcher.next(text);\n\n      if (m) {\n        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n\n    return resultLen;\n  } // #endregion\n  // #region Piece Table\n\n\n  insert(offset, value, eolNormalized = false) {\n    this._EOLNormalized = this._EOLNormalized && eolNormalized;\n    this._lastVisitedLine.lineNumber = 0;\n    this._lastVisitedLine.value = '';\n\n    if (this.root !== SENTINEL) {\n      const {\n        node,\n        remainder,\n        nodeStartOffset\n      } = this.nodeAt(offset);\n      const piece = node.piece;\n      const bufferIndex = piece.bufferIndex;\n      const insertPosInBuffer = this.positionInBuffer(node, remainder);\n\n      if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {\n        // changed buffer\n        this.appendToNode(node, value);\n        this.computeBufferMetadata();\n        return;\n      }\n\n      if (nodeStartOffset === offset) {\n        this.insertContentToNodeLeft(value, node);\n\n        this._searchCache.validate(offset);\n      } else if (nodeStartOffset + node.piece.length > offset) {\n        // we are inserting into the middle of a node.\n        const nodesToDel = [];\n        let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n          const headOfRight = this.nodeCharCodeAt(node, remainder);\n\n          if (headOfRight === 10\n          /** \\n */\n          ) {\n            const newStart = {\n              line: newRightPiece.start.line + 1,\n              column: 0\n            };\n            newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n            value += '\\n';\n          }\n        } // reuse node for content before insertion point.\n\n\n        if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n          const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\n          if (tailOfLeft === 13\n          /** \\r */\n          ) {\n            const previousPos = this.positionInBuffer(node, remainder - 1);\n            this.deleteNodeTail(node, previousPos);\n            value = '\\r' + value;\n\n            if (node.piece.length === 0) {\n              nodesToDel.push(node);\n            }\n          } else {\n            this.deleteNodeTail(node, insertPosInBuffer);\n          }\n        } else {\n          this.deleteNodeTail(node, insertPosInBuffer);\n        }\n\n        const newPieces = this.createNewPieces(value);\n\n        if (newRightPiece.length > 0) {\n          this.rbInsertRight(node, newRightPiece);\n        }\n\n        let tmpNode = node;\n\n        for (let k = 0; k < newPieces.length; k++) {\n          tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n\n        this.deleteNodes(nodesToDel);\n      } else {\n        this.insertContentToNodeRight(value, node);\n      }\n    } else {\n      // insert new node\n      const pieces = this.createNewPieces(value);\n      let node = this.rbInsertLeft(null, pieces[0]);\n\n      for (let k = 1; k < pieces.length; k++) {\n        node = this.rbInsertRight(node, pieces[k]);\n      }\n    } // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\n\n    this.computeBufferMetadata();\n  }\n\n  delete(offset, cnt) {\n    this._lastVisitedLine.lineNumber = 0;\n    this._lastVisitedLine.value = '';\n\n    if (cnt <= 0 || this.root === SENTINEL) {\n      return;\n    }\n\n    const startPosition = this.nodeAt(offset);\n    const endPosition = this.nodeAt(offset + cnt);\n    const startNode = startPosition.node;\n    const endNode = endPosition.node;\n\n    if (startNode === endNode) {\n      const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n      const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n\n      if (startPosition.nodeStartOffset === offset) {\n        if (cnt === startNode.piece.length) {\n          // delete node\n          const next = startNode.next();\n          rbDelete(this, startNode);\n          this.validateCRLFWithPrevNode(next);\n          this.computeBufferMetadata();\n          return;\n        }\n\n        this.deleteNodeHead(startNode, endSplitPosInBuffer);\n\n        this._searchCache.validate(offset);\n\n        this.validateCRLFWithPrevNode(startNode);\n        this.computeBufferMetadata();\n        return;\n      }\n\n      if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this.validateCRLFWithNextNode(startNode);\n        this.computeBufferMetadata();\n        return;\n      } // delete content in the middle, this node will be splitted to nodes\n\n\n      this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n      this.computeBufferMetadata();\n      return;\n    }\n\n    const nodesToDel = [];\n    const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n    this.deleteNodeTail(startNode, startSplitPosInBuffer);\n\n    this._searchCache.validate(offset);\n\n    if (startNode.piece.length === 0) {\n      nodesToDel.push(startNode);\n    } // update last touched node\n\n\n    const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n    this.deleteNodeHead(endNode, endSplitPosInBuffer);\n\n    if (endNode.piece.length === 0) {\n      nodesToDel.push(endNode);\n    } // delete nodes in between\n\n\n    const secondNode = startNode.next();\n\n    for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n      nodesToDel.push(node);\n    }\n\n    const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n    this.deleteNodes(nodesToDel);\n    this.validateCRLFWithNextNode(prev);\n    this.computeBufferMetadata();\n  }\n\n  insertContentToNodeLeft(value, node) {\n    // we are inserting content to the beginning of node\n    const nodesToDel = [];\n\n    if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n      // move `\\n` to new node.\n      const piece = node.piece;\n      const newStart = {\n        line: piece.start.line + 1,\n        column: 0\n      };\n      const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n      node.piece = nPiece;\n      value += '\\n';\n      updateTreeMetadata(this, node, -1, -1);\n\n      if (node.piece.length === 0) {\n        nodesToDel.push(node);\n      }\n    }\n\n    const newPieces = this.createNewPieces(value);\n    let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\n    for (let k = newPieces.length - 2; k >= 0; k--) {\n      newNode = this.rbInsertLeft(newNode, newPieces[k]);\n    }\n\n    this.validateCRLFWithPrevNode(newNode);\n    this.deleteNodes(nodesToDel);\n  }\n\n  insertContentToNodeRight(value, node) {\n    // we are inserting to the right of this node.\n    if (this.adjustCarriageReturnFromNext(value, node)) {\n      // move \\n to the new node.\n      value += '\\n';\n    }\n\n    const newPieces = this.createNewPieces(value);\n    const newNode = this.rbInsertRight(node, newPieces[0]);\n    let tmpNode = newNode;\n\n    for (let k = 1; k < newPieces.length; k++) {\n      tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n    }\n\n    this.validateCRLFWithPrevNode(newNode);\n  }\n\n  positionInBuffer(node, remainder, ret) {\n    const piece = node.piece;\n    const bufferIndex = node.piece.bufferIndex;\n    const lineStarts = this._buffers[bufferIndex].lineStarts;\n    const startOffset = lineStarts[piece.start.line] + piece.start.column;\n    const offset = startOffset + remainder; // binary search offset between startOffset and endOffset\n\n    let low = piece.start.line;\n    let high = piece.end.line;\n    let mid = 0;\n    let midStop = 0;\n    let midStart = 0;\n\n    while (low <= high) {\n      mid = low + (high - low) / 2 | 0;\n      midStart = lineStarts[mid];\n\n      if (mid === high) {\n        break;\n      }\n\n      midStop = lineStarts[mid + 1];\n\n      if (offset < midStart) {\n        high = mid - 1;\n      } else if (offset >= midStop) {\n        low = mid + 1;\n      } else {\n        break;\n      }\n    }\n\n    if (ret) {\n      ret.line = mid;\n      ret.column = offset - midStart;\n      return null;\n    }\n\n    return {\n      line: mid,\n      column: offset - midStart\n    };\n  }\n\n  getLineFeedCnt(bufferIndex, start, end) {\n    // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n    // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n    if (end.column === 0) {\n      return end.line - start.line;\n    }\n\n    const lineStarts = this._buffers[bufferIndex].lineStarts;\n\n    if (end.line === lineStarts.length - 1) {\n      // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n      return end.line - start.line;\n    }\n\n    const nextLineStartOffset = lineStarts[end.line + 1];\n    const endOffset = lineStarts[end.line] + end.column;\n\n    if (nextLineStartOffset > endOffset + 1) {\n      // there are more than 1 character after end, which means it can't be \\n\n      return end.line - start.line;\n    } // endOffset + 1 === nextLineStartOffset\n    // character at endOffset is \\n, so we check the character before first\n    // if character at endOffset is \\r, end.column is 0 and we can't get here.\n\n\n    const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\n    const buffer = this._buffers[bufferIndex].buffer;\n\n    if (buffer.charCodeAt(previousCharOffset) === 13) {\n      return end.line - start.line + 1;\n    } else {\n      return end.line - start.line;\n    }\n  }\n\n  offsetInBuffer(bufferIndex, cursor) {\n    const lineStarts = this._buffers[bufferIndex].lineStarts;\n    return lineStarts[cursor.line] + cursor.column;\n  }\n\n  deleteNodes(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      rbDelete(this, nodes[i]);\n    }\n  }\n\n  createNewPieces(text) {\n    if (text.length > AverageBufferSize) {\n      // the content is large, operations like substring, charCode becomes slow\n      // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n      const newPieces = [];\n\n      while (text.length > AverageBufferSize) {\n        const lastChar = text.charCodeAt(AverageBufferSize - 1);\n        let splitText;\n\n        if (lastChar === 13\n        /* CarriageReturn */\n        || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n          // last character is \\r or a high surrogate => keep it back\n          splitText = text.substring(0, AverageBufferSize - 1);\n          text = text.substring(AverageBufferSize - 1);\n        } else {\n          splitText = text.substring(0, AverageBufferSize);\n          text = text.substring(AverageBufferSize);\n        }\n\n        const lineStarts = createLineStartsFast(splitText);\n        newPieces.push(new Piece(this._buffers.length,\n        /* buffer index */\n        {\n          line: 0,\n          column: 0\n        }, {\n          line: lineStarts.length - 1,\n          column: splitText.length - lineStarts[lineStarts.length - 1]\n        }, lineStarts.length - 1, splitText.length));\n\n        this._buffers.push(new StringBuffer(splitText, lineStarts));\n      }\n\n      const lineStarts = createLineStartsFast(text);\n      newPieces.push(new Piece(this._buffers.length,\n      /* buffer index */\n      {\n        line: 0,\n        column: 0\n      }, {\n        line: lineStarts.length - 1,\n        column: text.length - lineStarts[lineStarts.length - 1]\n      }, lineStarts.length - 1, text.length));\n\n      this._buffers.push(new StringBuffer(text, lineStarts));\n\n      return newPieces;\n    }\n\n    let startOffset = this._buffers[0].buffer.length;\n    const lineStarts = createLineStartsFast(text, false);\n    let start = this._lastChangeBufferPos;\n\n    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n    ) {\n      this._lastChangeBufferPos = {\n        line: this._lastChangeBufferPos.line,\n        column: this._lastChangeBufferPos.column + 1\n      };\n      start = this._lastChangeBufferPos;\n\n      for (let i = 0; i < lineStarts.length; i++) {\n        lineStarts[i] += startOffset + 1;\n      }\n\n      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n      this._buffers[0].buffer += '_' + text;\n      startOffset += 1;\n    } else {\n      if (startOffset !== 0) {\n        for (let i = 0; i < lineStarts.length; i++) {\n          lineStarts[i] += startOffset;\n        }\n      }\n\n      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n      this._buffers[0].buffer += text;\n    }\n\n    const endOffset = this._buffers[0].buffer.length;\n    const endIndex = this._buffers[0].lineStarts.length - 1;\n    const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n    const endPos = {\n      line: endIndex,\n      column: endColumn\n    };\n    const newPiece = new Piece(0,\n    /** todo@peng */\n    start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n    this._lastChangeBufferPos = endPos;\n    return [newPiece];\n  }\n\n  getLineRawContent(lineNumber, endOffset = 0) {\n    let x = this.root;\n    let ret = '';\n\n    const cache = this._searchCache.get2(lineNumber);\n\n    if (cache) {\n      x = cache.node;\n      const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n      const buffer = this._buffers[x.piece.bufferIndex].buffer;\n      const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n      if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n        ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n      } else {\n        const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n        return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n      }\n    } else {\n      let nodeStartOffset = 0;\n      const originalLineNumber = lineNumber;\n\n      while (x !== SENTINEL) {\n        if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n          x = x.left;\n        } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n          const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n          const buffer = this._buffers[x.piece.bufferIndex].buffer;\n          const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n          nodeStartOffset += x.size_left;\n\n          this._searchCache.set({\n            node: x,\n            nodeStartOffset,\n            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n          });\n\n          return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n        } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n          const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          const buffer = this._buffers[x.piece.bufferIndex].buffer;\n          const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n          ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n          break;\n        } else {\n          lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n          nodeStartOffset += x.size_left + x.piece.length;\n          x = x.right;\n        }\n      }\n    } // search in order, to find the node contains end column\n\n\n    x = x.next();\n\n    while (x !== SENTINEL) {\n      const buffer = this._buffers[x.piece.bufferIndex].buffer;\n\n      if (x.piece.lineFeedCnt > 0) {\n        const accumulatedValue = this.getAccumulatedValue(x, 0);\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n        return ret;\n      } else {\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        ret += buffer.substr(startOffset, x.piece.length);\n      }\n\n      x = x.next();\n    }\n\n    return ret;\n  }\n\n  computeBufferMetadata() {\n    let x = this.root;\n    let lfCnt = 1;\n    let len = 0;\n\n    while (x !== SENTINEL) {\n      lfCnt += x.lf_left + x.piece.lineFeedCnt;\n      len += x.size_left + x.piece.length;\n      x = x.right;\n    }\n\n    this._lineCnt = lfCnt;\n    this._length = len;\n\n    this._searchCache.validate(this._length);\n  } // #region node operations\n\n\n  getIndexOf(node, accumulatedValue) {\n    const piece = node.piece;\n    const pos = this.positionInBuffer(node, accumulatedValue);\n    const lineCnt = pos.line - piece.start.line;\n\n    if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n      // we are checking the end of this node, so a CRLF check is necessary.\n      const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n\n      if (realLineCnt !== lineCnt) {\n        // aha yes, CRLF\n        return {\n          index: realLineCnt,\n          remainder: 0\n        };\n      }\n    }\n\n    return {\n      index: lineCnt,\n      remainder: pos.column\n    };\n  }\n\n  getAccumulatedValue(node, index) {\n    if (index < 0) {\n      return 0;\n    }\n\n    const piece = node.piece;\n    const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n    const expectedLineStartIndex = piece.start.line + index + 1;\n\n    if (expectedLineStartIndex > piece.end.line) {\n      return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n    } else {\n      return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n    }\n  }\n\n  deleteNodeTail(node, pos) {\n    const piece = node.piece;\n    const originalLFCnt = piece.lineFeedCnt;\n    const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n    const newEnd = pos;\n    const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n    const lf_delta = newLineFeedCnt - originalLFCnt;\n    const size_delta = newEndOffset - originalEndOffset;\n    const newLength = piece.length + size_delta;\n    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, size_delta, lf_delta);\n  }\n\n  deleteNodeHead(node, pos) {\n    const piece = node.piece;\n    const originalLFCnt = piece.lineFeedCnt;\n    const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n    const newStart = pos;\n    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n    const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n    const lf_delta = newLineFeedCnt - originalLFCnt;\n    const size_delta = originalStartOffset - newStartOffset;\n    const newLength = piece.length + size_delta;\n    node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, size_delta, lf_delta);\n  }\n\n  shrinkNode(node, start, end) {\n    const piece = node.piece;\n    const originalStartPos = piece.start;\n    const originalEndPos = piece.end; // old piece, originalStartPos, start\n\n    const oldLength = piece.length;\n    const oldLFCnt = piece.lineFeedCnt;\n    const newEnd = start;\n    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n    const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt); // new right piece, end, originalEndPos\n\n    const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n    const newNode = this.rbInsertRight(node, newPiece);\n    this.validateCRLFWithPrevNode(newNode);\n  }\n\n  appendToNode(node, value) {\n    if (this.adjustCarriageReturnFromNext(value, node)) {\n      value += '\\n';\n    }\n\n    const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n    const startOffset = this._buffers[0].buffer.length;\n    this._buffers[0].buffer += value;\n    const lineStarts = createLineStartsFast(value, false);\n\n    for (let i = 0; i < lineStarts.length; i++) {\n      lineStarts[i] += startOffset;\n    }\n\n    if (hitCRLF) {\n      const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n\n      this._buffers[0].lineStarts.pop(); // _lastChangeBufferPos is already wrong\n\n\n      this._lastChangeBufferPos = {\n        line: this._lastChangeBufferPos.line - 1,\n        column: startOffset - prevStartOffset\n      };\n    }\n\n    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n    const endIndex = this._buffers[0].lineStarts.length - 1;\n    const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n    const newEnd = {\n      line: endIndex,\n      column: endColumn\n    };\n    const newLength = node.piece.length + value.length;\n    const oldLineFeedCnt = node.piece.lineFeedCnt;\n    const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n    const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n    node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n    this._lastChangeBufferPos = newEnd;\n    updateTreeMetadata(this, node, value.length, lf_delta);\n  }\n\n  nodeAt(offset) {\n    let x = this.root;\n\n    const cache = this._searchCache.get(offset);\n\n    if (cache) {\n      return {\n        node: cache.node,\n        nodeStartOffset: cache.nodeStartOffset,\n        remainder: offset - cache.nodeStartOffset\n      };\n    }\n\n    let nodeStartOffset = 0;\n\n    while (x !== SENTINEL) {\n      if (x.size_left > offset) {\n        x = x.left;\n      } else if (x.size_left + x.piece.length >= offset) {\n        nodeStartOffset += x.size_left;\n        const ret = {\n          node: x,\n          remainder: offset - x.size_left,\n          nodeStartOffset\n        };\n\n        this._searchCache.set(ret);\n\n        return ret;\n      } else {\n        offset -= x.size_left + x.piece.length;\n        nodeStartOffset += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    }\n\n    return null;\n  }\n\n  nodeAt2(lineNumber, column) {\n    let x = this.root;\n    let nodeStartOffset = 0;\n\n    while (x !== SENTINEL) {\n      if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n        x = x.left;\n      } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n        const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n        const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n        nodeStartOffset += x.size_left;\n        return {\n          node: x,\n          remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n          nodeStartOffset\n        };\n      } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n        const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\n        if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n          return {\n            node: x,\n            remainder: prevAccumualtedValue + column - 1,\n            nodeStartOffset\n          };\n        } else {\n          column -= x.piece.length - prevAccumualtedValue;\n          break;\n        }\n      } else {\n        lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n        nodeStartOffset += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    } // search in order, to find the node contains position.column\n\n\n    x = x.next();\n\n    while (x !== SENTINEL) {\n      if (x.piece.lineFeedCnt > 0) {\n        const accumulatedValue = this.getAccumulatedValue(x, 0);\n        const nodeStartOffset = this.offsetOfNode(x);\n        return {\n          node: x,\n          remainder: Math.min(column - 1, accumulatedValue),\n          nodeStartOffset\n        };\n      } else {\n        if (x.piece.length >= column - 1) {\n          const nodeStartOffset = this.offsetOfNode(x);\n          return {\n            node: x,\n            remainder: column - 1,\n            nodeStartOffset\n          };\n        } else {\n          column -= x.piece.length;\n        }\n      }\n\n      x = x.next();\n    }\n\n    return null;\n  }\n\n  nodeCharCodeAt(node, offset) {\n    if (node.piece.lineFeedCnt < 1) {\n      return -1;\n    }\n\n    const buffer = this._buffers[node.piece.bufferIndex];\n    const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n    return buffer.buffer.charCodeAt(newOffset);\n  }\n\n  offsetOfNode(node) {\n    if (!node) {\n      return 0;\n    }\n\n    let pos = node.size_left;\n\n    while (node !== this.root) {\n      if (node.parent.right === node) {\n        pos += node.parent.size_left + node.parent.piece.length;\n      }\n\n      node = node.parent;\n    }\n\n    return pos;\n  } // #endregion\n  // #region CRLF\n\n\n  shouldCheckCRLF() {\n    return !(this._EOLNormalized && this._EOL === '\\n');\n  }\n\n  startWithLF(val) {\n    if (typeof val === 'string') {\n      return val.charCodeAt(0) === 10;\n    }\n\n    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n      return false;\n    }\n\n    const piece = val.piece;\n    const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n    const line = piece.start.line;\n    const startOffset = lineStarts[line] + piece.start.column;\n\n    if (line === lineStarts.length - 1) {\n      // last line, so there is no line feed at the end of this line\n      return false;\n    }\n\n    const nextLineOffset = lineStarts[line + 1];\n\n    if (nextLineOffset > startOffset + 1) {\n      return false;\n    }\n\n    return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n  }\n\n  endWithCR(val) {\n    if (typeof val === 'string') {\n      return val.charCodeAt(val.length - 1) === 13;\n    }\n\n    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n      return false;\n    }\n\n    return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n  }\n\n  validateCRLFWithPrevNode(nextNode) {\n    if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n      const node = nextNode.prev();\n\n      if (this.endWithCR(node)) {\n        this.fixCRLF(node, nextNode);\n      }\n    }\n  }\n\n  validateCRLFWithNextNode(node) {\n    if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n      const nextNode = node.next();\n\n      if (this.startWithLF(nextNode)) {\n        this.fixCRLF(node, nextNode);\n      }\n    }\n  }\n\n  fixCRLF(prev, next) {\n    const nodesToDel = []; // update node\n\n    const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n    let newEnd;\n\n    if (prev.piece.end.column === 0) {\n      // it means, last line ends with \\r, not \\r\\n\n      newEnd = {\n        line: prev.piece.end.line - 1,\n        column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1\n      };\n    } else {\n      // \\r\\n\n      newEnd = {\n        line: prev.piece.end.line,\n        column: prev.piece.end.column - 1\n      };\n    }\n\n    const prevNewLength = prev.piece.length - 1;\n    const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n    prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n    updateTreeMetadata(this, prev, -1, -1);\n\n    if (prev.piece.length === 0) {\n      nodesToDel.push(prev);\n    } // update nextNode\n\n\n    const newStart = {\n      line: next.piece.start.line + 1,\n      column: 0\n    };\n    const newLength = next.piece.length - 1;\n    const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n    next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, next, -1, -1);\n\n    if (next.piece.length === 0) {\n      nodesToDel.push(next);\n    } // create new piece which contains \\r\\n\n\n\n    const pieces = this.createNewPieces('\\r\\n');\n    this.rbInsertRight(prev, pieces[0]); // delete empty nodes\n\n    for (let i = 0; i < nodesToDel.length; i++) {\n      rbDelete(this, nodesToDel[i]);\n    }\n  }\n\n  adjustCarriageReturnFromNext(value, node) {\n    if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n      const nextNode = node.next();\n\n      if (this.startWithLF(nextNode)) {\n        // move `\\n` forward\n        value += '\\n';\n\n        if (nextNode.piece.length === 1) {\n          rbDelete(this, nextNode);\n        } else {\n          const piece = nextNode.piece;\n          const newStart = {\n            line: piece.start.line + 1,\n            column: 0\n          };\n          const newLength = piece.length - 1;\n          const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n          nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n          updateTreeMetadata(this, nextNode, -1, -1);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  } // #endregion\n  // #endregion\n  // #region Tree operations\n\n\n  iterate(node, callback) {\n    if (node === SENTINEL) {\n      return callback(SENTINEL);\n    }\n\n    const leftRet = this.iterate(node.left, callback);\n\n    if (!leftRet) {\n      return leftRet;\n    }\n\n    return callback(node) && this.iterate(node.right, callback);\n  }\n\n  getNodeContent(node) {\n    if (node === SENTINEL) {\n      return '';\n    }\n\n    const buffer = this._buffers[node.piece.bufferIndex];\n    let currentContent;\n    const piece = node.piece;\n    const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n    const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n    currentContent = buffer.buffer.substring(startOffset, endOffset);\n    return currentContent;\n  }\n\n  getPieceContent(piece) {\n    const buffer = this._buffers[piece.bufferIndex];\n    const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n    const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n    const currentContent = buffer.buffer.substring(startOffset, endOffset);\n    return currentContent;\n  }\n  /**\n   *      node              node\n   *     /  \\              /  \\\n   *    a   b    <----   a    b\n   *                         /\n   *                        z\n   */\n\n\n  rbInsertRight(node, p) {\n    const z = new TreeNode(p, 1\n    /* Red */\n    );\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    z.parent = SENTINEL;\n    z.size_left = 0;\n    z.lf_left = 0;\n    const x = this.root;\n\n    if (x === SENTINEL) {\n      this.root = z;\n      z.color = 0\n      /* Black */\n      ;\n    } else if (node.right === SENTINEL) {\n      node.right = z;\n      z.parent = node;\n    } else {\n      const nextNode = leftest(node.right);\n      nextNode.left = z;\n      z.parent = nextNode;\n    }\n\n    fixInsert(this, z);\n    return z;\n  }\n  /**\n   *      node              node\n   *     /  \\              /  \\\n   *    a   b     ---->   a    b\n   *                       \\\n   *                        z\n   */\n\n\n  rbInsertLeft(node, p) {\n    const z = new TreeNode(p, 1\n    /* Red */\n    );\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    z.parent = SENTINEL;\n    z.size_left = 0;\n    z.lf_left = 0;\n\n    if (this.root === SENTINEL) {\n      this.root = z;\n      z.color = 0\n      /* Black */\n      ;\n    } else if (node.left === SENTINEL) {\n      node.left = z;\n      z.parent = node;\n    } else {\n      const prevNode = righttest(node.left); // a\n\n      prevNode.right = z;\n      z.parent = prevNode;\n    }\n\n    fixInsert(this, z);\n    return z;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js"],"names":["Position","Range","FindMatch","SENTINEL","TreeNode","fixInsert","leftest","rbDelete","righttest","updateTreeMetadata","Searcher","createFindMatch","isValidMatch","AverageBufferSize","createUintArray","arr","r","length","Uint16Array","Uint32Array","set","LineStarts","constructor","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","str","readonly","rLength","i","len","chr","charCodeAt","createLineStarts","result","Piece","bufferIndex","start","end","lineFeedCnt","StringBuffer","buffer","PieceTreeSnapshot","tree","BOM","_pieces","_tree","_BOM","_index","root","iterate","node","push","piece","read","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","get","offset","nodePos","nodeStartOffset","get2","lineNumber","nodeStartLineNumber","nodePosition","shift","validate","hasInvalidVal","tmp","parent","newArr","entry","PieceTreeBase","chunks","eol","eolNormalized","create","_buffers","_lastChangeBufferPos","line","column","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","value","computeBufferMetadata","normalizeEOL","averageBufferSize","min","Math","floor","max","tempChunk","tempChunkLen","getNodeContent","text","replace","getEOL","setEOL","newEOL","createSnapshot","getOffsetAt","leftLen","x","left","lf_left","size_left","accumualtedValInCurrentIndex","getAccumulatedValue","right","getPositionAt","lfCnt","originalOffset","out","getIndexOf","index","lineStartOffset","remainder","getValueInRange","range","startLineNumber","endLineNumber","startColumn","endColumn","startPosition","nodeAt2","endPosition","getValueInRange2","startOffset","offsetInBuffer","substring","ret","next","substr","getLinesContent","lines","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineCount","getLineContent","getLineRawContent","_getCharCode","matchingNode","targetOffset","getLineCharCode","getLineLength","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","resultLen","startOffsetInBuffer","m","searchText","_wordSeparators","reset","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","findMatchesLineByLine","searchRange","wordSeparators","regex","currentNode","lineBreakCnt","nextLineStartOffset","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","textLength","lastMatchIndex","indexOf","insert","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","headOfRight","nodeCharCodeAt","newStart","startWithLF","tailOfLeft","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","delete","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","secondNode","prev","nPiece","newNode","adjustCarriageReturnFromNext","low","high","mid","midStop","midStart","endOffset","previousCharOffset","cursor","nodes","lastChar","splitText","concat","slice","endIndex","endPos","newPiece","cache","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","lf_delta","size_delta","newLength","originalStartOffset","newStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","prevAccumualtedValue","offsetOfNode","newOffset","val","nextLineOffset","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","currentContent","p","z","color","prevNode"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,QAAT,QAAyB,wBAAzB;AACA,SAASC,KAAT,QAAsB,qBAAtB;AACA,SAASC,SAAT,QAA0B,gBAA1B;AACA,SAASC,QAAT,EAAmBC,QAAnB,EAA6BC,SAA7B,EAAwCC,OAAxC,EAAiDC,QAAjD,EAA2DC,SAA3D,EAAsEC,kBAAtE,QAAgG,iBAAhG;AACA,SAASC,QAAT,EAAmBC,eAAnB,EAAoCC,YAApC,QAAwD,uBAAxD,C,CACA;;AACA,OAAO,MAAMC,iBAAiB,GAAG,KAA1B;AACP,OAAO,SAASC,eAAT,CAAyBC,GAAzB,EAA8B;AACjC,MAAIC,CAAJ;;AACA,MAAID,GAAG,CAACA,GAAG,CAACE,MAAJ,GAAa,CAAd,CAAH,GAAsB,KAA1B,EAAiC;AAC7BD,IAAAA,CAAC,GAAG,IAAIE,WAAJ,CAAgBH,GAAG,CAACE,MAApB,CAAJ;AACH,GAFD,MAGK;AACDD,IAAAA,CAAC,GAAG,IAAIG,WAAJ,CAAgBJ,GAAG,CAACE,MAApB,CAAJ;AACH;;AACDD,EAAAA,CAAC,CAACI,GAAF,CAAML,GAAN,EAAW,CAAX;AACA,SAAOC,CAAP;AACH;AACD,OAAO,MAAMK,UAAN,CAAiB;AACpBC,EAAAA,WAAW,CAACC,UAAD,EAAaC,EAAb,EAAiBC,EAAjB,EAAqBC,IAArB,EAA2BC,YAA3B,EAAyC;AAChD,SAAKJ,UAAL,GAAkBA,UAAlB;AACA,SAAKC,EAAL,GAAUA,EAAV;AACA,SAAKC,EAAL,GAAUA,EAAV;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACH;;AAPmB;AASxB,OAAO,SAASC,oBAAT,CAA8BC,GAA9B,EAAmCC,QAAQ,GAAG,IAA9C,EAAoD;AACvD,QAAMd,CAAC,GAAG,CAAC,CAAD,CAAV;AACA,MAAIe,OAAO,GAAG,CAAd;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,GAAG,CAACZ,MAA1B,EAAkCe,CAAC,GAAGC,GAAtC,EAA2CD,CAAC,EAA5C,EAAgD;AAC5C,UAAME,GAAG,GAAGL,GAAG,CAACM,UAAJ,CAAeH,CAAf,CAAZ;;AACA,QAAIE,GAAG,KAAK;AAAG;AAAf,MAAqC;AACjC,UAAIF,CAAC,GAAG,CAAJ,GAAQC,GAAR,IAAeJ,GAAG,CAACM,UAAJ,CAAeH,CAAC,GAAG,CAAnB,MAA0B;AAAG;AAAhD,QAAgE;AAC5D;AACAhB,QAAAA,CAAC,CAACe,OAAO,EAAR,CAAD,GAAeC,CAAC,GAAG,CAAnB;AACAA,QAAAA,CAAC,GAH2D,CAGvD;AACR,OAJD,MAKK;AACD;AACAhB,QAAAA,CAAC,CAACe,OAAO,EAAR,CAAD,GAAeC,CAAC,GAAG,CAAnB;AACH;AACJ,KAVD,MAWK,IAAIE,GAAG,KAAK;AAAG;AAAf,MAA+B;AAChClB,MAAAA,CAAC,CAACe,OAAO,EAAR,CAAD,GAAeC,CAAC,GAAG,CAAnB;AACH;AACJ;;AACD,MAAIF,QAAJ,EAAc;AACV,WAAOhB,eAAe,CAACE,CAAD,CAAtB;AACH,GAFD,MAGK;AACD,WAAOA,CAAP;AACH;AACJ;AACD,OAAO,SAASoB,gBAAT,CAA0BpB,CAA1B,EAA6Ba,GAA7B,EAAkC;AACrCb,EAAAA,CAAC,CAACC,MAAF,GAAW,CAAX;AACAD,EAAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACA,MAAIe,OAAO,GAAG,CAAd;AACA,MAAIP,EAAE,GAAG,CAAT;AAAA,MAAYC,EAAE,GAAG,CAAjB;AAAA,MAAoBC,IAAI,GAAG,CAA3B;AACA,MAAIC,YAAY,GAAG,IAAnB;;AACA,OAAK,IAAIK,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,GAAG,CAACZ,MAA1B,EAAkCe,CAAC,GAAGC,GAAtC,EAA2CD,CAAC,EAA5C,EAAgD;AAC5C,UAAME,GAAG,GAAGL,GAAG,CAACM,UAAJ,CAAeH,CAAf,CAAZ;;AACA,QAAIE,GAAG,KAAK;AAAG;AAAf,MAAqC;AACjC,UAAIF,CAAC,GAAG,CAAJ,GAAQC,GAAR,IAAeJ,GAAG,CAACM,UAAJ,CAAeH,CAAC,GAAG,CAAnB,MAA0B;AAAG;AAAhD,QAAgE;AAC5D;AACAN,QAAAA,IAAI;AACJV,QAAAA,CAAC,CAACe,OAAO,EAAR,CAAD,GAAeC,CAAC,GAAG,CAAnB;AACAA,QAAAA,CAAC,GAJ2D,CAIvD;AACR,OALD,MAMK;AACDR,QAAAA,EAAE,GADD,CAED;;AACAR,QAAAA,CAAC,CAACe,OAAO,EAAR,CAAD,GAAeC,CAAC,GAAG,CAAnB;AACH;AACJ,KAZD,MAaK,IAAIE,GAAG,KAAK;AAAG;AAAf,MAA+B;AAChCT,MAAAA,EAAE;AACFT,MAAAA,CAAC,CAACe,OAAO,EAAR,CAAD,GAAeC,CAAC,GAAG,CAAnB;AACH,KAHI,MAIA;AACD,UAAIL,YAAJ,EAAkB;AACd,YAAIO,GAAG,KAAK;AAAE;AAAV,YAAwBA,GAAG,GAAG,EAAN,IAAYA,GAAG,GAAG,GAA1C,CAAJ,EAAoD;AAChDP,UAAAA,YAAY,GAAG,KAAf;AACH;AACJ;AACJ;AACJ;;AACD,QAAMU,MAAM,GAAG,IAAIhB,UAAJ,CAAeP,eAAe,CAACE,CAAD,CAA9B,EAAmCQ,EAAnC,EAAuCC,EAAvC,EAA2CC,IAA3C,EAAiDC,YAAjD,CAAf;AACAX,EAAAA,CAAC,CAACC,MAAF,GAAW,CAAX;AACA,SAAOoB,MAAP;AACH;AACD,OAAO,MAAMC,KAAN,CAAY;AACfhB,EAAAA,WAAW,CAACiB,WAAD,EAAcC,KAAd,EAAqBC,GAArB,EAA0BC,WAA1B,EAAuCzB,MAAvC,EAA+C;AACtD,SAAKsB,WAAL,GAAmBA,WAAnB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKzB,MAAL,GAAcA,MAAd;AACH;;AAPc;AASnB,OAAO,MAAM0B,YAAN,CAAmB;AACtBrB,EAAAA,WAAW,CAACsB,MAAD,EAASrB,UAAT,EAAqB;AAC5B,SAAKqB,MAAL,GAAcA,MAAd;AACA,SAAKrB,UAAL,GAAkBA,UAAlB;AACH;;AAJqB;AAM1B;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMsB,iBAAN,CAAwB;AACpBvB,EAAAA,WAAW,CAACwB,IAAD,EAAOC,GAAP,EAAY;AACnB,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,KAAL,GAAaH,IAAb;AACA,SAAKI,IAAL,GAAYH,GAAZ;AACA,SAAKI,MAAL,GAAc,CAAd;;AACA,QAAIL,IAAI,CAACM,IAAL,KAAcjD,QAAlB,EAA4B;AACxB2C,MAAAA,IAAI,CAACO,OAAL,CAAaP,IAAI,CAACM,IAAlB,EAAwBE,IAAI,IAAI;AAC5B,YAAIA,IAAI,KAAKnD,QAAb,EAAuB;AACnB,eAAK6C,OAAL,CAAaO,IAAb,CAAkBD,IAAI,CAACE,KAAvB;AACH;;AACD,eAAO,IAAP;AACH,OALD;AAMH;AACJ;;AACDC,EAAAA,IAAI,GAAG;AACH,QAAI,KAAKT,OAAL,CAAa/B,MAAb,KAAwB,CAA5B,EAA+B;AAC3B,UAAI,KAAKkC,MAAL,KAAgB,CAApB,EAAuB;AACnB,aAAKA,MAAL;AACA,eAAO,KAAKD,IAAZ;AACH,OAHD,MAIK;AACD,eAAO,IAAP;AACH;AACJ;;AACD,QAAI,KAAKC,MAAL,GAAc,KAAKH,OAAL,CAAa/B,MAAb,GAAsB,CAAxC,EAA2C;AACvC,aAAO,IAAP;AACH;;AACD,QAAI,KAAKkC,MAAL,KAAgB,CAApB,EAAuB;AACnB,aAAO,KAAKD,IAAL,GAAY,KAAKD,KAAL,CAAWS,eAAX,CAA2B,KAAKV,OAAL,CAAa,KAAKG,MAAL,EAAb,CAA3B,CAAnB;AACH;;AACD,WAAO,KAAKF,KAAL,CAAWS,eAAX,CAA2B,KAAKV,OAAL,CAAa,KAAKG,MAAL,EAAb,CAA3B,CAAP;AACH;;AAhCmB;;AAkCxB,MAAMQ,oBAAN,CAA2B;AACvBrC,EAAAA,WAAW,CAACsC,KAAD,EAAQ;AACf,SAAKC,MAAL,GAAcD,KAAd;AACA,SAAKE,MAAL,GAAc,EAAd;AACH;;AACDC,EAAAA,GAAG,CAACC,MAAD,EAAS;AACR,SAAK,IAAIhC,CAAC,GAAG,KAAK8B,MAAL,CAAY7C,MAAZ,GAAqB,CAAlC,EAAqCe,CAAC,IAAI,CAA1C,EAA6CA,CAAC,EAA9C,EAAkD;AAC9C,YAAMiC,OAAO,GAAG,KAAKH,MAAL,CAAY9B,CAAZ,CAAhB;;AACA,UAAIiC,OAAO,CAACC,eAAR,IAA2BF,MAA3B,IAAqCC,OAAO,CAACC,eAAR,GAA0BD,OAAO,CAACX,IAAR,CAAaE,KAAb,CAAmBvC,MAA7C,IAAuD+C,MAAhG,EAAwG;AACpG,eAAOC,OAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACDE,EAAAA,IAAI,CAACC,UAAD,EAAa;AACb,SAAK,IAAIpC,CAAC,GAAG,KAAK8B,MAAL,CAAY7C,MAAZ,GAAqB,CAAlC,EAAqCe,CAAC,IAAI,CAA1C,EAA6CA,CAAC,EAA9C,EAAkD;AAC9C,YAAMiC,OAAO,GAAG,KAAKH,MAAL,CAAY9B,CAAZ,CAAhB;;AACA,UAAIiC,OAAO,CAACI,mBAAR,IAA+BJ,OAAO,CAACI,mBAAR,GAA8BD,UAA7D,IAA2EH,OAAO,CAACI,mBAAR,GAA8BJ,OAAO,CAACX,IAAR,CAAaE,KAAb,CAAmBd,WAAjD,IAAgE0B,UAA/I,EAA2J;AACvJ,eAAOH,OAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACD7C,EAAAA,GAAG,CAACkD,YAAD,EAAe;AACd,QAAI,KAAKR,MAAL,CAAY7C,MAAZ,IAAsB,KAAK4C,MAA/B,EAAuC;AACnC,WAAKC,MAAL,CAAYS,KAAZ;AACH;;AACD,SAAKT,MAAL,CAAYP,IAAZ,CAAiBe,YAAjB;AACH;;AACDE,EAAAA,QAAQ,CAACR,MAAD,EAAS;AACb,QAAIS,aAAa,GAAG,KAApB;AACA,UAAMC,GAAG,GAAG,KAAKZ,MAAjB;;AACA,SAAK,IAAI9B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0C,GAAG,CAACzD,MAAxB,EAAgCe,CAAC,EAAjC,EAAqC;AACjC,YAAMiC,OAAO,GAAGS,GAAG,CAAC1C,CAAD,CAAnB;;AACA,UAAIiC,OAAO,CAACX,IAAR,CAAaqB,MAAb,KAAwB,IAAxB,IAAgCV,OAAO,CAACC,eAAR,IAA2BF,MAA/D,EAAuE;AACnEU,QAAAA,GAAG,CAAC1C,CAAD,CAAH,GAAS,IAAT;AACAyC,QAAAA,aAAa,GAAG,IAAhB;AACA;AACH;AACJ;;AACD,QAAIA,aAAJ,EAAmB;AACf,YAAMG,MAAM,GAAG,EAAf;;AACA,WAAK,MAAMC,KAAX,IAAoBH,GAApB,EAAyB;AACrB,YAAIG,KAAK,KAAK,IAAd,EAAoB;AAChBD,UAAAA,MAAM,CAACrB,IAAP,CAAYsB,KAAZ;AACH;AACJ;;AACD,WAAKf,MAAL,GAAcc,MAAd;AACH;AACJ;;AAjDsB;;AAmD3B,OAAO,MAAME,aAAN,CAAoB;AACvBxD,EAAAA,WAAW,CAACyD,MAAD,EAASC,GAAT,EAAcC,aAAd,EAA6B;AACpC,SAAKC,MAAL,CAAYH,MAAZ,EAAoBC,GAApB,EAAyBC,aAAzB;AACH;;AACDC,EAAAA,MAAM,CAACH,MAAD,EAASC,GAAT,EAAcC,aAAd,EAA6B;AAC/B,SAAKE,QAAL,GAAgB,CACZ,IAAIxC,YAAJ,CAAiB,EAAjB,EAAqB,CAAC,CAAD,CAArB,CADY,CAAhB;AAGA,SAAKyC,oBAAL,GAA4B;AAAEC,MAAAA,IAAI,EAAE,CAAR;AAAWC,MAAAA,MAAM,EAAE;AAAnB,KAA5B;AACA,SAAKlC,IAAL,GAAYjD,QAAZ;AACA,SAAKoF,QAAL,GAAgB,CAAhB;AACA,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,IAAL,GAAYT,GAAZ;AACA,SAAKU,UAAL,GAAkBV,GAAG,CAAC/D,MAAtB;AACA,SAAK0E,cAAL,GAAsBV,aAAtB;AACA,QAAIW,QAAQ,GAAG,IAAf;;AACA,SAAK,IAAI5D,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG8C,MAAM,CAAC9D,MAA7B,EAAqCe,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,EAA/C,EAAmD;AAC/C,UAAI+C,MAAM,CAAC/C,CAAD,CAAN,CAAUY,MAAV,CAAiB3B,MAAjB,GAA0B,CAA9B,EAAiC;AAC7B,YAAI,CAAC8D,MAAM,CAAC/C,CAAD,CAAN,CAAUT,UAAf,EAA2B;AACvBwD,UAAAA,MAAM,CAAC/C,CAAD,CAAN,CAAUT,UAAV,GAAuBK,oBAAoB,CAACmD,MAAM,CAAC/C,CAAD,CAAN,CAAUY,MAAX,CAA3C;AACH;;AACD,cAAMY,KAAK,GAAG,IAAIlB,KAAJ,CAAUN,CAAC,GAAG,CAAd,EAAiB;AAAEqD,UAAAA,IAAI,EAAE,CAAR;AAAWC,UAAAA,MAAM,EAAE;AAAnB,SAAjB,EAAyC;AAAED,UAAAA,IAAI,EAAEN,MAAM,CAAC/C,CAAD,CAAN,CAAUT,UAAV,CAAqBN,MAArB,GAA8B,CAAtC;AAAyCqE,UAAAA,MAAM,EAAEP,MAAM,CAAC/C,CAAD,CAAN,CAAUY,MAAV,CAAiB3B,MAAjB,GAA0B8D,MAAM,CAAC/C,CAAD,CAAN,CAAUT,UAAV,CAAqBwD,MAAM,CAAC/C,CAAD,CAAN,CAAUT,UAAV,CAAqBN,MAArB,GAA8B,CAAnD;AAA3E,SAAzC,EAA6K8D,MAAM,CAAC/C,CAAD,CAAN,CAAUT,UAAV,CAAqBN,MAArB,GAA8B,CAA3M,EAA8M8D,MAAM,CAAC/C,CAAD,CAAN,CAAUY,MAAV,CAAiB3B,MAA/N,CAAd;;AACA,aAAKkE,QAAL,CAAc5B,IAAd,CAAmBwB,MAAM,CAAC/C,CAAD,CAAzB;;AACA4D,QAAAA,QAAQ,GAAG,KAAKC,aAAL,CAAmBD,QAAnB,EAA6BpC,KAA7B,CAAX;AACH;AACJ;;AACD,SAAKsC,YAAL,GAAoB,IAAInC,oBAAJ,CAAyB,CAAzB,CAApB;AACA,SAAKoC,gBAAL,GAAwB;AAAE3B,MAAAA,UAAU,EAAE,CAAd;AAAiB4B,MAAAA,KAAK,EAAE;AAAxB,KAAxB;AACA,SAAKC,qBAAL;AACH;;AACDC,EAAAA,YAAY,CAAClB,GAAD,EAAM;AACd,UAAMmB,iBAAiB,GAAGtF,iBAA1B;AACA,UAAMuF,GAAG,GAAGD,iBAAiB,GAAGE,IAAI,CAACC,KAAL,CAAWH,iBAAiB,GAAG,CAA/B,CAAhC;AACA,UAAMI,GAAG,GAAGH,GAAG,GAAG,CAAlB;AACA,QAAII,SAAS,GAAG,EAAhB;AACA,QAAIC,YAAY,GAAG,CAAnB;AACA,UAAM1B,MAAM,GAAG,EAAf;AACA,SAAK1B,OAAL,CAAa,KAAKD,IAAlB,EAAwBE,IAAI,IAAI;AAC5B,YAAMzB,GAAG,GAAG,KAAK6E,cAAL,CAAoBpD,IAApB,CAAZ;AACA,YAAMrB,GAAG,GAAGJ,GAAG,CAACZ,MAAhB;;AACA,UAAIwF,YAAY,IAAIL,GAAhB,IAAuBK,YAAY,GAAGxE,GAAf,GAAqBsE,GAAhD,EAAqD;AACjDC,QAAAA,SAAS,IAAI3E,GAAb;AACA4E,QAAAA,YAAY,IAAIxE,GAAhB;AACA,eAAO,IAAP;AACH,OAP2B,CAQ5B;;;AACA,YAAM0E,IAAI,GAAGH,SAAS,CAACI,OAAV,CAAkB,aAAlB,EAAiC5B,GAAjC,CAAb;AACAD,MAAAA,MAAM,CAACxB,IAAP,CAAY,IAAIZ,YAAJ,CAAiBgE,IAAjB,EAAuB/E,oBAAoB,CAAC+E,IAAD,CAA3C,CAAZ;AACAH,MAAAA,SAAS,GAAG3E,GAAZ;AACA4E,MAAAA,YAAY,GAAGxE,GAAf;AACA,aAAO,IAAP;AACH,KAdD;;AAeA,QAAIwE,YAAY,GAAG,CAAnB,EAAsB;AAClB,YAAME,IAAI,GAAGH,SAAS,CAACI,OAAV,CAAkB,aAAlB,EAAiC5B,GAAjC,CAAb;AACAD,MAAAA,MAAM,CAACxB,IAAP,CAAY,IAAIZ,YAAJ,CAAiBgE,IAAjB,EAAuB/E,oBAAoB,CAAC+E,IAAD,CAA3C,CAAZ;AACH;;AACD,SAAKzB,MAAL,CAAYH,MAAZ,EAAoBC,GAApB,EAAyB,IAAzB;AACH,GAzDsB,CA0DvB;;;AACA6B,EAAAA,MAAM,GAAG;AACL,WAAO,KAAKpB,IAAZ;AACH;;AACDqB,EAAAA,MAAM,CAACC,MAAD,EAAS;AACX,SAAKtB,IAAL,GAAYsB,MAAZ;AACA,SAAKrB,UAAL,GAAkB,KAAKD,IAAL,CAAUxE,MAA5B;AACA,SAAKiF,YAAL,CAAkBa,MAAlB;AACH;;AACDC,EAAAA,cAAc,CAACjE,GAAD,EAAM;AAChB,WAAO,IAAIF,iBAAJ,CAAsB,IAAtB,EAA4BE,GAA5B,CAAP;AACH;;AACDkE,EAAAA,WAAW,CAAC7C,UAAD,EAAakB,MAAb,EAAqB;AAC5B,QAAI4B,OAAO,GAAG,CAAd,CAD4B,CACX;;AACjB,QAAIC,CAAC,GAAG,KAAK/D,IAAb;;AACA,WAAO+D,CAAC,KAAKhH,QAAb,EAAuB;AACnB,UAAIgH,CAAC,CAACC,IAAF,KAAWjH,QAAX,IAAuBgH,CAAC,CAACE,OAAF,GAAY,CAAZ,IAAiBjD,UAA5C,EAAwD;AACpD+C,QAAAA,CAAC,GAAGA,CAAC,CAACC,IAAN;AACH,OAFD,MAGK,IAAID,CAAC,CAACE,OAAF,GAAYF,CAAC,CAAC3D,KAAF,CAAQd,WAApB,GAAkC,CAAlC,IAAuC0B,UAA3C,EAAuD;AACxD8C,QAAAA,OAAO,IAAIC,CAAC,CAACG,SAAb,CADwD,CAExD;;AACA,cAAMC,4BAA4B,GAAG,KAAKC,mBAAL,CAAyBL,CAAzB,EAA4B/C,UAAU,GAAG+C,CAAC,CAACE,OAAf,GAAyB,CAArD,CAArC;AACA,eAAOH,OAAO,IAAIK,4BAA4B,GAAGjC,MAA/B,GAAwC,CAA1D;AACH,OALI,MAMA;AACDlB,QAAAA,UAAU,IAAI+C,CAAC,CAACE,OAAF,GAAYF,CAAC,CAAC3D,KAAF,CAAQd,WAAlC;AACAwE,QAAAA,OAAO,IAAIC,CAAC,CAACG,SAAF,GAAcH,CAAC,CAAC3D,KAAF,CAAQvC,MAAjC;AACAkG,QAAAA,CAAC,GAAGA,CAAC,CAACM,KAAN;AACH;AACJ;;AACD,WAAOP,OAAP;AACH;;AACDQ,EAAAA,aAAa,CAAC1D,MAAD,EAAS;AAClBA,IAAAA,MAAM,GAAGqC,IAAI,CAACC,KAAL,CAAWtC,MAAX,CAAT;AACAA,IAAAA,MAAM,GAAGqC,IAAI,CAACE,GAAL,CAAS,CAAT,EAAYvC,MAAZ,CAAT;AACA,QAAImD,CAAC,GAAG,KAAK/D,IAAb;AACA,QAAIuE,KAAK,GAAG,CAAZ;AACA,UAAMC,cAAc,GAAG5D,MAAvB;;AACA,WAAOmD,CAAC,KAAKhH,QAAb,EAAuB;AACnB,UAAIgH,CAAC,CAACG,SAAF,KAAgB,CAAhB,IAAqBH,CAAC,CAACG,SAAF,IAAetD,MAAxC,EAAgD;AAC5CmD,QAAAA,CAAC,GAAGA,CAAC,CAACC,IAAN;AACH,OAFD,MAGK,IAAID,CAAC,CAACG,SAAF,GAAcH,CAAC,CAAC3D,KAAF,CAAQvC,MAAtB,IAAgC+C,MAApC,EAA4C;AAC7C,cAAM6D,GAAG,GAAG,KAAKC,UAAL,CAAgBX,CAAhB,EAAmBnD,MAAM,GAAGmD,CAAC,CAACG,SAA9B,CAAZ;AACAK,QAAAA,KAAK,IAAIR,CAAC,CAACE,OAAF,GAAYQ,GAAG,CAACE,KAAzB;;AACA,YAAIF,GAAG,CAACE,KAAJ,KAAc,CAAlB,EAAqB;AACjB,gBAAMC,eAAe,GAAG,KAAKf,WAAL,CAAiBU,KAAK,GAAG,CAAzB,EAA4B,CAA5B,CAAxB;AACA,gBAAMrC,MAAM,GAAGsC,cAAc,GAAGI,eAAhC;AACA,iBAAO,IAAIhI,QAAJ,CAAa2H,KAAK,GAAG,CAArB,EAAwBrC,MAAM,GAAG,CAAjC,CAAP;AACH;;AACD,eAAO,IAAItF,QAAJ,CAAa2H,KAAK,GAAG,CAArB,EAAwBE,GAAG,CAACI,SAAJ,GAAgB,CAAxC,CAAP;AACH,OATI,MAUA;AACDjE,QAAAA,MAAM,IAAImD,CAAC,CAACG,SAAF,GAAcH,CAAC,CAAC3D,KAAF,CAAQvC,MAAhC;AACA0G,QAAAA,KAAK,IAAIR,CAAC,CAACE,OAAF,GAAYF,CAAC,CAAC3D,KAAF,CAAQd,WAA7B;;AACA,YAAIyE,CAAC,CAACM,KAAF,KAAYtH,QAAhB,EAA0B;AACtB;AACA,gBAAM6H,eAAe,GAAG,KAAKf,WAAL,CAAiBU,KAAK,GAAG,CAAzB,EAA4B,CAA5B,CAAxB;AACA,gBAAMrC,MAAM,GAAGsC,cAAc,GAAG5D,MAAjB,GAA0BgE,eAAzC;AACA,iBAAO,IAAIhI,QAAJ,CAAa2H,KAAK,GAAG,CAArB,EAAwBrC,MAAM,GAAG,CAAjC,CAAP;AACH,SALD,MAMK;AACD6B,UAAAA,CAAC,GAAGA,CAAC,CAACM,KAAN;AACH;AACJ;AACJ;;AACD,WAAO,IAAIzH,QAAJ,CAAa,CAAb,EAAgB,CAAhB,CAAP;AACH;;AACDkI,EAAAA,eAAe,CAACC,KAAD,EAAQnD,GAAR,EAAa;AACxB,QAAImD,KAAK,CAACC,eAAN,KAA0BD,KAAK,CAACE,aAAhC,IAAiDF,KAAK,CAACG,WAAN,KAAsBH,KAAK,CAACI,SAAjF,EAA4F;AACxF,aAAO,EAAP;AACH;;AACD,UAAMC,aAAa,GAAG,KAAKC,OAAL,CAAaN,KAAK,CAACC,eAAnB,EAAoCD,KAAK,CAACG,WAA1C,CAAtB;AACA,UAAMI,WAAW,GAAG,KAAKD,OAAL,CAAaN,KAAK,CAACE,aAAnB,EAAkCF,KAAK,CAACI,SAAxC,CAApB;AACA,UAAMvC,KAAK,GAAG,KAAK2C,gBAAL,CAAsBH,aAAtB,EAAqCE,WAArC,CAAd;;AACA,QAAI1D,GAAJ,EAAS;AACL,UAAIA,GAAG,KAAK,KAAKS,IAAb,IAAqB,CAAC,KAAKE,cAA/B,EAA+C;AAC3C,eAAOK,KAAK,CAACY,OAAN,CAAc,aAAd,EAA6B5B,GAA7B,CAAP;AACH;;AACD,UAAIA,GAAG,KAAK,KAAK6B,MAAL,EAAR,IAAyB,KAAKlB,cAAlC,EAAkD;AAC9C,YAAIX,GAAG,KAAK,MAAZ,EAAoB,CACnB;;AACD,eAAOgB,KAAP;AACH;;AACD,aAAOA,KAAK,CAACY,OAAN,CAAc,aAAd,EAA6B5B,GAA7B,CAAP;AACH;;AACD,WAAOgB,KAAP;AACH;;AACD2C,EAAAA,gBAAgB,CAACH,aAAD,EAAgBE,WAAhB,EAA6B;AACzC,QAAIF,aAAa,CAAClF,IAAd,KAAuBoF,WAAW,CAACpF,IAAvC,EAA6C;AACzC,YAAMA,IAAI,GAAGkF,aAAa,CAAClF,IAA3B;AACA,YAAMV,MAAM,GAAG,KAAKuC,QAAL,CAAc7B,IAAI,CAACE,KAAL,CAAWjB,WAAzB,EAAsCK,MAArD;AACA,YAAMgG,WAAW,GAAG,KAAKC,cAAL,CAAoBvF,IAAI,CAACE,KAAL,CAAWjB,WAA/B,EAA4Ce,IAAI,CAACE,KAAL,CAAWhB,KAAvD,CAApB;AACA,aAAOI,MAAM,CAACkG,SAAP,CAAiBF,WAAW,GAAGJ,aAAa,CAACP,SAA7C,EAAwDW,WAAW,GAAGF,WAAW,CAACT,SAAlF,CAAP;AACH;;AACD,QAAId,CAAC,GAAGqB,aAAa,CAAClF,IAAtB;AACA,UAAMV,MAAM,GAAG,KAAKuC,QAAL,CAAcgC,CAAC,CAAC3D,KAAF,CAAQjB,WAAtB,EAAmCK,MAAlD;AACA,UAAMgG,WAAW,GAAG,KAAKC,cAAL,CAAoB1B,CAAC,CAAC3D,KAAF,CAAQjB,WAA5B,EAAyC4E,CAAC,CAAC3D,KAAF,CAAQhB,KAAjD,CAApB;AACA,QAAIuG,GAAG,GAAGnG,MAAM,CAACkG,SAAP,CAAiBF,WAAW,GAAGJ,aAAa,CAACP,SAA7C,EAAwDW,WAAW,GAAGzB,CAAC,CAAC3D,KAAF,CAAQvC,MAA9E,CAAV;AACAkG,IAAAA,CAAC,GAAGA,CAAC,CAAC6B,IAAF,EAAJ;;AACA,WAAO7B,CAAC,KAAKhH,QAAb,EAAuB;AACnB,YAAMyC,MAAM,GAAG,KAAKuC,QAAL,CAAcgC,CAAC,CAAC3D,KAAF,CAAQjB,WAAtB,EAAmCK,MAAlD;AACA,YAAMgG,WAAW,GAAG,KAAKC,cAAL,CAAoB1B,CAAC,CAAC3D,KAAF,CAAQjB,WAA5B,EAAyC4E,CAAC,CAAC3D,KAAF,CAAQhB,KAAjD,CAApB;;AACA,UAAI2E,CAAC,KAAKuB,WAAW,CAACpF,IAAtB,EAA4B;AACxByF,QAAAA,GAAG,IAAInG,MAAM,CAACkG,SAAP,CAAiBF,WAAjB,EAA8BA,WAAW,GAAGF,WAAW,CAACT,SAAxD,CAAP;AACA;AACH,OAHD,MAIK;AACDc,QAAAA,GAAG,IAAInG,MAAM,CAACqG,MAAP,CAAcL,WAAd,EAA2BzB,CAAC,CAAC3D,KAAF,CAAQvC,MAAnC,CAAP;AACH;;AACDkG,MAAAA,CAAC,GAAGA,CAAC,CAAC6B,IAAF,EAAJ;AACH;;AACD,WAAOD,GAAP;AACH;;AACDG,EAAAA,eAAe,GAAG;AACd,UAAMC,KAAK,GAAG,EAAd;AACA,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,WAAW,GAAG,EAAlB;AACA,QAAIC,UAAU,GAAG,KAAjB;AACA,SAAKjG,OAAL,CAAa,KAAKD,IAAlB,EAAwBE,IAAI,IAAI;AAC5B,UAAIA,IAAI,KAAKnD,QAAb,EAAuB;AACnB,eAAO,IAAP;AACH;;AACD,YAAMqD,KAAK,GAAGF,IAAI,CAACE,KAAnB;AACA,UAAI+F,WAAW,GAAG/F,KAAK,CAACvC,MAAxB;;AACA,UAAIsI,WAAW,KAAK,CAApB,EAAuB;AACnB,eAAO,IAAP;AACH;;AACD,YAAM3G,MAAM,GAAG,KAAKuC,QAAL,CAAc3B,KAAK,CAACjB,WAApB,EAAiCK,MAAhD;AACA,YAAMrB,UAAU,GAAG,KAAK4D,QAAL,CAAc3B,KAAK,CAACjB,WAApB,EAAiChB,UAApD;AACA,YAAMiI,cAAc,GAAGhG,KAAK,CAAChB,KAAN,CAAY6C,IAAnC;AACA,YAAMoE,YAAY,GAAGjG,KAAK,CAACf,GAAN,CAAU4C,IAA/B;AACA,UAAIqE,gBAAgB,GAAGnI,UAAU,CAACiI,cAAD,CAAV,GAA6BhG,KAAK,CAAChB,KAAN,CAAY8C,MAAhE;;AACA,UAAIgE,UAAJ,EAAgB;AACZ,YAAI1G,MAAM,CAACT,UAAP,CAAkBuH,gBAAlB,MAAwC;AAAG;AAA/C,UAA+D;AAC3D;AACAA,UAAAA,gBAAgB;AAChBH,UAAAA,WAAW;AACd;;AACDJ,QAAAA,KAAK,CAACC,WAAW,EAAZ,CAAL,GAAuBC,WAAvB;AACAA,QAAAA,WAAW,GAAG,EAAd;AACAC,QAAAA,UAAU,GAAG,KAAb;;AACA,YAAIC,WAAW,KAAK,CAApB,EAAuB;AACnB,iBAAO,IAAP;AACH;AACJ;;AACD,UAAIC,cAAc,KAAKC,YAAvB,EAAqC;AACjC;AACA,YAAI,CAAC,KAAK9D,cAAN,IAAwB/C,MAAM,CAACT,UAAP,CAAkBuH,gBAAgB,GAAGH,WAAnB,GAAiC,CAAnD,MAA0D;AAAG;AAAzF,UAA+G;AAC3GD,UAAAA,UAAU,GAAG,IAAb;AACAD,UAAAA,WAAW,IAAIzG,MAAM,CAACqG,MAAP,CAAcS,gBAAd,EAAgCH,WAAW,GAAG,CAA9C,CAAf;AACH,SAHD,MAIK;AACDF,UAAAA,WAAW,IAAIzG,MAAM,CAACqG,MAAP,CAAcS,gBAAd,EAAgCH,WAAhC,CAAf;AACH;;AACD,eAAO,IAAP;AACH,OArC2B,CAsC5B;;;AACAF,MAAAA,WAAW,IAAK,KAAK1D,cAAL,GACV/C,MAAM,CAACkG,SAAP,CAAiBY,gBAAjB,EAAmCrD,IAAI,CAACE,GAAL,CAASmD,gBAAT,EAA2BnI,UAAU,CAACiI,cAAc,GAAG,CAAlB,CAAV,GAAiC,KAAK9D,UAAjE,CAAnC,CADU,GAEV9C,MAAM,CAACkG,SAAP,CAAiBY,gBAAjB,EAAmCnI,UAAU,CAACiI,cAAc,GAAG,CAAlB,CAA7C,EAAmE5C,OAAnE,CAA2E,eAA3E,EAA4F,EAA5F,CAFN;AAGAuC,MAAAA,KAAK,CAACC,WAAW,EAAZ,CAAL,GAAuBC,WAAvB;;AACA,WAAK,IAAIhE,IAAI,GAAGmE,cAAc,GAAG,CAAjC,EAAoCnE,IAAI,GAAGoE,YAA3C,EAAyDpE,IAAI,EAA7D,EAAiE;AAC7DgE,QAAAA,WAAW,GAAI,KAAK1D,cAAL,GACT/C,MAAM,CAACkG,SAAP,CAAiBvH,UAAU,CAAC8D,IAAD,CAA3B,EAAmC9D,UAAU,CAAC8D,IAAI,GAAG,CAAR,CAAV,GAAuB,KAAKK,UAA/D,CADS,GAET9C,MAAM,CAACkG,SAAP,CAAiBvH,UAAU,CAAC8D,IAAD,CAA3B,EAAmC9D,UAAU,CAAC8D,IAAI,GAAG,CAAR,CAA7C,EAAyDuB,OAAzD,CAAiE,eAAjE,EAAkF,EAAlF,CAFN;AAGAuC,QAAAA,KAAK,CAACC,WAAW,EAAZ,CAAL,GAAuBC,WAAvB;AACH;;AACD,UAAI,CAAC,KAAK1D,cAAN,IAAwB/C,MAAM,CAACT,UAAP,CAAkBZ,UAAU,CAACkI,YAAD,CAAV,GAA2BjG,KAAK,CAACf,GAAN,CAAU6C,MAArC,GAA8C,CAAhE,MAAuE;AAAG;AAAtG,QAA4H;AACxHgE,QAAAA,UAAU,GAAG,IAAb;;AACA,YAAI9F,KAAK,CAACf,GAAN,CAAU6C,MAAV,KAAqB,CAAzB,EAA4B;AACxB;AACA8D,UAAAA,WAAW;AACd,SAHD,MAIK;AACDC,UAAAA,WAAW,GAAGzG,MAAM,CAACqG,MAAP,CAAc1H,UAAU,CAACkI,YAAD,CAAxB,EAAwCjG,KAAK,CAACf,GAAN,CAAU6C,MAAV,GAAmB,CAA3D,CAAd;AACH;AACJ,OATD,MAUK;AACD+D,QAAAA,WAAW,GAAGzG,MAAM,CAACqG,MAAP,CAAc1H,UAAU,CAACkI,YAAD,CAAxB,EAAwCjG,KAAK,CAACf,GAAN,CAAU6C,MAAlD,CAAd;AACH;;AACD,aAAO,IAAP;AACH,KA/DD;;AAgEA,QAAIgE,UAAJ,EAAgB;AACZH,MAAAA,KAAK,CAACC,WAAW,EAAZ,CAAL,GAAuBC,WAAvB;AACAA,MAAAA,WAAW,GAAG,EAAd;AACH;;AACDF,IAAAA,KAAK,CAACC,WAAW,EAAZ,CAAL,GAAuBC,WAAvB;AACA,WAAOF,KAAP;AACH;;AACDQ,EAAAA,SAAS,GAAG;AACR,WAAO,KAAKnE,OAAZ;AACH;;AACDoE,EAAAA,YAAY,GAAG;AACX,WAAO,KAAKrE,QAAZ;AACH;;AACDsE,EAAAA,cAAc,CAACzF,UAAD,EAAa;AACvB,QAAI,KAAK2B,gBAAL,CAAsB3B,UAAtB,KAAqCA,UAAzC,EAAqD;AACjD,aAAO,KAAK2B,gBAAL,CAAsBC,KAA7B;AACH;;AACD,SAAKD,gBAAL,CAAsB3B,UAAtB,GAAmCA,UAAnC;;AACA,QAAIA,UAAU,KAAK,KAAKmB,QAAxB,EAAkC;AAC9B,WAAKQ,gBAAL,CAAsBC,KAAtB,GAA8B,KAAK8D,iBAAL,CAAuB1F,UAAvB,CAA9B;AACH,KAFD,MAGK,IAAI,KAAKuB,cAAT,EAAyB;AAC1B,WAAKI,gBAAL,CAAsBC,KAAtB,GAA8B,KAAK8D,iBAAL,CAAuB1F,UAAvB,EAAmC,KAAKsB,UAAxC,CAA9B;AACH,KAFI,MAGA;AACD,WAAKK,gBAAL,CAAsBC,KAAtB,GAA8B,KAAK8D,iBAAL,CAAuB1F,UAAvB,EAAmCwC,OAAnC,CAA2C,eAA3C,EAA4D,EAA5D,CAA9B;AACH;;AACD,WAAO,KAAKb,gBAAL,CAAsBC,KAA7B;AACH;;AACD+D,EAAAA,YAAY,CAAC9F,OAAD,EAAU;AAClB,QAAIA,OAAO,CAACgE,SAAR,KAAsBhE,OAAO,CAACX,IAAR,CAAaE,KAAb,CAAmBvC,MAA7C,EAAqD;AACjD;AACA,YAAM+I,YAAY,GAAG/F,OAAO,CAACX,IAAR,CAAa0F,IAAb,EAArB;;AACA,UAAI,CAACgB,YAAL,EAAmB;AACf,eAAO,CAAP;AACH;;AACD,YAAMpH,MAAM,GAAG,KAAKuC,QAAL,CAAc6E,YAAY,CAACxG,KAAb,CAAmBjB,WAAjC,CAAf;AACA,YAAMqG,WAAW,GAAG,KAAKC,cAAL,CAAoBmB,YAAY,CAACxG,KAAb,CAAmBjB,WAAvC,EAAoDyH,YAAY,CAACxG,KAAb,CAAmBhB,KAAvE,CAApB;AACA,aAAOI,MAAM,CAACA,MAAP,CAAcT,UAAd,CAAyByG,WAAzB,CAAP;AACH,KATD,MAUK;AACD,YAAMhG,MAAM,GAAG,KAAKuC,QAAL,CAAclB,OAAO,CAACX,IAAR,CAAaE,KAAb,CAAmBjB,WAAjC,CAAf;AACA,YAAMqG,WAAW,GAAG,KAAKC,cAAL,CAAoB5E,OAAO,CAACX,IAAR,CAAaE,KAAb,CAAmBjB,WAAvC,EAAoD0B,OAAO,CAACX,IAAR,CAAaE,KAAb,CAAmBhB,KAAvE,CAApB;AACA,YAAMyH,YAAY,GAAGrB,WAAW,GAAG3E,OAAO,CAACgE,SAA3C;AACA,aAAOrF,MAAM,CAACA,MAAP,CAAcT,UAAd,CAAyB8H,YAAzB,CAAP;AACH;AACJ;;AACDC,EAAAA,eAAe,CAAC9F,UAAD,EAAa2D,KAAb,EAAoB;AAC/B,UAAM9D,OAAO,GAAG,KAAKwE,OAAL,CAAarE,UAAb,EAAyB2D,KAAK,GAAG,CAAjC,CAAhB;AACA,WAAO,KAAKgC,YAAL,CAAkB9F,OAAlB,CAAP;AACH;;AACDkG,EAAAA,aAAa,CAAC/F,UAAD,EAAa;AACtB,QAAIA,UAAU,KAAK,KAAKwF,YAAL,EAAnB,EAAwC;AACpC,YAAMhB,WAAW,GAAG,KAAK3B,WAAL,CAAiB7C,UAAjB,EAA6B,CAA7B,CAApB;AACA,aAAO,KAAKuF,SAAL,KAAmBf,WAA1B;AACH;;AACD,WAAO,KAAK3B,WAAL,CAAiB7C,UAAU,GAAG,CAA9B,EAAiC,CAAjC,IAAsC,KAAK6C,WAAL,CAAiB7C,UAAjB,EAA6B,CAA7B,CAAtC,GAAwE,KAAKsB,UAApF;AACH;;AACD0E,EAAAA,iBAAiB,CAAC9G,IAAD,EAAO+G,QAAP,EAAiBjC,eAAjB,EAAkCE,WAAlC,EAA+CgC,WAA/C,EAA4DC,SAA5D,EAAuEC,UAAvE,EAAmFC,cAAnF,EAAmGC,gBAAnG,EAAqHC,SAArH,EAAgItI,MAAhI,EAAwI;AACrJ,UAAMO,MAAM,GAAG,KAAKuC,QAAL,CAAc7B,IAAI,CAACE,KAAL,CAAWjB,WAAzB,CAAf;AACA,UAAMqI,mBAAmB,GAAG,KAAK/B,cAAL,CAAoBvF,IAAI,CAACE,KAAL,CAAWjB,WAA/B,EAA4Ce,IAAI,CAACE,KAAL,CAAWhB,KAAvD,CAA5B;AACA,UAAMA,KAAK,GAAG,KAAKqG,cAAL,CAAoBvF,IAAI,CAACE,KAAL,CAAWjB,WAA/B,EAA4C+H,WAA5C,CAAd;AACA,UAAM7H,GAAG,GAAG,KAAKoG,cAAL,CAAoBvF,IAAI,CAACE,KAAL,CAAWjB,WAA/B,EAA4CgI,SAA5C,CAAZ;AACA,QAAIM,CAAJ,CALqJ,CAMrJ;;AACA,UAAM9B,GAAG,GAAG;AAAE1D,MAAAA,IAAI,EAAE,CAAR;AAAWC,MAAAA,MAAM,EAAE;AAAnB,KAAZ;AACA,QAAIwF,UAAJ;AACA,QAAIjC,cAAJ;;AACA,QAAIwB,QAAQ,CAACU,eAAb,EAA8B;AAC1BD,MAAAA,UAAU,GAAGlI,MAAM,CAACA,MAAP,CAAckG,SAAd,CAAwBtG,KAAxB,EAA+BC,GAA/B,CAAb;;AACAoG,MAAAA,cAAc,GAAI7E,MAAD,IAAYA,MAAM,GAAGxB,KAAtC;;AACA6H,MAAAA,QAAQ,CAACW,KAAT,CAAe,CAAf;AACH,KAJD,MAKK;AACDF,MAAAA,UAAU,GAAGlI,MAAM,CAACA,MAApB;;AACAiG,MAAAA,cAAc,GAAI7E,MAAD,IAAYA,MAA7B;;AACAqG,MAAAA,QAAQ,CAACW,KAAT,CAAexI,KAAf;AACH;;AACD,OAAG;AACCqI,MAAAA,CAAC,GAAGR,QAAQ,CAACrB,IAAT,CAAc8B,UAAd,CAAJ;;AACA,UAAID,CAAJ,EAAO;AACH,YAAIhC,cAAc,CAACgC,CAAC,CAAC9C,KAAH,CAAd,IAA2BtF,GAA/B,EAAoC;AAChC,iBAAOkI,SAAP;AACH;;AACD,aAAKM,gBAAL,CAAsB3H,IAAtB,EAA4BuF,cAAc,CAACgC,CAAC,CAAC9C,KAAH,CAAd,GAA0B6C,mBAAtD,EAA2E7B,GAA3E;AACA,cAAMrG,WAAW,GAAG,KAAKwI,cAAL,CAAoB5H,IAAI,CAACE,KAAL,CAAWjB,WAA/B,EAA4C+H,WAA5C,EAAyDvB,GAAzD,CAApB;AACA,cAAMoC,cAAc,GAAGpC,GAAG,CAAC1D,IAAJ,KAAaiF,WAAW,CAACjF,IAAzB,GAAgC0D,GAAG,CAACzD,MAAJ,GAAagF,WAAW,CAAChF,MAAzB,GAAkCgD,WAAlE,GAAgFS,GAAG,CAACzD,MAAJ,GAAa,CAApH;AACA,cAAM8F,YAAY,GAAGD,cAAc,GAAGN,CAAC,CAAC,CAAD,CAAD,CAAK5J,MAA3C;AACAoB,QAAAA,MAAM,CAACsI,SAAS,EAAV,CAAN,GAAsBhK,eAAe,CAAC,IAAIV,KAAJ,CAAUmI,eAAe,GAAG1F,WAA5B,EAAyCyI,cAAzC,EAAyD/C,eAAe,GAAG1F,WAA3E,EAAwF0I,YAAxF,CAAD,EAAwGP,CAAxG,EAA2GJ,cAA3G,CAArC;;AACA,YAAI5B,cAAc,CAACgC,CAAC,CAAC9C,KAAH,CAAd,GAA0B8C,CAAC,CAAC,CAAD,CAAD,CAAK5J,MAA/B,IAAyCwB,GAA7C,EAAkD;AAC9C,iBAAOkI,SAAP;AACH;;AACD,YAAIA,SAAS,IAAID,gBAAjB,EAAmC;AAC/B,iBAAOC,SAAP;AACH;AACJ;AACJ,KAlBD,QAkBSE,CAlBT;;AAmBA,WAAOF,SAAP;AACH;;AACDU,EAAAA,qBAAqB,CAACC,WAAD,EAAcd,UAAd,EAA0BC,cAA1B,EAA0CC,gBAA1C,EAA4D;AAC7E,UAAMrI,MAAM,GAAG,EAAf;AACA,QAAIsI,SAAS,GAAG,CAAhB;AACA,UAAMN,QAAQ,GAAG,IAAI3J,QAAJ,CAAa8J,UAAU,CAACe,cAAxB,EAAwCf,UAAU,CAACgB,KAAnD,CAAjB;AACA,QAAIhD,aAAa,GAAG,KAAKC,OAAL,CAAa6C,WAAW,CAAClD,eAAzB,EAA0CkD,WAAW,CAAChD,WAAtD,CAApB;;AACA,QAAIE,aAAa,KAAK,IAAtB,EAA4B;AACxB,aAAO,EAAP;AACH;;AACD,UAAME,WAAW,GAAG,KAAKD,OAAL,CAAa6C,WAAW,CAACjD,aAAzB,EAAwCiD,WAAW,CAAC/C,SAApD,CAApB;;AACA,QAAIG,WAAW,KAAK,IAApB,EAA0B;AACtB,aAAO,EAAP;AACH;;AACD,QAAIlG,KAAK,GAAG,KAAKyI,gBAAL,CAAsBzC,aAAa,CAAClF,IAApC,EAA0CkF,aAAa,CAACP,SAAxD,CAAZ;AACA,UAAMxF,GAAG,GAAG,KAAKwI,gBAAL,CAAsBvC,WAAW,CAACpF,IAAlC,EAAwCoF,WAAW,CAACT,SAApD,CAAZ;;AACA,QAAIO,aAAa,CAAClF,IAAd,KAAuBoF,WAAW,CAACpF,IAAvC,EAA6C;AACzC,WAAK8G,iBAAL,CAAuB5B,aAAa,CAAClF,IAArC,EAA2C+G,QAA3C,EAAqDiB,WAAW,CAAClD,eAAjE,EAAkFkD,WAAW,CAAChD,WAA9F,EAA2G9F,KAA3G,EAAkHC,GAAlH,EAAuH+H,UAAvH,EAAmIC,cAAnI,EAAmJC,gBAAnJ,EAAqKC,SAArK,EAAgLtI,MAAhL;AACA,aAAOA,MAAP;AACH;;AACD,QAAI+F,eAAe,GAAGkD,WAAW,CAAClD,eAAlC;AACA,QAAIqD,WAAW,GAAGjD,aAAa,CAAClF,IAAhC;;AACA,WAAOmI,WAAW,KAAK/C,WAAW,CAACpF,IAAnC,EAAyC;AACrC,YAAMoI,YAAY,GAAG,KAAKR,cAAL,CAAoBO,WAAW,CAACjI,KAAZ,CAAkBjB,WAAtC,EAAmDC,KAAnD,EAA0DiJ,WAAW,CAACjI,KAAZ,CAAkBf,GAA5E,CAArB;;AACA,UAAIiJ,YAAY,IAAI,CAApB,EAAuB;AACnB;AACA,cAAMnK,UAAU,GAAG,KAAK4D,QAAL,CAAcsG,WAAW,CAACjI,KAAZ,CAAkBjB,WAAhC,EAA6ChB,UAAhE;AACA,cAAMqJ,mBAAmB,GAAG,KAAK/B,cAAL,CAAoB4C,WAAW,CAACjI,KAAZ,CAAkBjB,WAAtC,EAAmDkJ,WAAW,CAACjI,KAAZ,CAAkBhB,KAArE,CAA5B;AACA,cAAMmJ,mBAAmB,GAAGpK,UAAU,CAACiB,KAAK,CAAC6C,IAAN,GAAaqG,YAAd,CAAtC;AACA,cAAMpD,WAAW,GAAGF,eAAe,KAAKkD,WAAW,CAAClD,eAAhC,GAAkDkD,WAAW,CAAChD,WAA9D,GAA4E,CAAhG;AACAqC,QAAAA,SAAS,GAAG,KAAKP,iBAAL,CAAuBqB,WAAvB,EAAoCpB,QAApC,EAA8CjC,eAA9C,EAA+DE,WAA/D,EAA4E9F,KAA5E,EAAmF,KAAKyI,gBAAL,CAAsBQ,WAAtB,EAAmCE,mBAAmB,GAAGf,mBAAzD,CAAnF,EAAkKJ,UAAlK,EAA8KC,cAA9K,EAA8LC,gBAA9L,EAAgNC,SAAhN,EAA2NtI,MAA3N,CAAZ;;AACA,YAAIsI,SAAS,IAAID,gBAAjB,EAAmC;AAC/B,iBAAOrI,MAAP;AACH;;AACD+F,QAAAA,eAAe,IAAIsD,YAAnB;AACH;;AACD,YAAMpD,WAAW,GAAGF,eAAe,KAAKkD,WAAW,CAAClD,eAAhC,GAAkDkD,WAAW,CAAChD,WAAZ,GAA0B,CAA5E,GAAgF,CAApG,CAdqC,CAerC;;AACA,UAAIF,eAAe,KAAKkD,WAAW,CAACjD,aAApC,EAAmD;AAC/C,cAAM1B,IAAI,GAAG,KAAKkD,cAAL,CAAoBzB,eAApB,EAAqCU,SAArC,CAA+CR,WAA/C,EAA4DgD,WAAW,CAAC/C,SAAZ,GAAwB,CAApF,CAAb;AACAoC,QAAAA,SAAS,GAAG,KAAKiB,kBAAL,CAAwBpB,UAAxB,EAAoCH,QAApC,EAA8C1D,IAA9C,EAAoD2E,WAAW,CAACjD,aAAhE,EAA+EC,WAA/E,EAA4FqC,SAA5F,EAAuGtI,MAAvG,EAA+GoI,cAA/G,EAA+HC,gBAA/H,CAAZ;AACA,eAAOrI,MAAP;AACH;;AACDsI,MAAAA,SAAS,GAAG,KAAKiB,kBAAL,CAAwBpB,UAAxB,EAAoCH,QAApC,EAA8C,KAAKR,cAAL,CAAoBzB,eAApB,EAAqCa,MAArC,CAA4CX,WAA5C,CAA9C,EAAwGF,eAAxG,EAAyHE,WAAzH,EAAsIqC,SAAtI,EAAiJtI,MAAjJ,EAAyJoI,cAAzJ,EAAyKC,gBAAzK,CAAZ;;AACA,UAAIC,SAAS,IAAID,gBAAjB,EAAmC;AAC/B,eAAOrI,MAAP;AACH;;AACD+F,MAAAA,eAAe;AACfI,MAAAA,aAAa,GAAG,KAAKC,OAAL,CAAaL,eAAb,EAA8B,CAA9B,CAAhB;AACAqD,MAAAA,WAAW,GAAGjD,aAAa,CAAClF,IAA5B;AACAd,MAAAA,KAAK,GAAG,KAAKyI,gBAAL,CAAsBzC,aAAa,CAAClF,IAApC,EAA0CkF,aAAa,CAACP,SAAxD,CAAR;AACH;;AACD,QAAIG,eAAe,KAAKkD,WAAW,CAACjD,aAApC,EAAmD;AAC/C,YAAMC,WAAW,GAAGF,eAAe,KAAKkD,WAAW,CAAClD,eAAhC,GAAkDkD,WAAW,CAAChD,WAAZ,GAA0B,CAA5E,GAAgF,CAApG;AACA,YAAM3B,IAAI,GAAG,KAAKkD,cAAL,CAAoBzB,eAApB,EAAqCU,SAArC,CAA+CR,WAA/C,EAA4DgD,WAAW,CAAC/C,SAAZ,GAAwB,CAApF,CAAb;AACAoC,MAAAA,SAAS,GAAG,KAAKiB,kBAAL,CAAwBpB,UAAxB,EAAoCH,QAApC,EAA8C1D,IAA9C,EAAoD2E,WAAW,CAACjD,aAAhE,EAA+EC,WAA/E,EAA4FqC,SAA5F,EAAuGtI,MAAvG,EAA+GoI,cAA/G,EAA+HC,gBAA/H,CAAZ;AACA,aAAOrI,MAAP;AACH;;AACD,UAAMiG,WAAW,GAAGF,eAAe,KAAKkD,WAAW,CAAClD,eAAhC,GAAkDkD,WAAW,CAAChD,WAA9D,GAA4E,CAAhG;AACAqC,IAAAA,SAAS,GAAG,KAAKP,iBAAL,CAAuB1B,WAAW,CAACpF,IAAnC,EAAyC+G,QAAzC,EAAmDjC,eAAnD,EAAoEE,WAApE,EAAiF9F,KAAjF,EAAwFC,GAAxF,EAA6F+H,UAA7F,EAAyGC,cAAzG,EAAyHC,gBAAzH,EAA2IC,SAA3I,EAAsJtI,MAAtJ,CAAZ;AACA,WAAOA,MAAP;AACH;;AACDuJ,EAAAA,kBAAkB,CAACpB,UAAD,EAAaH,QAAb,EAAuB1D,IAAvB,EAA6BvC,UAA7B,EAAyCyH,WAAzC,EAAsDlB,SAAtD,EAAiEtI,MAAjE,EAAyEoI,cAAzE,EAAyFC,gBAAzF,EAA2G;AACzH,UAAMa,cAAc,GAAGf,UAAU,CAACe,cAAlC;;AACA,QAAI,CAACd,cAAD,IAAmBD,UAAU,CAACsB,YAAlC,EAAgD;AAC5C,YAAMC,YAAY,GAAGvB,UAAU,CAACsB,YAAhC;AACA,YAAME,eAAe,GAAGD,YAAY,CAAC9K,MAArC;AACA,YAAMgL,UAAU,GAAGtF,IAAI,CAAC1F,MAAxB;AACA,UAAIiL,cAAc,GAAG,CAACF,eAAtB;;AACA,aAAO,CAACE,cAAc,GAAGvF,IAAI,CAACwF,OAAL,CAAaJ,YAAb,EAA2BG,cAAc,GAAGF,eAA5C,CAAlB,MAAoF,CAAC,CAA5F,EAA+F;AAC3F,YAAI,CAACT,cAAD,IAAmB3K,YAAY,CAAC2K,cAAD,EAAiB5E,IAAjB,EAAuBsF,UAAvB,EAAmCC,cAAnC,EAAmDF,eAAnD,CAAnC,EAAwG;AACpG3J,UAAAA,MAAM,CAACsI,SAAS,EAAV,CAAN,GAAsB,IAAIzK,SAAJ,CAAc,IAAID,KAAJ,CAAUmE,UAAV,EAAsB8H,cAAc,GAAG,CAAjB,GAAqBL,WAA3C,EAAwDzH,UAAxD,EAAoE8H,cAAc,GAAG,CAAjB,GAAqBF,eAArB,GAAuCH,WAA3G,CAAd,EAAuI,IAAvI,CAAtB;;AACA,cAAIlB,SAAS,IAAID,gBAAjB,EAAmC;AAC/B,mBAAOC,SAAP;AACH;AACJ;AACJ;;AACD,aAAOA,SAAP;AACH;;AACD,QAAIE,CAAJ,CAjByH,CAkBzH;;AACAR,IAAAA,QAAQ,CAACW,KAAT,CAAe,CAAf;;AACA,OAAG;AACCH,MAAAA,CAAC,GAAGR,QAAQ,CAACrB,IAAT,CAAcrC,IAAd,CAAJ;;AACA,UAAIkE,CAAJ,EAAO;AACHxI,QAAAA,MAAM,CAACsI,SAAS,EAAV,CAAN,GAAsBhK,eAAe,CAAC,IAAIV,KAAJ,CAAUmE,UAAV,EAAsByG,CAAC,CAAC9C,KAAF,GAAU,CAAV,GAAc8D,WAApC,EAAiDzH,UAAjD,EAA6DyG,CAAC,CAAC9C,KAAF,GAAU,CAAV,GAAc8C,CAAC,CAAC,CAAD,CAAD,CAAK5J,MAAnB,GAA4B4K,WAAzF,CAAD,EAAwGhB,CAAxG,EAA2GJ,cAA3G,CAArC;;AACA,YAAIE,SAAS,IAAID,gBAAjB,EAAmC;AAC/B,iBAAOC,SAAP;AACH;AACJ;AACJ,KARD,QAQSE,CART;;AASA,WAAOF,SAAP;AACH,GA/asB,CAgbvB;AACA;;;AACAyB,EAAAA,MAAM,CAACpI,MAAD,EAASgC,KAAT,EAAgBf,aAAa,GAAG,KAAhC,EAAuC;AACzC,SAAKU,cAAL,GAAsB,KAAKA,cAAL,IAAuBV,aAA7C;AACA,SAAKc,gBAAL,CAAsB3B,UAAtB,GAAmC,CAAnC;AACA,SAAK2B,gBAAL,CAAsBC,KAAtB,GAA8B,EAA9B;;AACA,QAAI,KAAK5C,IAAL,KAAcjD,QAAlB,EAA4B;AACxB,YAAM;AAAEmD,QAAAA,IAAF;AAAQ2E,QAAAA,SAAR;AAAmB/D,QAAAA;AAAnB,UAAuC,KAAKmI,MAAL,CAAYrI,MAAZ,CAA7C;AACA,YAAMR,KAAK,GAAGF,IAAI,CAACE,KAAnB;AACA,YAAMjB,WAAW,GAAGiB,KAAK,CAACjB,WAA1B;AACA,YAAM+J,iBAAiB,GAAG,KAAKrB,gBAAL,CAAsB3H,IAAtB,EAA4B2E,SAA5B,CAA1B;;AACA,UAAI3E,IAAI,CAACE,KAAL,CAAWjB,WAAX,KAA2B,CAA3B,IACAiB,KAAK,CAACf,GAAN,CAAU4C,IAAV,KAAmB,KAAKD,oBAAL,CAA0BC,IAD7C,IAEA7B,KAAK,CAACf,GAAN,CAAU6C,MAAV,KAAqB,KAAKF,oBAAL,CAA0BE,MAF/C,IAGCpB,eAAe,GAAGV,KAAK,CAACvC,MAAxB,KAAmC+C,MAHpC,IAIAgC,KAAK,CAAC/E,MAAN,GAAeJ,iBAJnB,EAIsC;AAClC;AACA,aAAK0L,YAAL,CAAkBjJ,IAAlB,EAAwB0C,KAAxB;AACA,aAAKC,qBAAL;AACA;AACH;;AACD,UAAI/B,eAAe,KAAKF,MAAxB,EAAgC;AAC5B,aAAKwI,uBAAL,CAA6BxG,KAA7B,EAAoC1C,IAApC;;AACA,aAAKwC,YAAL,CAAkBtB,QAAlB,CAA2BR,MAA3B;AACH,OAHD,MAIK,IAAIE,eAAe,GAAGZ,IAAI,CAACE,KAAL,CAAWvC,MAA7B,GAAsC+C,MAA1C,EAAkD;AACnD;AACA,cAAMyI,UAAU,GAAG,EAAnB;AACA,YAAIC,aAAa,GAAG,IAAIpK,KAAJ,CAAUkB,KAAK,CAACjB,WAAhB,EAA6B+J,iBAA7B,EAAgD9I,KAAK,CAACf,GAAtD,EAA2D,KAAKyI,cAAL,CAAoB1H,KAAK,CAACjB,WAA1B,EAAuC+J,iBAAvC,EAA0D9I,KAAK,CAACf,GAAhE,CAA3D,EAAiI,KAAKoG,cAAL,CAAoBtG,WAApB,EAAiCiB,KAAK,CAACf,GAAvC,IAA8C,KAAKoG,cAAL,CAAoBtG,WAApB,EAAiC+J,iBAAjC,CAA/K,CAApB;;AACA,YAAI,KAAKK,eAAL,MAA0B,KAAKC,SAAL,CAAe5G,KAAf,CAA9B,EAAqD;AACjD,gBAAM6G,WAAW,GAAG,KAAKC,cAAL,CAAoBxJ,IAApB,EAA0B2E,SAA1B,CAApB;;AACA,cAAI4E,WAAW,KAAK;AAAG;AAAvB,YAAkC;AAC9B,kBAAME,QAAQ,GAAG;AAAE1H,cAAAA,IAAI,EAAEqH,aAAa,CAAClK,KAAd,CAAoB6C,IAApB,GAA2B,CAAnC;AAAsCC,cAAAA,MAAM,EAAE;AAA9C,aAAjB;AACAoH,YAAAA,aAAa,GAAG,IAAIpK,KAAJ,CAAUoK,aAAa,CAACnK,WAAxB,EAAqCwK,QAArC,EAA+CL,aAAa,CAACjK,GAA7D,EAAkE,KAAKyI,cAAL,CAAoBwB,aAAa,CAACnK,WAAlC,EAA+CwK,QAA/C,EAAyDL,aAAa,CAACjK,GAAvE,CAAlE,EAA+IiK,aAAa,CAACzL,MAAd,GAAuB,CAAtK,CAAhB;AACA+E,YAAAA,KAAK,IAAI,IAAT;AACH;AACJ,SAXkD,CAYnD;;;AACA,YAAI,KAAK2G,eAAL,MAA0B,KAAKK,WAAL,CAAiBhH,KAAjB,CAA9B,EAAuD;AACnD,gBAAMiH,UAAU,GAAG,KAAKH,cAAL,CAAoBxJ,IAApB,EAA0B2E,SAAS,GAAG,CAAtC,CAAnB;;AACA,cAAIgF,UAAU,KAAK;AAAG;AAAtB,YAAiC;AAC7B,kBAAMC,WAAW,GAAG,KAAKjC,gBAAL,CAAsB3H,IAAtB,EAA4B2E,SAAS,GAAG,CAAxC,CAApB;AACA,iBAAKkF,cAAL,CAAoB7J,IAApB,EAA0B4J,WAA1B;AACAlH,YAAAA,KAAK,GAAG,OAAOA,KAAf;;AACA,gBAAI1C,IAAI,CAACE,KAAL,CAAWvC,MAAX,KAAsB,CAA1B,EAA6B;AACzBwL,cAAAA,UAAU,CAAClJ,IAAX,CAAgBD,IAAhB;AACH;AACJ,WAPD,MAQK;AACD,iBAAK6J,cAAL,CAAoB7J,IAApB,EAA0BgJ,iBAA1B;AACH;AACJ,SAbD,MAcK;AACD,eAAKa,cAAL,CAAoB7J,IAApB,EAA0BgJ,iBAA1B;AACH;;AACD,cAAMc,SAAS,GAAG,KAAKC,eAAL,CAAqBrH,KAArB,CAAlB;;AACA,YAAI0G,aAAa,CAACzL,MAAd,GAAuB,CAA3B,EAA8B;AAC1B,eAAK4E,aAAL,CAAmBvC,IAAnB,EAAyBoJ,aAAzB;AACH;;AACD,YAAIY,OAAO,GAAGhK,IAAd;;AACA,aAAK,IAAIiK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACnM,MAA9B,EAAsCsM,CAAC,EAAvC,EAA2C;AACvCD,UAAAA,OAAO,GAAG,KAAKzH,aAAL,CAAmByH,OAAnB,EAA4BF,SAAS,CAACG,CAAD,CAArC,CAAV;AACH;;AACD,aAAKC,WAAL,CAAiBf,UAAjB;AACH,OAvCI,MAwCA;AACD,aAAKgB,wBAAL,CAA8BzH,KAA9B,EAAqC1C,IAArC;AACH;AACJ,KA9DD,MA+DK;AACD;AACA,YAAMoK,MAAM,GAAG,KAAKL,eAAL,CAAqBrH,KAArB,CAAf;AACA,UAAI1C,IAAI,GAAG,KAAKqK,YAAL,CAAkB,IAAlB,EAAwBD,MAAM,CAAC,CAAD,CAA9B,CAAX;;AACA,WAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,MAAM,CAACzM,MAA3B,EAAmCsM,CAAC,EAApC,EAAwC;AACpCjK,QAAAA,IAAI,GAAG,KAAKuC,aAAL,CAAmBvC,IAAnB,EAAyBoK,MAAM,CAACH,CAAD,CAA/B,CAAP;AACH;AACJ,KA1EwC,CA2EzC;;;AACA,SAAKtH,qBAAL;AACH;;AACD2H,EAAAA,MAAM,CAAC5J,MAAD,EAAS6J,GAAT,EAAc;AAChB,SAAK9H,gBAAL,CAAsB3B,UAAtB,GAAmC,CAAnC;AACA,SAAK2B,gBAAL,CAAsBC,KAAtB,GAA8B,EAA9B;;AACA,QAAI6H,GAAG,IAAI,CAAP,IAAY,KAAKzK,IAAL,KAAcjD,QAA9B,EAAwC;AACpC;AACH;;AACD,UAAMqI,aAAa,GAAG,KAAK6D,MAAL,CAAYrI,MAAZ,CAAtB;AACA,UAAM0E,WAAW,GAAG,KAAK2D,MAAL,CAAYrI,MAAM,GAAG6J,GAArB,CAApB;AACA,UAAMC,SAAS,GAAGtF,aAAa,CAAClF,IAAhC;AACA,UAAMyK,OAAO,GAAGrF,WAAW,CAACpF,IAA5B;;AACA,QAAIwK,SAAS,KAAKC,OAAlB,EAA2B;AACvB,YAAMC,qBAAqB,GAAG,KAAK/C,gBAAL,CAAsB6C,SAAtB,EAAiCtF,aAAa,CAACP,SAA/C,CAA9B;AACA,YAAMgG,mBAAmB,GAAG,KAAKhD,gBAAL,CAAsB6C,SAAtB,EAAiCpF,WAAW,CAACT,SAA7C,CAA5B;;AACA,UAAIO,aAAa,CAACtE,eAAd,KAAkCF,MAAtC,EAA8C;AAC1C,YAAI6J,GAAG,KAAKC,SAAS,CAACtK,KAAV,CAAgBvC,MAA5B,EAAoC;AAAE;AAClC,gBAAM+H,IAAI,GAAG8E,SAAS,CAAC9E,IAAV,EAAb;AACAzI,UAAAA,QAAQ,CAAC,IAAD,EAAOuN,SAAP,CAAR;AACA,eAAKI,wBAAL,CAA8BlF,IAA9B;AACA,eAAK/C,qBAAL;AACA;AACH;;AACD,aAAKkI,cAAL,CAAoBL,SAApB,EAA+BG,mBAA/B;;AACA,aAAKnI,YAAL,CAAkBtB,QAAlB,CAA2BR,MAA3B;;AACA,aAAKkK,wBAAL,CAA8BJ,SAA9B;AACA,aAAK7H,qBAAL;AACA;AACH;;AACD,UAAIuC,aAAa,CAACtE,eAAd,GAAgC4J,SAAS,CAACtK,KAAV,CAAgBvC,MAAhD,KAA2D+C,MAAM,GAAG6J,GAAxE,EAA6E;AACzE,aAAKV,cAAL,CAAoBW,SAApB,EAA+BE,qBAA/B;AACA,aAAKI,wBAAL,CAA8BN,SAA9B;AACA,aAAK7H,qBAAL;AACA;AACH,OAtBsB,CAuBvB;;;AACA,WAAKoI,UAAL,CAAgBP,SAAhB,EAA2BE,qBAA3B,EAAkDC,mBAAlD;AACA,WAAKhI,qBAAL;AACA;AACH;;AACD,UAAMwG,UAAU,GAAG,EAAnB;AACA,UAAMuB,qBAAqB,GAAG,KAAK/C,gBAAL,CAAsB6C,SAAtB,EAAiCtF,aAAa,CAACP,SAA/C,CAA9B;AACA,SAAKkF,cAAL,CAAoBW,SAApB,EAA+BE,qBAA/B;;AACA,SAAKlI,YAAL,CAAkBtB,QAAlB,CAA2BR,MAA3B;;AACA,QAAI8J,SAAS,CAACtK,KAAV,CAAgBvC,MAAhB,KAA2B,CAA/B,EAAkC;AAC9BwL,MAAAA,UAAU,CAAClJ,IAAX,CAAgBuK,SAAhB;AACH,KA5Ce,CA6ChB;;;AACA,UAAMG,mBAAmB,GAAG,KAAKhD,gBAAL,CAAsB8C,OAAtB,EAA+BrF,WAAW,CAACT,SAA3C,CAA5B;AACA,SAAKkG,cAAL,CAAoBJ,OAApB,EAA6BE,mBAA7B;;AACA,QAAIF,OAAO,CAACvK,KAAR,CAAcvC,MAAd,KAAyB,CAA7B,EAAgC;AAC5BwL,MAAAA,UAAU,CAAClJ,IAAX,CAAgBwK,OAAhB;AACH,KAlDe,CAmDhB;;;AACA,UAAMO,UAAU,GAAGR,SAAS,CAAC9E,IAAV,EAAnB;;AACA,SAAK,IAAI1F,IAAI,GAAGgL,UAAhB,EAA4BhL,IAAI,KAAKnD,QAAT,IAAqBmD,IAAI,KAAKyK,OAA1D,EAAmEzK,IAAI,GAAGA,IAAI,CAAC0F,IAAL,EAA1E,EAAuF;AACnFyD,MAAAA,UAAU,CAAClJ,IAAX,CAAgBD,IAAhB;AACH;;AACD,UAAMiL,IAAI,GAAGT,SAAS,CAACtK,KAAV,CAAgBvC,MAAhB,KAA2B,CAA3B,GAA+B6M,SAAS,CAACS,IAAV,EAA/B,GAAkDT,SAA/D;AACA,SAAKN,WAAL,CAAiBf,UAAjB;AACA,SAAK2B,wBAAL,CAA8BG,IAA9B;AACA,SAAKtI,qBAAL;AACH;;AACDuG,EAAAA,uBAAuB,CAACxG,KAAD,EAAQ1C,IAAR,EAAc;AACjC;AACA,UAAMmJ,UAAU,GAAG,EAAnB;;AACA,QAAI,KAAKE,eAAL,MAA0B,KAAKC,SAAL,CAAe5G,KAAf,CAA1B,IAAmD,KAAKgH,WAAL,CAAiB1J,IAAjB,CAAvD,EAA+E;AAC3E;AACA,YAAME,KAAK,GAAGF,IAAI,CAACE,KAAnB;AACA,YAAMuJ,QAAQ,GAAG;AAAE1H,QAAAA,IAAI,EAAE7B,KAAK,CAAChB,KAAN,CAAY6C,IAAZ,GAAmB,CAA3B;AAA8BC,QAAAA,MAAM,EAAE;AAAtC,OAAjB;AACA,YAAMkJ,MAAM,GAAG,IAAIlM,KAAJ,CAAUkB,KAAK,CAACjB,WAAhB,EAA6BwK,QAA7B,EAAuCvJ,KAAK,CAACf,GAA7C,EAAkD,KAAKyI,cAAL,CAAoB1H,KAAK,CAACjB,WAA1B,EAAuCwK,QAAvC,EAAiDvJ,KAAK,CAACf,GAAvD,CAAlD,EAA+Ge,KAAK,CAACvC,MAAN,GAAe,CAA9H,CAAf;AACAqC,MAAAA,IAAI,CAACE,KAAL,GAAagL,MAAb;AACAxI,MAAAA,KAAK,IAAI,IAAT;AACAvF,MAAAA,kBAAkB,CAAC,IAAD,EAAO6C,IAAP,EAAa,CAAC,CAAd,EAAiB,CAAC,CAAlB,CAAlB;;AACA,UAAIA,IAAI,CAACE,KAAL,CAAWvC,MAAX,KAAsB,CAA1B,EAA6B;AACzBwL,QAAAA,UAAU,CAAClJ,IAAX,CAAgBD,IAAhB;AACH;AACJ;;AACD,UAAM8J,SAAS,GAAG,KAAKC,eAAL,CAAqBrH,KAArB,CAAlB;AACA,QAAIyI,OAAO,GAAG,KAAKd,YAAL,CAAkBrK,IAAlB,EAAwB8J,SAAS,CAACA,SAAS,CAACnM,MAAV,GAAmB,CAApB,CAAjC,CAAd;;AACA,SAAK,IAAIsM,CAAC,GAAGH,SAAS,CAACnM,MAAV,GAAmB,CAAhC,EAAmCsM,CAAC,IAAI,CAAxC,EAA2CA,CAAC,EAA5C,EAAgD;AAC5CkB,MAAAA,OAAO,GAAG,KAAKd,YAAL,CAAkBc,OAAlB,EAA2BrB,SAAS,CAACG,CAAD,CAApC,CAAV;AACH;;AACD,SAAKW,wBAAL,CAA8BO,OAA9B;AACA,SAAKjB,WAAL,CAAiBf,UAAjB;AACH;;AACDgB,EAAAA,wBAAwB,CAACzH,KAAD,EAAQ1C,IAAR,EAAc;AAClC;AACA,QAAI,KAAKoL,4BAAL,CAAkC1I,KAAlC,EAAyC1C,IAAzC,CAAJ,EAAoD;AAChD;AACA0C,MAAAA,KAAK,IAAI,IAAT;AACH;;AACD,UAAMoH,SAAS,GAAG,KAAKC,eAAL,CAAqBrH,KAArB,CAAlB;AACA,UAAMyI,OAAO,GAAG,KAAK5I,aAAL,CAAmBvC,IAAnB,EAAyB8J,SAAS,CAAC,CAAD,CAAlC,CAAhB;AACA,QAAIE,OAAO,GAAGmB,OAAd;;AACA,SAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACnM,MAA9B,EAAsCsM,CAAC,EAAvC,EAA2C;AACvCD,MAAAA,OAAO,GAAG,KAAKzH,aAAL,CAAmByH,OAAnB,EAA4BF,SAAS,CAACG,CAAD,CAArC,CAAV;AACH;;AACD,SAAKW,wBAAL,CAA8BO,OAA9B;AACH;;AACDxD,EAAAA,gBAAgB,CAAC3H,IAAD,EAAO2E,SAAP,EAAkBc,GAAlB,EAAuB;AACnC,UAAMvF,KAAK,GAAGF,IAAI,CAACE,KAAnB;AACA,UAAMjB,WAAW,GAAGe,IAAI,CAACE,KAAL,CAAWjB,WAA/B;AACA,UAAMhB,UAAU,GAAG,KAAK4D,QAAL,CAAc5C,WAAd,EAA2BhB,UAA9C;AACA,UAAMqH,WAAW,GAAGrH,UAAU,CAACiC,KAAK,CAAChB,KAAN,CAAY6C,IAAb,CAAV,GAA+B7B,KAAK,CAAChB,KAAN,CAAY8C,MAA/D;AACA,UAAMtB,MAAM,GAAG4E,WAAW,GAAGX,SAA7B,CALmC,CAMnC;;AACA,QAAI0G,GAAG,GAAGnL,KAAK,CAAChB,KAAN,CAAY6C,IAAtB;AACA,QAAIuJ,IAAI,GAAGpL,KAAK,CAACf,GAAN,CAAU4C,IAArB;AACA,QAAIwJ,GAAG,GAAG,CAAV;AACA,QAAIC,OAAO,GAAG,CAAd;AACA,QAAIC,QAAQ,GAAG,CAAf;;AACA,WAAOJ,GAAG,IAAIC,IAAd,EAAoB;AAChBC,MAAAA,GAAG,GAAGF,GAAG,GAAI,CAACC,IAAI,GAAGD,GAAR,IAAe,CAAtB,GAA2B,CAAjC;AACAI,MAAAA,QAAQ,GAAGxN,UAAU,CAACsN,GAAD,CAArB;;AACA,UAAIA,GAAG,KAAKD,IAAZ,EAAkB;AACd;AACH;;AACDE,MAAAA,OAAO,GAAGvN,UAAU,CAACsN,GAAG,GAAG,CAAP,CAApB;;AACA,UAAI7K,MAAM,GAAG+K,QAAb,EAAuB;AACnBH,QAAAA,IAAI,GAAGC,GAAG,GAAG,CAAb;AACH,OAFD,MAGK,IAAI7K,MAAM,IAAI8K,OAAd,EAAuB;AACxBH,QAAAA,GAAG,GAAGE,GAAG,GAAG,CAAZ;AACH,OAFI,MAGA;AACD;AACH;AACJ;;AACD,QAAI9F,GAAJ,EAAS;AACLA,MAAAA,GAAG,CAAC1D,IAAJ,GAAWwJ,GAAX;AACA9F,MAAAA,GAAG,CAACzD,MAAJ,GAAatB,MAAM,GAAG+K,QAAtB;AACA,aAAO,IAAP;AACH;;AACD,WAAO;AACH1J,MAAAA,IAAI,EAAEwJ,GADH;AAEHvJ,MAAAA,MAAM,EAAEtB,MAAM,GAAG+K;AAFd,KAAP;AAIH;;AACD7D,EAAAA,cAAc,CAAC3I,WAAD,EAAcC,KAAd,EAAqBC,GAArB,EAA0B;AACpC;AACA;AACA,QAAIA,GAAG,CAAC6C,MAAJ,KAAe,CAAnB,EAAsB;AAClB,aAAO7C,GAAG,CAAC4C,IAAJ,GAAW7C,KAAK,CAAC6C,IAAxB;AACH;;AACD,UAAM9D,UAAU,GAAG,KAAK4D,QAAL,CAAc5C,WAAd,EAA2BhB,UAA9C;;AACA,QAAIkB,GAAG,CAAC4C,IAAJ,KAAa9D,UAAU,CAACN,MAAX,GAAoB,CAArC,EAAwC;AAAE;AACtC,aAAOwB,GAAG,CAAC4C,IAAJ,GAAW7C,KAAK,CAAC6C,IAAxB;AACH;;AACD,UAAMsG,mBAAmB,GAAGpK,UAAU,CAACkB,GAAG,CAAC4C,IAAJ,GAAW,CAAZ,CAAtC;AACA,UAAM2J,SAAS,GAAGzN,UAAU,CAACkB,GAAG,CAAC4C,IAAL,CAAV,GAAuB5C,GAAG,CAAC6C,MAA7C;;AACA,QAAIqG,mBAAmB,GAAGqD,SAAS,GAAG,CAAtC,EAAyC;AAAE;AACvC,aAAOvM,GAAG,CAAC4C,IAAJ,GAAW7C,KAAK,CAAC6C,IAAxB;AACH,KAdmC,CAepC;AACA;AACA;;;AACA,UAAM4J,kBAAkB,GAAGD,SAAS,GAAG,CAAvC,CAlBoC,CAkBM;;AAC1C,UAAMpM,MAAM,GAAG,KAAKuC,QAAL,CAAc5C,WAAd,EAA2BK,MAA1C;;AACA,QAAIA,MAAM,CAACT,UAAP,CAAkB8M,kBAAlB,MAA0C,EAA9C,EAAkD;AAC9C,aAAOxM,GAAG,CAAC4C,IAAJ,GAAW7C,KAAK,CAAC6C,IAAjB,GAAwB,CAA/B;AACH,KAFD,MAGK;AACD,aAAO5C,GAAG,CAAC4C,IAAJ,GAAW7C,KAAK,CAAC6C,IAAxB;AACH;AACJ;;AACDwD,EAAAA,cAAc,CAACtG,WAAD,EAAc2M,MAAd,EAAsB;AAChC,UAAM3N,UAAU,GAAG,KAAK4D,QAAL,CAAc5C,WAAd,EAA2BhB,UAA9C;AACA,WAAOA,UAAU,CAAC2N,MAAM,CAAC7J,IAAR,CAAV,GAA0B6J,MAAM,CAAC5J,MAAxC;AACH;;AACDkI,EAAAA,WAAW,CAAC2B,KAAD,EAAQ;AACf,SAAK,IAAInN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmN,KAAK,CAAClO,MAA1B,EAAkCe,CAAC,EAAnC,EAAuC;AACnCzB,MAAAA,QAAQ,CAAC,IAAD,EAAO4O,KAAK,CAACnN,CAAD,CAAZ,CAAR;AACH;AACJ;;AACDqL,EAAAA,eAAe,CAAC1G,IAAD,EAAO;AAClB,QAAIA,IAAI,CAAC1F,MAAL,GAAcJ,iBAAlB,EAAqC;AACjC;AACA;AACA,YAAMuM,SAAS,GAAG,EAAlB;;AACA,aAAOzG,IAAI,CAAC1F,MAAL,GAAcJ,iBAArB,EAAwC;AACpC,cAAMuO,QAAQ,GAAGzI,IAAI,CAACxE,UAAL,CAAgBtB,iBAAiB,GAAG,CAApC,CAAjB;AACA,YAAIwO,SAAJ;;AACA,YAAID,QAAQ,KAAK;AAAG;AAAhB,WAAyCA,QAAQ,IAAI,MAAZ,IAAsBA,QAAQ,IAAI,MAA/E,EAAwF;AACpF;AACAC,UAAAA,SAAS,GAAG1I,IAAI,CAACmC,SAAL,CAAe,CAAf,EAAkBjI,iBAAiB,GAAG,CAAtC,CAAZ;AACA8F,UAAAA,IAAI,GAAGA,IAAI,CAACmC,SAAL,CAAejI,iBAAiB,GAAG,CAAnC,CAAP;AACH,SAJD,MAKK;AACDwO,UAAAA,SAAS,GAAG1I,IAAI,CAACmC,SAAL,CAAe,CAAf,EAAkBjI,iBAAlB,CAAZ;AACA8F,UAAAA,IAAI,GAAGA,IAAI,CAACmC,SAAL,CAAejI,iBAAf,CAAP;AACH;;AACD,cAAMU,UAAU,GAAGK,oBAAoB,CAACyN,SAAD,CAAvC;AACAjC,QAAAA,SAAS,CAAC7J,IAAV,CAAe,IAAIjB,KAAJ,CAAU,KAAK6C,QAAL,CAAclE,MAAxB;AAAgC;AAAmB;AAAEoE,UAAAA,IAAI,EAAE,CAAR;AAAWC,UAAAA,MAAM,EAAE;AAAnB,SAAnD,EAA2E;AAAED,UAAAA,IAAI,EAAE9D,UAAU,CAACN,MAAX,GAAoB,CAA5B;AAA+BqE,UAAAA,MAAM,EAAE+J,SAAS,CAACpO,MAAV,GAAmBM,UAAU,CAACA,UAAU,CAACN,MAAX,GAAoB,CAArB;AAApE,SAA3E,EAA0KM,UAAU,CAACN,MAAX,GAAoB,CAA9L,EAAiMoO,SAAS,CAACpO,MAA3M,CAAf;;AACA,aAAKkE,QAAL,CAAc5B,IAAd,CAAmB,IAAIZ,YAAJ,CAAiB0M,SAAjB,EAA4B9N,UAA5B,CAAnB;AACH;;AACD,YAAMA,UAAU,GAAGK,oBAAoB,CAAC+E,IAAD,CAAvC;AACAyG,MAAAA,SAAS,CAAC7J,IAAV,CAAe,IAAIjB,KAAJ,CAAU,KAAK6C,QAAL,CAAclE,MAAxB;AAAgC;AAAmB;AAAEoE,QAAAA,IAAI,EAAE,CAAR;AAAWC,QAAAA,MAAM,EAAE;AAAnB,OAAnD,EAA2E;AAAED,QAAAA,IAAI,EAAE9D,UAAU,CAACN,MAAX,GAAoB,CAA5B;AAA+BqE,QAAAA,MAAM,EAAEqB,IAAI,CAAC1F,MAAL,GAAcM,UAAU,CAACA,UAAU,CAACN,MAAX,GAAoB,CAArB;AAA/D,OAA3E,EAAqKM,UAAU,CAACN,MAAX,GAAoB,CAAzL,EAA4L0F,IAAI,CAAC1F,MAAjM,CAAf;;AACA,WAAKkE,QAAL,CAAc5B,IAAd,CAAmB,IAAIZ,YAAJ,CAAiBgE,IAAjB,EAAuBpF,UAAvB,CAAnB;;AACA,aAAO6L,SAAP;AACH;;AACD,QAAIxE,WAAW,GAAG,KAAKzD,QAAL,CAAc,CAAd,EAAiBvC,MAAjB,CAAwB3B,MAA1C;AACA,UAAMM,UAAU,GAAGK,oBAAoB,CAAC+E,IAAD,EAAO,KAAP,CAAvC;AACA,QAAInE,KAAK,GAAG,KAAK4C,oBAAjB;;AACA,QAAI,KAAKD,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4B,KAAK4D,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4BN,MAA5B,GAAqC,CAAjE,MAAwE2H,WAAxE,IACGA,WAAW,KAAK,CADnB,IAEG,KAAKoE,WAAL,CAAiBrG,IAAjB,CAFH,IAGG,KAAKiG,SAAL,CAAe,KAAKzH,QAAL,CAAc,CAAd,EAAiBvC,MAAhC,CAHP,CAG+C;AAH/C,MAIE;AACE,WAAKwC,oBAAL,GAA4B;AAAEC,QAAAA,IAAI,EAAE,KAAKD,oBAAL,CAA0BC,IAAlC;AAAwCC,QAAAA,MAAM,EAAE,KAAKF,oBAAL,CAA0BE,MAA1B,GAAmC;AAAnF,OAA5B;AACA9C,MAAAA,KAAK,GAAG,KAAK4C,oBAAb;;AACA,WAAK,IAAIpD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,UAAU,CAACN,MAA/B,EAAuCe,CAAC,EAAxC,EAA4C;AACxCT,QAAAA,UAAU,CAACS,CAAD,CAAV,IAAiB4G,WAAW,GAAG,CAA/B;AACH;;AACD,WAAKzD,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,GAA8B,KAAK4D,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4B+N,MAA5B,CAAmC/N,UAAU,CAACgO,KAAX,CAAiB,CAAjB,CAAnC,CAA9B;AACA,WAAKpK,QAAL,CAAc,CAAd,EAAiBvC,MAAjB,IAA2B,MAAM+D,IAAjC;AACAiC,MAAAA,WAAW,IAAI,CAAf;AACH,KAbD,MAcK;AACD,UAAIA,WAAW,KAAK,CAApB,EAAuB;AACnB,aAAK,IAAI5G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,UAAU,CAACN,MAA/B,EAAuCe,CAAC,EAAxC,EAA4C;AACxCT,UAAAA,UAAU,CAACS,CAAD,CAAV,IAAiB4G,WAAjB;AACH;AACJ;;AACD,WAAKzD,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,GAA8B,KAAK4D,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4B+N,MAA5B,CAAmC/N,UAAU,CAACgO,KAAX,CAAiB,CAAjB,CAAnC,CAA9B;AACA,WAAKpK,QAAL,CAAc,CAAd,EAAiBvC,MAAjB,IAA2B+D,IAA3B;AACH;;AACD,UAAMqI,SAAS,GAAG,KAAK7J,QAAL,CAAc,CAAd,EAAiBvC,MAAjB,CAAwB3B,MAA1C;AACA,UAAMuO,QAAQ,GAAG,KAAKrK,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4BN,MAA5B,GAAqC,CAAtD;AACA,UAAMsH,SAAS,GAAGyG,SAAS,GAAG,KAAK7J,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4BiO,QAA5B,CAA9B;AACA,UAAMC,MAAM,GAAG;AAAEpK,MAAAA,IAAI,EAAEmK,QAAR;AAAkBlK,MAAAA,MAAM,EAAEiD;AAA1B,KAAf;AACA,UAAMmH,QAAQ,GAAG,IAAIpN,KAAJ,CAAU,CAAV;AAAa;AAAiBE,IAAAA,KAA9B,EAAqCiN,MAArC,EAA6C,KAAKvE,cAAL,CAAoB,CAApB,EAAuB1I,KAAvB,EAA8BiN,MAA9B,CAA7C,EAAoFT,SAAS,GAAGpG,WAAhG,CAAjB;AACA,SAAKxD,oBAAL,GAA4BqK,MAA5B;AACA,WAAO,CAACC,QAAD,CAAP;AACH;;AACD5F,EAAAA,iBAAiB,CAAC1F,UAAD,EAAa4K,SAAS,GAAG,CAAzB,EAA4B;AACzC,QAAI7H,CAAC,GAAG,KAAK/D,IAAb;AACA,QAAI2F,GAAG,GAAG,EAAV;;AACA,UAAM4G,KAAK,GAAG,KAAK7J,YAAL,CAAkB3B,IAAlB,CAAuBC,UAAvB,CAAd;;AACA,QAAIuL,KAAJ,EAAW;AACPxI,MAAAA,CAAC,GAAGwI,KAAK,CAACrM,IAAV;AACA,YAAMsM,oBAAoB,GAAG,KAAKpI,mBAAL,CAAyBL,CAAzB,EAA4B/C,UAAU,GAAGuL,KAAK,CAACtL,mBAAnB,GAAyC,CAArE,CAA7B;AACA,YAAMzB,MAAM,GAAG,KAAKuC,QAAL,CAAcgC,CAAC,CAAC3D,KAAF,CAAQjB,WAAtB,EAAmCK,MAAlD;AACA,YAAMgG,WAAW,GAAG,KAAKC,cAAL,CAAoB1B,CAAC,CAAC3D,KAAF,CAAQjB,WAA5B,EAAyC4E,CAAC,CAAC3D,KAAF,CAAQhB,KAAjD,CAApB;;AACA,UAAImN,KAAK,CAACtL,mBAAN,GAA4B8C,CAAC,CAAC3D,KAAF,CAAQd,WAApC,KAAoD0B,UAAxD,EAAoE;AAChE2E,QAAAA,GAAG,GAAGnG,MAAM,CAACkG,SAAP,CAAiBF,WAAW,GAAGgH,oBAA/B,EAAqDhH,WAAW,GAAGzB,CAAC,CAAC3D,KAAF,CAAQvC,MAA3E,CAAN;AACH,OAFD,MAGK;AACD,cAAM4O,gBAAgB,GAAG,KAAKrI,mBAAL,CAAyBL,CAAzB,EAA4B/C,UAAU,GAAGuL,KAAK,CAACtL,mBAA/C,CAAzB;AACA,eAAOzB,MAAM,CAACkG,SAAP,CAAiBF,WAAW,GAAGgH,oBAA/B,EAAqDhH,WAAW,GAAGiH,gBAAd,GAAiCb,SAAtF,CAAP;AACH;AACJ,KAZD,MAaK;AACD,UAAI9K,eAAe,GAAG,CAAtB;AACA,YAAM4L,kBAAkB,GAAG1L,UAA3B;;AACA,aAAO+C,CAAC,KAAKhH,QAAb,EAAuB;AACnB,YAAIgH,CAAC,CAACC,IAAF,KAAWjH,QAAX,IAAuBgH,CAAC,CAACE,OAAF,IAAajD,UAAU,GAAG,CAArD,EAAwD;AACpD+C,UAAAA,CAAC,GAAGA,CAAC,CAACC,IAAN;AACH,SAFD,MAGK,IAAID,CAAC,CAACE,OAAF,GAAYF,CAAC,CAAC3D,KAAF,CAAQd,WAApB,GAAkC0B,UAAU,GAAG,CAAnD,EAAsD;AACvD,gBAAMwL,oBAAoB,GAAG,KAAKpI,mBAAL,CAAyBL,CAAzB,EAA4B/C,UAAU,GAAG+C,CAAC,CAACE,OAAf,GAAyB,CAArD,CAA7B;AACA,gBAAMwI,gBAAgB,GAAG,KAAKrI,mBAAL,CAAyBL,CAAzB,EAA4B/C,UAAU,GAAG+C,CAAC,CAACE,OAAf,GAAyB,CAArD,CAAzB;AACA,gBAAMzE,MAAM,GAAG,KAAKuC,QAAL,CAAcgC,CAAC,CAAC3D,KAAF,CAAQjB,WAAtB,EAAmCK,MAAlD;AACA,gBAAMgG,WAAW,GAAG,KAAKC,cAAL,CAAoB1B,CAAC,CAAC3D,KAAF,CAAQjB,WAA5B,EAAyC4E,CAAC,CAAC3D,KAAF,CAAQhB,KAAjD,CAApB;AACA0B,UAAAA,eAAe,IAAIiD,CAAC,CAACG,SAArB;;AACA,eAAKxB,YAAL,CAAkB1E,GAAlB,CAAsB;AAClBkC,YAAAA,IAAI,EAAE6D,CADY;AAElBjD,YAAAA,eAFkB;AAGlBG,YAAAA,mBAAmB,EAAEyL,kBAAkB,IAAI1L,UAAU,GAAG,CAAb,GAAiB+C,CAAC,CAACE,OAAvB;AAHrB,WAAtB;;AAKA,iBAAOzE,MAAM,CAACkG,SAAP,CAAiBF,WAAW,GAAGgH,oBAA/B,EAAqDhH,WAAW,GAAGiH,gBAAd,GAAiCb,SAAtF,CAAP;AACH,SAZI,MAaA,IAAI7H,CAAC,CAACE,OAAF,GAAYF,CAAC,CAAC3D,KAAF,CAAQd,WAApB,KAAoC0B,UAAU,GAAG,CAArD,EAAwD;AACzD,gBAAMwL,oBAAoB,GAAG,KAAKpI,mBAAL,CAAyBL,CAAzB,EAA4B/C,UAAU,GAAG+C,CAAC,CAACE,OAAf,GAAyB,CAArD,CAA7B;AACA,gBAAMzE,MAAM,GAAG,KAAKuC,QAAL,CAAcgC,CAAC,CAAC3D,KAAF,CAAQjB,WAAtB,EAAmCK,MAAlD;AACA,gBAAMgG,WAAW,GAAG,KAAKC,cAAL,CAAoB1B,CAAC,CAAC3D,KAAF,CAAQjB,WAA5B,EAAyC4E,CAAC,CAAC3D,KAAF,CAAQhB,KAAjD,CAApB;AACAuG,UAAAA,GAAG,GAAGnG,MAAM,CAACkG,SAAP,CAAiBF,WAAW,GAAGgH,oBAA/B,EAAqDhH,WAAW,GAAGzB,CAAC,CAAC3D,KAAF,CAAQvC,MAA3E,CAAN;AACA;AACH,SANI,MAOA;AACDmD,UAAAA,UAAU,IAAI+C,CAAC,CAACE,OAAF,GAAYF,CAAC,CAAC3D,KAAF,CAAQd,WAAlC;AACAwB,UAAAA,eAAe,IAAIiD,CAAC,CAACG,SAAF,GAAcH,CAAC,CAAC3D,KAAF,CAAQvC,MAAzC;AACAkG,UAAAA,CAAC,GAAGA,CAAC,CAACM,KAAN;AACH;AACJ;AACJ,KAlDwC,CAmDzC;;;AACAN,IAAAA,CAAC,GAAGA,CAAC,CAAC6B,IAAF,EAAJ;;AACA,WAAO7B,CAAC,KAAKhH,QAAb,EAAuB;AACnB,YAAMyC,MAAM,GAAG,KAAKuC,QAAL,CAAcgC,CAAC,CAAC3D,KAAF,CAAQjB,WAAtB,EAAmCK,MAAlD;;AACA,UAAIuE,CAAC,CAAC3D,KAAF,CAAQd,WAAR,GAAsB,CAA1B,EAA6B;AACzB,cAAMmN,gBAAgB,GAAG,KAAKrI,mBAAL,CAAyBL,CAAzB,EAA4B,CAA5B,CAAzB;AACA,cAAMyB,WAAW,GAAG,KAAKC,cAAL,CAAoB1B,CAAC,CAAC3D,KAAF,CAAQjB,WAA5B,EAAyC4E,CAAC,CAAC3D,KAAF,CAAQhB,KAAjD,CAApB;AACAuG,QAAAA,GAAG,IAAInG,MAAM,CAACkG,SAAP,CAAiBF,WAAjB,EAA8BA,WAAW,GAAGiH,gBAAd,GAAiCb,SAA/D,CAAP;AACA,eAAOjG,GAAP;AACH,OALD,MAMK;AACD,cAAMH,WAAW,GAAG,KAAKC,cAAL,CAAoB1B,CAAC,CAAC3D,KAAF,CAAQjB,WAA5B,EAAyC4E,CAAC,CAAC3D,KAAF,CAAQhB,KAAjD,CAApB;AACAuG,QAAAA,GAAG,IAAInG,MAAM,CAACqG,MAAP,CAAcL,WAAd,EAA2BzB,CAAC,CAAC3D,KAAF,CAAQvC,MAAnC,CAAP;AACH;;AACDkG,MAAAA,CAAC,GAAGA,CAAC,CAAC6B,IAAF,EAAJ;AACH;;AACD,WAAOD,GAAP;AACH;;AACD9C,EAAAA,qBAAqB,GAAG;AACpB,QAAIkB,CAAC,GAAG,KAAK/D,IAAb;AACA,QAAIuE,KAAK,GAAG,CAAZ;AACA,QAAI1F,GAAG,GAAG,CAAV;;AACA,WAAOkF,CAAC,KAAKhH,QAAb,EAAuB;AACnBwH,MAAAA,KAAK,IAAIR,CAAC,CAACE,OAAF,GAAYF,CAAC,CAAC3D,KAAF,CAAQd,WAA7B;AACAT,MAAAA,GAAG,IAAIkF,CAAC,CAACG,SAAF,GAAcH,CAAC,CAAC3D,KAAF,CAAQvC,MAA7B;AACAkG,MAAAA,CAAC,GAAGA,CAAC,CAACM,KAAN;AACH;;AACD,SAAKlC,QAAL,GAAgBoC,KAAhB;AACA,SAAKnC,OAAL,GAAevD,GAAf;;AACA,SAAK6D,YAAL,CAAkBtB,QAAlB,CAA2B,KAAKgB,OAAhC;AACH,GA1zBsB,CA2zBvB;;;AACAsC,EAAAA,UAAU,CAACxE,IAAD,EAAOuM,gBAAP,EAAyB;AAC/B,UAAMrM,KAAK,GAAGF,IAAI,CAACE,KAAnB;AACA,UAAMuM,GAAG,GAAG,KAAK9E,gBAAL,CAAsB3H,IAAtB,EAA4BuM,gBAA5B,CAAZ;AACA,UAAMG,OAAO,GAAGD,GAAG,CAAC1K,IAAJ,GAAW7B,KAAK,CAAChB,KAAN,CAAY6C,IAAvC;;AACA,QAAI,KAAKwD,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCiB,KAAK,CAACf,GAA7C,IAAoD,KAAKoG,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCiB,KAAK,CAAChB,KAA7C,CAApD,KAA4GqN,gBAAhH,EAAkI;AAC9H;AACA,YAAMI,WAAW,GAAG,KAAK/E,cAAL,CAAoB5H,IAAI,CAACE,KAAL,CAAWjB,WAA/B,EAA4CiB,KAAK,CAAChB,KAAlD,EAAyDuN,GAAzD,CAApB;;AACA,UAAIE,WAAW,KAAKD,OAApB,EAA6B;AACzB;AACA,eAAO;AAAEjI,UAAAA,KAAK,EAAEkI,WAAT;AAAsBhI,UAAAA,SAAS,EAAE;AAAjC,SAAP;AACH;AACJ;;AACD,WAAO;AAAEF,MAAAA,KAAK,EAAEiI,OAAT;AAAkB/H,MAAAA,SAAS,EAAE8H,GAAG,CAACzK;AAAjC,KAAP;AACH;;AACDkC,EAAAA,mBAAmB,CAAClE,IAAD,EAAOyE,KAAP,EAAc;AAC7B,QAAIA,KAAK,GAAG,CAAZ,EAAe;AACX,aAAO,CAAP;AACH;;AACD,UAAMvE,KAAK,GAAGF,IAAI,CAACE,KAAnB;AACA,UAAMjC,UAAU,GAAG,KAAK4D,QAAL,CAAc3B,KAAK,CAACjB,WAApB,EAAiChB,UAApD;AACA,UAAM2O,sBAAsB,GAAG1M,KAAK,CAAChB,KAAN,CAAY6C,IAAZ,GAAmB0C,KAAnB,GAA2B,CAA1D;;AACA,QAAImI,sBAAsB,GAAG1M,KAAK,CAACf,GAAN,CAAU4C,IAAvC,EAA6C;AACzC,aAAO9D,UAAU,CAACiC,KAAK,CAACf,GAAN,CAAU4C,IAAX,CAAV,GAA6B7B,KAAK,CAACf,GAAN,CAAU6C,MAAvC,GAAgD/D,UAAU,CAACiC,KAAK,CAAChB,KAAN,CAAY6C,IAAb,CAA1D,GAA+E7B,KAAK,CAAChB,KAAN,CAAY8C,MAAlG;AACH,KAFD,MAGK;AACD,aAAO/D,UAAU,CAAC2O,sBAAD,CAAV,GAAqC3O,UAAU,CAACiC,KAAK,CAAChB,KAAN,CAAY6C,IAAb,CAA/C,GAAoE7B,KAAK,CAAChB,KAAN,CAAY8C,MAAvF;AACH;AACJ;;AACD6H,EAAAA,cAAc,CAAC7J,IAAD,EAAOyM,GAAP,EAAY;AACtB,UAAMvM,KAAK,GAAGF,IAAI,CAACE,KAAnB;AACA,UAAM2M,aAAa,GAAG3M,KAAK,CAACd,WAA5B;AACA,UAAM0N,iBAAiB,GAAG,KAAKvH,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCiB,KAAK,CAACf,GAA7C,CAA1B;AACA,UAAM4N,MAAM,GAAGN,GAAf;AACA,UAAMO,YAAY,GAAG,KAAKzH,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuC8N,MAAvC,CAArB;AACA,UAAME,cAAc,GAAG,KAAKrF,cAAL,CAAoB1H,KAAK,CAACjB,WAA1B,EAAuCiB,KAAK,CAAChB,KAA7C,EAAoD6N,MAApD,CAAvB;AACA,UAAMG,QAAQ,GAAGD,cAAc,GAAGJ,aAAlC;AACA,UAAMM,UAAU,GAAGH,YAAY,GAAGF,iBAAlC;AACA,UAAMM,SAAS,GAAGlN,KAAK,CAACvC,MAAN,GAAewP,UAAjC;AACAnN,IAAAA,IAAI,CAACE,KAAL,GAAa,IAAIlB,KAAJ,CAAUkB,KAAK,CAACjB,WAAhB,EAA6BiB,KAAK,CAAChB,KAAnC,EAA0C6N,MAA1C,EAAkDE,cAAlD,EAAkEG,SAAlE,CAAb;AACAjQ,IAAAA,kBAAkB,CAAC,IAAD,EAAO6C,IAAP,EAAamN,UAAb,EAAyBD,QAAzB,CAAlB;AACH;;AACDrC,EAAAA,cAAc,CAAC7K,IAAD,EAAOyM,GAAP,EAAY;AACtB,UAAMvM,KAAK,GAAGF,IAAI,CAACE,KAAnB;AACA,UAAM2M,aAAa,GAAG3M,KAAK,CAACd,WAA5B;AACA,UAAMiO,mBAAmB,GAAG,KAAK9H,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCiB,KAAK,CAAChB,KAA7C,CAA5B;AACA,UAAMuK,QAAQ,GAAGgD,GAAjB;AACA,UAAMQ,cAAc,GAAG,KAAKrF,cAAL,CAAoB1H,KAAK,CAACjB,WAA1B,EAAuCwK,QAAvC,EAAiDvJ,KAAK,CAACf,GAAvD,CAAvB;AACA,UAAMmO,cAAc,GAAG,KAAK/H,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCwK,QAAvC,CAAvB;AACA,UAAMyD,QAAQ,GAAGD,cAAc,GAAGJ,aAAlC;AACA,UAAMM,UAAU,GAAGE,mBAAmB,GAAGC,cAAzC;AACA,UAAMF,SAAS,GAAGlN,KAAK,CAACvC,MAAN,GAAewP,UAAjC;AACAnN,IAAAA,IAAI,CAACE,KAAL,GAAa,IAAIlB,KAAJ,CAAUkB,KAAK,CAACjB,WAAhB,EAA6BwK,QAA7B,EAAuCvJ,KAAK,CAACf,GAA7C,EAAkD8N,cAAlD,EAAkEG,SAAlE,CAAb;AACAjQ,IAAAA,kBAAkB,CAAC,IAAD,EAAO6C,IAAP,EAAamN,UAAb,EAAyBD,QAAzB,CAAlB;AACH;;AACDnC,EAAAA,UAAU,CAAC/K,IAAD,EAAOd,KAAP,EAAcC,GAAd,EAAmB;AACzB,UAAMe,KAAK,GAAGF,IAAI,CAACE,KAAnB;AACA,UAAMqN,gBAAgB,GAAGrN,KAAK,CAAChB,KAA/B;AACA,UAAMsO,cAAc,GAAGtN,KAAK,CAACf,GAA7B,CAHyB,CAIzB;;AACA,UAAMsO,SAAS,GAAGvN,KAAK,CAACvC,MAAxB;AACA,UAAM+P,QAAQ,GAAGxN,KAAK,CAACd,WAAvB;AACA,UAAM2N,MAAM,GAAG7N,KAAf;AACA,UAAM+N,cAAc,GAAG,KAAKrF,cAAL,CAAoB1H,KAAK,CAACjB,WAA1B,EAAuCiB,KAAK,CAAChB,KAA7C,EAAoD6N,MAApD,CAAvB;AACA,UAAMK,SAAS,GAAG,KAAK7H,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCC,KAAvC,IAAgD,KAAKqG,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCsO,gBAAvC,CAAlE;AACAvN,IAAAA,IAAI,CAACE,KAAL,GAAa,IAAIlB,KAAJ,CAAUkB,KAAK,CAACjB,WAAhB,EAA6BiB,KAAK,CAAChB,KAAnC,EAA0C6N,MAA1C,EAAkDE,cAAlD,EAAkEG,SAAlE,CAAb;AACAjQ,IAAAA,kBAAkB,CAAC,IAAD,EAAO6C,IAAP,EAAaoN,SAAS,GAAGK,SAAzB,EAAoCR,cAAc,GAAGS,QAArD,CAAlB,CAXyB,CAYzB;;AACA,UAAMtB,QAAQ,GAAG,IAAIpN,KAAJ,CAAUkB,KAAK,CAACjB,WAAhB,EAA6BE,GAA7B,EAAkCqO,cAAlC,EAAkD,KAAK5F,cAAL,CAAoB1H,KAAK,CAACjB,WAA1B,EAAuCE,GAAvC,EAA4CqO,cAA5C,CAAlD,EAA+G,KAAKjI,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCuO,cAAvC,IAAyD,KAAKjI,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCE,GAAvC,CAAxK,CAAjB;AACA,UAAMgM,OAAO,GAAG,KAAK5I,aAAL,CAAmBvC,IAAnB,EAAyBoM,QAAzB,CAAhB;AACA,SAAKxB,wBAAL,CAA8BO,OAA9B;AACH;;AACDlC,EAAAA,YAAY,CAACjJ,IAAD,EAAO0C,KAAP,EAAc;AACtB,QAAI,KAAK0I,4BAAL,CAAkC1I,KAAlC,EAAyC1C,IAAzC,CAAJ,EAAoD;AAChD0C,MAAAA,KAAK,IAAI,IAAT;AACH;;AACD,UAAMiL,OAAO,GAAG,KAAKtE,eAAL,MAA0B,KAAKK,WAAL,CAAiBhH,KAAjB,CAA1B,IAAqD,KAAK4G,SAAL,CAAetJ,IAAf,CAArE;AACA,UAAMsF,WAAW,GAAG,KAAKzD,QAAL,CAAc,CAAd,EAAiBvC,MAAjB,CAAwB3B,MAA5C;AACA,SAAKkE,QAAL,CAAc,CAAd,EAAiBvC,MAAjB,IAA2BoD,KAA3B;AACA,UAAMzE,UAAU,GAAGK,oBAAoB,CAACoE,KAAD,EAAQ,KAAR,CAAvC;;AACA,SAAK,IAAIhE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,UAAU,CAACN,MAA/B,EAAuCe,CAAC,EAAxC,EAA4C;AACxCT,MAAAA,UAAU,CAACS,CAAD,CAAV,IAAiB4G,WAAjB;AACH;;AACD,QAAIqI,OAAJ,EAAa;AACT,YAAMC,eAAe,GAAG,KAAK/L,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4B,KAAK4D,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4BN,MAA5B,GAAqC,CAAjE,CAAxB;;AACA,WAAKkE,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4B4P,GAA5B,GAFS,CAGT;;;AACA,WAAK/L,oBAAL,GAA4B;AAAEC,QAAAA,IAAI,EAAE,KAAKD,oBAAL,CAA0BC,IAA1B,GAAiC,CAAzC;AAA4CC,QAAAA,MAAM,EAAEsD,WAAW,GAAGsI;AAAlE,OAA5B;AACH;;AACD,SAAK/L,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,GAA8B,KAAK4D,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4B+N,MAA5B,CAAmC/N,UAAU,CAACgO,KAAX,CAAiB,CAAjB,CAAnC,CAA9B;AACA,UAAMC,QAAQ,GAAG,KAAKrK,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4BN,MAA5B,GAAqC,CAAtD;AACA,UAAMsH,SAAS,GAAG,KAAKpD,QAAL,CAAc,CAAd,EAAiBvC,MAAjB,CAAwB3B,MAAxB,GAAiC,KAAKkE,QAAL,CAAc,CAAd,EAAiB5D,UAAjB,CAA4BiO,QAA5B,CAAnD;AACA,UAAMa,MAAM,GAAG;AAAEhL,MAAAA,IAAI,EAAEmK,QAAR;AAAkBlK,MAAAA,MAAM,EAAEiD;AAA1B,KAAf;AACA,UAAMmI,SAAS,GAAGpN,IAAI,CAACE,KAAL,CAAWvC,MAAX,GAAoB+E,KAAK,CAAC/E,MAA5C;AACA,UAAMmQ,cAAc,GAAG9N,IAAI,CAACE,KAAL,CAAWd,WAAlC;AACA,UAAM6N,cAAc,GAAG,KAAKrF,cAAL,CAAoB,CAApB,EAAuB5H,IAAI,CAACE,KAAL,CAAWhB,KAAlC,EAAyC6N,MAAzC,CAAvB;AACA,UAAMG,QAAQ,GAAGD,cAAc,GAAGa,cAAlC;AACA9N,IAAAA,IAAI,CAACE,KAAL,GAAa,IAAIlB,KAAJ,CAAUgB,IAAI,CAACE,KAAL,CAAWjB,WAArB,EAAkCe,IAAI,CAACE,KAAL,CAAWhB,KAA7C,EAAoD6N,MAApD,EAA4DE,cAA5D,EAA4EG,SAA5E,CAAb;AACA,SAAKtL,oBAAL,GAA4BiL,MAA5B;AACA5P,IAAAA,kBAAkB,CAAC,IAAD,EAAO6C,IAAP,EAAa0C,KAAK,CAAC/E,MAAnB,EAA2BuP,QAA3B,CAAlB;AACH;;AACDnE,EAAAA,MAAM,CAACrI,MAAD,EAAS;AACX,QAAImD,CAAC,GAAG,KAAK/D,IAAb;;AACA,UAAMuM,KAAK,GAAG,KAAK7J,YAAL,CAAkB/B,GAAlB,CAAsBC,MAAtB,CAAd;;AACA,QAAI2L,KAAJ,EAAW;AACP,aAAO;AACHrM,QAAAA,IAAI,EAAEqM,KAAK,CAACrM,IADT;AAEHY,QAAAA,eAAe,EAAEyL,KAAK,CAACzL,eAFpB;AAGH+D,QAAAA,SAAS,EAAEjE,MAAM,GAAG2L,KAAK,CAACzL;AAHvB,OAAP;AAKH;;AACD,QAAIA,eAAe,GAAG,CAAtB;;AACA,WAAOiD,CAAC,KAAKhH,QAAb,EAAuB;AACnB,UAAIgH,CAAC,CAACG,SAAF,GAActD,MAAlB,EAA0B;AACtBmD,QAAAA,CAAC,GAAGA,CAAC,CAACC,IAAN;AACH,OAFD,MAGK,IAAID,CAAC,CAACG,SAAF,GAAcH,CAAC,CAAC3D,KAAF,CAAQvC,MAAtB,IAAgC+C,MAApC,EAA4C;AAC7CE,QAAAA,eAAe,IAAIiD,CAAC,CAACG,SAArB;AACA,cAAMyB,GAAG,GAAG;AACRzF,UAAAA,IAAI,EAAE6D,CADE;AAERc,UAAAA,SAAS,EAAEjE,MAAM,GAAGmD,CAAC,CAACG,SAFd;AAGRpD,UAAAA;AAHQ,SAAZ;;AAKA,aAAK4B,YAAL,CAAkB1E,GAAlB,CAAsB2H,GAAtB;;AACA,eAAOA,GAAP;AACH,OATI,MAUA;AACD/E,QAAAA,MAAM,IAAImD,CAAC,CAACG,SAAF,GAAcH,CAAC,CAAC3D,KAAF,CAAQvC,MAAhC;AACAiD,QAAAA,eAAe,IAAIiD,CAAC,CAACG,SAAF,GAAcH,CAAC,CAAC3D,KAAF,CAAQvC,MAAzC;AACAkG,QAAAA,CAAC,GAAGA,CAAC,CAACM,KAAN;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACDgB,EAAAA,OAAO,CAACrE,UAAD,EAAakB,MAAb,EAAqB;AACxB,QAAI6B,CAAC,GAAG,KAAK/D,IAAb;AACA,QAAIc,eAAe,GAAG,CAAtB;;AACA,WAAOiD,CAAC,KAAKhH,QAAb,EAAuB;AACnB,UAAIgH,CAAC,CAACC,IAAF,KAAWjH,QAAX,IAAuBgH,CAAC,CAACE,OAAF,IAAajD,UAAU,GAAG,CAArD,EAAwD;AACpD+C,QAAAA,CAAC,GAAGA,CAAC,CAACC,IAAN;AACH,OAFD,MAGK,IAAID,CAAC,CAACE,OAAF,GAAYF,CAAC,CAAC3D,KAAF,CAAQd,WAApB,GAAkC0B,UAAU,GAAG,CAAnD,EAAsD;AACvD,cAAMiN,oBAAoB,GAAG,KAAK7J,mBAAL,CAAyBL,CAAzB,EAA4B/C,UAAU,GAAG+C,CAAC,CAACE,OAAf,GAAyB,CAArD,CAA7B;AACA,cAAMwI,gBAAgB,GAAG,KAAKrI,mBAAL,CAAyBL,CAAzB,EAA4B/C,UAAU,GAAG+C,CAAC,CAACE,OAAf,GAAyB,CAArD,CAAzB;AACAnD,QAAAA,eAAe,IAAIiD,CAAC,CAACG,SAArB;AACA,eAAO;AACHhE,UAAAA,IAAI,EAAE6D,CADH;AAEHc,UAAAA,SAAS,EAAE5B,IAAI,CAACD,GAAL,CAASiL,oBAAoB,GAAG/L,MAAvB,GAAgC,CAAzC,EAA4CuK,gBAA5C,CAFR;AAGH3L,UAAAA;AAHG,SAAP;AAKH,OATI,MAUA,IAAIiD,CAAC,CAACE,OAAF,GAAYF,CAAC,CAAC3D,KAAF,CAAQd,WAApB,KAAoC0B,UAAU,GAAG,CAArD,EAAwD;AACzD,cAAMiN,oBAAoB,GAAG,KAAK7J,mBAAL,CAAyBL,CAAzB,EAA4B/C,UAAU,GAAG+C,CAAC,CAACE,OAAf,GAAyB,CAArD,CAA7B;;AACA,YAAIgK,oBAAoB,GAAG/L,MAAvB,GAAgC,CAAhC,IAAqC6B,CAAC,CAAC3D,KAAF,CAAQvC,MAAjD,EAAyD;AACrD,iBAAO;AACHqC,YAAAA,IAAI,EAAE6D,CADH;AAEHc,YAAAA,SAAS,EAAEoJ,oBAAoB,GAAG/L,MAAvB,GAAgC,CAFxC;AAGHpB,YAAAA;AAHG,WAAP;AAKH,SAND,MAOK;AACDoB,UAAAA,MAAM,IAAI6B,CAAC,CAAC3D,KAAF,CAAQvC,MAAR,GAAiBoQ,oBAA3B;AACA;AACH;AACJ,OAbI,MAcA;AACDjN,QAAAA,UAAU,IAAI+C,CAAC,CAACE,OAAF,GAAYF,CAAC,CAAC3D,KAAF,CAAQd,WAAlC;AACAwB,QAAAA,eAAe,IAAIiD,CAAC,CAACG,SAAF,GAAcH,CAAC,CAAC3D,KAAF,CAAQvC,MAAzC;AACAkG,QAAAA,CAAC,GAAGA,CAAC,CAACM,KAAN;AACH;AACJ,KApCuB,CAqCxB;;;AACAN,IAAAA,CAAC,GAAGA,CAAC,CAAC6B,IAAF,EAAJ;;AACA,WAAO7B,CAAC,KAAKhH,QAAb,EAAuB;AACnB,UAAIgH,CAAC,CAAC3D,KAAF,CAAQd,WAAR,GAAsB,CAA1B,EAA6B;AACzB,cAAMmN,gBAAgB,GAAG,KAAKrI,mBAAL,CAAyBL,CAAzB,EAA4B,CAA5B,CAAzB;AACA,cAAMjD,eAAe,GAAG,KAAKoN,YAAL,CAAkBnK,CAAlB,CAAxB;AACA,eAAO;AACH7D,UAAAA,IAAI,EAAE6D,CADH;AAEHc,UAAAA,SAAS,EAAE5B,IAAI,CAACD,GAAL,CAASd,MAAM,GAAG,CAAlB,EAAqBuK,gBAArB,CAFR;AAGH3L,UAAAA;AAHG,SAAP;AAKH,OARD,MASK;AACD,YAAIiD,CAAC,CAAC3D,KAAF,CAAQvC,MAAR,IAAkBqE,MAAM,GAAG,CAA/B,EAAkC;AAC9B,gBAAMpB,eAAe,GAAG,KAAKoN,YAAL,CAAkBnK,CAAlB,CAAxB;AACA,iBAAO;AACH7D,YAAAA,IAAI,EAAE6D,CADH;AAEHc,YAAAA,SAAS,EAAE3C,MAAM,GAAG,CAFjB;AAGHpB,YAAAA;AAHG,WAAP;AAKH,SAPD,MAQK;AACDoB,UAAAA,MAAM,IAAI6B,CAAC,CAAC3D,KAAF,CAAQvC,MAAlB;AACH;AACJ;;AACDkG,MAAAA,CAAC,GAAGA,CAAC,CAAC6B,IAAF,EAAJ;AACH;;AACD,WAAO,IAAP;AACH;;AACD8D,EAAAA,cAAc,CAACxJ,IAAD,EAAOU,MAAP,EAAe;AACzB,QAAIV,IAAI,CAACE,KAAL,CAAWd,WAAX,GAAyB,CAA7B,EAAgC;AAC5B,aAAO,CAAC,CAAR;AACH;;AACD,UAAME,MAAM,GAAG,KAAKuC,QAAL,CAAc7B,IAAI,CAACE,KAAL,CAAWjB,WAAzB,CAAf;AACA,UAAMgP,SAAS,GAAG,KAAK1I,cAAL,CAAoBvF,IAAI,CAACE,KAAL,CAAWjB,WAA/B,EAA4Ce,IAAI,CAACE,KAAL,CAAWhB,KAAvD,IAAgEwB,MAAlF;AACA,WAAOpB,MAAM,CAACA,MAAP,CAAcT,UAAd,CAAyBoP,SAAzB,CAAP;AACH;;AACDD,EAAAA,YAAY,CAAChO,IAAD,EAAO;AACf,QAAI,CAACA,IAAL,EAAW;AACP,aAAO,CAAP;AACH;;AACD,QAAIyM,GAAG,GAAGzM,IAAI,CAACgE,SAAf;;AACA,WAAOhE,IAAI,KAAK,KAAKF,IAArB,EAA2B;AACvB,UAAIE,IAAI,CAACqB,MAAL,CAAY8C,KAAZ,KAAsBnE,IAA1B,EAAgC;AAC5ByM,QAAAA,GAAG,IAAIzM,IAAI,CAACqB,MAAL,CAAY2C,SAAZ,GAAwBhE,IAAI,CAACqB,MAAL,CAAYnB,KAAZ,CAAkBvC,MAAjD;AACH;;AACDqC,MAAAA,IAAI,GAAGA,IAAI,CAACqB,MAAZ;AACH;;AACD,WAAOoL,GAAP;AACH,GAvhCsB,CAwhCvB;AACA;;;AACApD,EAAAA,eAAe,GAAG;AACd,WAAO,EAAE,KAAKhH,cAAL,IAAuB,KAAKF,IAAL,KAAc,IAAvC,CAAP;AACH;;AACDuH,EAAAA,WAAW,CAACwE,GAAD,EAAM;AACb,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AACzB,aAAOA,GAAG,CAACrP,UAAJ,CAAe,CAAf,MAAsB,EAA7B;AACH;;AACD,QAAIqP,GAAG,KAAKrR,QAAR,IAAoBqR,GAAG,CAAChO,KAAJ,CAAUd,WAAV,KAA0B,CAAlD,EAAqD;AACjD,aAAO,KAAP;AACH;;AACD,UAAMc,KAAK,GAAGgO,GAAG,CAAChO,KAAlB;AACA,UAAMjC,UAAU,GAAG,KAAK4D,QAAL,CAAc3B,KAAK,CAACjB,WAApB,EAAiChB,UAApD;AACA,UAAM8D,IAAI,GAAG7B,KAAK,CAAChB,KAAN,CAAY6C,IAAzB;AACA,UAAMuD,WAAW,GAAGrH,UAAU,CAAC8D,IAAD,CAAV,GAAmB7B,KAAK,CAAChB,KAAN,CAAY8C,MAAnD;;AACA,QAAID,IAAI,KAAK9D,UAAU,CAACN,MAAX,GAAoB,CAAjC,EAAoC;AAChC;AACA,aAAO,KAAP;AACH;;AACD,UAAMwQ,cAAc,GAAGlQ,UAAU,CAAC8D,IAAI,GAAG,CAAR,CAAjC;;AACA,QAAIoM,cAAc,GAAG7I,WAAW,GAAG,CAAnC,EAAsC;AAClC,aAAO,KAAP;AACH;;AACD,WAAO,KAAKzD,QAAL,CAAc3B,KAAK,CAACjB,WAApB,EAAiCK,MAAjC,CAAwCT,UAAxC,CAAmDyG,WAAnD,MAAoE,EAA3E;AACH;;AACDgE,EAAAA,SAAS,CAAC4E,GAAD,EAAM;AACX,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AACzB,aAAOA,GAAG,CAACrP,UAAJ,CAAeqP,GAAG,CAACvQ,MAAJ,GAAa,CAA5B,MAAmC,EAA1C;AACH;;AACD,QAAIuQ,GAAG,KAAKrR,QAAR,IAAoBqR,GAAG,CAAChO,KAAJ,CAAUd,WAAV,KAA0B,CAAlD,EAAqD;AACjD,aAAO,KAAP;AACH;;AACD,WAAO,KAAKoK,cAAL,CAAoB0E,GAApB,EAAyBA,GAAG,CAAChO,KAAJ,CAAUvC,MAAV,GAAmB,CAA5C,MAAmD,EAA1D;AACH;;AACDiN,EAAAA,wBAAwB,CAACwD,QAAD,EAAW;AAC/B,QAAI,KAAK/E,eAAL,MAA0B,KAAKK,WAAL,CAAiB0E,QAAjB,CAA9B,EAA0D;AACtD,YAAMpO,IAAI,GAAGoO,QAAQ,CAACnD,IAAT,EAAb;;AACA,UAAI,KAAK3B,SAAL,CAAetJ,IAAf,CAAJ,EAA0B;AACtB,aAAKqO,OAAL,CAAarO,IAAb,EAAmBoO,QAAnB;AACH;AACJ;AACJ;;AACDtD,EAAAA,wBAAwB,CAAC9K,IAAD,EAAO;AAC3B,QAAI,KAAKqJ,eAAL,MAA0B,KAAKC,SAAL,CAAetJ,IAAf,CAA9B,EAAoD;AAChD,YAAMoO,QAAQ,GAAGpO,IAAI,CAAC0F,IAAL,EAAjB;;AACA,UAAI,KAAKgE,WAAL,CAAiB0E,QAAjB,CAAJ,EAAgC;AAC5B,aAAKC,OAAL,CAAarO,IAAb,EAAmBoO,QAAnB;AACH;AACJ;AACJ;;AACDC,EAAAA,OAAO,CAACpD,IAAD,EAAOvF,IAAP,EAAa;AAChB,UAAMyD,UAAU,GAAG,EAAnB,CADgB,CAEhB;;AACA,UAAMlL,UAAU,GAAG,KAAK4D,QAAL,CAAcoJ,IAAI,CAAC/K,KAAL,CAAWjB,WAAzB,EAAsChB,UAAzD;AACA,QAAI8O,MAAJ;;AACA,QAAI9B,IAAI,CAAC/K,KAAL,CAAWf,GAAX,CAAe6C,MAAf,KAA0B,CAA9B,EAAiC;AAC7B;AACA+K,MAAAA,MAAM,GAAG;AAAEhL,QAAAA,IAAI,EAAEkJ,IAAI,CAAC/K,KAAL,CAAWf,GAAX,CAAe4C,IAAf,GAAsB,CAA9B;AAAiCC,QAAAA,MAAM,EAAE/D,UAAU,CAACgN,IAAI,CAAC/K,KAAL,CAAWf,GAAX,CAAe4C,IAAhB,CAAV,GAAkC9D,UAAU,CAACgN,IAAI,CAAC/K,KAAL,CAAWf,GAAX,CAAe4C,IAAf,GAAsB,CAAvB,CAA5C,GAAwE;AAAjH,OAAT;AACH,KAHD,MAIK;AACD;AACAgL,MAAAA,MAAM,GAAG;AAAEhL,QAAAA,IAAI,EAAEkJ,IAAI,CAAC/K,KAAL,CAAWf,GAAX,CAAe4C,IAAvB;AAA6BC,QAAAA,MAAM,EAAEiJ,IAAI,CAAC/K,KAAL,CAAWf,GAAX,CAAe6C,MAAf,GAAwB;AAA7D,OAAT;AACH;;AACD,UAAMsM,aAAa,GAAGrD,IAAI,CAAC/K,KAAL,CAAWvC,MAAX,GAAoB,CAA1C;AACA,UAAM4Q,YAAY,GAAGtD,IAAI,CAAC/K,KAAL,CAAWd,WAAX,GAAyB,CAA9C;AACA6L,IAAAA,IAAI,CAAC/K,KAAL,GAAa,IAAIlB,KAAJ,CAAUiM,IAAI,CAAC/K,KAAL,CAAWjB,WAArB,EAAkCgM,IAAI,CAAC/K,KAAL,CAAWhB,KAA7C,EAAoD6N,MAApD,EAA4DwB,YAA5D,EAA0ED,aAA1E,CAAb;AACAnR,IAAAA,kBAAkB,CAAC,IAAD,EAAO8N,IAAP,EAAa,CAAC,CAAd,EAAiB,CAAC,CAAlB,CAAlB;;AACA,QAAIA,IAAI,CAAC/K,KAAL,CAAWvC,MAAX,KAAsB,CAA1B,EAA6B;AACzBwL,MAAAA,UAAU,CAAClJ,IAAX,CAAgBgL,IAAhB;AACH,KAnBe,CAoBhB;;;AACA,UAAMxB,QAAQ,GAAG;AAAE1H,MAAAA,IAAI,EAAE2D,IAAI,CAACxF,KAAL,CAAWhB,KAAX,CAAiB6C,IAAjB,GAAwB,CAAhC;AAAmCC,MAAAA,MAAM,EAAE;AAA3C,KAAjB;AACA,UAAMoL,SAAS,GAAG1H,IAAI,CAACxF,KAAL,CAAWvC,MAAX,GAAoB,CAAtC;AACA,UAAMsP,cAAc,GAAG,KAAKrF,cAAL,CAAoBlC,IAAI,CAACxF,KAAL,CAAWjB,WAA/B,EAA4CwK,QAA5C,EAAsD/D,IAAI,CAACxF,KAAL,CAAWf,GAAjE,CAAvB;AACAuG,IAAAA,IAAI,CAACxF,KAAL,GAAa,IAAIlB,KAAJ,CAAU0G,IAAI,CAACxF,KAAL,CAAWjB,WAArB,EAAkCwK,QAAlC,EAA4C/D,IAAI,CAACxF,KAAL,CAAWf,GAAvD,EAA4D8N,cAA5D,EAA4EG,SAA5E,CAAb;AACAjQ,IAAAA,kBAAkB,CAAC,IAAD,EAAOuI,IAAP,EAAa,CAAC,CAAd,EAAiB,CAAC,CAAlB,CAAlB;;AACA,QAAIA,IAAI,CAACxF,KAAL,CAAWvC,MAAX,KAAsB,CAA1B,EAA6B;AACzBwL,MAAAA,UAAU,CAAClJ,IAAX,CAAgByF,IAAhB;AACH,KA5Be,CA6BhB;;;AACA,UAAM0E,MAAM,GAAG,KAAKL,eAAL,CAAqB,MAArB,CAAf;AACA,SAAKxH,aAAL,CAAmB0I,IAAnB,EAAyBb,MAAM,CAAC,CAAD,CAA/B,EA/BgB,CAgChB;;AACA,SAAK,IAAI1L,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyK,UAAU,CAACxL,MAA/B,EAAuCe,CAAC,EAAxC,EAA4C;AACxCzB,MAAAA,QAAQ,CAAC,IAAD,EAAOkM,UAAU,CAACzK,CAAD,CAAjB,CAAR;AACH;AACJ;;AACD0M,EAAAA,4BAA4B,CAAC1I,KAAD,EAAQ1C,IAAR,EAAc;AACtC,QAAI,KAAKqJ,eAAL,MAA0B,KAAKC,SAAL,CAAe5G,KAAf,CAA9B,EAAqD;AACjD,YAAM0L,QAAQ,GAAGpO,IAAI,CAAC0F,IAAL,EAAjB;;AACA,UAAI,KAAKgE,WAAL,CAAiB0E,QAAjB,CAAJ,EAAgC;AAC5B;AACA1L,QAAAA,KAAK,IAAI,IAAT;;AACA,YAAI0L,QAAQ,CAAClO,KAAT,CAAevC,MAAf,KAA0B,CAA9B,EAAiC;AAC7BV,UAAAA,QAAQ,CAAC,IAAD,EAAOmR,QAAP,CAAR;AACH,SAFD,MAGK;AACD,gBAAMlO,KAAK,GAAGkO,QAAQ,CAAClO,KAAvB;AACA,gBAAMuJ,QAAQ,GAAG;AAAE1H,YAAAA,IAAI,EAAE7B,KAAK,CAAChB,KAAN,CAAY6C,IAAZ,GAAmB,CAA3B;AAA8BC,YAAAA,MAAM,EAAE;AAAtC,WAAjB;AACA,gBAAMoL,SAAS,GAAGlN,KAAK,CAACvC,MAAN,GAAe,CAAjC;AACA,gBAAMsP,cAAc,GAAG,KAAKrF,cAAL,CAAoB1H,KAAK,CAACjB,WAA1B,EAAuCwK,QAAvC,EAAiDvJ,KAAK,CAACf,GAAvD,CAAvB;AACAiP,UAAAA,QAAQ,CAAClO,KAAT,GAAiB,IAAIlB,KAAJ,CAAUkB,KAAK,CAACjB,WAAhB,EAA6BwK,QAA7B,EAAuCvJ,KAAK,CAACf,GAA7C,EAAkD8N,cAAlD,EAAkEG,SAAlE,CAAjB;AACAjQ,UAAAA,kBAAkB,CAAC,IAAD,EAAOiR,QAAP,EAAiB,CAAC,CAAlB,EAAqB,CAAC,CAAtB,CAAlB;AACH;;AACD,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH,GAroCsB,CAsoCvB;AACA;AACA;;;AACArO,EAAAA,OAAO,CAACC,IAAD,EAAOwO,QAAP,EAAiB;AACpB,QAAIxO,IAAI,KAAKnD,QAAb,EAAuB;AACnB,aAAO2R,QAAQ,CAAC3R,QAAD,CAAf;AACH;;AACD,UAAM4R,OAAO,GAAG,KAAK1O,OAAL,CAAaC,IAAI,CAAC8D,IAAlB,EAAwB0K,QAAxB,CAAhB;;AACA,QAAI,CAACC,OAAL,EAAc;AACV,aAAOA,OAAP;AACH;;AACD,WAAOD,QAAQ,CAACxO,IAAD,CAAR,IAAkB,KAAKD,OAAL,CAAaC,IAAI,CAACmE,KAAlB,EAAyBqK,QAAzB,CAAzB;AACH;;AACDpL,EAAAA,cAAc,CAACpD,IAAD,EAAO;AACjB,QAAIA,IAAI,KAAKnD,QAAb,EAAuB;AACnB,aAAO,EAAP;AACH;;AACD,UAAMyC,MAAM,GAAG,KAAKuC,QAAL,CAAc7B,IAAI,CAACE,KAAL,CAAWjB,WAAzB,CAAf;AACA,QAAIyP,cAAJ;AACA,UAAMxO,KAAK,GAAGF,IAAI,CAACE,KAAnB;AACA,UAAMoF,WAAW,GAAG,KAAKC,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCiB,KAAK,CAAChB,KAA7C,CAApB;AACA,UAAMwM,SAAS,GAAG,KAAKnG,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCiB,KAAK,CAACf,GAA7C,CAAlB;AACAuP,IAAAA,cAAc,GAAGpP,MAAM,CAACA,MAAP,CAAckG,SAAd,CAAwBF,WAAxB,EAAqCoG,SAArC,CAAjB;AACA,WAAOgD,cAAP;AACH;;AACDtO,EAAAA,eAAe,CAACF,KAAD,EAAQ;AACnB,UAAMZ,MAAM,GAAG,KAAKuC,QAAL,CAAc3B,KAAK,CAACjB,WAApB,CAAf;AACA,UAAMqG,WAAW,GAAG,KAAKC,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCiB,KAAK,CAAChB,KAA7C,CAApB;AACA,UAAMwM,SAAS,GAAG,KAAKnG,cAAL,CAAoBrF,KAAK,CAACjB,WAA1B,EAAuCiB,KAAK,CAACf,GAA7C,CAAlB;AACA,UAAMuP,cAAc,GAAGpP,MAAM,CAACA,MAAP,CAAckG,SAAd,CAAwBF,WAAxB,EAAqCoG,SAArC,CAAvB;AACA,WAAOgD,cAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACInM,EAAAA,aAAa,CAACvC,IAAD,EAAO2O,CAAP,EAAU;AACnB,UAAMC,CAAC,GAAG,IAAI9R,QAAJ,CAAa6R,CAAb,EAAgB;AAAE;AAAlB,KAAV;AACAC,IAAAA,CAAC,CAAC9K,IAAF,GAASjH,QAAT;AACA+R,IAAAA,CAAC,CAACzK,KAAF,GAAUtH,QAAV;AACA+R,IAAAA,CAAC,CAACvN,MAAF,GAAWxE,QAAX;AACA+R,IAAAA,CAAC,CAAC5K,SAAF,GAAc,CAAd;AACA4K,IAAAA,CAAC,CAAC7K,OAAF,GAAY,CAAZ;AACA,UAAMF,CAAC,GAAG,KAAK/D,IAAf;;AACA,QAAI+D,CAAC,KAAKhH,QAAV,EAAoB;AAChB,WAAKiD,IAAL,GAAY8O,CAAZ;AACAA,MAAAA,CAAC,CAACC,KAAF,GAAU;AAAE;AAAZ;AACH,KAHD,MAIK,IAAI7O,IAAI,CAACmE,KAAL,KAAetH,QAAnB,EAA6B;AAC9BmD,MAAAA,IAAI,CAACmE,KAAL,GAAayK,CAAb;AACAA,MAAAA,CAAC,CAACvN,MAAF,GAAWrB,IAAX;AACH,KAHI,MAIA;AACD,YAAMoO,QAAQ,GAAGpR,OAAO,CAACgD,IAAI,CAACmE,KAAN,CAAxB;AACAiK,MAAAA,QAAQ,CAACtK,IAAT,GAAgB8K,CAAhB;AACAA,MAAAA,CAAC,CAACvN,MAAF,GAAW+M,QAAX;AACH;;AACDrR,IAAAA,SAAS,CAAC,IAAD,EAAO6R,CAAP,CAAT;AACA,WAAOA,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIvE,EAAAA,YAAY,CAACrK,IAAD,EAAO2O,CAAP,EAAU;AAClB,UAAMC,CAAC,GAAG,IAAI9R,QAAJ,CAAa6R,CAAb,EAAgB;AAAE;AAAlB,KAAV;AACAC,IAAAA,CAAC,CAAC9K,IAAF,GAASjH,QAAT;AACA+R,IAAAA,CAAC,CAACzK,KAAF,GAAUtH,QAAV;AACA+R,IAAAA,CAAC,CAACvN,MAAF,GAAWxE,QAAX;AACA+R,IAAAA,CAAC,CAAC5K,SAAF,GAAc,CAAd;AACA4K,IAAAA,CAAC,CAAC7K,OAAF,GAAY,CAAZ;;AACA,QAAI,KAAKjE,IAAL,KAAcjD,QAAlB,EAA4B;AACxB,WAAKiD,IAAL,GAAY8O,CAAZ;AACAA,MAAAA,CAAC,CAACC,KAAF,GAAU;AAAE;AAAZ;AACH,KAHD,MAIK,IAAI7O,IAAI,CAAC8D,IAAL,KAAcjH,QAAlB,EAA4B;AAC7BmD,MAAAA,IAAI,CAAC8D,IAAL,GAAY8K,CAAZ;AACAA,MAAAA,CAAC,CAACvN,MAAF,GAAWrB,IAAX;AACH,KAHI,MAIA;AACD,YAAM8O,QAAQ,GAAG5R,SAAS,CAAC8C,IAAI,CAAC8D,IAAN,CAA1B,CADC,CACsC;;AACvCgL,MAAAA,QAAQ,CAAC3K,KAAT,GAAiByK,CAAjB;AACAA,MAAAA,CAAC,CAACvN,MAAF,GAAWyN,QAAX;AACH;;AACD/R,IAAAA,SAAS,CAAC,IAAD,EAAO6R,CAAP,CAAT;AACA,WAAOA,CAAP;AACH;;AAluCsB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nexport const AverageBufferSize = 65535;\nexport function createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nexport class LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        let currentContent;\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}