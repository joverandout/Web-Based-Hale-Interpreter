{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution } from '../../../browser/editorExtensions.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { TextModel } from '../../../common/model/textModel.js';\nimport { ILanguageConfigurationService, LanguageConfigurationRegistry } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport * as indentUtils from './indentUtils.js';\nimport * as nls from '../../../../nls.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nexport function getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber, inheritedIndent) {\n  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n    // Model is empty\n    return [];\n  }\n\n  const indentationRules = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentationRules;\n\n  if (!indentationRules) {\n    return [];\n  }\n\n  endLineNumber = Math.min(endLineNumber, model.getLineCount()); // Skip `unIndentedLinePattern` lines\n\n  while (startLineNumber <= endLineNumber) {\n    if (!indentationRules.unIndentedLinePattern) {\n      break;\n    }\n\n    let text = model.getLineContent(startLineNumber);\n\n    if (!indentationRules.unIndentedLinePattern.test(text)) {\n      break;\n    }\n\n    startLineNumber++;\n  }\n\n  if (startLineNumber > endLineNumber - 1) {\n    return [];\n  }\n\n  const {\n    tabSize,\n    indentSize,\n    insertSpaces\n  } = model.getOptions();\n\n  const shiftIndent = (indentation, count) => {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\n  };\n\n  const unshiftIndent = (indentation, count) => {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\n  };\n\n  let indentEdits = []; // indentation being passed to lines below\n\n  let globalIndent; // Calculate indentation for the first line\n  // If there is no passed-in indentation, we use the indentation of the first line as base.\n\n  let currentLineText = model.getLineContent(startLineNumber);\n  let adjustedLineContent = currentLineText;\n\n  if (inheritedIndent !== undefined && inheritedIndent !== null) {\n    globalIndent = inheritedIndent;\n    let oldIndentation = strings.getLeadingWhitespace(currentLineText);\n    adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);\n\n    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {\n      globalIndent = unshiftIndent(globalIndent);\n      adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);\n    }\n\n    if (currentLineText !== adjustedLineContent) {\n      indentEdits.push(EditOperation.replaceMove(new Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(globalIndent, indentSize, insertSpaces)));\n    }\n  } else {\n    globalIndent = strings.getLeadingWhitespace(currentLineText);\n  } // idealIndentForNextLine doesn't equal globalIndent when there is a line matching `indentNextLinePattern`.\n\n\n  let idealIndentForNextLine = globalIndent;\n\n  if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {\n    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n    globalIndent = shiftIndent(globalIndent);\n  } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {\n    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n  }\n\n  startLineNumber++; // Calculate indentation adjustment for all following lines\n\n  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n    let text = model.getLineContent(lineNumber);\n    let oldIndentation = strings.getLeadingWhitespace(text);\n    let adjustedLineContent = idealIndentForNextLine + text.substring(oldIndentation.length);\n\n    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {\n      idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);\n      globalIndent = unshiftIndent(globalIndent);\n    }\n\n    if (oldIndentation !== idealIndentForNextLine) {\n      indentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));\n    } // calculate idealIndentForNextLine\n\n\n    if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {\n      // In reindent phase, if the line matches `unIndentedLinePattern` we inherit indentation from above lines\n      // but don't change globalIndent and idealIndentForNextLine.\n      continue;\n    } else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {\n      globalIndent = shiftIndent(globalIndent);\n      idealIndentForNextLine = globalIndent;\n    } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {\n      idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n    } else {\n      idealIndentForNextLine = globalIndent;\n    }\n  }\n\n  return indentEdits;\n}\nexport class IndentationToSpacesAction extends EditorAction {\n  constructor() {\n    super({\n      id: IndentationToSpacesAction.ID,\n      label: nls.localize('indentationToSpaces', \"Convert Indentation to Spaces\"),\n      alias: 'Convert Indentation to Spaces',\n      precondition: EditorContextKeys.writable\n    });\n  }\n\n  run(accessor, editor) {\n    let model = editor.getModel();\n\n    if (!model) {\n      return;\n    }\n\n    let modelOpts = model.getOptions();\n    let selection = editor.getSelection();\n\n    if (!selection) {\n      return;\n    }\n\n    const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, [command]);\n    editor.pushUndoStop();\n    model.updateOptions({\n      insertSpaces: true\n    });\n  }\n\n}\nIndentationToSpacesAction.ID = 'editor.action.indentationToSpaces';\nexport class IndentationToTabsAction extends EditorAction {\n  constructor() {\n    super({\n      id: IndentationToTabsAction.ID,\n      label: nls.localize('indentationToTabs', \"Convert Indentation to Tabs\"),\n      alias: 'Convert Indentation to Tabs',\n      precondition: EditorContextKeys.writable\n    });\n  }\n\n  run(accessor, editor) {\n    let model = editor.getModel();\n\n    if (!model) {\n      return;\n    }\n\n    let modelOpts = model.getOptions();\n    let selection = editor.getSelection();\n\n    if (!selection) {\n      return;\n    }\n\n    const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, [command]);\n    editor.pushUndoStop();\n    model.updateOptions({\n      insertSpaces: false\n    });\n  }\n\n}\nIndentationToTabsAction.ID = 'editor.action.indentationToTabs';\nexport class ChangeIndentationSizeAction extends EditorAction {\n  constructor(insertSpaces, opts) {\n    super(opts);\n    this.insertSpaces = insertSpaces;\n  }\n\n  run(accessor, editor) {\n    const quickInputService = accessor.get(IQuickInputService);\n    const modelService = accessor.get(IModelService);\n    let model = editor.getModel();\n\n    if (!model) {\n      return;\n    }\n\n    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);\n    const picks = [1, 2, 3, 4, 5, 6, 7, 8].map(n => ({\n      id: n.toString(),\n      label: n.toString(),\n      // add description for tabSize value set in the configuration\n      description: n === creationOpts.tabSize ? nls.localize('configuredTabSize', \"Configured Tab Size\") : undefined\n    })); // auto focus the tabSize set for the current editor\n\n    const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);\n    setTimeout(() => {\n      quickInputService.pick(picks, {\n        placeHolder: nls.localize({\n          key: 'selectTabWidth',\n          comment: ['Tab corresponds to the tab key']\n        }, \"Select Tab Size for Current File\"),\n        activeItem: picks[autoFocusIndex]\n      }).then(pick => {\n        if (pick) {\n          if (model && !model.isDisposed()) {\n            model.updateOptions({\n              tabSize: parseInt(pick.label, 10),\n              insertSpaces: this.insertSpaces\n            });\n          }\n        }\n      });\n    }, 50\n    /* quick input is sensitive to being opened so soon after another */\n    );\n  }\n\n}\nexport class IndentUsingTabs extends ChangeIndentationSizeAction {\n  constructor() {\n    super(false, {\n      id: IndentUsingTabs.ID,\n      label: nls.localize('indentUsingTabs', \"Indent Using Tabs\"),\n      alias: 'Indent Using Tabs',\n      precondition: undefined\n    });\n  }\n\n}\nIndentUsingTabs.ID = 'editor.action.indentUsingTabs';\nexport class IndentUsingSpaces extends ChangeIndentationSizeAction {\n  constructor() {\n    super(true, {\n      id: IndentUsingSpaces.ID,\n      label: nls.localize('indentUsingSpaces', \"Indent Using Spaces\"),\n      alias: 'Indent Using Spaces',\n      precondition: undefined\n    });\n  }\n\n}\nIndentUsingSpaces.ID = 'editor.action.indentUsingSpaces';\nexport class DetectIndentation extends EditorAction {\n  constructor() {\n    super({\n      id: DetectIndentation.ID,\n      label: nls.localize('detectIndentation', \"Detect Indentation from Content\"),\n      alias: 'Detect Indentation from Content',\n      precondition: undefined\n    });\n  }\n\n  run(accessor, editor) {\n    const modelService = accessor.get(IModelService);\n    let model = editor.getModel();\n\n    if (!model) {\n      return;\n    }\n\n    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);\n    model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);\n  }\n\n}\nDetectIndentation.ID = 'editor.action.detectIndentation';\nexport class ReindentLinesAction extends EditorAction {\n  constructor() {\n    super({\n      id: 'editor.action.reindentlines',\n      label: nls.localize('editor.reindentlines', \"Reindent Lines\"),\n      alias: 'Reindent Lines',\n      precondition: EditorContextKeys.writable\n    });\n  }\n\n  run(accessor, editor) {\n    const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n    let model = editor.getModel();\n\n    if (!model) {\n      return;\n    }\n\n    let edits = getReindentEditOperations(model, languageConfigurationService, 1, model.getLineCount());\n\n    if (edits.length > 0) {\n      editor.pushUndoStop();\n      editor.executeEdits(this.id, edits);\n      editor.pushUndoStop();\n    }\n  }\n\n}\nexport class ReindentSelectedLinesAction extends EditorAction {\n  constructor() {\n    super({\n      id: 'editor.action.reindentselectedlines',\n      label: nls.localize('editor.reindentselectedlines', \"Reindent Selected Lines\"),\n      alias: 'Reindent Selected Lines',\n      precondition: EditorContextKeys.writable\n    });\n  }\n\n  run(accessor, editor) {\n    const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n    let model = editor.getModel();\n\n    if (!model) {\n      return;\n    }\n\n    let selections = editor.getSelections();\n\n    if (selections === null) {\n      return;\n    }\n\n    let edits = [];\n\n    for (let selection of selections) {\n      let startLineNumber = selection.startLineNumber;\n      let endLineNumber = selection.endLineNumber;\n\n      if (startLineNumber !== endLineNumber && selection.endColumn === 1) {\n        endLineNumber--;\n      }\n\n      if (startLineNumber === 1) {\n        if (startLineNumber === endLineNumber) {\n          continue;\n        }\n      } else {\n        startLineNumber--;\n      }\n\n      let editOperations = getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber);\n      edits.push(...editOperations);\n    }\n\n    if (edits.length > 0) {\n      editor.pushUndoStop();\n      editor.executeEdits(this.id, edits);\n      editor.pushUndoStop();\n    }\n  }\n\n}\nexport class AutoIndentOnPasteCommand {\n  constructor(edits, initialSelection) {\n    this._initialSelection = initialSelection;\n    this._edits = [];\n    this._selectionId = null;\n\n    for (let edit of edits) {\n      if (edit.range && typeof edit.text === 'string') {\n        this._edits.push(edit);\n      }\n    }\n  }\n\n  getEditOperations(model, builder) {\n    for (let edit of this._edits) {\n      builder.addEditOperation(Range.lift(edit.range), edit.text);\n    }\n\n    let selectionIsSet = false;\n\n    if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {\n      if (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {\n        selectionIsSet = true;\n        this._selectionId = builder.trackSelection(this._initialSelection, true);\n      } else if (this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {\n        selectionIsSet = true;\n        this._selectionId = builder.trackSelection(this._initialSelection, false);\n      }\n    }\n\n    if (!selectionIsSet) {\n      this._selectionId = builder.trackSelection(this._initialSelection);\n    }\n  }\n\n  computeCursorState(model, helper) {\n    return helper.getTrackedSelection(this._selectionId);\n  }\n\n}\nexport class AutoIndentOnPaste {\n  constructor(editor) {\n    this.callOnDispose = new DisposableStore();\n    this.callOnModel = new DisposableStore();\n    this.editor = editor;\n    this.callOnDispose.add(editor.onDidChangeConfiguration(() => this.update()));\n    this.callOnDispose.add(editor.onDidChangeModel(() => this.update()));\n    this.callOnDispose.add(editor.onDidChangeModelLanguage(() => this.update()));\n  }\n\n  update() {\n    // clean up\n    this.callOnModel.clear(); // we are disabled\n\n    if (this.editor.getOption(9\n    /* autoIndent */\n    ) < 4\n    /* Full */\n    || this.editor.getOption(48\n    /* formatOnPaste */\n    )) {\n      return;\n    } // no model\n\n\n    if (!this.editor.hasModel()) {\n      return;\n    }\n\n    this.callOnModel.add(this.editor.onDidPaste(({\n      range\n    }) => {\n      this.trigger(range);\n    }));\n  }\n\n  trigger(range) {\n    let selections = this.editor.getSelections();\n\n    if (selections === null || selections.length > 1) {\n      return;\n    }\n\n    const model = this.editor.getModel();\n\n    if (!model) {\n      return;\n    }\n\n    if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {\n      return;\n    }\n\n    const autoIndent = this.editor.getOption(9\n    /* autoIndent */\n    );\n    const {\n      tabSize,\n      indentSize,\n      insertSpaces\n    } = model.getOptions();\n    let textEdits = [];\n    let indentConverter = {\n      shiftIndent: indentation => {\n        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      },\n      unshiftIndent: indentation => {\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      }\n    };\n    let startLineNumber = range.startLineNumber;\n\n    while (startLineNumber <= range.endLineNumber) {\n      if (this.shouldIgnoreLine(model, startLineNumber)) {\n        startLineNumber++;\n        continue;\n      }\n\n      break;\n    }\n\n    if (startLineNumber > range.endLineNumber) {\n      return;\n    }\n\n    let firstLineText = model.getLineContent(startLineNumber);\n\n    if (!/\\S/.test(firstLineText.substring(0, range.startColumn - 1))) {\n      const indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, model, model.getLanguageId(), startLineNumber, indentConverter);\n\n      if (indentOfFirstLine !== null) {\n        let oldIndentation = strings.getLeadingWhitespace(firstLineText);\n        let newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n        let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n\n        if (newSpaceCnt !== oldSpaceCnt) {\n          let newIndent = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n          textEdits.push({\n            range: new Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),\n            text: newIndent\n          });\n          firstLineText = newIndent + firstLineText.substr(oldIndentation.length);\n        } else {\n          let indentMetadata = LanguageConfigurationRegistry.getIndentMetadata(model, startLineNumber);\n\n          if (indentMetadata === 0 || indentMetadata === 8\n          /* UNINDENT_MASK */\n          ) {\n            // we paste content into a line where only contains whitespaces\n            // after pasting, the indentation of the first line is already correct\n            // the first line doesn't match any indentation rule\n            // then no-op.\n            return;\n          }\n        }\n      }\n    }\n\n    const firstLineNumber = startLineNumber; // ignore empty or ignored lines\n\n    while (startLineNumber < range.endLineNumber) {\n      if (!/\\S/.test(model.getLineContent(startLineNumber + 1))) {\n        startLineNumber++;\n        continue;\n      }\n\n      break;\n    }\n\n    if (startLineNumber !== range.endLineNumber) {\n      let virtualModel = {\n        getLineTokens: lineNumber => {\n          return model.getLineTokens(lineNumber);\n        },\n        getLanguageId: () => {\n          return model.getLanguageId();\n        },\n        getLanguageIdAtPosition: (lineNumber, column) => {\n          return model.getLanguageIdAtPosition(lineNumber, column);\n        },\n        getLineContent: lineNumber => {\n          if (lineNumber === firstLineNumber) {\n            return firstLineText;\n          } else {\n            return model.getLineContent(lineNumber);\n          }\n        }\n      };\n      let indentOfSecondLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageId(), startLineNumber + 1, indentConverter);\n\n      if (indentOfSecondLine !== null) {\n        let newSpaceCntOfSecondLine = indentUtils.getSpaceCnt(indentOfSecondLine, tabSize);\n        let oldSpaceCntOfSecondLine = indentUtils.getSpaceCnt(strings.getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);\n\n        if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {\n          let spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;\n\n          for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {\n            let lineContent = model.getLineContent(i);\n            let originalIndent = strings.getLeadingWhitespace(lineContent);\n            let originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n            let newSpacesCnt = originalSpacesCnt + spaceCntOffset;\n            let newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n\n            if (newIndent !== originalIndent) {\n              textEdits.push({\n                range: new Range(i, 1, i, originalIndent.length + 1),\n                text: newIndent\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (textEdits.length > 0) {\n      this.editor.pushUndoStop();\n      let cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());\n      this.editor.executeCommand('autoIndentOnPaste', cmd);\n      this.editor.pushUndoStop();\n    }\n  }\n\n  shouldIgnoreLine(model, lineNumber) {\n    model.forceTokenization(lineNumber);\n    let nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n\n    if (nonWhitespaceColumn === 0) {\n      return true;\n    }\n\n    let tokens = model.getLineTokens(lineNumber);\n\n    if (tokens.getCount() > 0) {\n      let firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);\n\n      if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1\n      /* Comment */\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  dispose() {\n    this.callOnDispose.dispose();\n    this.callOnModel.dispose();\n  }\n\n}\nAutoIndentOnPaste.ID = 'editor.contrib.autoIndentOnPaste';\n\nfunction getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {\n  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n    // Model is empty\n    return;\n  }\n\n  let spaces = '';\n\n  for (let i = 0; i < tabSize; i++) {\n    spaces += ' ';\n  }\n\n  let spacesRegExp = new RegExp(spaces, 'gi');\n\n  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n    let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n\n    if (lastIndentationColumn === 0) {\n      lastIndentationColumn = model.getLineMaxColumn(lineNumber);\n    }\n\n    if (lastIndentationColumn === 1) {\n      continue;\n    }\n\n    const originalIndentationRange = new Range(lineNumber, 1, lineNumber, lastIndentationColumn);\n    const originalIndentation = model.getValueInRange(originalIndentationRange);\n    const newIndentation = tabsToSpaces ? originalIndentation.replace(/\\t/ig, spaces) : originalIndentation.replace(spacesRegExp, '\\t');\n    builder.addEditOperation(originalIndentationRange, newIndentation);\n  }\n}\n\nexport class IndentationToSpacesCommand {\n  constructor(selection, tabSize) {\n    this.selection = selection;\n    this.tabSize = tabSize;\n    this.selectionId = null;\n  }\n\n  getEditOperations(model, builder) {\n    this.selectionId = builder.trackSelection(this.selection);\n    getIndentationEditOperations(model, builder, this.tabSize, true);\n  }\n\n  computeCursorState(model, helper) {\n    return helper.getTrackedSelection(this.selectionId);\n  }\n\n}\nexport class IndentationToTabsCommand {\n  constructor(selection, tabSize) {\n    this.selection = selection;\n    this.tabSize = tabSize;\n    this.selectionId = null;\n  }\n\n  getEditOperations(model, builder) {\n    this.selectionId = builder.trackSelection(this.selection);\n    getIndentationEditOperations(model, builder, this.tabSize, false);\n  }\n\n  computeCursorState(model, helper) {\n    return helper.getTrackedSelection(this.selectionId);\n  }\n\n}\nregisterEditorContribution(AutoIndentOnPaste.ID, AutoIndentOnPaste);\nregisterEditorAction(IndentationToSpacesAction);\nregisterEditorAction(IndentationToTabsAction);\nregisterEditorAction(IndentUsingTabs);\nregisterEditorAction(IndentUsingSpaces);\nregisterEditorAction(DetectIndentation);\nregisterEditorAction(ReindentLinesAction);\nregisterEditorAction(ReindentSelectedLinesAction);","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentation.js"],"names":["DisposableStore","strings","EditorAction","registerEditorAction","registerEditorContribution","ShiftCommand","EditOperation","Range","Selection","EditorContextKeys","TextModel","ILanguageConfigurationService","LanguageConfigurationRegistry","IModelService","indentUtils","nls","IQuickInputService","getReindentEditOperations","model","languageConfigurationService","startLineNumber","endLineNumber","inheritedIndent","getLineCount","getLineMaxColumn","indentationRules","getLanguageConfiguration","getLanguageId","Math","min","unIndentedLinePattern","text","getLineContent","test","tabSize","indentSize","insertSpaces","getOptions","shiftIndent","indentation","count","length","unshiftIndent","indentEdits","globalIndent","currentLineText","adjustedLineContent","undefined","oldIndentation","getLeadingWhitespace","substring","decreaseIndentPattern","push","replaceMove","normalizeIndentation","idealIndentForNextLine","increaseIndentPattern","indentNextLinePattern","lineNumber","IndentationToSpacesAction","constructor","id","ID","label","localize","alias","precondition","writable","run","accessor","editor","getModel","modelOpts","selection","getSelection","command","IndentationToSpacesCommand","pushUndoStop","executeCommands","updateOptions","IndentationToTabsAction","IndentationToTabsCommand","ChangeIndentationSizeAction","opts","quickInputService","get","modelService","creationOpts","getCreationOptions","uri","isForSimpleWidget","picks","map","n","toString","description","autoFocusIndex","setTimeout","pick","placeHolder","key","comment","activeItem","then","isDisposed","parseInt","IndentUsingTabs","IndentUsingSpaces","DetectIndentation","detectIndentation","ReindentLinesAction","edits","executeEdits","ReindentSelectedLinesAction","selections","getSelections","endColumn","editOperations","AutoIndentOnPasteCommand","initialSelection","_initialSelection","_edits","_selectionId","edit","range","getEditOperations","builder","addEditOperation","lift","selectionIsSet","Array","isArray","isEmpty","startColumn","trackSelection","computeCursorState","helper","getTrackedSelection","AutoIndentOnPaste","callOnDispose","callOnModel","add","onDidChangeConfiguration","update","onDidChangeModel","onDidChangeModelLanguage","clear","getOption","hasModel","onDidPaste","trigger","isCheapToTokenize","getStartPosition","autoIndent","textEdits","indentConverter","shouldIgnoreLine","firstLineText","indentOfFirstLine","getGoodIndentForLine","newSpaceCnt","getSpaceCnt","oldSpaceCnt","newIndent","generateIndent","substr","indentMetadata","getIndentMetadata","firstLineNumber","virtualModel","getLineTokens","getLanguageIdAtPosition","column","indentOfSecondLine","newSpaceCntOfSecondLine","oldSpaceCntOfSecondLine","spaceCntOffset","i","lineContent","originalIndent","originalSpacesCnt","newSpacesCnt","cmd","executeCommand","forceTokenization","nonWhitespaceColumn","getLineFirstNonWhitespaceColumn","tokens","getCount","firstNonWhitespaceTokenIndex","findTokenIndexAtOffset","getStandardTokenType","dispose","getIndentationEditOperations","tabsToSpaces","spaces","spacesRegExp","RegExp","lineCount","lastIndentationColumn","originalIndentationRange","originalIndentation","getValueInRange","newIndentation","replace","selectionId"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution } from '../../../browser/editorExtensions.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { TextModel } from '../../../common/model/textModel.js';\nimport { ILanguageConfigurationService, LanguageConfigurationRegistry } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport * as indentUtils from './indentUtils.js';\nimport * as nls from '../../../../nls.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nexport function getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber, inheritedIndent) {\n    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n        // Model is empty\n        return [];\n    }\n    const indentationRules = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentationRules;\n    if (!indentationRules) {\n        return [];\n    }\n    endLineNumber = Math.min(endLineNumber, model.getLineCount());\n    // Skip `unIndentedLinePattern` lines\n    while (startLineNumber <= endLineNumber) {\n        if (!indentationRules.unIndentedLinePattern) {\n            break;\n        }\n        let text = model.getLineContent(startLineNumber);\n        if (!indentationRules.unIndentedLinePattern.test(text)) {\n            break;\n        }\n        startLineNumber++;\n    }\n    if (startLineNumber > endLineNumber - 1) {\n        return [];\n    }\n    const { tabSize, indentSize, insertSpaces } = model.getOptions();\n    const shiftIndent = (indentation, count) => {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\n    };\n    const unshiftIndent = (indentation, count) => {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\n    };\n    let indentEdits = [];\n    // indentation being passed to lines below\n    let globalIndent;\n    // Calculate indentation for the first line\n    // If there is no passed-in indentation, we use the indentation of the first line as base.\n    let currentLineText = model.getLineContent(startLineNumber);\n    let adjustedLineContent = currentLineText;\n    if (inheritedIndent !== undefined && inheritedIndent !== null) {\n        globalIndent = inheritedIndent;\n        let oldIndentation = strings.getLeadingWhitespace(currentLineText);\n        adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);\n        if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {\n            globalIndent = unshiftIndent(globalIndent);\n            adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);\n        }\n        if (currentLineText !== adjustedLineContent) {\n            indentEdits.push(EditOperation.replaceMove(new Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(globalIndent, indentSize, insertSpaces)));\n        }\n    }\n    else {\n        globalIndent = strings.getLeadingWhitespace(currentLineText);\n    }\n    // idealIndentForNextLine doesn't equal globalIndent when there is a line matching `indentNextLinePattern`.\n    let idealIndentForNextLine = globalIndent;\n    if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {\n        idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n        globalIndent = shiftIndent(globalIndent);\n    }\n    else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {\n        idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n    }\n    startLineNumber++;\n    // Calculate indentation adjustment for all following lines\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        let text = model.getLineContent(lineNumber);\n        let oldIndentation = strings.getLeadingWhitespace(text);\n        let adjustedLineContent = idealIndentForNextLine + text.substring(oldIndentation.length);\n        if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {\n            idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);\n            globalIndent = unshiftIndent(globalIndent);\n        }\n        if (oldIndentation !== idealIndentForNextLine) {\n            indentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));\n        }\n        // calculate idealIndentForNextLine\n        if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {\n            // In reindent phase, if the line matches `unIndentedLinePattern` we inherit indentation from above lines\n            // but don't change globalIndent and idealIndentForNextLine.\n            continue;\n        }\n        else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {\n            globalIndent = shiftIndent(globalIndent);\n            idealIndentForNextLine = globalIndent;\n        }\n        else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {\n            idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n        }\n        else {\n            idealIndentForNextLine = globalIndent;\n        }\n    }\n    return indentEdits;\n}\nexport class IndentationToSpacesAction extends EditorAction {\n    constructor() {\n        super({\n            id: IndentationToSpacesAction.ID,\n            label: nls.localize('indentationToSpaces', \"Convert Indentation to Spaces\"),\n            alias: 'Convert Indentation to Spaces',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    run(accessor, editor) {\n        let model = editor.getModel();\n        if (!model) {\n            return;\n        }\n        let modelOpts = model.getOptions();\n        let selection = editor.getSelection();\n        if (!selection) {\n            return;\n        }\n        const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, [command]);\n        editor.pushUndoStop();\n        model.updateOptions({\n            insertSpaces: true\n        });\n    }\n}\nIndentationToSpacesAction.ID = 'editor.action.indentationToSpaces';\nexport class IndentationToTabsAction extends EditorAction {\n    constructor() {\n        super({\n            id: IndentationToTabsAction.ID,\n            label: nls.localize('indentationToTabs', \"Convert Indentation to Tabs\"),\n            alias: 'Convert Indentation to Tabs',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    run(accessor, editor) {\n        let model = editor.getModel();\n        if (!model) {\n            return;\n        }\n        let modelOpts = model.getOptions();\n        let selection = editor.getSelection();\n        if (!selection) {\n            return;\n        }\n        const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);\n        editor.pushUndoStop();\n        editor.executeCommands(this.id, [command]);\n        editor.pushUndoStop();\n        model.updateOptions({\n            insertSpaces: false\n        });\n    }\n}\nIndentationToTabsAction.ID = 'editor.action.indentationToTabs';\nexport class ChangeIndentationSizeAction extends EditorAction {\n    constructor(insertSpaces, opts) {\n        super(opts);\n        this.insertSpaces = insertSpaces;\n    }\n    run(accessor, editor) {\n        const quickInputService = accessor.get(IQuickInputService);\n        const modelService = accessor.get(IModelService);\n        let model = editor.getModel();\n        if (!model) {\n            return;\n        }\n        const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);\n        const picks = [1, 2, 3, 4, 5, 6, 7, 8].map(n => ({\n            id: n.toString(),\n            label: n.toString(),\n            // add description for tabSize value set in the configuration\n            description: n === creationOpts.tabSize ? nls.localize('configuredTabSize', \"Configured Tab Size\") : undefined\n        }));\n        // auto focus the tabSize set for the current editor\n        const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);\n        setTimeout(() => {\n            quickInputService.pick(picks, { placeHolder: nls.localize({ key: 'selectTabWidth', comment: ['Tab corresponds to the tab key'] }, \"Select Tab Size for Current File\"), activeItem: picks[autoFocusIndex] }).then(pick => {\n                if (pick) {\n                    if (model && !model.isDisposed()) {\n                        model.updateOptions({\n                            tabSize: parseInt(pick.label, 10),\n                            insertSpaces: this.insertSpaces\n                        });\n                    }\n                }\n            });\n        }, 50 /* quick input is sensitive to being opened so soon after another */);\n    }\n}\nexport class IndentUsingTabs extends ChangeIndentationSizeAction {\n    constructor() {\n        super(false, {\n            id: IndentUsingTabs.ID,\n            label: nls.localize('indentUsingTabs', \"Indent Using Tabs\"),\n            alias: 'Indent Using Tabs',\n            precondition: undefined\n        });\n    }\n}\nIndentUsingTabs.ID = 'editor.action.indentUsingTabs';\nexport class IndentUsingSpaces extends ChangeIndentationSizeAction {\n    constructor() {\n        super(true, {\n            id: IndentUsingSpaces.ID,\n            label: nls.localize('indentUsingSpaces', \"Indent Using Spaces\"),\n            alias: 'Indent Using Spaces',\n            precondition: undefined\n        });\n    }\n}\nIndentUsingSpaces.ID = 'editor.action.indentUsingSpaces';\nexport class DetectIndentation extends EditorAction {\n    constructor() {\n        super({\n            id: DetectIndentation.ID,\n            label: nls.localize('detectIndentation', \"Detect Indentation from Content\"),\n            alias: 'Detect Indentation from Content',\n            precondition: undefined\n        });\n    }\n    run(accessor, editor) {\n        const modelService = accessor.get(IModelService);\n        let model = editor.getModel();\n        if (!model) {\n            return;\n        }\n        const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);\n        model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);\n    }\n}\nDetectIndentation.ID = 'editor.action.detectIndentation';\nexport class ReindentLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.reindentlines',\n            label: nls.localize('editor.reindentlines', \"Reindent Lines\"),\n            alias: 'Reindent Lines',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    run(accessor, editor) {\n        const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n        let model = editor.getModel();\n        if (!model) {\n            return;\n        }\n        let edits = getReindentEditOperations(model, languageConfigurationService, 1, model.getLineCount());\n        if (edits.length > 0) {\n            editor.pushUndoStop();\n            editor.executeEdits(this.id, edits);\n            editor.pushUndoStop();\n        }\n    }\n}\nexport class ReindentSelectedLinesAction extends EditorAction {\n    constructor() {\n        super({\n            id: 'editor.action.reindentselectedlines',\n            label: nls.localize('editor.reindentselectedlines', \"Reindent Selected Lines\"),\n            alias: 'Reindent Selected Lines',\n            precondition: EditorContextKeys.writable\n        });\n    }\n    run(accessor, editor) {\n        const languageConfigurationService = accessor.get(ILanguageConfigurationService);\n        let model = editor.getModel();\n        if (!model) {\n            return;\n        }\n        let selections = editor.getSelections();\n        if (selections === null) {\n            return;\n        }\n        let edits = [];\n        for (let selection of selections) {\n            let startLineNumber = selection.startLineNumber;\n            let endLineNumber = selection.endLineNumber;\n            if (startLineNumber !== endLineNumber && selection.endColumn === 1) {\n                endLineNumber--;\n            }\n            if (startLineNumber === 1) {\n                if (startLineNumber === endLineNumber) {\n                    continue;\n                }\n            }\n            else {\n                startLineNumber--;\n            }\n            let editOperations = getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber);\n            edits.push(...editOperations);\n        }\n        if (edits.length > 0) {\n            editor.pushUndoStop();\n            editor.executeEdits(this.id, edits);\n            editor.pushUndoStop();\n        }\n    }\n}\nexport class AutoIndentOnPasteCommand {\n    constructor(edits, initialSelection) {\n        this._initialSelection = initialSelection;\n        this._edits = [];\n        this._selectionId = null;\n        for (let edit of edits) {\n            if (edit.range && typeof edit.text === 'string') {\n                this._edits.push(edit);\n            }\n        }\n    }\n    getEditOperations(model, builder) {\n        for (let edit of this._edits) {\n            builder.addEditOperation(Range.lift(edit.range), edit.text);\n        }\n        let selectionIsSet = false;\n        if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {\n            if (this._edits[0].range.startColumn === this._initialSelection.endColumn &&\n                this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {\n                selectionIsSet = true;\n                this._selectionId = builder.trackSelection(this._initialSelection, true);\n            }\n            else if (this._edits[0].range.endColumn === this._initialSelection.startColumn &&\n                this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {\n                selectionIsSet = true;\n                this._selectionId = builder.trackSelection(this._initialSelection, false);\n            }\n        }\n        if (!selectionIsSet) {\n            this._selectionId = builder.trackSelection(this._initialSelection);\n        }\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this._selectionId);\n    }\n}\nexport class AutoIndentOnPaste {\n    constructor(editor) {\n        this.callOnDispose = new DisposableStore();\n        this.callOnModel = new DisposableStore();\n        this.editor = editor;\n        this.callOnDispose.add(editor.onDidChangeConfiguration(() => this.update()));\n        this.callOnDispose.add(editor.onDidChangeModel(() => this.update()));\n        this.callOnDispose.add(editor.onDidChangeModelLanguage(() => this.update()));\n    }\n    update() {\n        // clean up\n        this.callOnModel.clear();\n        // we are disabled\n        if (this.editor.getOption(9 /* autoIndent */) < 4 /* Full */ || this.editor.getOption(48 /* formatOnPaste */)) {\n            return;\n        }\n        // no model\n        if (!this.editor.hasModel()) {\n            return;\n        }\n        this.callOnModel.add(this.editor.onDidPaste(({ range }) => {\n            this.trigger(range);\n        }));\n    }\n    trigger(range) {\n        let selections = this.editor.getSelections();\n        if (selections === null || selections.length > 1) {\n            return;\n        }\n        const model = this.editor.getModel();\n        if (!model) {\n            return;\n        }\n        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {\n            return;\n        }\n        const autoIndent = this.editor.getOption(9 /* autoIndent */);\n        const { tabSize, indentSize, insertSpaces } = model.getOptions();\n        let textEdits = [];\n        let indentConverter = {\n            shiftIndent: (indentation) => {\n                return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            },\n            unshiftIndent: (indentation) => {\n                return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            }\n        };\n        let startLineNumber = range.startLineNumber;\n        while (startLineNumber <= range.endLineNumber) {\n            if (this.shouldIgnoreLine(model, startLineNumber)) {\n                startLineNumber++;\n                continue;\n            }\n            break;\n        }\n        if (startLineNumber > range.endLineNumber) {\n            return;\n        }\n        let firstLineText = model.getLineContent(startLineNumber);\n        if (!/\\S/.test(firstLineText.substring(0, range.startColumn - 1))) {\n            const indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, model, model.getLanguageId(), startLineNumber, indentConverter);\n            if (indentOfFirstLine !== null) {\n                let oldIndentation = strings.getLeadingWhitespace(firstLineText);\n                let newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n                let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                if (newSpaceCnt !== oldSpaceCnt) {\n                    let newIndent = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                    textEdits.push({\n                        range: new Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),\n                        text: newIndent\n                    });\n                    firstLineText = newIndent + firstLineText.substr(oldIndentation.length);\n                }\n                else {\n                    let indentMetadata = LanguageConfigurationRegistry.getIndentMetadata(model, startLineNumber);\n                    if (indentMetadata === 0 || indentMetadata === 8 /* UNINDENT_MASK */) {\n                        // we paste content into a line where only contains whitespaces\n                        // after pasting, the indentation of the first line is already correct\n                        // the first line doesn't match any indentation rule\n                        // then no-op.\n                        return;\n                    }\n                }\n            }\n        }\n        const firstLineNumber = startLineNumber;\n        // ignore empty or ignored lines\n        while (startLineNumber < range.endLineNumber) {\n            if (!/\\S/.test(model.getLineContent(startLineNumber + 1))) {\n                startLineNumber++;\n                continue;\n            }\n            break;\n        }\n        if (startLineNumber !== range.endLineNumber) {\n            let virtualModel = {\n                getLineTokens: (lineNumber) => {\n                    return model.getLineTokens(lineNumber);\n                },\n                getLanguageId: () => {\n                    return model.getLanguageId();\n                },\n                getLanguageIdAtPosition: (lineNumber, column) => {\n                    return model.getLanguageIdAtPosition(lineNumber, column);\n                },\n                getLineContent: (lineNumber) => {\n                    if (lineNumber === firstLineNumber) {\n                        return firstLineText;\n                    }\n                    else {\n                        return model.getLineContent(lineNumber);\n                    }\n                }\n            };\n            let indentOfSecondLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageId(), startLineNumber + 1, indentConverter);\n            if (indentOfSecondLine !== null) {\n                let newSpaceCntOfSecondLine = indentUtils.getSpaceCnt(indentOfSecondLine, tabSize);\n                let oldSpaceCntOfSecondLine = indentUtils.getSpaceCnt(strings.getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);\n                if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {\n                    let spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;\n                    for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {\n                        let lineContent = model.getLineContent(i);\n                        let originalIndent = strings.getLeadingWhitespace(lineContent);\n                        let originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n                        let newSpacesCnt = originalSpacesCnt + spaceCntOffset;\n                        let newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n                        if (newIndent !== originalIndent) {\n                            textEdits.push({\n                                range: new Range(i, 1, i, originalIndent.length + 1),\n                                text: newIndent\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if (textEdits.length > 0) {\n            this.editor.pushUndoStop();\n            let cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());\n            this.editor.executeCommand('autoIndentOnPaste', cmd);\n            this.editor.pushUndoStop();\n        }\n    }\n    shouldIgnoreLine(model, lineNumber) {\n        model.forceTokenization(lineNumber);\n        let nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n        if (nonWhitespaceColumn === 0) {\n            return true;\n        }\n        let tokens = model.getLineTokens(lineNumber);\n        if (tokens.getCount() > 0) {\n            let firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);\n            if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1 /* Comment */) {\n                return true;\n            }\n        }\n        return false;\n    }\n    dispose() {\n        this.callOnDispose.dispose();\n        this.callOnModel.dispose();\n    }\n}\nAutoIndentOnPaste.ID = 'editor.contrib.autoIndentOnPaste';\nfunction getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {\n    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n        // Model is empty\n        return;\n    }\n    let spaces = '';\n    for (let i = 0; i < tabSize; i++) {\n        spaces += ' ';\n    }\n    let spacesRegExp = new RegExp(spaces, 'gi');\n    for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n        let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n        if (lastIndentationColumn === 0) {\n            lastIndentationColumn = model.getLineMaxColumn(lineNumber);\n        }\n        if (lastIndentationColumn === 1) {\n            continue;\n        }\n        const originalIndentationRange = new Range(lineNumber, 1, lineNumber, lastIndentationColumn);\n        const originalIndentation = model.getValueInRange(originalIndentationRange);\n        const newIndentation = (tabsToSpaces\n            ? originalIndentation.replace(/\\t/ig, spaces)\n            : originalIndentation.replace(spacesRegExp, '\\t'));\n        builder.addEditOperation(originalIndentationRange, newIndentation);\n    }\n}\nexport class IndentationToSpacesCommand {\n    constructor(selection, tabSize) {\n        this.selection = selection;\n        this.tabSize = tabSize;\n        this.selectionId = null;\n    }\n    getEditOperations(model, builder) {\n        this.selectionId = builder.trackSelection(this.selection);\n        getIndentationEditOperations(model, builder, this.tabSize, true);\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this.selectionId);\n    }\n}\nexport class IndentationToTabsCommand {\n    constructor(selection, tabSize) {\n        this.selection = selection;\n        this.tabSize = tabSize;\n        this.selectionId = null;\n    }\n    getEditOperations(model, builder) {\n        this.selectionId = builder.trackSelection(this.selection);\n        getIndentationEditOperations(model, builder, this.tabSize, false);\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this.selectionId);\n    }\n}\nregisterEditorContribution(AutoIndentOnPaste.ID, AutoIndentOnPaste);\nregisterEditorAction(IndentationToSpacesAction);\nregisterEditorAction(IndentationToTabsAction);\nregisterEditorAction(IndentUsingTabs);\nregisterEditorAction(IndentUsingSpaces);\nregisterEditorAction(DetectIndentation);\nregisterEditorAction(ReindentLinesAction);\nregisterEditorAction(ReindentSelectedLinesAction);\n"]},"metadata":{},"sourceType":"module"}