{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\n\nclass Coordinate {\n  constructor(top, left) {\n    this._coordinateBrand = undefined;\n    this.top = top;\n    this.left = left;\n  }\n\n}\n\nexport class ViewContentWidgets extends ViewPart {\n  constructor(context, viewDomNode) {\n    super(context);\n    this._viewDomNode = viewDomNode;\n    this._widgets = {};\n    this.domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(this.domNode, 1\n    /* ContentWidgets */\n    );\n    this.domNode.setClassName('contentWidgets');\n    this.domNode.setPosition('absolute');\n    this.domNode.setTop(0);\n    this.overflowingContentWidgetsDomNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(this.overflowingContentWidgetsDomNode, 2\n    /* OverflowingContentWidgets */\n    );\n    this.overflowingContentWidgetsDomNode.setClassName('overflowingContentWidgets');\n  }\n\n  dispose() {\n    super.dispose();\n    this._widgets = {};\n  } // --- begin event handlers\n\n\n  onConfigurationChanged(e) {\n    const keys = Object.keys(this._widgets);\n\n    for (const widgetId of keys) {\n      this._widgets[widgetId].onConfigurationChanged(e);\n    }\n\n    return true;\n  }\n\n  onDecorationsChanged(e) {\n    // true for inline decorations that can end up relayouting text\n    return true;\n  }\n\n  onFlushed(e) {\n    return true;\n  }\n\n  onLineMappingChanged(e) {\n    const keys = Object.keys(this._widgets);\n\n    for (const widgetId of keys) {\n      this._widgets[widgetId].onLineMappingChanged(e);\n    }\n\n    return true;\n  }\n\n  onLinesChanged(e) {\n    return true;\n  }\n\n  onLinesDeleted(e) {\n    return true;\n  }\n\n  onLinesInserted(e) {\n    return true;\n  }\n\n  onScrollChanged(e) {\n    return true;\n  }\n\n  onZonesChanged(e) {\n    return true;\n  } // ---- end view event handlers\n\n\n  addWidget(_widget) {\n    const myWidget = new Widget(this._context, this._viewDomNode, _widget);\n    this._widgets[myWidget.id] = myWidget;\n\n    if (myWidget.allowEditorOverflow) {\n      this.overflowingContentWidgetsDomNode.appendChild(myWidget.domNode);\n    } else {\n      this.domNode.appendChild(myWidget.domNode);\n    }\n\n    this.setShouldRender();\n  }\n\n  setWidgetPosition(widget, range, preference) {\n    const myWidget = this._widgets[widget.getId()];\n\n    myWidget.setPosition(range, preference);\n    this.setShouldRender();\n  }\n\n  removeWidget(widget) {\n    const widgetId = widget.getId();\n\n    if (this._widgets.hasOwnProperty(widgetId)) {\n      const myWidget = this._widgets[widgetId];\n      delete this._widgets[widgetId];\n      const domNode = myWidget.domNode.domNode;\n      domNode.parentNode.removeChild(domNode);\n      domNode.removeAttribute('monaco-visible-content-widget');\n      this.setShouldRender();\n    }\n  }\n\n  shouldSuppressMouseDownOnWidget(widgetId) {\n    if (this._widgets.hasOwnProperty(widgetId)) {\n      return this._widgets[widgetId].suppressMouseDown;\n    }\n\n    return false;\n  }\n\n  onBeforeRender(viewportData) {\n    const keys = Object.keys(this._widgets);\n\n    for (const widgetId of keys) {\n      this._widgets[widgetId].onBeforeRender(viewportData);\n    }\n  }\n\n  prepareRender(ctx) {\n    const keys = Object.keys(this._widgets);\n\n    for (const widgetId of keys) {\n      this._widgets[widgetId].prepareRender(ctx);\n    }\n  }\n\n  render(ctx) {\n    const keys = Object.keys(this._widgets);\n\n    for (const widgetId of keys) {\n      this._widgets[widgetId].render(ctx);\n    }\n  }\n\n}\n\nclass Widget {\n  constructor(context, viewDomNode, actual) {\n    this._context = context;\n    this._viewDomNode = viewDomNode;\n    this._actual = actual;\n    this.domNode = createFastDomNode(this._actual.getDomNode());\n    this.id = this._actual.getId();\n    this.allowEditorOverflow = this._actual.allowEditorOverflow || false;\n    this.suppressMouseDown = this._actual.suppressMouseDown || false;\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(131\n    /* layoutInfo */\n    );\n    this._fixedOverflowWidgets = options.get(36\n    /* fixedOverflowWidgets */\n    );\n    this._contentWidth = layoutInfo.contentWidth;\n    this._contentLeft = layoutInfo.contentLeft;\n    this._lineHeight = options.get(59\n    /* lineHeight */\n    );\n    this._range = null;\n    this._viewRange = null;\n    this._preference = [];\n    this._cachedDomNodeOffsetWidth = -1;\n    this._cachedDomNodeOffsetHeight = -1;\n    this._maxWidth = this._getMaxWidth();\n    this._isVisible = false;\n    this._renderData = null;\n    this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? 'fixed' : 'absolute');\n    this.domNode.setDisplay('none');\n    this.domNode.setVisibility('hidden');\n    this.domNode.setAttribute('widgetId', this.id);\n    this.domNode.setMaxWidth(this._maxWidth);\n  }\n\n  onConfigurationChanged(e) {\n    const options = this._context.configuration.options;\n    this._lineHeight = options.get(59\n    /* lineHeight */\n    );\n\n    if (e.hasChanged(131\n    /* layoutInfo */\n    )) {\n      const layoutInfo = options.get(131\n      /* layoutInfo */\n      );\n      this._contentLeft = layoutInfo.contentLeft;\n      this._contentWidth = layoutInfo.contentWidth;\n      this._maxWidth = this._getMaxWidth();\n    }\n  }\n\n  onLineMappingChanged(e) {\n    this._setPosition(this._range);\n  }\n\n  _setPosition(range) {\n    this._range = range;\n    this._viewRange = null;\n\n    if (this._range) {\n      // Do not trust that widgets give a valid position\n      const validModelRange = this._context.model.validateModelRange(this._range);\n\n      if (this._context.model.coordinatesConverter.modelPositionIsVisible(validModelRange.getStartPosition()) || this._context.model.coordinatesConverter.modelPositionIsVisible(validModelRange.getEndPosition())) {\n        this._viewRange = this._context.model.coordinatesConverter.convertModelRangeToViewRange(validModelRange);\n      }\n    }\n  }\n\n  _getMaxWidth() {\n    return this.allowEditorOverflow ? window.innerWidth || document.documentElement.offsetWidth || document.body.offsetWidth : this._contentWidth;\n  }\n\n  setPosition(range, preference) {\n    this._setPosition(range);\n\n    this._preference = preference;\n\n    if (this._viewRange && this._preference && this._preference.length > 0) {\n      // this content widget would like to be visible if possible\n      // we change it from `display:none` to `display:block` even if it\n      // might be outside the viewport such that we can measure its size\n      // in `prepareRender`\n      this.domNode.setDisplay('block');\n    } else {\n      this.domNode.setDisplay('none');\n    }\n\n    this._cachedDomNodeOffsetWidth = -1;\n    this._cachedDomNodeOffsetHeight = -1;\n  }\n\n  _layoutBoxInViewport(topLeft, bottomLeft, width, height, ctx) {\n    // Our visible box is split horizontally by the current line => 2 boxes\n    // a) the box above the line\n    const aboveLineTop = topLeft.top;\n    const heightAboveLine = aboveLineTop; // b) the box under the line\n\n    const underLineTop = bottomLeft.top + this._lineHeight;\n    const heightUnderLine = ctx.viewportHeight - underLineTop;\n    const aboveTop = aboveLineTop - height;\n    const fitsAbove = heightAboveLine >= height;\n    const belowTop = underLineTop;\n    const fitsBelow = heightUnderLine >= height; // And its left\n\n    let actualAboveLeft = topLeft.left;\n    let actualBelowLeft = bottomLeft.left;\n\n    if (actualAboveLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n      actualAboveLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n    }\n\n    if (actualBelowLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n      actualBelowLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n    }\n\n    if (actualAboveLeft < ctx.scrollLeft) {\n      actualAboveLeft = ctx.scrollLeft;\n    }\n\n    if (actualBelowLeft < ctx.scrollLeft) {\n      actualBelowLeft = ctx.scrollLeft;\n    }\n\n    return {\n      fitsAbove: fitsAbove,\n      aboveTop: aboveTop,\n      aboveLeft: actualAboveLeft,\n      fitsBelow: fitsBelow,\n      belowTop: belowTop,\n      belowLeft: actualBelowLeft\n    };\n  }\n\n  _layoutHorizontalSegmentInPage(windowSize, domNodePosition, left, width) {\n    // Initially, the limits are defined as the dom node limits\n    const MIN_LIMIT = Math.max(0, domNodePosition.left - width);\n    const MAX_LIMIT = Math.min(domNodePosition.left + domNodePosition.width + width, windowSize.width);\n    let absoluteLeft = domNodePosition.left + left - dom.StandardWindow.scrollX;\n\n    if (absoluteLeft + width > MAX_LIMIT) {\n      const delta = absoluteLeft - (MAX_LIMIT - width);\n      absoluteLeft -= delta;\n      left -= delta;\n    }\n\n    if (absoluteLeft < MIN_LIMIT) {\n      const delta = absoluteLeft - MIN_LIMIT;\n      absoluteLeft -= delta;\n      left -= delta;\n    }\n\n    return [left, absoluteLeft];\n  }\n\n  _layoutBoxInPage(topLeft, bottomLeft, width, height, ctx) {\n    const aboveTop = topLeft.top - height;\n    const belowTop = bottomLeft.top + this._lineHeight;\n    const domNodePosition = dom.getDomNodePagePosition(this._viewDomNode.domNode);\n    const absoluteAboveTop = domNodePosition.top + aboveTop - dom.StandardWindow.scrollY;\n    const absoluteBelowTop = domNodePosition.top + belowTop - dom.StandardWindow.scrollY;\n    const windowSize = dom.getClientArea(document.body);\n\n    const [aboveLeft, absoluteAboveLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, topLeft.left - ctx.scrollLeft + this._contentLeft, width);\n\n    const [belowLeft, absoluteBelowLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, bottomLeft.left - ctx.scrollLeft + this._contentLeft, width); // Leave some clearance to the top/bottom\n\n\n    const TOP_PADDING = 22;\n    const BOTTOM_PADDING = 22;\n    const fitsAbove = absoluteAboveTop >= TOP_PADDING;\n    const fitsBelow = absoluteBelowTop + height <= windowSize.height - BOTTOM_PADDING;\n\n    if (this._fixedOverflowWidgets) {\n      return {\n        fitsAbove,\n        aboveTop: Math.max(absoluteAboveTop, TOP_PADDING),\n        aboveLeft: absoluteAboveLeft,\n        fitsBelow,\n        belowTop: absoluteBelowTop,\n        belowLeft: absoluteBelowLeft\n      };\n    }\n\n    return {\n      fitsAbove,\n      aboveTop: aboveTop,\n      aboveLeft,\n      fitsBelow,\n      belowTop,\n      belowLeft\n    };\n  }\n\n  _prepareRenderWidgetAtExactPositionOverflowing(topLeft) {\n    return new Coordinate(topLeft.top, topLeft.left + this._contentLeft);\n  }\n  /**\n   * Compute `this._topLeft`\n   */\n\n\n  _getTopAndBottomLeft(ctx) {\n    if (!this._viewRange) {\n      return [null, null];\n    }\n\n    const visibleRangesForRange = ctx.linesVisibleRangesForRange(this._viewRange, false);\n\n    if (!visibleRangesForRange || visibleRangesForRange.length === 0) {\n      return [null, null];\n    }\n\n    let firstLine = visibleRangesForRange[0];\n    let lastLine = visibleRangesForRange[0];\n\n    for (const visibleRangesForLine of visibleRangesForRange) {\n      if (visibleRangesForLine.lineNumber < firstLine.lineNumber) {\n        firstLine = visibleRangesForLine;\n      }\n\n      if (visibleRangesForLine.lineNumber > lastLine.lineNumber) {\n        lastLine = visibleRangesForLine;\n      }\n    }\n\n    let firstLineMinLeft = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ; //firstLine.Constants.MAX_SAFE_SMALL_INTEGER;\n\n    for (const visibleRange of firstLine.ranges) {\n      if (visibleRange.left < firstLineMinLeft) {\n        firstLineMinLeft = visibleRange.left;\n      }\n    }\n\n    let lastLineMinLeft = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ; //lastLine.Constants.MAX_SAFE_SMALL_INTEGER;\n\n    for (const visibleRange of lastLine.ranges) {\n      if (visibleRange.left < lastLineMinLeft) {\n        lastLineMinLeft = visibleRange.left;\n      }\n    }\n\n    const topForPosition = ctx.getVerticalOffsetForLineNumber(firstLine.lineNumber) - ctx.scrollTop;\n    const topLeft = new Coordinate(topForPosition, firstLineMinLeft);\n    const topForBottomLine = ctx.getVerticalOffsetForLineNumber(lastLine.lineNumber) - ctx.scrollTop;\n    const bottomLeft = new Coordinate(topForBottomLine, lastLineMinLeft);\n    return [topLeft, bottomLeft];\n  }\n\n  _prepareRenderWidget(ctx) {\n    if (!this._preference || this._preference.length === 0) {\n      return null;\n    }\n\n    const [topLeft, bottomLeft] = this._getTopAndBottomLeft(ctx);\n\n    if (!topLeft || !bottomLeft) {\n      return null;\n    }\n\n    if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {\n      let preferredDimensions = null;\n\n      if (typeof this._actual.beforeRender === 'function') {\n        preferredDimensions = safeInvoke(this._actual.beforeRender, this._actual);\n      }\n\n      if (preferredDimensions) {\n        this._cachedDomNodeOffsetWidth = preferredDimensions.width;\n        this._cachedDomNodeOffsetHeight = preferredDimensions.height;\n      } else {\n        const domNode = this.domNode.domNode;\n        this._cachedDomNodeOffsetWidth = domNode.offsetWidth;\n        this._cachedDomNodeOffsetHeight = domNode.offsetHeight;\n      }\n    }\n\n    let placement;\n\n    if (this.allowEditorOverflow) {\n      placement = this._layoutBoxInPage(topLeft, bottomLeft, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, ctx);\n    } else {\n      placement = this._layoutBoxInViewport(topLeft, bottomLeft, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, ctx);\n    } // Do two passes, first for perfect fit, second picks first option\n\n\n    for (let pass = 1; pass <= 2; pass++) {\n      for (const pref of this._preference) {\n        // placement\n        if (pref === 1\n        /* ABOVE */\n        ) {\n          if (!placement) {\n            // Widget outside of viewport\n            return null;\n          }\n\n          if (pass === 2 || placement.fitsAbove) {\n            return {\n              coordinate: new Coordinate(placement.aboveTop, placement.aboveLeft),\n              position: 1\n              /* ABOVE */\n\n            };\n          }\n        } else if (pref === 2\n        /* BELOW */\n        ) {\n          if (!placement) {\n            // Widget outside of viewport\n            return null;\n          }\n\n          if (pass === 2 || placement.fitsBelow) {\n            return {\n              coordinate: new Coordinate(placement.belowTop, placement.belowLeft),\n              position: 2\n              /* BELOW */\n\n            };\n          }\n        } else {\n          if (this.allowEditorOverflow) {\n            return {\n              coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(topLeft),\n              position: 0\n              /* EXACT */\n\n            };\n          } else {\n            return {\n              coordinate: topLeft,\n              position: 0\n              /* EXACT */\n\n            };\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.\n   */\n\n\n  onBeforeRender(viewportData) {\n    if (!this._viewRange || !this._preference) {\n      return;\n    }\n\n    if (this._viewRange.endLineNumber < viewportData.startLineNumber || this._viewRange.startLineNumber > viewportData.endLineNumber) {\n      // Outside of viewport\n      return;\n    }\n\n    this.domNode.setMaxWidth(this._maxWidth);\n  }\n\n  prepareRender(ctx) {\n    this._renderData = this._prepareRenderWidget(ctx);\n  }\n\n  render(ctx) {\n    if (!this._renderData) {\n      // This widget should be invisible\n      if (this._isVisible) {\n        this.domNode.removeAttribute('monaco-visible-content-widget');\n        this._isVisible = false;\n        this.domNode.setVisibility('hidden');\n      }\n\n      if (typeof this._actual.afterRender === 'function') {\n        safeInvoke(this._actual.afterRender, this._actual, null);\n      }\n\n      return;\n    } // This widget should be visible\n\n\n    if (this.allowEditorOverflow) {\n      this.domNode.setTop(this._renderData.coordinate.top);\n      this.domNode.setLeft(this._renderData.coordinate.left);\n    } else {\n      this.domNode.setTop(this._renderData.coordinate.top + ctx.scrollTop - ctx.bigNumbersDelta);\n      this.domNode.setLeft(this._renderData.coordinate.left);\n    }\n\n    if (!this._isVisible) {\n      this.domNode.setVisibility('inherit');\n      this.domNode.setAttribute('monaco-visible-content-widget', 'true');\n      this._isVisible = true;\n    }\n\n    if (typeof this._actual.afterRender === 'function') {\n      safeInvoke(this._actual.afterRender, this._actual, this._renderData.position);\n    }\n  }\n\n}\n\nfunction safeInvoke(fn, thisArg, ...args) {\n  try {\n    return fn.call(thisArg, ...args);\n  } catch (_a) {\n    // ignore\n    return null;\n  }\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/contentWidgets/contentWidgets.js"],"names":["dom","createFastDomNode","PartFingerprints","ViewPart","Coordinate","constructor","top","left","_coordinateBrand","undefined","ViewContentWidgets","context","viewDomNode","_viewDomNode","_widgets","domNode","document","createElement","write","setClassName","setPosition","setTop","overflowingContentWidgetsDomNode","dispose","onConfigurationChanged","e","keys","Object","widgetId","onDecorationsChanged","onFlushed","onLineMappingChanged","onLinesChanged","onLinesDeleted","onLinesInserted","onScrollChanged","onZonesChanged","addWidget","_widget","myWidget","Widget","_context","id","allowEditorOverflow","appendChild","setShouldRender","setWidgetPosition","widget","range","preference","getId","removeWidget","hasOwnProperty","parentNode","removeChild","removeAttribute","shouldSuppressMouseDownOnWidget","suppressMouseDown","onBeforeRender","viewportData","prepareRender","ctx","render","actual","_actual","getDomNode","options","configuration","layoutInfo","get","_fixedOverflowWidgets","_contentWidth","contentWidth","_contentLeft","contentLeft","_lineHeight","_range","_viewRange","_preference","_cachedDomNodeOffsetWidth","_cachedDomNodeOffsetHeight","_maxWidth","_getMaxWidth","_isVisible","_renderData","setDisplay","setVisibility","setAttribute","setMaxWidth","hasChanged","_setPosition","validModelRange","model","validateModelRange","coordinatesConverter","modelPositionIsVisible","getStartPosition","getEndPosition","convertModelRangeToViewRange","window","innerWidth","documentElement","offsetWidth","body","length","_layoutBoxInViewport","topLeft","bottomLeft","width","height","aboveLineTop","heightAboveLine","underLineTop","heightUnderLine","viewportHeight","aboveTop","fitsAbove","belowTop","fitsBelow","actualAboveLeft","actualBelowLeft","scrollLeft","viewportWidth","aboveLeft","belowLeft","_layoutHorizontalSegmentInPage","windowSize","domNodePosition","MIN_LIMIT","Math","max","MAX_LIMIT","min","absoluteLeft","StandardWindow","scrollX","delta","_layoutBoxInPage","getDomNodePagePosition","absoluteAboveTop","scrollY","absoluteBelowTop","getClientArea","absoluteAboveLeft","absoluteBelowLeft","TOP_PADDING","BOTTOM_PADDING","_prepareRenderWidgetAtExactPositionOverflowing","_getTopAndBottomLeft","visibleRangesForRange","linesVisibleRangesForRange","firstLine","lastLine","visibleRangesForLine","lineNumber","firstLineMinLeft","visibleRange","ranges","lastLineMinLeft","topForPosition","getVerticalOffsetForLineNumber","scrollTop","topForBottomLine","_prepareRenderWidget","preferredDimensions","beforeRender","safeInvoke","offsetHeight","placement","pass","pref","coordinate","position","endLineNumber","startLineNumber","afterRender","setLeft","bigNumbersDelta","fn","thisArg","args","call","_a"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,GAAZ,MAAqB,iCAArB;AACA,SAASC,iBAAT,QAAkC,yCAAlC;AACA,SAASC,gBAAT,EAA2BC,QAA3B,QAA2C,wBAA3C;;AACA,MAAMC,UAAN,CAAiB;AACbC,EAAAA,WAAW,CAACC,GAAD,EAAMC,IAAN,EAAY;AACnB,SAAKC,gBAAL,GAAwBC,SAAxB;AACA,SAAKH,GAAL,GAAWA,GAAX;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACH;;AALY;;AAOjB,OAAO,MAAMG,kBAAN,SAAiCP,QAAjC,CAA0C;AAC7CE,EAAAA,WAAW,CAACM,OAAD,EAAUC,WAAV,EAAuB;AAC9B,UAAMD,OAAN;AACA,SAAKE,YAAL,GAAoBD,WAApB;AACA,SAAKE,QAAL,GAAgB,EAAhB;AACA,SAAKC,OAAL,GAAed,iBAAiB,CAACe,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAD,CAAhC;AACAf,IAAAA,gBAAgB,CAACgB,KAAjB,CAAuB,KAAKH,OAA5B,EAAqC;AAAE;AAAvC;AACA,SAAKA,OAAL,CAAaI,YAAb,CAA0B,gBAA1B;AACA,SAAKJ,OAAL,CAAaK,WAAb,CAAyB,UAAzB;AACA,SAAKL,OAAL,CAAaM,MAAb,CAAoB,CAApB;AACA,SAAKC,gCAAL,GAAwCrB,iBAAiB,CAACe,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAD,CAAzD;AACAf,IAAAA,gBAAgB,CAACgB,KAAjB,CAAuB,KAAKI,gCAA5B,EAA8D;AAAE;AAAhE;AACA,SAAKA,gCAAL,CAAsCH,YAAtC,CAAmD,2BAAnD;AACH;;AACDI,EAAAA,OAAO,GAAG;AACN,UAAMA,OAAN;AACA,SAAKT,QAAL,GAAgB,EAAhB;AACH,GAjB4C,CAkB7C;;;AACAU,EAAAA,sBAAsB,CAACC,CAAD,EAAI;AACtB,UAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAY,KAAKZ,QAAjB,CAAb;;AACA,SAAK,MAAMc,QAAX,IAAuBF,IAAvB,EAA6B;AACzB,WAAKZ,QAAL,CAAcc,QAAd,EAAwBJ,sBAAxB,CAA+CC,CAA/C;AACH;;AACD,WAAO,IAAP;AACH;;AACDI,EAAAA,oBAAoB,CAACJ,CAAD,EAAI;AACpB;AACA,WAAO,IAAP;AACH;;AACDK,EAAAA,SAAS,CAACL,CAAD,EAAI;AACT,WAAO,IAAP;AACH;;AACDM,EAAAA,oBAAoB,CAACN,CAAD,EAAI;AACpB,UAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAY,KAAKZ,QAAjB,CAAb;;AACA,SAAK,MAAMc,QAAX,IAAuBF,IAAvB,EAA6B;AACzB,WAAKZ,QAAL,CAAcc,QAAd,EAAwBG,oBAAxB,CAA6CN,CAA7C;AACH;;AACD,WAAO,IAAP;AACH;;AACDO,EAAAA,cAAc,CAACP,CAAD,EAAI;AACd,WAAO,IAAP;AACH;;AACDQ,EAAAA,cAAc,CAACR,CAAD,EAAI;AACd,WAAO,IAAP;AACH;;AACDS,EAAAA,eAAe,CAACT,CAAD,EAAI;AACf,WAAO,IAAP;AACH;;AACDU,EAAAA,eAAe,CAACV,CAAD,EAAI;AACf,WAAO,IAAP;AACH;;AACDW,EAAAA,cAAc,CAACX,CAAD,EAAI;AACd,WAAO,IAAP;AACH,GAtD4C,CAuD7C;;;AACAY,EAAAA,SAAS,CAACC,OAAD,EAAU;AACf,UAAMC,QAAQ,GAAG,IAAIC,MAAJ,CAAW,KAAKC,QAAhB,EAA0B,KAAK5B,YAA/B,EAA6CyB,OAA7C,CAAjB;AACA,SAAKxB,QAAL,CAAcyB,QAAQ,CAACG,EAAvB,IAA6BH,QAA7B;;AACA,QAAIA,QAAQ,CAACI,mBAAb,EAAkC;AAC9B,WAAKrB,gCAAL,CAAsCsB,WAAtC,CAAkDL,QAAQ,CAACxB,OAA3D;AACH,KAFD,MAGK;AACD,WAAKA,OAAL,CAAa6B,WAAb,CAAyBL,QAAQ,CAACxB,OAAlC;AACH;;AACD,SAAK8B,eAAL;AACH;;AACDC,EAAAA,iBAAiB,CAACC,MAAD,EAASC,KAAT,EAAgBC,UAAhB,EAA4B;AACzC,UAAMV,QAAQ,GAAG,KAAKzB,QAAL,CAAciC,MAAM,CAACG,KAAP,EAAd,CAAjB;;AACAX,IAAAA,QAAQ,CAACnB,WAAT,CAAqB4B,KAArB,EAA4BC,UAA5B;AACA,SAAKJ,eAAL;AACH;;AACDM,EAAAA,YAAY,CAACJ,MAAD,EAAS;AACjB,UAAMnB,QAAQ,GAAGmB,MAAM,CAACG,KAAP,EAAjB;;AACA,QAAI,KAAKpC,QAAL,CAAcsC,cAAd,CAA6BxB,QAA7B,CAAJ,EAA4C;AACxC,YAAMW,QAAQ,GAAG,KAAKzB,QAAL,CAAcc,QAAd,CAAjB;AACA,aAAO,KAAKd,QAAL,CAAcc,QAAd,CAAP;AACA,YAAMb,OAAO,GAAGwB,QAAQ,CAACxB,OAAT,CAAiBA,OAAjC;AACAA,MAAAA,OAAO,CAACsC,UAAR,CAAmBC,WAAnB,CAA+BvC,OAA/B;AACAA,MAAAA,OAAO,CAACwC,eAAR,CAAwB,+BAAxB;AACA,WAAKV,eAAL;AACH;AACJ;;AACDW,EAAAA,+BAA+B,CAAC5B,QAAD,EAAW;AACtC,QAAI,KAAKd,QAAL,CAAcsC,cAAd,CAA6BxB,QAA7B,CAAJ,EAA4C;AACxC,aAAO,KAAKd,QAAL,CAAcc,QAAd,EAAwB6B,iBAA/B;AACH;;AACD,WAAO,KAAP;AACH;;AACDC,EAAAA,cAAc,CAACC,YAAD,EAAe;AACzB,UAAMjC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAY,KAAKZ,QAAjB,CAAb;;AACA,SAAK,MAAMc,QAAX,IAAuBF,IAAvB,EAA6B;AACzB,WAAKZ,QAAL,CAAcc,QAAd,EAAwB8B,cAAxB,CAAuCC,YAAvC;AACH;AACJ;;AACDC,EAAAA,aAAa,CAACC,GAAD,EAAM;AACf,UAAMnC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAY,KAAKZ,QAAjB,CAAb;;AACA,SAAK,MAAMc,QAAX,IAAuBF,IAAvB,EAA6B;AACzB,WAAKZ,QAAL,CAAcc,QAAd,EAAwBgC,aAAxB,CAAsCC,GAAtC;AACH;AACJ;;AACDC,EAAAA,MAAM,CAACD,GAAD,EAAM;AACR,UAAMnC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAY,KAAKZ,QAAjB,CAAb;;AACA,SAAK,MAAMc,QAAX,IAAuBF,IAAvB,EAA6B;AACzB,WAAKZ,QAAL,CAAcc,QAAd,EAAwBkC,MAAxB,CAA+BD,GAA/B;AACH;AACJ;;AA1G4C;;AA4GjD,MAAMrB,MAAN,CAAa;AACTnC,EAAAA,WAAW,CAACM,OAAD,EAAUC,WAAV,EAAuBmD,MAAvB,EAA+B;AACtC,SAAKtB,QAAL,GAAgB9B,OAAhB;AACA,SAAKE,YAAL,GAAoBD,WAApB;AACA,SAAKoD,OAAL,GAAeD,MAAf;AACA,SAAKhD,OAAL,GAAed,iBAAiB,CAAC,KAAK+D,OAAL,CAAaC,UAAb,EAAD,CAAhC;AACA,SAAKvB,EAAL,GAAU,KAAKsB,OAAL,CAAad,KAAb,EAAV;AACA,SAAKP,mBAAL,GAA2B,KAAKqB,OAAL,CAAarB,mBAAb,IAAoC,KAA/D;AACA,SAAKc,iBAAL,GAAyB,KAAKO,OAAL,CAAaP,iBAAb,IAAkC,KAA3D;AACA,UAAMS,OAAO,GAAG,KAAKzB,QAAL,CAAc0B,aAAd,CAA4BD,OAA5C;AACA,UAAME,UAAU,GAAGF,OAAO,CAACG,GAAR,CAAY;AAAI;AAAhB,KAAnB;AACA,SAAKC,qBAAL,GAA6BJ,OAAO,CAACG,GAAR,CAAY;AAAG;AAAf,KAA7B;AACA,SAAKE,aAAL,GAAqBH,UAAU,CAACI,YAAhC;AACA,SAAKC,YAAL,GAAoBL,UAAU,CAACM,WAA/B;AACA,SAAKC,WAAL,GAAmBT,OAAO,CAACG,GAAR,CAAY;AAAG;AAAf,KAAnB;AACA,SAAKO,MAAL,GAAc,IAAd;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,yBAAL,GAAiC,CAAC,CAAlC;AACA,SAAKC,0BAAL,GAAkC,CAAC,CAAnC;AACA,SAAKC,SAAL,GAAiB,KAAKC,YAAL,EAAjB;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKrE,OAAL,CAAaK,WAAb,CAA0B,KAAKkD,qBAAL,IAA8B,KAAK3B,mBAApC,GAA2D,OAA3D,GAAqE,UAA9F;AACA,SAAK5B,OAAL,CAAasE,UAAb,CAAwB,MAAxB;AACA,SAAKtE,OAAL,CAAauE,aAAb,CAA2B,QAA3B;AACA,SAAKvE,OAAL,CAAawE,YAAb,CAA0B,UAA1B,EAAsC,KAAK7C,EAA3C;AACA,SAAK3B,OAAL,CAAayE,WAAb,CAAyB,KAAKP,SAA9B;AACH;;AACDzD,EAAAA,sBAAsB,CAACC,CAAD,EAAI;AACtB,UAAMyC,OAAO,GAAG,KAAKzB,QAAL,CAAc0B,aAAd,CAA4BD,OAA5C;AACA,SAAKS,WAAL,GAAmBT,OAAO,CAACG,GAAR,CAAY;AAAG;AAAf,KAAnB;;AACA,QAAI5C,CAAC,CAACgE,UAAF,CAAa;AAAI;AAAjB,KAAJ,EAAwC;AACpC,YAAMrB,UAAU,GAAGF,OAAO,CAACG,GAAR,CAAY;AAAI;AAAhB,OAAnB;AACA,WAAKI,YAAL,GAAoBL,UAAU,CAACM,WAA/B;AACA,WAAKH,aAAL,GAAqBH,UAAU,CAACI,YAAhC;AACA,WAAKS,SAAL,GAAiB,KAAKC,YAAL,EAAjB;AACH;AACJ;;AACDnD,EAAAA,oBAAoB,CAACN,CAAD,EAAI;AACpB,SAAKiE,YAAL,CAAkB,KAAKd,MAAvB;AACH;;AACDc,EAAAA,YAAY,CAAC1C,KAAD,EAAQ;AAChB,SAAK4B,MAAL,GAAc5B,KAAd;AACA,SAAK6B,UAAL,GAAkB,IAAlB;;AACA,QAAI,KAAKD,MAAT,EAAiB;AACb;AACA,YAAMe,eAAe,GAAG,KAAKlD,QAAL,CAAcmD,KAAd,CAAoBC,kBAApB,CAAuC,KAAKjB,MAA5C,CAAxB;;AACA,UAAI,KAAKnC,QAAL,CAAcmD,KAAd,CAAoBE,oBAApB,CAAyCC,sBAAzC,CAAgEJ,eAAe,CAACK,gBAAhB,EAAhE,KAAuG,KAAKvD,QAAL,CAAcmD,KAAd,CAAoBE,oBAApB,CAAyCC,sBAAzC,CAAgEJ,eAAe,CAACM,cAAhB,EAAhE,CAA3G,EAA8M;AAC1M,aAAKpB,UAAL,GAAkB,KAAKpC,QAAL,CAAcmD,KAAd,CAAoBE,oBAApB,CAAyCI,4BAAzC,CAAsEP,eAAtE,CAAlB;AACH;AACJ;AACJ;;AACDT,EAAAA,YAAY,GAAG;AACX,WAAQ,KAAKvC,mBAAL,GACFwD,MAAM,CAACC,UAAP,IAAqBpF,QAAQ,CAACqF,eAAT,CAAyBC,WAA9C,IAA6DtF,QAAQ,CAACuF,IAAT,CAAcD,WADzE,GAEF,KAAK/B,aAFX;AAGH;;AACDnD,EAAAA,WAAW,CAAC4B,KAAD,EAAQC,UAAR,EAAoB;AAC3B,SAAKyC,YAAL,CAAkB1C,KAAlB;;AACA,SAAK8B,WAAL,GAAmB7B,UAAnB;;AACA,QAAI,KAAK4B,UAAL,IAAmB,KAAKC,WAAxB,IAAuC,KAAKA,WAAL,CAAiB0B,MAAjB,GAA0B,CAArE,EAAwE;AACpE;AACA;AACA;AACA;AACA,WAAKzF,OAAL,CAAasE,UAAb,CAAwB,OAAxB;AACH,KAND,MAOK;AACD,WAAKtE,OAAL,CAAasE,UAAb,CAAwB,MAAxB;AACH;;AACD,SAAKN,yBAAL,GAAiC,CAAC,CAAlC;AACA,SAAKC,0BAAL,GAAkC,CAAC,CAAnC;AACH;;AACDyB,EAAAA,oBAAoB,CAACC,OAAD,EAAUC,UAAV,EAAsBC,KAAtB,EAA6BC,MAA7B,EAAqChD,GAArC,EAA0C;AAC1D;AACA;AACA,UAAMiD,YAAY,GAAGJ,OAAO,CAACpG,GAA7B;AACA,UAAMyG,eAAe,GAAGD,YAAxB,CAJ0D,CAK1D;;AACA,UAAME,YAAY,GAAGL,UAAU,CAACrG,GAAX,GAAiB,KAAKqE,WAA3C;AACA,UAAMsC,eAAe,GAAGpD,GAAG,CAACqD,cAAJ,GAAqBF,YAA7C;AACA,UAAMG,QAAQ,GAAGL,YAAY,GAAGD,MAAhC;AACA,UAAMO,SAAS,GAAIL,eAAe,IAAIF,MAAtC;AACA,UAAMQ,QAAQ,GAAGL,YAAjB;AACA,UAAMM,SAAS,GAAIL,eAAe,IAAIJ,MAAtC,CAX0D,CAY1D;;AACA,QAAIU,eAAe,GAAGb,OAAO,CAACnG,IAA9B;AACA,QAAIiH,eAAe,GAAGb,UAAU,CAACpG,IAAjC;;AACA,QAAIgH,eAAe,GAAGX,KAAlB,GAA0B/C,GAAG,CAAC4D,UAAJ,GAAiB5D,GAAG,CAAC6D,aAAnD,EAAkE;AAC9DH,MAAAA,eAAe,GAAG1D,GAAG,CAAC4D,UAAJ,GAAiB5D,GAAG,CAAC6D,aAArB,GAAqCd,KAAvD;AACH;;AACD,QAAIY,eAAe,GAAGZ,KAAlB,GAA0B/C,GAAG,CAAC4D,UAAJ,GAAiB5D,GAAG,CAAC6D,aAAnD,EAAkE;AAC9DF,MAAAA,eAAe,GAAG3D,GAAG,CAAC4D,UAAJ,GAAiB5D,GAAG,CAAC6D,aAArB,GAAqCd,KAAvD;AACH;;AACD,QAAIW,eAAe,GAAG1D,GAAG,CAAC4D,UAA1B,EAAsC;AAClCF,MAAAA,eAAe,GAAG1D,GAAG,CAAC4D,UAAtB;AACH;;AACD,QAAID,eAAe,GAAG3D,GAAG,CAAC4D,UAA1B,EAAsC;AAClCD,MAAAA,eAAe,GAAG3D,GAAG,CAAC4D,UAAtB;AACH;;AACD,WAAO;AACHL,MAAAA,SAAS,EAAEA,SADR;AAEHD,MAAAA,QAAQ,EAAEA,QAFP;AAGHQ,MAAAA,SAAS,EAAEJ,eAHR;AAIHD,MAAAA,SAAS,EAAEA,SAJR;AAKHD,MAAAA,QAAQ,EAAEA,QALP;AAMHO,MAAAA,SAAS,EAAEJ;AANR,KAAP;AAQH;;AACDK,EAAAA,8BAA8B,CAACC,UAAD,EAAaC,eAAb,EAA8BxH,IAA9B,EAAoCqG,KAApC,EAA2C;AACrE;AACA,UAAMoB,SAAS,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,eAAe,CAACxH,IAAhB,GAAuBqG,KAAnC,CAAlB;AACA,UAAMuB,SAAS,GAAGF,IAAI,CAACG,GAAL,CAASL,eAAe,CAACxH,IAAhB,GAAuBwH,eAAe,CAACnB,KAAvC,GAA+CA,KAAxD,EAA+DkB,UAAU,CAAClB,KAA1E,CAAlB;AACA,QAAIyB,YAAY,GAAGN,eAAe,CAACxH,IAAhB,GAAuBA,IAAvB,GAA8BP,GAAG,CAACsI,cAAJ,CAAmBC,OAApE;;AACA,QAAIF,YAAY,GAAGzB,KAAf,GAAuBuB,SAA3B,EAAsC;AAClC,YAAMK,KAAK,GAAGH,YAAY,IAAIF,SAAS,GAAGvB,KAAhB,CAA1B;AACAyB,MAAAA,YAAY,IAAIG,KAAhB;AACAjI,MAAAA,IAAI,IAAIiI,KAAR;AACH;;AACD,QAAIH,YAAY,GAAGL,SAAnB,EAA8B;AAC1B,YAAMQ,KAAK,GAAGH,YAAY,GAAGL,SAA7B;AACAK,MAAAA,YAAY,IAAIG,KAAhB;AACAjI,MAAAA,IAAI,IAAIiI,KAAR;AACH;;AACD,WAAO,CAACjI,IAAD,EAAO8H,YAAP,CAAP;AACH;;AACDI,EAAAA,gBAAgB,CAAC/B,OAAD,EAAUC,UAAV,EAAsBC,KAAtB,EAA6BC,MAA7B,EAAqChD,GAArC,EAA0C;AACtD,UAAMsD,QAAQ,GAAGT,OAAO,CAACpG,GAAR,GAAcuG,MAA/B;AACA,UAAMQ,QAAQ,GAAGV,UAAU,CAACrG,GAAX,GAAiB,KAAKqE,WAAvC;AACA,UAAMoD,eAAe,GAAG/H,GAAG,CAAC0I,sBAAJ,CAA2B,KAAK7H,YAAL,CAAkBE,OAA7C,CAAxB;AACA,UAAM4H,gBAAgB,GAAGZ,eAAe,CAACzH,GAAhB,GAAsB6G,QAAtB,GAAiCnH,GAAG,CAACsI,cAAJ,CAAmBM,OAA7E;AACA,UAAMC,gBAAgB,GAAGd,eAAe,CAACzH,GAAhB,GAAsB+G,QAAtB,GAAiCrH,GAAG,CAACsI,cAAJ,CAAmBM,OAA7E;AACA,UAAMd,UAAU,GAAG9H,GAAG,CAAC8I,aAAJ,CAAkB9H,QAAQ,CAACuF,IAA3B,CAAnB;;AACA,UAAM,CAACoB,SAAD,EAAYoB,iBAAZ,IAAiC,KAAKlB,8BAAL,CAAoCC,UAApC,EAAgDC,eAAhD,EAAiErB,OAAO,CAACnG,IAAR,GAAesD,GAAG,CAAC4D,UAAnB,GAAgC,KAAKhD,YAAtG,EAAoHmC,KAApH,CAAvC;;AACA,UAAM,CAACgB,SAAD,EAAYoB,iBAAZ,IAAiC,KAAKnB,8BAAL,CAAoCC,UAApC,EAAgDC,eAAhD,EAAiEpB,UAAU,CAACpG,IAAX,GAAkBsD,GAAG,CAAC4D,UAAtB,GAAmC,KAAKhD,YAAzG,EAAuHmC,KAAvH,CAAvC,CARsD,CAStD;;;AACA,UAAMqC,WAAW,GAAG,EAApB;AACA,UAAMC,cAAc,GAAG,EAAvB;AACA,UAAM9B,SAAS,GAAIuB,gBAAgB,IAAIM,WAAvC;AACA,UAAM3B,SAAS,GAAIuB,gBAAgB,GAAGhC,MAAnB,IAA6BiB,UAAU,CAACjB,MAAX,GAAoBqC,cAApE;;AACA,QAAI,KAAK5E,qBAAT,EAAgC;AAC5B,aAAO;AACH8C,QAAAA,SADG;AAEHD,QAAAA,QAAQ,EAAEc,IAAI,CAACC,GAAL,CAASS,gBAAT,EAA2BM,WAA3B,CAFP;AAGHtB,QAAAA,SAAS,EAAEoB,iBAHR;AAIHzB,QAAAA,SAJG;AAKHD,QAAAA,QAAQ,EAAEwB,gBALP;AAMHjB,QAAAA,SAAS,EAAEoB;AANR,OAAP;AAQH;;AACD,WAAO;AACH5B,MAAAA,SADG;AAEHD,MAAAA,QAAQ,EAAEA,QAFP;AAGHQ,MAAAA,SAHG;AAIHL,MAAAA,SAJG;AAKHD,MAAAA,QALG;AAMHO,MAAAA;AANG,KAAP;AAQH;;AACDuB,EAAAA,8CAA8C,CAACzC,OAAD,EAAU;AACpD,WAAO,IAAItG,UAAJ,CAAesG,OAAO,CAACpG,GAAvB,EAA4BoG,OAAO,CAACnG,IAAR,GAAe,KAAKkE,YAAhD,CAAP;AACH;AACD;AACJ;AACA;;;AACI2E,EAAAA,oBAAoB,CAACvF,GAAD,EAAM;AACtB,QAAI,CAAC,KAAKgB,UAAV,EAAsB;AAClB,aAAO,CAAC,IAAD,EAAO,IAAP,CAAP;AACH;;AACD,UAAMwE,qBAAqB,GAAGxF,GAAG,CAACyF,0BAAJ,CAA+B,KAAKzE,UAApC,EAAgD,KAAhD,CAA9B;;AACA,QAAI,CAACwE,qBAAD,IAA0BA,qBAAqB,CAAC7C,MAAtB,KAAiC,CAA/D,EAAkE;AAC9D,aAAO,CAAC,IAAD,EAAO,IAAP,CAAP;AACH;;AACD,QAAI+C,SAAS,GAAGF,qBAAqB,CAAC,CAAD,CAArC;AACA,QAAIG,QAAQ,GAAGH,qBAAqB,CAAC,CAAD,CAApC;;AACA,SAAK,MAAMI,oBAAX,IAAmCJ,qBAAnC,EAA0D;AACtD,UAAII,oBAAoB,CAACC,UAArB,GAAkCH,SAAS,CAACG,UAAhD,EAA4D;AACxDH,QAAAA,SAAS,GAAGE,oBAAZ;AACH;;AACD,UAAIA,oBAAoB,CAACC,UAArB,GAAkCF,QAAQ,CAACE,UAA/C,EAA2D;AACvDF,QAAAA,QAAQ,GAAGC,oBAAX;AACH;AACJ;;AACD,QAAIE,gBAAgB,GAAG;AAAW;AAAlC,KAlBsB,CAkB0C;;AAChE,SAAK,MAAMC,YAAX,IAA2BL,SAAS,CAACM,MAArC,EAA6C;AACzC,UAAID,YAAY,CAACrJ,IAAb,GAAoBoJ,gBAAxB,EAA0C;AACtCA,QAAAA,gBAAgB,GAAGC,YAAY,CAACrJ,IAAhC;AACH;AACJ;;AACD,QAAIuJ,eAAe,GAAG;AAAW;AAAjC,KAxBsB,CAwByC;;AAC/D,SAAK,MAAMF,YAAX,IAA2BJ,QAAQ,CAACK,MAApC,EAA4C;AACxC,UAAID,YAAY,CAACrJ,IAAb,GAAoBuJ,eAAxB,EAAyC;AACrCA,QAAAA,eAAe,GAAGF,YAAY,CAACrJ,IAA/B;AACH;AACJ;;AACD,UAAMwJ,cAAc,GAAGlG,GAAG,CAACmG,8BAAJ,CAAmCT,SAAS,CAACG,UAA7C,IAA2D7F,GAAG,CAACoG,SAAtF;AACA,UAAMvD,OAAO,GAAG,IAAItG,UAAJ,CAAe2J,cAAf,EAA+BJ,gBAA/B,CAAhB;AACA,UAAMO,gBAAgB,GAAGrG,GAAG,CAACmG,8BAAJ,CAAmCR,QAAQ,CAACE,UAA5C,IAA0D7F,GAAG,CAACoG,SAAvF;AACA,UAAMtD,UAAU,GAAG,IAAIvG,UAAJ,CAAe8J,gBAAf,EAAiCJ,eAAjC,CAAnB;AACA,WAAO,CAACpD,OAAD,EAAUC,UAAV,CAAP;AACH;;AACDwD,EAAAA,oBAAoB,CAACtG,GAAD,EAAM;AACtB,QAAI,CAAC,KAAKiB,WAAN,IAAqB,KAAKA,WAAL,CAAiB0B,MAAjB,KAA4B,CAArD,EAAwD;AACpD,aAAO,IAAP;AACH;;AACD,UAAM,CAACE,OAAD,EAAUC,UAAV,IAAwB,KAAKyC,oBAAL,CAA0BvF,GAA1B,CAA9B;;AACA,QAAI,CAAC6C,OAAD,IAAY,CAACC,UAAjB,EAA6B;AACzB,aAAO,IAAP;AACH;;AACD,QAAI,KAAK5B,yBAAL,KAAmC,CAAC,CAApC,IAAyC,KAAKC,0BAAL,KAAoC,CAAC,CAAlF,EAAqF;AACjF,UAAIoF,mBAAmB,GAAG,IAA1B;;AACA,UAAI,OAAO,KAAKpG,OAAL,CAAaqG,YAApB,KAAqC,UAAzC,EAAqD;AACjDD,QAAAA,mBAAmB,GAAGE,UAAU,CAAC,KAAKtG,OAAL,CAAaqG,YAAd,EAA4B,KAAKrG,OAAjC,CAAhC;AACH;;AACD,UAAIoG,mBAAJ,EAAyB;AACrB,aAAKrF,yBAAL,GAAiCqF,mBAAmB,CAACxD,KAArD;AACA,aAAK5B,0BAAL,GAAkCoF,mBAAmB,CAACvD,MAAtD;AACH,OAHD,MAIK;AACD,cAAM9F,OAAO,GAAG,KAAKA,OAAL,CAAaA,OAA7B;AACA,aAAKgE,yBAAL,GAAiChE,OAAO,CAACuF,WAAzC;AACA,aAAKtB,0BAAL,GAAkCjE,OAAO,CAACwJ,YAA1C;AACH;AACJ;;AACD,QAAIC,SAAJ;;AACA,QAAI,KAAK7H,mBAAT,EAA8B;AAC1B6H,MAAAA,SAAS,GAAG,KAAK/B,gBAAL,CAAsB/B,OAAtB,EAA+BC,UAA/B,EAA2C,KAAK5B,yBAAhD,EAA2E,KAAKC,0BAAhF,EAA4GnB,GAA5G,CAAZ;AACH,KAFD,MAGK;AACD2G,MAAAA,SAAS,GAAG,KAAK/D,oBAAL,CAA0BC,OAA1B,EAAmCC,UAAnC,EAA+C,KAAK5B,yBAApD,EAA+E,KAAKC,0BAApF,EAAgHnB,GAAhH,CAAZ;AACH,KA7BqB,CA8BtB;;;AACA,SAAK,IAAI4G,IAAI,GAAG,CAAhB,EAAmBA,IAAI,IAAI,CAA3B,EAA8BA,IAAI,EAAlC,EAAsC;AAClC,WAAK,MAAMC,IAAX,IAAmB,KAAK5F,WAAxB,EAAqC;AACjC;AACA,YAAI4F,IAAI,KAAK;AAAE;AAAf,UAA4B;AACxB,cAAI,CAACF,SAAL,EAAgB;AACZ;AACA,mBAAO,IAAP;AACH;;AACD,cAAIC,IAAI,KAAK,CAAT,IAAcD,SAAS,CAACpD,SAA5B,EAAuC;AACnC,mBAAO;AAAEuD,cAAAA,UAAU,EAAE,IAAIvK,UAAJ,CAAeoK,SAAS,CAACrD,QAAzB,EAAmCqD,SAAS,CAAC7C,SAA7C,CAAd;AAAuEiD,cAAAA,QAAQ,EAAE;AAAE;;AAAnF,aAAP;AACH;AACJ,SARD,MASK,IAAIF,IAAI,KAAK;AAAE;AAAf,UAA4B;AAC7B,cAAI,CAACF,SAAL,EAAgB;AACZ;AACA,mBAAO,IAAP;AACH;;AACD,cAAIC,IAAI,KAAK,CAAT,IAAcD,SAAS,CAAClD,SAA5B,EAAuC;AACnC,mBAAO;AAAEqD,cAAAA,UAAU,EAAE,IAAIvK,UAAJ,CAAeoK,SAAS,CAACnD,QAAzB,EAAmCmD,SAAS,CAAC5C,SAA7C,CAAd;AAAuEgD,cAAAA,QAAQ,EAAE;AAAE;;AAAnF,aAAP;AACH;AACJ,SARI,MASA;AACD,cAAI,KAAKjI,mBAAT,EAA8B;AAC1B,mBAAO;AAAEgI,cAAAA,UAAU,EAAE,KAAKxB,8CAAL,CAAoDzC,OAApD,CAAd;AAA4EkE,cAAAA,QAAQ,EAAE;AAAE;;AAAxF,aAAP;AACH,WAFD,MAGK;AACD,mBAAO;AAAED,cAAAA,UAAU,EAAEjE,OAAd;AAAuBkE,cAAAA,QAAQ,EAAE;AAAE;;AAAnC,aAAP;AACH;AACJ;AACJ;AACJ;;AACD,WAAO,IAAP;AACH;AACD;AACJ;AACA;;;AACIlH,EAAAA,cAAc,CAACC,YAAD,EAAe;AACzB,QAAI,CAAC,KAAKkB,UAAN,IAAoB,CAAC,KAAKC,WAA9B,EAA2C;AACvC;AACH;;AACD,QAAI,KAAKD,UAAL,CAAgBgG,aAAhB,GAAgClH,YAAY,CAACmH,eAA7C,IAAgE,KAAKjG,UAAL,CAAgBiG,eAAhB,GAAkCnH,YAAY,CAACkH,aAAnH,EAAkI;AAC9H;AACA;AACH;;AACD,SAAK9J,OAAL,CAAayE,WAAb,CAAyB,KAAKP,SAA9B;AACH;;AACDrB,EAAAA,aAAa,CAACC,GAAD,EAAM;AACf,SAAKuB,WAAL,GAAmB,KAAK+E,oBAAL,CAA0BtG,GAA1B,CAAnB;AACH;;AACDC,EAAAA,MAAM,CAACD,GAAD,EAAM;AACR,QAAI,CAAC,KAAKuB,WAAV,EAAuB;AACnB;AACA,UAAI,KAAKD,UAAT,EAAqB;AACjB,aAAKpE,OAAL,CAAawC,eAAb,CAA6B,+BAA7B;AACA,aAAK4B,UAAL,GAAkB,KAAlB;AACA,aAAKpE,OAAL,CAAauE,aAAb,CAA2B,QAA3B;AACH;;AACD,UAAI,OAAO,KAAKtB,OAAL,CAAa+G,WAApB,KAAoC,UAAxC,EAAoD;AAChDT,QAAAA,UAAU,CAAC,KAAKtG,OAAL,CAAa+G,WAAd,EAA2B,KAAK/G,OAAhC,EAAyC,IAAzC,CAAV;AACH;;AACD;AACH,KAZO,CAaR;;;AACA,QAAI,KAAKrB,mBAAT,EAA8B;AAC1B,WAAK5B,OAAL,CAAaM,MAAb,CAAoB,KAAK+D,WAAL,CAAiBuF,UAAjB,CAA4BrK,GAAhD;AACA,WAAKS,OAAL,CAAaiK,OAAb,CAAqB,KAAK5F,WAAL,CAAiBuF,UAAjB,CAA4BpK,IAAjD;AACH,KAHD,MAIK;AACD,WAAKQ,OAAL,CAAaM,MAAb,CAAoB,KAAK+D,WAAL,CAAiBuF,UAAjB,CAA4BrK,GAA5B,GAAkCuD,GAAG,CAACoG,SAAtC,GAAkDpG,GAAG,CAACoH,eAA1E;AACA,WAAKlK,OAAL,CAAaiK,OAAb,CAAqB,KAAK5F,WAAL,CAAiBuF,UAAjB,CAA4BpK,IAAjD;AACH;;AACD,QAAI,CAAC,KAAK4E,UAAV,EAAsB;AAClB,WAAKpE,OAAL,CAAauE,aAAb,CAA2B,SAA3B;AACA,WAAKvE,OAAL,CAAawE,YAAb,CAA0B,+BAA1B,EAA2D,MAA3D;AACA,WAAKJ,UAAL,GAAkB,IAAlB;AACH;;AACD,QAAI,OAAO,KAAKnB,OAAL,CAAa+G,WAApB,KAAoC,UAAxC,EAAoD;AAChDT,MAAAA,UAAU,CAAC,KAAKtG,OAAL,CAAa+G,WAAd,EAA2B,KAAK/G,OAAhC,EAAyC,KAAKoB,WAAL,CAAiBwF,QAA1D,CAAV;AACH;AACJ;;AAxTQ;;AA0Tb,SAASN,UAAT,CAAoBY,EAApB,EAAwBC,OAAxB,EAAiC,GAAGC,IAApC,EAA0C;AACtC,MAAI;AACA,WAAOF,EAAE,CAACG,IAAH,CAAQF,OAAR,EAAiB,GAAGC,IAApB,CAAP;AACH,GAFD,CAGA,OAAOE,EAAP,EAAW;AACP;AACA,WAAO,IAAP;AACH;AACJ","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nclass Coordinate {\n    constructor(top, left) {\n        this._coordinateBrand = undefined;\n        this.top = top;\n        this.left = left;\n    }\n}\nexport class ViewContentWidgets extends ViewPart {\n    constructor(context, viewDomNode) {\n        super(context);\n        this._viewDomNode = viewDomNode;\n        this._widgets = {};\n        this.domNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this.domNode, 1 /* ContentWidgets */);\n        this.domNode.setClassName('contentWidgets');\n        this.domNode.setPosition('absolute');\n        this.domNode.setTop(0);\n        this.overflowingContentWidgetsDomNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this.overflowingContentWidgetsDomNode, 2 /* OverflowingContentWidgets */);\n        this.overflowingContentWidgetsDomNode.setClassName('overflowingContentWidgets');\n    }\n    dispose() {\n        super.dispose();\n        this._widgets = {};\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].onConfigurationChanged(e);\n        }\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLineMappingChanged(e) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].onLineMappingChanged(e);\n        }\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return true;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // ---- end view event handlers\n    addWidget(_widget) {\n        const myWidget = new Widget(this._context, this._viewDomNode, _widget);\n        this._widgets[myWidget.id] = myWidget;\n        if (myWidget.allowEditorOverflow) {\n            this.overflowingContentWidgetsDomNode.appendChild(myWidget.domNode);\n        }\n        else {\n            this.domNode.appendChild(myWidget.domNode);\n        }\n        this.setShouldRender();\n    }\n    setWidgetPosition(widget, range, preference) {\n        const myWidget = this._widgets[widget.getId()];\n        myWidget.setPosition(range, preference);\n        this.setShouldRender();\n    }\n    removeWidget(widget) {\n        const widgetId = widget.getId();\n        if (this._widgets.hasOwnProperty(widgetId)) {\n            const myWidget = this._widgets[widgetId];\n            delete this._widgets[widgetId];\n            const domNode = myWidget.domNode.domNode;\n            domNode.parentNode.removeChild(domNode);\n            domNode.removeAttribute('monaco-visible-content-widget');\n            this.setShouldRender();\n        }\n    }\n    shouldSuppressMouseDownOnWidget(widgetId) {\n        if (this._widgets.hasOwnProperty(widgetId)) {\n            return this._widgets[widgetId].suppressMouseDown;\n        }\n        return false;\n    }\n    onBeforeRender(viewportData) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].onBeforeRender(viewportData);\n        }\n    }\n    prepareRender(ctx) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].prepareRender(ctx);\n        }\n    }\n    render(ctx) {\n        const keys = Object.keys(this._widgets);\n        for (const widgetId of keys) {\n            this._widgets[widgetId].render(ctx);\n        }\n    }\n}\nclass Widget {\n    constructor(context, viewDomNode, actual) {\n        this._context = context;\n        this._viewDomNode = viewDomNode;\n        this._actual = actual;\n        this.domNode = createFastDomNode(this._actual.getDomNode());\n        this.id = this._actual.getId();\n        this.allowEditorOverflow = this._actual.allowEditorOverflow || false;\n        this.suppressMouseDown = this._actual.suppressMouseDown || false;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(131 /* layoutInfo */);\n        this._fixedOverflowWidgets = options.get(36 /* fixedOverflowWidgets */);\n        this._contentWidth = layoutInfo.contentWidth;\n        this._contentLeft = layoutInfo.contentLeft;\n        this._lineHeight = options.get(59 /* lineHeight */);\n        this._range = null;\n        this._viewRange = null;\n        this._preference = [];\n        this._cachedDomNodeOffsetWidth = -1;\n        this._cachedDomNodeOffsetHeight = -1;\n        this._maxWidth = this._getMaxWidth();\n        this._isVisible = false;\n        this._renderData = null;\n        this.domNode.setPosition((this._fixedOverflowWidgets && this.allowEditorOverflow) ? 'fixed' : 'absolute');\n        this.domNode.setDisplay('none');\n        this.domNode.setVisibility('hidden');\n        this.domNode.setAttribute('widgetId', this.id);\n        this.domNode.setMaxWidth(this._maxWidth);\n    }\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(59 /* lineHeight */);\n        if (e.hasChanged(131 /* layoutInfo */)) {\n            const layoutInfo = options.get(131 /* layoutInfo */);\n            this._contentLeft = layoutInfo.contentLeft;\n            this._contentWidth = layoutInfo.contentWidth;\n            this._maxWidth = this._getMaxWidth();\n        }\n    }\n    onLineMappingChanged(e) {\n        this._setPosition(this._range);\n    }\n    _setPosition(range) {\n        this._range = range;\n        this._viewRange = null;\n        if (this._range) {\n            // Do not trust that widgets give a valid position\n            const validModelRange = this._context.model.validateModelRange(this._range);\n            if (this._context.model.coordinatesConverter.modelPositionIsVisible(validModelRange.getStartPosition()) || this._context.model.coordinatesConverter.modelPositionIsVisible(validModelRange.getEndPosition())) {\n                this._viewRange = this._context.model.coordinatesConverter.convertModelRangeToViewRange(validModelRange);\n            }\n        }\n    }\n    _getMaxWidth() {\n        return (this.allowEditorOverflow\n            ? window.innerWidth || document.documentElement.offsetWidth || document.body.offsetWidth\n            : this._contentWidth);\n    }\n    setPosition(range, preference) {\n        this._setPosition(range);\n        this._preference = preference;\n        if (this._viewRange && this._preference && this._preference.length > 0) {\n            // this content widget would like to be visible if possible\n            // we change it from `display:none` to `display:block` even if it\n            // might be outside the viewport such that we can measure its size\n            // in `prepareRender`\n            this.domNode.setDisplay('block');\n        }\n        else {\n            this.domNode.setDisplay('none');\n        }\n        this._cachedDomNodeOffsetWidth = -1;\n        this._cachedDomNodeOffsetHeight = -1;\n    }\n    _layoutBoxInViewport(topLeft, bottomLeft, width, height, ctx) {\n        // Our visible box is split horizontally by the current line => 2 boxes\n        // a) the box above the line\n        const aboveLineTop = topLeft.top;\n        const heightAboveLine = aboveLineTop;\n        // b) the box under the line\n        const underLineTop = bottomLeft.top + this._lineHeight;\n        const heightUnderLine = ctx.viewportHeight - underLineTop;\n        const aboveTop = aboveLineTop - height;\n        const fitsAbove = (heightAboveLine >= height);\n        const belowTop = underLineTop;\n        const fitsBelow = (heightUnderLine >= height);\n        // And its left\n        let actualAboveLeft = topLeft.left;\n        let actualBelowLeft = bottomLeft.left;\n        if (actualAboveLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n            actualAboveLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n        }\n        if (actualBelowLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n            actualBelowLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n        }\n        if (actualAboveLeft < ctx.scrollLeft) {\n            actualAboveLeft = ctx.scrollLeft;\n        }\n        if (actualBelowLeft < ctx.scrollLeft) {\n            actualBelowLeft = ctx.scrollLeft;\n        }\n        return {\n            fitsAbove: fitsAbove,\n            aboveTop: aboveTop,\n            aboveLeft: actualAboveLeft,\n            fitsBelow: fitsBelow,\n            belowTop: belowTop,\n            belowLeft: actualBelowLeft,\n        };\n    }\n    _layoutHorizontalSegmentInPage(windowSize, domNodePosition, left, width) {\n        // Initially, the limits are defined as the dom node limits\n        const MIN_LIMIT = Math.max(0, domNodePosition.left - width);\n        const MAX_LIMIT = Math.min(domNodePosition.left + domNodePosition.width + width, windowSize.width);\n        let absoluteLeft = domNodePosition.left + left - dom.StandardWindow.scrollX;\n        if (absoluteLeft + width > MAX_LIMIT) {\n            const delta = absoluteLeft - (MAX_LIMIT - width);\n            absoluteLeft -= delta;\n            left -= delta;\n        }\n        if (absoluteLeft < MIN_LIMIT) {\n            const delta = absoluteLeft - MIN_LIMIT;\n            absoluteLeft -= delta;\n            left -= delta;\n        }\n        return [left, absoluteLeft];\n    }\n    _layoutBoxInPage(topLeft, bottomLeft, width, height, ctx) {\n        const aboveTop = topLeft.top - height;\n        const belowTop = bottomLeft.top + this._lineHeight;\n        const domNodePosition = dom.getDomNodePagePosition(this._viewDomNode.domNode);\n        const absoluteAboveTop = domNodePosition.top + aboveTop - dom.StandardWindow.scrollY;\n        const absoluteBelowTop = domNodePosition.top + belowTop - dom.StandardWindow.scrollY;\n        const windowSize = dom.getClientArea(document.body);\n        const [aboveLeft, absoluteAboveLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, topLeft.left - ctx.scrollLeft + this._contentLeft, width);\n        const [belowLeft, absoluteBelowLeft] = this._layoutHorizontalSegmentInPage(windowSize, domNodePosition, bottomLeft.left - ctx.scrollLeft + this._contentLeft, width);\n        // Leave some clearance to the top/bottom\n        const TOP_PADDING = 22;\n        const BOTTOM_PADDING = 22;\n        const fitsAbove = (absoluteAboveTop >= TOP_PADDING);\n        const fitsBelow = (absoluteBelowTop + height <= windowSize.height - BOTTOM_PADDING);\n        if (this._fixedOverflowWidgets) {\n            return {\n                fitsAbove,\n                aboveTop: Math.max(absoluteAboveTop, TOP_PADDING),\n                aboveLeft: absoluteAboveLeft,\n                fitsBelow,\n                belowTop: absoluteBelowTop,\n                belowLeft: absoluteBelowLeft\n            };\n        }\n        return {\n            fitsAbove,\n            aboveTop: aboveTop,\n            aboveLeft,\n            fitsBelow,\n            belowTop,\n            belowLeft\n        };\n    }\n    _prepareRenderWidgetAtExactPositionOverflowing(topLeft) {\n        return new Coordinate(topLeft.top, topLeft.left + this._contentLeft);\n    }\n    /**\n     * Compute `this._topLeft`\n     */\n    _getTopAndBottomLeft(ctx) {\n        if (!this._viewRange) {\n            return [null, null];\n        }\n        const visibleRangesForRange = ctx.linesVisibleRangesForRange(this._viewRange, false);\n        if (!visibleRangesForRange || visibleRangesForRange.length === 0) {\n            return [null, null];\n        }\n        let firstLine = visibleRangesForRange[0];\n        let lastLine = visibleRangesForRange[0];\n        for (const visibleRangesForLine of visibleRangesForRange) {\n            if (visibleRangesForLine.lineNumber < firstLine.lineNumber) {\n                firstLine = visibleRangesForLine;\n            }\n            if (visibleRangesForLine.lineNumber > lastLine.lineNumber) {\n                lastLine = visibleRangesForLine;\n            }\n        }\n        let firstLineMinLeft = 1073741824 /* MAX_SAFE_SMALL_INTEGER */; //firstLine.Constants.MAX_SAFE_SMALL_INTEGER;\n        for (const visibleRange of firstLine.ranges) {\n            if (visibleRange.left < firstLineMinLeft) {\n                firstLineMinLeft = visibleRange.left;\n            }\n        }\n        let lastLineMinLeft = 1073741824 /* MAX_SAFE_SMALL_INTEGER */; //lastLine.Constants.MAX_SAFE_SMALL_INTEGER;\n        for (const visibleRange of lastLine.ranges) {\n            if (visibleRange.left < lastLineMinLeft) {\n                lastLineMinLeft = visibleRange.left;\n            }\n        }\n        const topForPosition = ctx.getVerticalOffsetForLineNumber(firstLine.lineNumber) - ctx.scrollTop;\n        const topLeft = new Coordinate(topForPosition, firstLineMinLeft);\n        const topForBottomLine = ctx.getVerticalOffsetForLineNumber(lastLine.lineNumber) - ctx.scrollTop;\n        const bottomLeft = new Coordinate(topForBottomLine, lastLineMinLeft);\n        return [topLeft, bottomLeft];\n    }\n    _prepareRenderWidget(ctx) {\n        if (!this._preference || this._preference.length === 0) {\n            return null;\n        }\n        const [topLeft, bottomLeft] = this._getTopAndBottomLeft(ctx);\n        if (!topLeft || !bottomLeft) {\n            return null;\n        }\n        if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {\n            let preferredDimensions = null;\n            if (typeof this._actual.beforeRender === 'function') {\n                preferredDimensions = safeInvoke(this._actual.beforeRender, this._actual);\n            }\n            if (preferredDimensions) {\n                this._cachedDomNodeOffsetWidth = preferredDimensions.width;\n                this._cachedDomNodeOffsetHeight = preferredDimensions.height;\n            }\n            else {\n                const domNode = this.domNode.domNode;\n                this._cachedDomNodeOffsetWidth = domNode.offsetWidth;\n                this._cachedDomNodeOffsetHeight = domNode.offsetHeight;\n            }\n        }\n        let placement;\n        if (this.allowEditorOverflow) {\n            placement = this._layoutBoxInPage(topLeft, bottomLeft, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, ctx);\n        }\n        else {\n            placement = this._layoutBoxInViewport(topLeft, bottomLeft, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, ctx);\n        }\n        // Do two passes, first for perfect fit, second picks first option\n        for (let pass = 1; pass <= 2; pass++) {\n            for (const pref of this._preference) {\n                // placement\n                if (pref === 1 /* ABOVE */) {\n                    if (!placement) {\n                        // Widget outside of viewport\n                        return null;\n                    }\n                    if (pass === 2 || placement.fitsAbove) {\n                        return { coordinate: new Coordinate(placement.aboveTop, placement.aboveLeft), position: 1 /* ABOVE */ };\n                    }\n                }\n                else if (pref === 2 /* BELOW */) {\n                    if (!placement) {\n                        // Widget outside of viewport\n                        return null;\n                    }\n                    if (pass === 2 || placement.fitsBelow) {\n                        return { coordinate: new Coordinate(placement.belowTop, placement.belowLeft), position: 2 /* BELOW */ };\n                    }\n                }\n                else {\n                    if (this.allowEditorOverflow) {\n                        return { coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(topLeft), position: 0 /* EXACT */ };\n                    }\n                    else {\n                        return { coordinate: topLeft, position: 0 /* EXACT */ };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.\n     */\n    onBeforeRender(viewportData) {\n        if (!this._viewRange || !this._preference) {\n            return;\n        }\n        if (this._viewRange.endLineNumber < viewportData.startLineNumber || this._viewRange.startLineNumber > viewportData.endLineNumber) {\n            // Outside of viewport\n            return;\n        }\n        this.domNode.setMaxWidth(this._maxWidth);\n    }\n    prepareRender(ctx) {\n        this._renderData = this._prepareRenderWidget(ctx);\n    }\n    render(ctx) {\n        if (!this._renderData) {\n            // This widget should be invisible\n            if (this._isVisible) {\n                this.domNode.removeAttribute('monaco-visible-content-widget');\n                this._isVisible = false;\n                this.domNode.setVisibility('hidden');\n            }\n            if (typeof this._actual.afterRender === 'function') {\n                safeInvoke(this._actual.afterRender, this._actual, null);\n            }\n            return;\n        }\n        // This widget should be visible\n        if (this.allowEditorOverflow) {\n            this.domNode.setTop(this._renderData.coordinate.top);\n            this.domNode.setLeft(this._renderData.coordinate.left);\n        }\n        else {\n            this.domNode.setTop(this._renderData.coordinate.top + ctx.scrollTop - ctx.bigNumbersDelta);\n            this.domNode.setLeft(this._renderData.coordinate.left);\n        }\n        if (!this._isVisible) {\n            this.domNode.setVisibility('inherit');\n            this.domNode.setAttribute('monaco-visible-content-widget', 'true');\n            this._isVisible = true;\n        }\n        if (typeof this._actual.afterRender === 'function') {\n            safeInvoke(this._actual.afterRender, this._actual, this._renderData.position);\n        }\n    }\n}\nfunction safeInvoke(fn, thisArg, ...args) {\n    try {\n        return fn.call(thisArg, ...args);\n    }\n    catch (_a) {\n        // ignore\n        return null;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}