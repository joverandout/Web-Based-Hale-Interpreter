{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as paths from './path.js';\nimport { isWindows } from './platform.js';\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret, _strict) {\n  // scheme, must be set\n  if (!ret.scheme && _strict) {\n    throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n  } // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n  // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\n\n  if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n    throw new Error('[UriError]: Scheme contains illegal characters.');\n  } // path, http://tools.ietf.org/html/rfc3986#section-3.3\n  // If a URI contains an authority component, then the path component\n  // must either be empty or begin with a slash (\"/\") character.  If a URI\n  // does not contain an authority component, then the path cannot begin\n  // with two slash characters (\"//\").\n\n\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n      }\n    }\n  }\n} // for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\n\n\nfunction _schemeFix(scheme, _strict) {\n  if (!scheme && !_strict) {\n    return 'file';\n  }\n\n  return scheme;\n} // implements a bit of https://tools.ietf.org/html/rfc3986#section-5\n\n\nfunction _referenceResolution(scheme, path) {\n  // the slash-character is our 'default base' as we don't\n  // support constructing URIs relative to other URIs. This\n  // also means that we alter and potentially break paths.\n  // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n  switch (scheme) {\n    case 'https':\n    case 'http':\n    case 'file':\n      if (!path) {\n        path = _slash;\n      } else if (path[0] !== _slash) {\n        path = _slash + path;\n      }\n\n      break;\n  }\n\n  return path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\n\nexport class URI {\n  /**\n   * @internal\n   */\n  constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n    if (typeof schemeOrData === 'object') {\n      this.scheme = schemeOrData.scheme || _empty;\n      this.authority = schemeOrData.authority || _empty;\n      this.path = schemeOrData.path || _empty;\n      this.query = schemeOrData.query || _empty;\n      this.fragment = schemeOrData.fragment || _empty; // no validation because it's this URI\n      // that creates uri components.\n      // _validateUri(this);\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict);\n      this.authority = authority || _empty;\n      this.path = _referenceResolution(this.scheme, path || _empty);\n      this.query = query || _empty;\n      this.fragment = fragment || _empty;\n\n      _validateUri(this, _strict);\n    }\n  }\n\n  static isUri(thing) {\n    if (thing instanceof URI) {\n      return true;\n    }\n\n    if (!thing) {\n      return false;\n    }\n\n    return typeof thing.authority === 'string' && typeof thing.fragment === 'string' && typeof thing.path === 'string' && typeof thing.query === 'string' && typeof thing.scheme === 'string' && typeof thing.fsPath === 'string' && typeof thing.with === 'function' && typeof thing.toString === 'function';\n  } // ---- filesystem path -----------------------\n\n  /**\n   * Returns a string representing the corresponding file system path of this URI.\n   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n   * platform specific path separator.\n   *\n   * * Will *not* validate the path for invalid characters and semantics.\n   * * Will *not* look at the scheme of this URI.\n   * * The result shall *not* be used for display purposes but for accessing a file on disk.\n   *\n   *\n   * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n   *\n   * ```ts\n      const u = URI.parse('file://server/c$/folder/file.txt')\n      u.authority === 'server'\n      u.path === '/shares/c$/file.txt'\n      u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n  ```\n   *\n   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n   * with URIs that represent files on disk (`file` scheme).\n   */\n\n\n  get fsPath() {\n    // if (this.scheme !== 'file') {\n    // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n    // }\n    return uriToFsPath(this, false);\n  } // ---- modify to new -------------------------\n\n\n  with(change) {\n    if (!change) {\n      return this;\n    }\n\n    let {\n      scheme,\n      authority,\n      path,\n      query,\n      fragment\n    } = change;\n\n    if (scheme === undefined) {\n      scheme = this.scheme;\n    } else if (scheme === null) {\n      scheme = _empty;\n    }\n\n    if (authority === undefined) {\n      authority = this.authority;\n    } else if (authority === null) {\n      authority = _empty;\n    }\n\n    if (path === undefined) {\n      path = this.path;\n    } else if (path === null) {\n      path = _empty;\n    }\n\n    if (query === undefined) {\n      query = this.query;\n    } else if (query === null) {\n      query = _empty;\n    }\n\n    if (fragment === undefined) {\n      fragment = this.fragment;\n    } else if (fragment === null) {\n      fragment = _empty;\n    }\n\n    if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {\n      return this;\n    }\n\n    return new Uri(scheme, authority, path, query, fragment);\n  } // ---- parse & validate ------------------------\n\n  /**\n   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n   * `file:///usr/home`, or `scheme:with/path`.\n   *\n   * @param value A string which represents an URI (see `URI#toString`).\n   */\n\n\n  static parse(value, _strict = false) {\n    const match = _regexp.exec(value);\n\n    if (!match) {\n      return new Uri(_empty, _empty, _empty, _empty, _empty);\n    }\n\n    return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n  }\n  /**\n   * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n   * `/usr/home`, or `\\\\server\\share\\some\\path`.\n   *\n   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n   * `URI.parse('file://' + path)` because the path might contain characters that are\n   * interpreted (# and ?). See the following sample:\n   * ```ts\n  const good = URI.file('/coding/c#/project1');\n  good.scheme === 'file';\n  good.path === '/coding/c#/project1';\n  good.fragment === '';\n  const bad = URI.parse('file://' + '/coding/c#/project1');\n  bad.scheme === 'file';\n  bad.path === '/coding/c'; // path is now broken\n  bad.fragment === '/project1';\n  ```\n   *\n   * @param path A file system path (see `URI#fsPath`)\n   */\n\n\n  static file(path) {\n    let authority = _empty; // normalize to fwd-slashes on windows,\n    // on other systems bwd-slashes are valid\n    // filename character, eg /f\\oo/ba\\r.txt\n\n    if (isWindows) {\n      path = path.replace(/\\\\/g, _slash);\n    } // check for authority as used in UNC shares\n    // or use the path as given\n\n\n    if (path[0] === _slash && path[1] === _slash) {\n      const idx = path.indexOf(_slash, 2);\n\n      if (idx === -1) {\n        authority = path.substring(2);\n        path = _slash;\n      } else {\n        authority = path.substring(2, idx);\n        path = path.substring(idx) || _slash;\n      }\n    }\n\n    return new Uri('file', authority, path, _empty, _empty);\n  }\n\n  static from(components) {\n    const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);\n\n    _validateUri(result, true);\n\n    return result;\n  }\n  /**\n   * Join a URI path with path fragments and normalizes the resulting path.\n   *\n   * @param uri The input URI.\n   * @param pathFragment The path fragment to add to the URI path.\n   * @returns The resulting URI.\n   */\n\n\n  static joinPath(uri, ...pathFragment) {\n    if (!uri.path) {\n      throw new Error(`[UriError]: cannot call joinPath on URI without path`);\n    }\n\n    let newPath;\n\n    if (isWindows && uri.scheme === 'file') {\n      newPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n    } else {\n      newPath = paths.posix.join(uri.path, ...pathFragment);\n    }\n\n    return uri.with({\n      path: newPath\n    });\n  } // ---- printing/externalize ---------------------------\n\n  /**\n   * Creates a string representation for this URI. It's guaranteed that calling\n   * `URI.parse` with the result of this function creates an URI which is equal\n   * to this URI.\n   *\n   * * The result shall *not* be used for display purposes but for externalization or transport.\n   * * The result will be encoded using the percentage encoding and encoding happens mostly\n   * ignore the scheme-specific encoding rules.\n   *\n   * @param skipEncoding Do not encode the result, default is `false`\n   */\n\n\n  toString(skipEncoding = false) {\n    return _asFormatted(this, skipEncoding);\n  }\n\n  toJSON() {\n    return this;\n  }\n\n  static revive(data) {\n    if (!data) {\n      return data;\n    } else if (data instanceof URI) {\n      return data;\n    } else {\n      const result = new Uri(data);\n      result._formatted = data.external;\n      result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\n      return result;\n    }\n  }\n\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined; // This class exists so that URI is compatible with vscode.Uri (API).\n\n\nclass Uri extends URI {\n  constructor() {\n    super(...arguments);\n    this._formatted = null;\n    this._fsPath = null;\n  }\n\n  get fsPath() {\n    if (!this._fsPath) {\n      this._fsPath = uriToFsPath(this, false);\n    }\n\n    return this._fsPath;\n  }\n\n  toString(skipEncoding = false) {\n    if (!skipEncoding) {\n      if (!this._formatted) {\n        this._formatted = _asFormatted(this, false);\n      }\n\n      return this._formatted;\n    } else {\n      // we don't cache that\n      return _asFormatted(this, true);\n    }\n  }\n\n  toJSON() {\n    const res = {\n      $mid: 1\n      /* Uri */\n\n    }; // cached state\n\n    if (this._fsPath) {\n      res.fsPath = this._fsPath;\n      res._sep = _pathSepMarker;\n    }\n\n    if (this._formatted) {\n      res.external = this._formatted;\n    } // uri components\n\n\n    if (this.path) {\n      res.path = this.path;\n    }\n\n    if (this.scheme) {\n      res.scheme = this.scheme;\n    }\n\n    if (this.authority) {\n      res.authority = this.authority;\n    }\n\n    if (this.query) {\n      res.query = this.query;\n    }\n\n    if (this.fragment) {\n      res.fragment = this.fragment;\n    }\n\n    return res;\n  }\n\n} // reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\n\n\nconst encodeTable = {\n  [58\n  /* Colon */\n  ]: '%3A',\n  [47\n  /* Slash */\n  ]: '%2F',\n  [63\n  /* QuestionMark */\n  ]: '%3F',\n  [35\n  /* Hash */\n  ]: '%23',\n  [91\n  /* OpenSquareBracket */\n  ]: '%5B',\n  [93\n  /* CloseSquareBracket */\n  ]: '%5D',\n  [64\n  /* AtSign */\n  ]: '%40',\n  [33\n  /* ExclamationMark */\n  ]: '%21',\n  [36\n  /* DollarSign */\n  ]: '%24',\n  [38\n  /* Ampersand */\n  ]: '%26',\n  [39\n  /* SingleQuote */\n  ]: '%27',\n  [40\n  /* OpenParen */\n  ]: '%28',\n  [41\n  /* CloseParen */\n  ]: '%29',\n  [42\n  /* Asterisk */\n  ]: '%2A',\n  [43\n  /* Plus */\n  ]: '%2B',\n  [44\n  /* Comma */\n  ]: '%2C',\n  [59\n  /* Semicolon */\n  ]: '%3B',\n  [61\n  /* Equals */\n  ]: '%3D',\n  [32\n  /* Space */\n  ]: '%20'\n};\n\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\n  let res = undefined;\n  let nativeEncodePos = -1;\n\n  for (let pos = 0; pos < uriComponent.length; pos++) {\n    const code = uriComponent.charCodeAt(pos); // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\n    if (code >= 97\n    /* a */\n    && code <= 122\n    /* z */\n    || code >= 65\n    /* A */\n    && code <= 90\n    /* Z */\n    || code >= 48\n    /* Digit0 */\n    && code <= 57\n    /* Digit9 */\n    || code === 45\n    /* Dash */\n    || code === 46\n    /* Period */\n    || code === 95\n    /* Underline */\n    || code === 126\n    /* Tilde */\n    || allowSlash && code === 47\n    /* Slash */\n    ) {\n      // check if we are delaying native encode\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n        nativeEncodePos = -1;\n      } // check if we write into a new string (by default we try to return the param)\n\n\n      if (res !== undefined) {\n        res += uriComponent.charAt(pos);\n      }\n    } else {\n      // encoding needed, we need to allocate a new string\n      if (res === undefined) {\n        res = uriComponent.substr(0, pos);\n      } // check with default table first\n\n\n      const escaped = encodeTable[code];\n\n      if (escaped !== undefined) {\n        // check if we are delaying native encode\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n          nativeEncodePos = -1;\n        } // append escaped variant to result\n\n\n        res += escaped;\n      } else if (nativeEncodePos === -1) {\n        // use native encode only when needed\n        nativeEncodePos = pos;\n      }\n    }\n  }\n\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n  }\n\n  return res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path) {\n  let res = undefined;\n\n  for (let pos = 0; pos < path.length; pos++) {\n    const code = path.charCodeAt(pos);\n\n    if (code === 35\n    /* Hash */\n    || code === 63\n    /* QuestionMark */\n    ) {\n      if (res === undefined) {\n        res = path.substr(0, pos);\n      }\n\n      res += encodeTable[code];\n    } else {\n      if (res !== undefined) {\n        res += path[pos];\n      }\n    }\n  }\n\n  return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\n\n\nexport function uriToFsPath(uri, keepDriveLetterCasing) {\n  let value;\n\n  if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n    // unc path: file://shares/c$/far/boo\n    value = `//${uri.authority}${uri.path}`;\n  } else if (uri.path.charCodeAt(0) === 47\n  /* Slash */\n  && (uri.path.charCodeAt(1) >= 65\n  /* A */\n  && uri.path.charCodeAt(1) <= 90\n  /* Z */\n  || uri.path.charCodeAt(1) >= 97\n  /* a */\n  && uri.path.charCodeAt(1) <= 122\n  /* z */\n  ) && uri.path.charCodeAt(2) === 58\n  /* Colon */\n  ) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2);\n    } else {\n      value = uri.path.substr(1);\n    }\n  } else {\n    // other path\n    value = uri.path;\n  }\n\n  if (isWindows) {\n    value = value.replace(/\\//g, '\\\\');\n  }\n\n  return value;\n}\n/**\n * Create the external version of a uri\n */\n\nfunction _asFormatted(uri, skipEncoding) {\n  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n  let res = '';\n  let {\n    scheme,\n    authority,\n    path,\n    query,\n    fragment\n  } = uri;\n\n  if (scheme) {\n    res += scheme;\n    res += ':';\n  }\n\n  if (authority || scheme === 'file') {\n    res += _slash;\n    res += _slash;\n  }\n\n  if (authority) {\n    let idx = authority.indexOf('@');\n\n    if (idx !== -1) {\n      // <user>@<auth>\n      const userinfo = authority.substr(0, idx);\n      authority = authority.substr(idx + 1);\n      idx = userinfo.indexOf(':');\n\n      if (idx === -1) {\n        res += encoder(userinfo, false);\n      } else {\n        // <user>:<pass>@<auth>\n        res += encoder(userinfo.substr(0, idx), false);\n        res += ':';\n        res += encoder(userinfo.substr(idx + 1), false);\n      }\n\n      res += '@';\n    }\n\n    authority = authority.toLowerCase();\n    idx = authority.indexOf(':');\n\n    if (idx === -1) {\n      res += encoder(authority, false);\n    } else {\n      // <auth>:<port>\n      res += encoder(authority.substr(0, idx), false);\n      res += authority.substr(idx);\n    }\n  }\n\n  if (path) {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (path.length >= 3 && path.charCodeAt(0) === 47\n    /* Slash */\n    && path.charCodeAt(2) === 58\n    /* Colon */\n    ) {\n      const code = path.charCodeAt(1);\n\n      if (code >= 65\n      /* A */\n      && code <= 90\n      /* Z */\n      ) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n      }\n    } else if (path.length >= 2 && path.charCodeAt(1) === 58\n    /* Colon */\n    ) {\n      const code = path.charCodeAt(0);\n\n      if (code >= 65\n      /* A */\n      && code <= 90\n      /* Z */\n      ) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n      }\n    } // encode the rest of the path\n\n\n    res += encoder(path, true);\n  }\n\n  if (query) {\n    res += '?';\n    res += encoder(query, false);\n  }\n\n  if (fragment) {\n    res += '#';\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n  }\n\n  return res;\n} // --- decode\n\n\nfunction decodeURIComponentGraceful(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (_a) {\n    if (str.length > 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n    } else {\n      return str;\n    }\n  }\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str) {\n  if (!str.match(_rEncodedAsHex)) {\n    return str;\n  }\n\n  return str.replace(_rEncodedAsHex, match => decodeURIComponentGraceful(match));\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/common/uri.js"],"names":["paths","isWindows","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","ret","_strict","scheme","Error","authority","path","query","fragment","test","_schemeFix","_referenceResolution","_slash","_empty","_regexp","URI","constructor","schemeOrData","isUri","thing","fsPath","with","toString","uriToFsPath","change","undefined","Uri","parse","value","match","exec","percentDecode","file","replace","idx","indexOf","substring","from","components","result","joinPath","uri","pathFragment","newPath","win32","join","posix","skipEncoding","_asFormatted","toJSON","revive","data","_formatted","external","_fsPath","_sep","_pathSepMarker","arguments","res","$mid","encodeTable","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","pos","length","code","charCodeAt","encodeURIComponent","charAt","substr","escaped","encodeURIComponentMinimal","keepDriveLetterCasing","toLowerCase","encoder","userinfo","String","fromCharCode","decodeURIComponentGraceful","str","decodeURIComponent","_a","_rEncodedAsHex"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as paths from './path.js';\nimport { isWindows } from './platform.js';\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n    // scheme, must be set\n    if (!ret.scheme && _strict) {\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n    }\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n    if (!scheme && !_strict) {\n        return 'file';\n    }\n    return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n    // the slash-character is our 'default base' as we don't\n    // support constructing URIs relative to other URIs. This\n    // also means that we alter and potentially break paths.\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n    switch (scheme) {\n        case 'https':\n        case 'http':\n        case 'file':\n            if (!path) {\n                path = _slash;\n            }\n            else if (path[0] !== _slash) {\n                path = _slash + path;\n            }\n            break;\n    }\n    return path;\n}\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI {\n    /**\n     * @internal\n     */\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = _schemeFix(schemeOrData, _strict);\n            this.authority = authority || _empty;\n            this.path = _referenceResolution(this.scheme, path || _empty);\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this, _strict);\n        }\n    }\n    static isUri(thing) {\n        if (thing instanceof URI) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.authority === 'string'\n            && typeof thing.fragment === 'string'\n            && typeof thing.path === 'string'\n            && typeof thing.query === 'string'\n            && typeof thing.scheme === 'string'\n            && typeof thing.fsPath === 'string'\n            && typeof thing.with === 'function'\n            && typeof thing.toString === 'function';\n    }\n    // ---- filesystem path -----------------------\n    /**\n     * Returns a string representing the corresponding file system path of this URI.\n     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n     * platform specific path separator.\n     *\n     * * Will *not* validate the path for invalid characters and semantics.\n     * * Will *not* look at the scheme of this URI.\n     * * The result shall *not* be used for display purposes but for accessing a file on disk.\n     *\n     *\n     * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n     *\n     * ```ts\n        const u = URI.parse('file://server/c$/folder/file.txt')\n        u.authority === 'server'\n        u.path === '/shares/c$/file.txt'\n        u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n    ```\n     *\n     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n     * with URIs that represent files on disk (`file` scheme).\n     */\n    get fsPath() {\n        // if (this.scheme !== 'file') {\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n        // }\n        return uriToFsPath(this, false);\n    }\n    // ---- modify to new -------------------------\n    with(change) {\n        if (!change) {\n            return this;\n        }\n        let { scheme, authority, path, query, fragment } = change;\n        if (scheme === undefined) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === undefined) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === undefined) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === undefined) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === undefined) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme\n            && authority === this.authority\n            && path === this.path\n            && query === this.query\n            && fragment === this.fragment) {\n            return this;\n        }\n        return new Uri(scheme, authority, path, query, fragment);\n    }\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n    static parse(value, _strict = false) {\n        const match = _regexp.exec(value);\n        if (!match) {\n            return new Uri(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    }\n    /**\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\n     *\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n     * `URI.parse('file://' + path)` because the path might contain characters that are\n     * interpreted (# and ?). See the following sample:\n     * ```ts\n    const good = URI.file('/coding/c#/project1');\n    good.scheme === 'file';\n    good.path === '/coding/c#/project1';\n    good.fragment === '';\n    const bad = URI.parse('file://' + '/coding/c#/project1');\n    bad.scheme === 'file';\n    bad.path === '/coding/c'; // path is now broken\n    bad.fragment === '/project1';\n    ```\n     *\n     * @param path A file system path (see `URI#fsPath`)\n     */\n    static file(path) {\n        let authority = _empty;\n        // normalize to fwd-slashes on windows,\n        // on other systems bwd-slashes are valid\n        // filename character, eg /f\\oo/ba\\r.txt\n        if (isWindows) {\n            path = path.replace(/\\\\/g, _slash);\n        }\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            const idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        return new Uri('file', authority, path, _empty, _empty);\n    }\n    static from(components) {\n        const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);\n        _validateUri(result, true);\n        return result;\n    }\n    /**\n     * Join a URI path with path fragments and normalizes the resulting path.\n     *\n     * @param uri The input URI.\n     * @param pathFragment The path fragment to add to the URI path.\n     * @returns The resulting URI.\n     */\n    static joinPath(uri, ...pathFragment) {\n        if (!uri.path) {\n            throw new Error(`[UriError]: cannot call joinPath on URI without path`);\n        }\n        let newPath;\n        if (isWindows && uri.scheme === 'file') {\n            newPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n        }\n        else {\n            newPath = paths.posix.join(uri.path, ...pathFragment);\n        }\n        return uri.with({ path: newPath });\n    }\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    toString(skipEncoding = false) {\n        return _asFormatted(this, skipEncoding);\n    }\n    toJSON() {\n        return this;\n    }\n    static revive(data) {\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof URI) {\n            return data;\n        }\n        else {\n            const result = new Uri(data);\n            result._formatted = data.external;\n            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\n            return result;\n        }\n    }\n}\nconst _pathSepMarker = isWindows ? 1 : undefined;\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n    constructor() {\n        super(...arguments);\n        this._formatted = null;\n        this._fsPath = null;\n    }\n    get fsPath() {\n        if (!this._fsPath) {\n            this._fsPath = uriToFsPath(this, false);\n        }\n        return this._fsPath;\n    }\n    toString(skipEncoding = false) {\n        if (!skipEncoding) {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, false);\n            }\n            return this._formatted;\n        }\n        else {\n            // we don't cache that\n            return _asFormatted(this, true);\n        }\n    }\n    toJSON() {\n        const res = {\n            $mid: 1 /* Uri */\n        };\n        // cached state\n        if (this._fsPath) {\n            res.fsPath = this._fsPath;\n            res._sep = _pathSepMarker;\n        }\n        if (this._formatted) {\n            res.external = this._formatted;\n        }\n        // uri components\n        if (this.path) {\n            res.path = this.path;\n        }\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    }\n}\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable = {\n    [58 /* Colon */]: '%3A',\n    [47 /* Slash */]: '%2F',\n    [63 /* QuestionMark */]: '%3F',\n    [35 /* Hash */]: '%23',\n    [91 /* OpenSquareBracket */]: '%5B',\n    [93 /* CloseSquareBracket */]: '%5D',\n    [64 /* AtSign */]: '%40',\n    [33 /* ExclamationMark */]: '%21',\n    [36 /* DollarSign */]: '%24',\n    [38 /* Ampersand */]: '%26',\n    [39 /* SingleQuote */]: '%27',\n    [40 /* OpenParen */]: '%28',\n    [41 /* CloseParen */]: '%29',\n    [42 /* Asterisk */]: '%2A',\n    [43 /* Plus */]: '%2B',\n    [44 /* Comma */]: '%2C',\n    [59 /* Semicolon */]: '%3B',\n    [61 /* Equals */]: '%3D',\n    [32 /* Space */]: '%20',\n};\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\n    let res = undefined;\n    let nativeEncodePos = -1;\n    for (let pos = 0; pos < uriComponent.length; pos++) {\n        const code = uriComponent.charCodeAt(pos);\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n        if ((code >= 97 /* a */ && code <= 122 /* z */)\n            || (code >= 65 /* A */ && code <= 90 /* Z */)\n            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)\n            || code === 45 /* Dash */\n            || code === 46 /* Period */\n            || code === 95 /* Underline */\n            || code === 126 /* Tilde */\n            || (allowSlash && code === 47 /* Slash */)) {\n            // check if we are delaying native encode\n            if (nativeEncodePos !== -1) {\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                nativeEncodePos = -1;\n            }\n            // check if we write into a new string (by default we try to return the param)\n            if (res !== undefined) {\n                res += uriComponent.charAt(pos);\n            }\n        }\n        else {\n            // encoding needed, we need to allocate a new string\n            if (res === undefined) {\n                res = uriComponent.substr(0, pos);\n            }\n            // check with default table first\n            const escaped = encodeTable[code];\n            if (escaped !== undefined) {\n                // check if we are delaying native encode\n                if (nativeEncodePos !== -1) {\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                    nativeEncodePos = -1;\n                }\n                // append escaped variant to result\n                res += escaped;\n            }\n            else if (nativeEncodePos === -1) {\n                // use native encode only when needed\n                nativeEncodePos = pos;\n            }\n        }\n    }\n    if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n    }\n    return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n    let res = undefined;\n    for (let pos = 0; pos < path.length; pos++) {\n        const code = path.charCodeAt(pos);\n        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {\n            if (res === undefined) {\n                res = path.substr(0, pos);\n            }\n            res += encodeTable[code];\n        }\n        else {\n            if (res !== undefined) {\n                res += path[pos];\n            }\n        }\n    }\n    return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri, keepDriveLetterCasing) {\n    let value;\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = `//${uri.authority}${uri.path}`;\n    }\n    else if (uri.path.charCodeAt(0) === 47 /* Slash */\n        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)\n        && uri.path.charCodeAt(2) === 58 /* Colon */) {\n        if (!keepDriveLetterCasing) {\n            // windows drive letter: file:///c:/far/boo\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\n        }\n        else {\n            value = uri.path.substr(1);\n        }\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    if (isWindows) {\n        value = value.replace(/\\//g, '\\\\');\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    const encoder = !skipEncoding\n        ? encodeURIComponentFast\n        : encodeURIComponentMinimal;\n    let res = '';\n    let { scheme, authority, path, query, fragment } = uri;\n    if (scheme) {\n        res += scheme;\n        res += ':';\n    }\n    if (authority || scheme === 'file') {\n        res += _slash;\n        res += _slash;\n    }\n    if (authority) {\n        let idx = authority.indexOf('@');\n        if (idx !== -1) {\n            // <user>@<auth>\n            const userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.indexOf(':');\n            if (idx === -1) {\n                res += encoder(userinfo, false);\n            }\n            else {\n                // <user>:<pass>@<auth>\n                res += encoder(userinfo.substr(0, idx), false);\n                res += ':';\n                res += encoder(userinfo.substr(idx + 1), false);\n            }\n            res += '@';\n        }\n        authority = authority.toLowerCase();\n        idx = authority.indexOf(':');\n        if (idx === -1) {\n            res += encoder(authority, false);\n        }\n        else {\n            // <auth>:<port>\n            res += encoder(authority.substr(0, idx), false);\n            res += authority.substr(idx);\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {\n            const code = path.charCodeAt(1);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n            }\n        }\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {\n            const code = path.charCodeAt(0);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n            }\n        }\n        // encode the rest of the path\n        res += encoder(path, true);\n    }\n    if (query) {\n        res += '?';\n        res += encoder(query, false);\n    }\n    if (fragment) {\n        res += '#';\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n    }\n    return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (_a) {\n        if (str.length > 3) {\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n        }\n        else {\n            return str;\n        }\n    }\n}\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n    if (!str.match(_rEncodedAsHex)) {\n        return str;\n    }\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n"]},"metadata":{},"sourceType":"module"}