{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/types.js';\nexport class UnicodeTextModelHighlighter {\n  static computeUnicodeHighlights(model, options, range) {\n    const startLine = range ? range.startLineNumber : 1;\n    const endLine = range ? range.endLineNumber : model.getLineCount();\n    const codePointHighlighter = new CodePointHighlighter(options);\n    const candidates = codePointHighlighter.getCandidateCodePoints();\n    let regex;\n\n    if (candidates === 'allNonBasicAscii') {\n      regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n    } else {\n      regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n    }\n\n    const searcher = new Searcher(null, regex);\n    const ranges = [];\n    let hasMore = false;\n    let m;\n    let ambiguousCharacterCount = 0;\n    let invisibleCharacterCount = 0;\n    let nonBasicAsciiCharacterCount = 0;\n\n    forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n      const lineContent = model.getLineContent(lineNumber);\n      const lineLength = lineContent.length; // Reset regex to search from the beginning\n\n      searcher.reset(0);\n\n      do {\n        m = searcher.next(lineContent);\n\n        if (m) {\n          let startIndex = m.index;\n          let endIndex = m.index + m[0].length; // Extend range to entire code point\n\n          if (startIndex > 0) {\n            const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n\n            if (strings.isHighSurrogate(charCodeBefore)) {\n              startIndex--;\n            }\n          }\n\n          if (endIndex + 1 < lineLength) {\n            const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n\n            if (strings.isHighSurrogate(charCodeBefore)) {\n              endIndex++;\n            }\n          }\n\n          const str = lineContent.substring(startIndex, endIndex);\n          const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str);\n\n          if (highlightReason !== 0\n          /* None */\n          ) {\n            if (highlightReason === 3\n            /* Ambiguous */\n            ) {\n              ambiguousCharacterCount++;\n            } else if (highlightReason === 2\n            /* Invisible */\n            ) {\n              invisibleCharacterCount++;\n            } else if (highlightReason === 1\n            /* NonBasicASCII */\n            ) {\n              nonBasicAsciiCharacterCount++;\n            } else {\n              assertNever(highlightReason);\n            }\n\n            const MAX_RESULT_LENGTH = 1000;\n\n            if (ranges.length >= MAX_RESULT_LENGTH) {\n              hasMore = true;\n              break forLoop;\n            }\n\n            ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n          }\n        }\n      } while (m);\n    }\n\n    return {\n      ranges,\n      hasMore,\n      ambiguousCharacterCount,\n      invisibleCharacterCount,\n      nonBasicAsciiCharacterCount\n    };\n  }\n\n  static computeUnicodeHighlightReason(char, options) {\n    const codePointHighlighter = new CodePointHighlighter(options);\n    const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char);\n\n    switch (reason) {\n      case 0\n      /* None */\n      :\n        return null;\n\n      case 2\n      /* Invisible */\n      :\n        return {\n          kind: 1\n          /* Invisible */\n\n        };\n\n      case 3\n      /* Ambiguous */\n      :\n        {\n          const codePoint = char.codePointAt(0);\n          const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n          const notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter(l => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n          return {\n            kind: 0\n            /* Ambiguous */\n            ,\n            confusableWith: String.fromCodePoint(primaryConfusable),\n            notAmbiguousInLocales\n          };\n        }\n\n      case 1\n      /* NonBasicASCII */\n      :\n        return {\n          kind: 2\n          /* NonBasicAscii */\n\n        };\n    }\n  }\n\n}\n\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n  const src = `[${strings.escapeRegExpCharacters(codePoints.map(i => String.fromCodePoint(i)).join(''))}]`;\n  return src;\n}\n\nclass CodePointHighlighter {\n  constructor(options) {\n    this.options = options;\n    this.allowedCodePoints = new Set(options.allowedCodePoints);\n    this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n  }\n\n  getCandidateCodePoints() {\n    if (this.options.nonBasicASCII) {\n      return 'allNonBasicAscii';\n    }\n\n    const set = new Set();\n\n    if (this.options.invisibleCharacters) {\n      for (const cp of strings.InvisibleCharacters.codePoints) {\n        set.add(cp);\n      }\n    }\n\n    if (this.options.ambiguousCharacters) {\n      for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n        set.add(cp);\n      }\n    }\n\n    for (const cp of this.allowedCodePoints) {\n      set.delete(cp);\n    }\n\n    return set;\n  }\n\n  shouldHighlightNonBasicASCII(character) {\n    const codePoint = character.codePointAt(0);\n\n    if (this.allowedCodePoints.has(codePoint)) {\n      return 0\n      /* None */\n      ;\n    }\n\n    if (this.options.nonBasicASCII) {\n      return 1\n      /* NonBasicASCII */\n      ;\n    }\n\n    if (this.options.invisibleCharacters) {\n      const isAllowedInvisibleCharacter = character === ' ' || character === '\\n' || character === '\\t'; // TODO check for emojis\n\n      if (!isAllowedInvisibleCharacter && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n        return 2\n        /* Invisible */\n        ;\n      }\n    }\n\n    if (this.options.ambiguousCharacters) {\n      if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n        return 3\n        /* Ambiguous */\n        ;\n      }\n    }\n\n    return 0\n    /* None */\n    ;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/languages/unicodeTextModelHighlighter.js"],"names":["Range","Searcher","strings","assertNever","UnicodeTextModelHighlighter","computeUnicodeHighlights","model","options","range","startLine","startLineNumber","endLine","endLineNumber","getLineCount","codePointHighlighter","CodePointHighlighter","candidates","getCandidateCodePoints","regex","RegExp","buildRegExpCharClassExpr","Array","from","searcher","ranges","hasMore","m","ambiguousCharacterCount","invisibleCharacterCount","nonBasicAsciiCharacterCount","forLoop","lineNumber","lineCount","lineContent","getLineContent","lineLength","length","reset","next","startIndex","index","endIndex","charCodeBefore","charCodeAt","isHighSurrogate","str","substring","highlightReason","shouldHighlightNonBasicASCII","MAX_RESULT_LENGTH","push","computeUnicodeHighlightReason","char","reason","kind","codePoint","codePointAt","primaryConfusable","ambiguousCharacters","getPrimaryConfusable","notAmbiguousInLocales","AmbiguousCharacters","getLocales","filter","l","getInstance","Set","allowedLocales","isAmbiguous","confusableWith","String","fromCodePoint","codePoints","flags","src","escapeRegExpCharacters","map","i","join","constructor","allowedCodePoints","nonBasicASCII","set","invisibleCharacters","cp","InvisibleCharacters","add","getConfusableCodePoints","delete","character","has","isAllowedInvisibleCharacter","isInvisibleCharacter"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/types.js';\nexport class UnicodeTextModelHighlighter {\n    static computeUnicodeHighlights(model, options, range) {\n        const startLine = range ? range.startLineNumber : 1;\n        const endLine = range ? range.endLineNumber : model.getLineCount();\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const candidates = codePointHighlighter.getCandidateCodePoints();\n        let regex;\n        if (candidates === 'allNonBasicAscii') {\n            regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n        }\n        else {\n            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n        }\n        const searcher = new Searcher(null, regex);\n        const ranges = [];\n        let hasMore = false;\n        let m;\n        let ambiguousCharacterCount = 0;\n        let invisibleCharacterCount = 0;\n        let nonBasicAsciiCharacterCount = 0;\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n            const lineContent = model.getLineContent(lineNumber);\n            const lineLength = lineContent.length;\n            // Reset regex to search from the beginning\n            searcher.reset(0);\n            do {\n                m = searcher.next(lineContent);\n                if (m) {\n                    let startIndex = m.index;\n                    let endIndex = m.index + m[0].length;\n                    // Extend range to entire code point\n                    if (startIndex > 0) {\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            startIndex--;\n                        }\n                    }\n                    if (endIndex + 1 < lineLength) {\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            endIndex++;\n                        }\n                    }\n                    const str = lineContent.substring(startIndex, endIndex);\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str);\n                    if (highlightReason !== 0 /* None */) {\n                        if (highlightReason === 3 /* Ambiguous */) {\n                            ambiguousCharacterCount++;\n                        }\n                        else if (highlightReason === 2 /* Invisible */) {\n                            invisibleCharacterCount++;\n                        }\n                        else if (highlightReason === 1 /* NonBasicASCII */) {\n                            nonBasicAsciiCharacterCount++;\n                        }\n                        else {\n                            assertNever(highlightReason);\n                        }\n                        const MAX_RESULT_LENGTH = 1000;\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\n                            hasMore = true;\n                            break forLoop;\n                        }\n                        ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n                    }\n                }\n            } while (m);\n        }\n        return {\n            ranges,\n            hasMore,\n            ambiguousCharacterCount,\n            invisibleCharacterCount,\n            nonBasicAsciiCharacterCount\n        };\n    }\n    static computeUnicodeHighlightReason(char, options) {\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char);\n        switch (reason) {\n            case 0 /* None */:\n                return null;\n            case 2 /* Invisible */:\n                return { kind: 1 /* Invisible */ };\n            case 3 /* Ambiguous */: {\n                const codePoint = char.codePointAt(0);\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n                const notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter((l) => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n                return { kind: 0 /* Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n            }\n            case 1 /* NonBasicASCII */:\n                return { kind: 2 /* NonBasicAscii */ };\n        }\n    }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n    const src = `[${strings.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;\n    return src;\n}\nclass CodePointHighlighter {\n    constructor(options) {\n        this.options = options;\n        this.allowedCodePoints = new Set(options.allowedCodePoints);\n        this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n    }\n    getCandidateCodePoints() {\n        if (this.options.nonBasicASCII) {\n            return 'allNonBasicAscii';\n        }\n        const set = new Set();\n        if (this.options.invisibleCharacters) {\n            for (const cp of strings.InvisibleCharacters.codePoints) {\n                set.add(cp);\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n                set.add(cp);\n            }\n        }\n        for (const cp of this.allowedCodePoints) {\n            set.delete(cp);\n        }\n        return set;\n    }\n    shouldHighlightNonBasicASCII(character) {\n        const codePoint = character.codePointAt(0);\n        if (this.allowedCodePoints.has(codePoint)) {\n            return 0 /* None */;\n        }\n        if (this.options.nonBasicASCII) {\n            return 1 /* NonBasicASCII */;\n        }\n        if (this.options.invisibleCharacters) {\n            const isAllowedInvisibleCharacter = character === ' ' || character === '\\n' || character === '\\t';\n            // TODO check for emojis\n            if (!isAllowedInvisibleCharacter && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                return 2 /* Invisible */;\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n                return 3 /* Ambiguous */;\n            }\n        }\n        return 0 /* None */;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}