{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n  constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n    super();\n    this._onDidChangeContent = this._register(new Emitter());\n    this._BOM = BOM;\n    this._mightContainNonBasicASCII = !isBasicASCII;\n    this._mightContainRTL = containsRTL;\n    this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n    this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n  }\n\n  mightContainRTL() {\n    return this._mightContainRTL;\n  }\n\n  mightContainUnusualLineTerminators() {\n    return this._mightContainUnusualLineTerminators;\n  }\n\n  resetMightContainUnusualLineTerminators() {\n    this._mightContainUnusualLineTerminators = false;\n  }\n\n  mightContainNonBasicASCII() {\n    return this._mightContainNonBasicASCII;\n  }\n\n  getBOM() {\n    return this._BOM;\n  }\n\n  getEOL() {\n    return this._pieceTree.getEOL();\n  }\n\n  createSnapshot(preserveBOM) {\n    return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n  }\n\n  getOffsetAt(lineNumber, column) {\n    return this._pieceTree.getOffsetAt(lineNumber, column);\n  }\n\n  getPositionAt(offset) {\n    return this._pieceTree.getPositionAt(offset);\n  }\n\n  getRangeAt(start, length) {\n    const end = start + length;\n    const startPosition = this.getPositionAt(start);\n    const endPosition = this.getPositionAt(end);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  }\n\n  getValueInRange(range, eol = 0\n  /* TextDefined */\n  ) {\n    if (range.isEmpty()) {\n      return '';\n    }\n\n    const lineEnding = this._getEndOfLine(eol);\n\n    return this._pieceTree.getValueInRange(range, lineEnding);\n  }\n\n  getValueLengthInRange(range, eol = 0\n  /* TextDefined */\n  ) {\n    if (range.isEmpty()) {\n      return 0;\n    }\n\n    if (range.startLineNumber === range.endLineNumber) {\n      return range.endColumn - range.startColumn;\n    }\n\n    const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n    return endOffset - startOffset;\n  }\n\n  getCharacterCountInRange(range, eol = 0\n  /* TextDefined */\n  ) {\n    if (this._mightContainNonBasicASCII) {\n      // we must count by iterating\n      let result = 0;\n      const fromLineNumber = range.startLineNumber;\n      const toLineNumber = range.endLineNumber;\n\n      for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n        const lineContent = this.getLineContent(lineNumber);\n        const fromOffset = lineNumber === fromLineNumber ? range.startColumn - 1 : 0;\n        const toOffset = lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length;\n\n        for (let offset = fromOffset; offset < toOffset; offset++) {\n          if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n            result = result + 1;\n            offset = offset + 1;\n          } else {\n            result = result + 1;\n          }\n        }\n      }\n\n      result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n      return result;\n    }\n\n    return this.getValueLengthInRange(range, eol);\n  }\n\n  getLength() {\n    return this._pieceTree.getLength();\n  }\n\n  getLineCount() {\n    return this._pieceTree.getLineCount();\n  }\n\n  getLinesContent() {\n    return this._pieceTree.getLinesContent();\n  }\n\n  getLineContent(lineNumber) {\n    return this._pieceTree.getLineContent(lineNumber);\n  }\n\n  getLineCharCode(lineNumber, index) {\n    return this._pieceTree.getLineCharCode(lineNumber, index);\n  }\n\n  getLineLength(lineNumber) {\n    return this._pieceTree.getLineLength(lineNumber);\n  }\n\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 1;\n  }\n\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 2;\n  }\n\n  _getEndOfLine(eol) {\n    switch (eol) {\n      case 1\n      /* LF */\n      :\n        return '\\n';\n\n      case 2\n      /* CRLF */\n      :\n        return '\\r\\n';\n\n      case 0\n      /* TextDefined */\n      :\n        return this.getEOL();\n\n      default:\n        throw new Error('Unknown EOL preference');\n    }\n  }\n\n  setEOL(newEOL) {\n    this._pieceTree.setEOL(newEOL);\n  }\n\n  applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n    let mightContainRTL = this._mightContainRTL;\n    let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n    let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n    let canReduceOperations = true;\n    let operations = [];\n\n    for (let i = 0; i < rawOperations.length; i++) {\n      const op = rawOperations[i];\n\n      if (canReduceOperations && op._isTracked) {\n        canReduceOperations = false;\n      }\n\n      const validatedRange = op.range;\n\n      if (op.text) {\n        let textMightContainNonBasicASCII = true;\n\n        if (!mightContainNonBasicASCII) {\n          textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n          mightContainNonBasicASCII = textMightContainNonBasicASCII;\n        }\n\n        if (!mightContainRTL && textMightContainNonBasicASCII) {\n          // check if the new inserted text contains RTL\n          mightContainRTL = strings.containsRTL(op.text);\n        }\n\n        if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n          // check if the new inserted text contains unusual line terminators\n          mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n        }\n      }\n\n      let validText = '';\n      let eolCount = 0;\n      let firstLineLength = 0;\n      let lastLineLength = 0;\n\n      if (op.text) {\n        let strEOL;\n        [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n        const bufferEOL = this.getEOL();\n        const expectedStrEOL = bufferEOL === '\\r\\n' ? 2\n        /* CRLF */\n        : 1\n        /* LF */\n        ;\n\n        if (strEOL === 0\n        /* Unknown */\n        || strEOL === expectedStrEOL) {\n          validText = op.text;\n        } else {\n          validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n        }\n      }\n\n      operations[i] = {\n        sortIndex: i,\n        identifier: op.identifier || null,\n        range: validatedRange,\n        rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n        rangeLength: this.getValueLengthInRange(validatedRange),\n        text: validText,\n        eolCount: eolCount,\n        firstLineLength: firstLineLength,\n        lastLineLength: lastLineLength,\n        forceMoveMarkers: Boolean(op.forceMoveMarkers),\n        isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n      };\n    } // Sort operations ascending\n\n\n    operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n    let hasTouchingRanges = false;\n\n    for (let i = 0, count = operations.length - 1; i < count; i++) {\n      const rangeEnd = operations[i].range.getEndPosition();\n      const nextRangeStart = operations[i + 1].range.getStartPosition();\n\n      if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n        if (nextRangeStart.isBefore(rangeEnd)) {\n          // overlapping ranges\n          throw new Error('Overlapping ranges are not allowed!');\n        }\n\n        hasTouchingRanges = true;\n      }\n    }\n\n    if (canReduceOperations) {\n      operations = this._reduceOperations(operations);\n    } // Delta encode operations\n\n\n    const reverseRanges = computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : [];\n    const newTrimAutoWhitespaceCandidates = [];\n\n    if (recordTrimAutoWhitespace) {\n      for (let i = 0; i < operations.length; i++) {\n        const op = operations[i];\n        const reverseRange = reverseRanges[i];\n\n        if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n          // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n          for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n            let currentLineContent = '';\n\n            if (lineNumber === reverseRange.startLineNumber) {\n              currentLineContent = this.getLineContent(op.range.startLineNumber);\n\n              if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                continue;\n              }\n            }\n\n            newTrimAutoWhitespaceCandidates.push({\n              lineNumber: lineNumber,\n              oldContent: currentLineContent\n            });\n          }\n        }\n      }\n    }\n\n    let reverseOperations = null;\n\n    if (computeUndoEdits) {\n      let reverseRangeDeltaOffset = 0;\n      reverseOperations = [];\n\n      for (let i = 0; i < operations.length; i++) {\n        const op = operations[i];\n        const reverseRange = reverseRanges[i];\n        const bufferText = this.getValueInRange(op.range);\n        const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n        reverseRangeDeltaOffset += op.text.length - bufferText.length;\n        reverseOperations[i] = {\n          sortIndex: op.sortIndex,\n          identifier: op.identifier,\n          range: reverseRange,\n          text: bufferText,\n          textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n        };\n      } // Can only sort reverse operations when the order is not significant\n\n\n      if (!hasTouchingRanges) {\n        reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n      }\n    }\n\n    this._mightContainRTL = mightContainRTL;\n    this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n    this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n    const contentChanges = this._doApplyEdits(operations);\n\n    let trimAutoWhitespaceLineNumbers = null;\n\n    if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n      // sort line numbers auto whitespace removal candidates for next edit descending\n      newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n      trimAutoWhitespaceLineNumbers = [];\n\n      for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n        const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\n        if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n          // Do not have the same line number twice\n          continue;\n        }\n\n        const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n        const lineContent = this.getLineContent(lineNumber);\n\n        if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n          continue;\n        }\n\n        trimAutoWhitespaceLineNumbers.push(lineNumber);\n      }\n    }\n\n    this._onDidChangeContent.fire();\n\n    return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n  }\n  /**\n   * Transform operations such that they represent the same logic edit,\n   * but that they also do not cause OOM crashes.\n   */\n\n\n  _reduceOperations(operations) {\n    if (operations.length < 1000) {\n      // We know from empirical testing that a thousand edits work fine regardless of their shape.\n      return operations;\n    } // At one point, due to how events are emitted and how each operation is handled,\n    // some operations can trigger a high amount of temporary string allocations,\n    // that will immediately get edited again.\n    // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n    // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\n\n    return [this._toSingleEditOperation(operations)];\n  }\n\n  _toSingleEditOperation(operations) {\n    let forceMoveMarkers = false;\n    const firstEditRange = operations[0].range;\n    const lastEditRange = operations[operations.length - 1].range;\n    const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n    let lastEndLineNumber = firstEditRange.startLineNumber;\n    let lastEndColumn = firstEditRange.startColumn;\n    const result = [];\n\n    for (let i = 0, len = operations.length; i < len; i++) {\n      const operation = operations[i];\n      const range = operation.range;\n      forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers; // (1) -- Push old text\n\n      result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn))); // (2) -- Push new text\n\n      if (operation.text.length > 0) {\n        result.push(operation.text);\n      }\n\n      lastEndLineNumber = range.endLineNumber;\n      lastEndColumn = range.endColumn;\n    }\n\n    const text = result.join('');\n    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n    return {\n      sortIndex: 0,\n      identifier: operations[0].identifier,\n      range: entireEditRange,\n      rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n      rangeLength: this.getValueLengthInRange(entireEditRange, 0\n      /* TextDefined */\n      ),\n      text: text,\n      eolCount: eolCount,\n      firstLineLength: firstLineLength,\n      lastLineLength: lastLineLength,\n      forceMoveMarkers: forceMoveMarkers,\n      isAutoWhitespaceEdit: false\n    };\n  }\n\n  _doApplyEdits(operations) {\n    operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n    const contentChanges = []; // operations are from bottom to top\n\n    for (let i = 0; i < operations.length; i++) {\n      const op = operations[i];\n      const startLineNumber = op.range.startLineNumber;\n      const startColumn = op.range.startColumn;\n      const endLineNumber = op.range.endLineNumber;\n      const endColumn = op.range.endColumn;\n\n      if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n        // no-op\n        continue;\n      }\n\n      if (op.text) {\n        // replacement\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\n        this._pieceTree.insert(op.rangeOffset, op.text, true);\n      } else {\n        // deletion\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n      }\n\n      const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      contentChanges.push({\n        range: contentChangeRange,\n        rangeLength: op.rangeLength,\n        text: op.text,\n        rangeOffset: op.rangeOffset,\n        forceMoveMarkers: op.forceMoveMarkers\n      });\n    }\n\n    return contentChanges;\n  }\n\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n  /**\n   * Assumes `operations` are validated and sorted ascending\n   */\n\n\n  static _getInverseEditRanges(operations) {\n    const result = [];\n    let prevOpEndLineNumber = 0;\n    let prevOpEndColumn = 0;\n    let prevOp = null;\n\n    for (let i = 0, len = operations.length; i < len; i++) {\n      const op = operations[i];\n      let startLineNumber;\n      let startColumn;\n\n      if (prevOp) {\n        if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n          startLineNumber = prevOpEndLineNumber;\n          startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n        } else {\n          startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n          startColumn = op.range.startColumn;\n        }\n      } else {\n        startLineNumber = op.range.startLineNumber;\n        startColumn = op.range.startColumn;\n      }\n\n      let resultRange;\n\n      if (op.text.length > 0) {\n        // the operation inserts something\n        const lineCount = op.eolCount + 1;\n\n        if (lineCount === 1) {\n          // single line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n        } else {\n          // multi line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n        }\n      } else {\n        // There is nothing to insert\n        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n      }\n\n      prevOpEndLineNumber = resultRange.endLineNumber;\n      prevOpEndColumn = resultRange.endColumn;\n      result.push(resultRange);\n      prevOp = op;\n    }\n\n    return result;\n  }\n\n  static _sortOpsAscending(a, b) {\n    const r = Range.compareRangesUsingEnds(a.range, b.range);\n\n    if (r === 0) {\n      return a.sortIndex - b.sortIndex;\n    }\n\n    return r;\n  }\n\n  static _sortOpsDescending(a, b) {\n    const r = Range.compareRangesUsingEnds(a.range, b.range);\n\n    if (r === 0) {\n      return b.sortIndex - a.sortIndex;\n    }\n\n    return -r;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"],"names":["Emitter","strings","Range","ApplyEditsResult","PieceTreeBase","countEOL","TextChange","Disposable","PieceTreeTextBuffer","constructor","chunks","BOM","eol","containsRTL","containsUnusualLineTerminators","isBasicASCII","eolNormalized","_onDidChangeContent","_register","_BOM","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","getEOL","createSnapshot","preserveBOM","getOffsetAt","lineNumber","column","getPositionAt","offset","getRangeAt","start","length","end","startPosition","endPosition","getValueInRange","range","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","startLineNumber","endLineNumber","endColumn","startColumn","startOffset","endOffset","getCharacterCountInRange","result","fromLineNumber","toLineNumber","lineContent","getLineContent","fromOffset","toOffset","isHighSurrogate","charCodeAt","getLength","getLineCount","getLinesContent","getLineCharCode","index","getLineLength","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","Error","setEOL","newEOL","applyEdits","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","i","op","_isTracked","validatedRange","text","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","bufferEOL","expectedStrEOL","replace","sortIndex","identifier","rangeOffset","rangeLength","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","count","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","push","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","len","prevContent","fire","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","join","_sortOpsDescending","delete","insert","contentChangeRange","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","r","compareRangesUsingEnds"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        return endOffset - startOffset;\n    }\n    getCharacterCountInRange(range, eol = 0 /* TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* LF */:\n                return '\\n';\n            case 2 /* CRLF */:\n                return '\\r\\n';\n            case 0 /* TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* CRLF */ : 1 /* LF */);\n                if (strEOL === 0 /* Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}