{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from '../services/language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nexport class LanguageConfigurationServiceChangeEvent {\n  constructor(languageId) {\n    this.languageId = languageId;\n  }\n\n  affects(languageId) {\n    return !this.languageId ? true : this.languageId === languageId;\n  }\n\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n  constructor(configurationService, languageService) {\n    super();\n    this.configurationService = configurationService;\n    this.languageService = languageService;\n    this.onDidChangeEmitter = this._register(new Emitter());\n    this.onDidChange = this.onDidChangeEmitter.event;\n    this.configurations = new Map();\n    const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n\n    this._register(this.configurationService.onDidChangeConfiguration(e => {\n      const globalConfigChanged = e.change.keys.some(k => languageConfigKeys.has(k));\n      const localConfigChanged = e.change.overrides.filter(([overrideLangName, keys]) => keys.some(k => languageConfigKeys.has(k))).map(([overrideLangName]) => overrideLangName);\n\n      if (globalConfigChanged) {\n        this.configurations.clear();\n        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n      } else {\n        for (const languageId of localConfigChanged) {\n          if (this.languageService.isRegisteredLanguageId(languageId)) {\n            this.configurations.delete(languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n          }\n        }\n      }\n    }));\n\n    this._register(LanguageConfigurationRegistry.onDidChange(e => {\n      this.configurations.delete(e.languageId);\n      this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n    }));\n  }\n\n  getLanguageConfiguration(languageId) {\n    let result = this.configurations.get(languageId);\n\n    if (!result) {\n      result = computeConfig(languageId, this.configurationService, this.languageService);\n      this.configurations.set(languageId, result);\n    }\n\n    return result;\n  }\n\n};\nLanguageConfigurationService = __decorate([__param(0, IConfigurationService), __param(1, ILanguageService)], LanguageConfigurationService);\nexport { LanguageConfigurationService };\n\nfunction computeConfig(languageId, configurationService, languageService) {\n  let languageConfig = LanguageConfigurationRegistry.getLanguageConfiguration(languageId);\n\n  if (!languageConfig) {\n    if (!languageService.isRegisteredLanguageId(languageId)) {\n      throw new Error('Unexpected languageId');\n    }\n\n    languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n  }\n\n  const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n  const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n  const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n  return config;\n}\n\nconst customizedLanguageConfigKeys = {\n  brackets: 'editor.language.brackets',\n  colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\n\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n  const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n    overrideIdentifier: languageId\n  });\n  const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n    overrideIdentifier: languageId\n  });\n  return {\n    brackets: validateBracketPairs(brackets),\n    colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs)\n  };\n}\n\nfunction validateBracketPairs(data) {\n  if (!Array.isArray(data)) {\n    return undefined;\n  }\n\n  return data.map(pair => {\n    if (!Array.isArray(pair) || pair.length !== 2) {\n      return undefined;\n    }\n\n    return [pair[0], pair[1]];\n  }).filter(p => !!p);\n}\n\nexport class LanguageConfigurationChangeEvent {\n  constructor(languageId) {\n    this.languageId = languageId;\n  }\n\n}\nexport class LanguageConfigurationRegistryImpl {\n  constructor() {\n    this._entries = new Map();\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n  }\n  /**\n   * @param priority Use a higher number for higher priority\n   */\n\n\n  register(languageId, configuration, priority = 0) {\n    let entries = this._entries.get(languageId);\n\n    if (!entries) {\n      entries = new ComposedLanguageConfiguration(languageId);\n\n      this._entries.set(languageId, entries);\n    }\n\n    const disposable = entries.register(configuration, priority);\n\n    this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n\n    return toDisposable(() => {\n      disposable.dispose();\n\n      this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n    });\n  }\n\n  getLanguageConfiguration(languageId) {\n    const entries = this._entries.get(languageId);\n\n    return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n  }\n\n  getComments(languageId) {\n    const value = this.getLanguageConfiguration(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.comments || null;\n  } // begin Indent Rules\n\n\n  getIndentRulesSupport(languageId) {\n    const value = this.getLanguageConfiguration(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.indentRulesSupport || null;\n  }\n  /**\n   * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n   * Result:\n   * -1: run into the boundary of embedded languages\n   * 0: every line above are invalid\n   * else: nearest preceding line of the same language\n   */\n\n\n  getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n    const languageId = model.getLanguageIdAtPosition(lineNumber, 0);\n\n    if (lineNumber > 1) {\n      let lastLineNumber;\n      let resultLineNumber = -1;\n\n      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n        if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n          return resultLineNumber;\n        }\n\n        const text = model.getLineContent(lastLineNumber);\n\n        if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n          resultLineNumber = lastLineNumber;\n          continue;\n        }\n\n        return lastLineNumber;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Get inherited indentation from above lines.\n   * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n   * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n   * 3. If this line doesn't match any indent rules\n   *   a. check whether the line above it matches indentNextLinePattern\n   *   b. If not, the indent level of this line is the result\n   *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n   * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n   *\n   * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n   */\n\n\n  getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true) {\n    if (autoIndent < 4\n    /* Full */\n    ) {\n      return null;\n    }\n\n    const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    if (lineNumber <= 1) {\n      return {\n        indentation: '',\n        action: null\n      };\n    }\n\n    const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n\n    if (precedingUnIgnoredLine < 0) {\n      return null;\n    } else if (precedingUnIgnoredLine < 1) {\n      return {\n        indentation: '',\n        action: null\n      };\n    }\n\n    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\n    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n      return {\n        indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n        action: IndentAction.Indent,\n        line: precedingUnIgnoredLine\n      };\n    } else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n      return {\n        indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n        action: null,\n        line: precedingUnIgnoredLine\n      };\n    } else {\n      // precedingUnIgnoredLine can not be ignored.\n      // it doesn't increase indent of following lines\n      // it doesn't increase just next line\n      // so current line is not affect by precedingUnIgnoredLine\n      // and then we should get a correct inheritted indentation from above lines\n      if (precedingUnIgnoredLine === 1) {\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n          action: null,\n          line: precedingUnIgnoredLine\n        };\n      }\n\n      const previousLine = precedingUnIgnoredLine - 1;\n      const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n\n      if (!(previousLineIndentMetadata & (1\n      /* INCREASE_MASK */\n      | 2\n      /* DECREASE_MASK */\n      )) && previousLineIndentMetadata & 4\n      /* INDENT_NEXTLINE_MASK */\n      ) {\n        let stopLine = 0;\n\n        for (let i = previousLine - 1; i > 0; i--) {\n          if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n            continue;\n          }\n\n          stopLine = i;\n          break;\n        }\n\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n          action: null,\n          line: stopLine + 1\n        };\n      }\n\n      if (honorIntentialIndent) {\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n          action: null,\n          line: precedingUnIgnoredLine\n        };\n      } else {\n        // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n        for (let i = precedingUnIgnoredLine; i > 0; i--) {\n          const lineContent = model.getLineContent(i);\n\n          if (indentRulesSupport.shouldIncrease(lineContent)) {\n            return {\n              indentation: strings.getLeadingWhitespace(lineContent),\n              action: IndentAction.Indent,\n              line: i\n            };\n          } else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n            let stopLine = 0;\n\n            for (let j = i - 1; j > 0; j--) {\n              if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                continue;\n              }\n\n              stopLine = j;\n              break;\n            }\n\n            return {\n              indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n              action: null,\n              line: stopLine + 1\n            };\n          } else if (indentRulesSupport.shouldDecrease(lineContent)) {\n            return {\n              indentation: strings.getLeadingWhitespace(lineContent),\n              action: null,\n              line: i\n            };\n          }\n        }\n\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n          action: null,\n          line: 1\n        };\n      }\n    }\n  }\n\n  getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\n    if (autoIndent < 4\n    /* Full */\n    ) {\n      return null;\n    }\n\n    const richEditSupport = this.getLanguageConfiguration(languageId);\n\n    if (!richEditSupport) {\n      return null;\n    }\n\n    const indentRulesSupport = this.getIndentRulesSupport(languageId);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\n    const lineContent = virtualModel.getLineContent(lineNumber);\n\n    if (indent) {\n      const inheritLine = indent.line;\n\n      if (inheritLine !== undefined) {\n        const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n\n        if (enterResult) {\n          let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n\n          if (enterResult.removeText) {\n            indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n          }\n\n          if (enterResult.indentAction === IndentAction.Indent || enterResult.indentAction === IndentAction.IndentOutdent) {\n            indentation = indentConverter.shiftIndent(indentation);\n          } else if (enterResult.indentAction === IndentAction.Outdent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n          }\n\n          if (indentRulesSupport.shouldDecrease(lineContent)) {\n            indentation = indentConverter.unshiftIndent(indentation);\n          }\n\n          if (enterResult.appendText) {\n            indentation += enterResult.appendText;\n          }\n\n          return strings.getLeadingWhitespace(indentation);\n        }\n      }\n\n      if (indentRulesSupport.shouldDecrease(lineContent)) {\n        if (indent.action === IndentAction.Indent) {\n          return indent.indentation;\n        } else {\n          return indentConverter.unshiftIndent(indent.indentation);\n        }\n      } else {\n        if (indent.action === IndentAction.Indent) {\n          return indentConverter.shiftIndent(indent.indentation);\n        } else {\n          return indent.indentation;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  getIndentForEnter(autoIndent, model, range, indentConverter) {\n    if (autoIndent < 4\n    /* Full */\n    ) {\n      return null;\n    }\n\n    model.forceTokenization(range.startLineNumber);\n    const lineTokens = model.getLineTokens(range.startLineNumber);\n    const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n    const scopedLineText = scopedLineTokens.getLineContent();\n    let embeddedLanguage = false;\n    let beforeEnterText;\n\n    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n      // we are in the embeded language content\n      embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n\n      beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n    }\n\n    let afterEnterText;\n\n    if (range.isEmpty()) {\n      afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n\n    const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    const beforeEnterResult = beforeEnterText;\n    const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n    const virtualModel = {\n      getLineTokens: lineNumber => {\n        return model.getLineTokens(lineNumber);\n      },\n      getLanguageId: () => {\n        return model.getLanguageId();\n      },\n      getLanguageIdAtPosition: (lineNumber, column) => {\n        return model.getLanguageIdAtPosition(lineNumber, column);\n      },\n      getLineContent: lineNumber => {\n        if (lineNumber === range.startLineNumber) {\n          return beforeEnterResult;\n        } else {\n          return model.getLineContent(lineNumber);\n        }\n      }\n    };\n    const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n    const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\n\n    if (!afterEnterAction) {\n      const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n      return {\n        beforeEnter: beforeEnter,\n        afterEnter: beforeEnter\n      };\n    }\n\n    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n\n    if (afterEnterAction.action === IndentAction.Indent) {\n      afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n\n    if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n      afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n\n    return {\n      beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n      afterEnter: afterEnterIndent\n    };\n  }\n  /**\n   * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n   * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n   */\n\n\n  getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\n    if (autoIndent < 4\n    /* Full */\n    ) {\n      return null;\n    }\n\n    const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n\n    if (scopedLineTokens.firstCharOffset) {\n      // this line has mixed languages and indentation rules will not work\n      return null;\n    }\n\n    const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset); // selection support\n\n    let afterTypeText;\n\n    if (range.isEmpty()) {\n      afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    } // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n\n\n    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n      // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n      // 1. Get inherited indent action\n      const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\n\n      if (!r) {\n        return null;\n      }\n\n      let indentation = r.indentation;\n\n      if (r.action !== IndentAction.Indent) {\n        indentation = indentConverter.unshiftIndent(indentation);\n      }\n\n      return indentation;\n    }\n\n    return null;\n  }\n\n  getIndentMetadata(model, lineNumber) {\n    const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n      return null;\n    }\n\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n  } // end Indent Rules\n  // begin onEnter\n\n\n  getEnterAction(autoIndent, model, range) {\n    const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    const richEditSupport = this.getLanguageConfiguration(scopedLineTokens.languageId);\n\n    if (!richEditSupport) {\n      return null;\n    }\n\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset); // selection support\n\n    let afterEnterText;\n\n    if (range.isEmpty()) {\n      afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n\n    let previousLineText = '';\n\n    if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n      // This is not the first line and the entire line belongs to this mode\n      const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\n\n      if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n        // The line above ends with text belonging to the same mode\n        previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n      }\n    }\n\n    const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n\n    if (!enterResult) {\n      return null;\n    }\n\n    const indentAction = enterResult.indentAction;\n    let appendText = enterResult.appendText;\n    const removeText = enterResult.removeText || 0; // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n\n    if (!appendText) {\n      if (indentAction === IndentAction.Indent || indentAction === IndentAction.IndentOutdent) {\n        appendText = '\\t';\n      } else {\n        appendText = '';\n      }\n    } else if (indentAction === IndentAction.Indent) {\n      appendText = '\\t' + appendText;\n    }\n\n    let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n\n    if (removeText) {\n      indentation = indentation.substring(0, indentation.length - removeText);\n    }\n\n    return {\n      indentAction: indentAction,\n      appendText: appendText,\n      removeText: removeText,\n      indentation: indentation\n    };\n  }\n\n  getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n\n    if (indentation.length > column - 1) {\n      indentation = indentation.substring(0, column - 1);\n    }\n\n    return indentation;\n  }\n\n  getScopedLineTokens(model, lineNumber, columnNumber) {\n    model.forceTokenization(lineNumber);\n    const lineTokens = model.getLineTokens(lineNumber);\n    const column = typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;\n    return createScopedLineTokens(lineTokens, column);\n  }\n\n}\n/**\n * @deprecated Use ILanguageConfigurationService instead.\n*/\n\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\n\nclass ComposedLanguageConfiguration {\n  constructor(languageId) {\n    this.languageId = languageId;\n    this._resolved = null;\n    this._entries = [];\n    this._order = 0;\n    this._resolved = null;\n  }\n\n  register(configuration, priority) {\n    const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n\n    this._entries.push(entry);\n\n    this._resolved = null;\n    return toDisposable(() => {\n      for (let i = 0; i < this._entries.length; i++) {\n        if (this._entries[i] === entry) {\n          this._entries.splice(i, 1);\n\n          this._resolved = null;\n          break;\n        }\n      }\n    });\n  }\n\n  getResolvedConfiguration() {\n    if (!this._resolved) {\n      const config = this._resolve();\n\n      if (config) {\n        this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n      }\n    }\n\n    return this._resolved;\n  }\n\n  _resolve() {\n    if (this._entries.length === 0) {\n      return null;\n    }\n\n    this._entries.sort(LanguageConfigurationContribution.cmp);\n\n    return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n  }\n\n}\n\nfunction combineLanguageConfigurations(configs) {\n  let result = {\n    comments: undefined,\n    brackets: undefined,\n    wordPattern: undefined,\n    indentationRules: undefined,\n    onEnterRules: undefined,\n    autoClosingPairs: undefined,\n    surroundingPairs: undefined,\n    autoCloseBefore: undefined,\n    folding: undefined,\n    colorizedBracketPairs: undefined,\n    __electricCharacterSupport: undefined\n  };\n\n  for (const entry of configs) {\n    result = {\n      comments: entry.comments || result.comments,\n      brackets: entry.brackets || result.brackets,\n      wordPattern: entry.wordPattern || result.wordPattern,\n      indentationRules: entry.indentationRules || result.indentationRules,\n      onEnterRules: entry.onEnterRules || result.onEnterRules,\n      autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n      surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n      autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n      folding: entry.folding || result.folding,\n      colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n      __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport\n    };\n  }\n\n  return result;\n}\n\nclass LanguageConfigurationContribution {\n  constructor(configuration, priority, order) {\n    this.configuration = configuration;\n    this.priority = priority;\n    this.order = order;\n  }\n\n  static cmp(a, b) {\n    if (a.priority === b.priority) {\n      // higher order last\n      return a.order - b.order;\n    } // higher priority last\n\n\n    return a.priority - b.priority;\n  }\n\n}\n/**\n * Immutable.\n*/\n\n\nexport class ResolvedLanguageConfiguration {\n  constructor(languageId, underlyingConfig) {\n    this.languageId = languageId;\n    this.underlyingConfig = underlyingConfig;\n    this._brackets = null;\n    this._electricCharacter = null;\n    this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new OnEnterSupport(this.underlyingConfig) : null;\n    this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n    this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n    this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n    this.indentationRules = this.underlyingConfig.indentationRules;\n\n    if (this.underlyingConfig.indentationRules) {\n      this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n    } else {\n      this.indentRulesSupport = null;\n    }\n\n    this.foldingRules = this.underlyingConfig.folding || {};\n  }\n\n  getWordDefinition() {\n    return ensureValidWordDefinition(this.wordDefinition);\n  }\n\n  get brackets() {\n    if (!this._brackets && this.underlyingConfig.brackets) {\n      this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n    }\n\n    return this._brackets;\n  }\n\n  get electricCharacter() {\n    if (!this._electricCharacter) {\n      this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n    }\n\n    return this._electricCharacter;\n  }\n\n  onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n    if (!this._onEnterSupport) {\n      return null;\n    }\n\n    return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n  }\n\n  getAutoClosingPairs() {\n    return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n  }\n\n  getAutoCloseBeforeSet() {\n    return this.characterPair.getAutoCloseBeforeSet();\n  }\n\n  getSurroundingPairs() {\n    return this.characterPair.getSurroundingPairs();\n  }\n\n  static _handleComments(conf) {\n    const commentRule = conf.comments;\n\n    if (!commentRule) {\n      return null;\n    } // comment configuration\n\n\n    const comments = {};\n\n    if (commentRule.lineComment) {\n      comments.lineCommentToken = commentRule.lineComment;\n    }\n\n    if (commentRule.blockComment) {\n      const [blockStart, blockEnd] = commentRule.blockComment;\n      comments.blockCommentStartToken = blockStart;\n      comments.blockCommentEndToken = blockEnd;\n    }\n\n    return comments;\n  }\n\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService);","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","Emitter","Disposable","toDisposable","strings","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","IndentAction","AutoClosingPairs","createScopedLineTokens","CharacterPairSupport","BracketElectricCharacterSupport","IndentRulesSupport","OnEnterSupport","RichEditBrackets","createDecorator","IConfigurationService","ILanguageService","registerSingleton","LanguageConfigurationServiceChangeEvent","constructor","languageId","affects","ILanguageConfigurationService","LanguageConfigurationService","configurationService","languageService","onDidChangeEmitter","_register","onDidChange","event","configurations","Map","languageConfigKeys","Set","values","customizedLanguageConfigKeys","onDidChangeConfiguration","e","globalConfigChanged","change","keys","some","k","has","localConfigChanged","overrides","filter","overrideLangName","map","clear","fire","undefined","isRegisteredLanguageId","delete","LanguageConfigurationRegistry","getLanguageConfiguration","result","get","computeConfig","set","languageConfig","Error","ResolvedLanguageConfiguration","customizedConfig","getCustomizedLanguageConfig","data","combineLanguageConfigurations","underlyingConfig","config","brackets","colorizedBracketPairs","getValue","overrideIdentifier","validateBracketPairs","Array","isArray","pair","p","LanguageConfigurationChangeEvent","LanguageConfigurationRegistryImpl","_entries","_onDidChange","register","configuration","priority","entries","ComposedLanguageConfiguration","disposable","dispose","getResolvedConfiguration","getComments","value","comments","getIndentRulesSupport","indentRulesSupport","getPrecedingValidLine","model","lineNumber","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","text","getLineContent","shouldIgnore","test","getInheritIndentForLine","autoIndent","honorIntentialIndent","getLanguageId","indentation","action","precedingUnIgnoredLine","precedingUnIgnoredLineContent","shouldIncrease","shouldIndentNextLine","getLeadingWhitespace","Indent","line","shouldDecrease","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","lineContent","j","getGoodIndentForLine","virtualModel","indentConverter","richEditSupport","indent","inheritLine","enterResult","onEnter","removeText","substring","indentAction","IndentOutdent","shiftIndent","Outdent","unshiftIndent","appendText","getIndentForEnter","range","forceTokenization","startLineNumber","lineTokens","getLineTokens","scopedLineTokens","startColumn","scopedLineText","embeddedLanguage","beforeEnterText","firstCharOffset","substr","afterEnterText","isEmpty","endScopedLineTokens","getScopedLineTokens","endLineNumber","endColumn","beforeEnterResult","beforeEnterIndent","column","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","getIndentActionForType","ch","beforeTypeText","afterTypeText","getLineCount","getEnterAction","previousLineText","oneLineAboveScopedLineTokens","getIndentationAtPosition","lineText","columnNumber","getLineMaxColumn","_resolved","_order","entry","LanguageConfigurationContribution","push","splice","_resolve","sort","cmp","configs","wordPattern","indentationRules","onEnterRules","autoClosingPairs","surroundingPairs","autoCloseBefore","folding","__electricCharacterSupport","order","a","b","_brackets","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","foldingRules","getWordDefinition","electricCharacter","getAutoClosingPairs","getAutoCloseBeforeSet","getSurroundingPairs","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from '../services/language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(LanguageConfigurationRegistry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, configurationService, languageService) {\n    let languageConfig = LanguageConfigurationRegistry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            throw new Error('Unexpected languageId');\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistryImpl {\n    constructor() {\n        this._entries = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n    }\n    getComments(languageId) {\n        const value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.comments || null;\n    }\n    // begin Indent Rules\n    getIndentRulesSupport(languageId) {\n        const value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.indentRulesSupport || null;\n    }\n    /**\n     * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n     * Result:\n     * -1: run into the boundary of embedded languages\n     * 0: every line above are invalid\n     * else: nearest preceding line of the same language\n     */\n    getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n        const languageId = model.getLanguageIdAtPosition(lineNumber, 0);\n        if (lineNumber > 1) {\n            let lastLineNumber;\n            let resultLineNumber = -1;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n                    return resultLineNumber;\n                }\n                const text = model.getLineContent(lastLineNumber);\n                if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                    resultLineNumber = lastLineNumber;\n                    continue;\n                }\n                return lastLineNumber;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Get inherited indentation from above lines.\n     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n     * 3. If this line doesn't match any indent rules\n     *   a. check whether the line above it matches indentNextLinePattern\n     *   b. If not, the indent level of this line is the result\n     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n     *\n     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n     */\n    getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber <= 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n        if (precedingUnIgnoredLine < 0) {\n            return null;\n        }\n        else if (precedingUnIgnoredLine < 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n        if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: IndentAction.Indent,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // precedingUnIgnoredLine can not be ignored.\n            // it doesn't increase indent of following lines\n            // it doesn't increase just next line\n            // so current line is not affect by precedingUnIgnoredLine\n            // and then we should get a correct inheritted indentation from above lines\n            if (precedingUnIgnoredLine === 1) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            const previousLine = precedingUnIgnoredLine - 1;\n            const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n            if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) &&\n                (previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */)) {\n                let stopLine = 0;\n                for (let i = previousLine - 1; i > 0; i--) {\n                    if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                        continue;\n                    }\n                    stopLine = i;\n                    break;\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                    action: null,\n                    line: stopLine + 1\n                };\n            }\n            if (honorIntentialIndent) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            else {\n                // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n                for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                    const lineContent = model.getLineContent(i);\n                    if (indentRulesSupport.shouldIncrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: IndentAction.Indent,\n                            line: i\n                        };\n                    }\n                    else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                        let stopLine = 0;\n                        for (let j = i - 1; j > 0; j--) {\n                            if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                                continue;\n                            }\n                            stopLine = j;\n                            break;\n                        }\n                        return {\n                            indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                            action: null,\n                            line: stopLine + 1\n                        };\n                    }\n                    else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: null,\n                            line: i\n                        };\n                    }\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                    action: null,\n                    line: 1\n                };\n            }\n        }\n    }\n    getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const richEditSupport = this.getLanguageConfiguration(languageId);\n        if (!richEditSupport) {\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\n        const lineContent = virtualModel.getLineContent(lineNumber);\n        if (indent) {\n            const inheritLine = indent.line;\n            if (inheritLine !== undefined) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n            if (indentRulesSupport.shouldDecrease(lineContent)) {\n                if (indent.action === IndentAction.Indent) {\n                    return indent.indentation;\n                }\n                else {\n                    return indentConverter.unshiftIndent(indent.indentation);\n                }\n            }\n            else {\n                if (indent.action === IndentAction.Indent) {\n                    return indentConverter.shiftIndent(indent.indentation);\n                }\n                else {\n                    return indent.indentation;\n                }\n            }\n        }\n        return null;\n    }\n    getIndentForEnter(autoIndent, model, range, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        model.forceTokenization(range.startLineNumber);\n        const lineTokens = model.getLineTokens(range.startLineNumber);\n        const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n        const scopedLineText = scopedLineTokens.getLineContent();\n        let embeddedLanguage = false;\n        let beforeEnterText;\n        if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n            // we are in the embeded language content\n            embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n            beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n        }\n        let afterEnterText;\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const beforeEnterResult = beforeEnterText;\n        const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n        const virtualModel = {\n            getLineTokens: (lineNumber) => {\n                return model.getLineTokens(lineNumber);\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n            getLineContent: (lineNumber) => {\n                if (lineNumber === range.startLineNumber) {\n                    return beforeEnterResult;\n                }\n                else {\n                    return model.getLineContent(lineNumber);\n                }\n            }\n        };\n        const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n        const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\n        if (!afterEnterAction) {\n            const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n            return {\n                beforeEnter: beforeEnter,\n                afterEnter: beforeEnter\n            };\n        }\n        let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n        if (afterEnterAction.action === IndentAction.Indent) {\n            afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n        }\n        if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n            afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n        }\n        return {\n            beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n            afterEnter: afterEnterIndent\n        };\n    }\n    /**\n     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n     */\n    getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        if (scopedLineTokens.firstCharOffset) {\n            // this line has mixed languages and indentation rules will not work\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const scopedLineText = scopedLineTokens.getLineContent();\n        const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        // selection support\n        let afterTypeText;\n        if (range.isEmpty()) {\n            afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n        // Users might change the indentation by purpose and we should honor that instead of readjusting.\n        if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n            // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n            // 1. Get inherited indent action\n            const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\n            if (!r) {\n                return null;\n            }\n            let indentation = r.indentation;\n            if (r.action !== IndentAction.Indent) {\n                indentation = indentConverter.unshiftIndent(indentation);\n            }\n            return indentation;\n        }\n        return null;\n    }\n    getIndentMetadata(model, lineNumber) {\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n            return null;\n        }\n        return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n    }\n    // end Indent Rules\n    // begin onEnter\n    getEnterAction(autoIndent, model, range) {\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        const richEditSupport = this.getLanguageConfiguration(scopedLineTokens.languageId);\n        if (!richEditSupport) {\n            return null;\n        }\n        const scopedLineText = scopedLineTokens.getLineContent();\n        const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        // selection support\n        let afterEnterText;\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        let previousLineText = '';\n        if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n            // This is not the first line and the entire line belongs to this mode\n            const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\n            if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n                // The line above ends with text belonging to the same mode\n                previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n            }\n        }\n        const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n        if (!enterResult) {\n            return null;\n        }\n        const indentAction = enterResult.indentAction;\n        let appendText = enterResult.appendText;\n        const removeText = enterResult.removeText || 0;\n        // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n        if (!appendText) {\n            if ((indentAction === IndentAction.Indent) ||\n                (indentAction === IndentAction.IndentOutdent)) {\n                appendText = '\\t';\n            }\n            else {\n                appendText = '';\n            }\n        }\n        else if (indentAction === IndentAction.Indent) {\n            appendText = '\\t' + appendText;\n        }\n        let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        if (removeText) {\n            indentation = indentation.substring(0, indentation.length - removeText);\n        }\n        return {\n            indentAction: indentAction,\n            appendText: appendText,\n            removeText: removeText,\n            indentation: indentation\n        };\n    }\n    getIndentationAtPosition(model, lineNumber, column) {\n        const lineText = model.getLineContent(lineNumber);\n        let indentation = strings.getLeadingWhitespace(lineText);\n        if (indentation.length > column - 1) {\n            indentation = indentation.substring(0, column - 1);\n        }\n        return indentation;\n    }\n    getScopedLineTokens(model, lineNumber, columnNumber) {\n        model.forceTokenization(lineNumber);\n        const lineTokens = model.getLineTokens(lineNumber);\n        const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n        return createScopedLineTokens(lineTokens, column);\n    }\n}\n/**\n * @deprecated Use ILanguageConfigurationService instead.\n*/\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet() {\n        return this.characterPair.getAutoCloseBeforeSet();\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService);\n"]},"metadata":{},"sourceType":"module"}