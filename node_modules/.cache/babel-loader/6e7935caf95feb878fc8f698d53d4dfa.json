{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../../base/common/diff/diff.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\nexport function normalizedInlineCompletionsEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!a || !b) {\n    return false;\n  }\n\n  return a.range.equalsRange(b.range) && a.text === b.text && a.command === b.command;\n}\n/**\n * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n*/\n\nexport function inlineCompletionToGhostText(inlineCompletion, textModel, mode, cursorPosition, previewSuffixLength = 0) {\n  if (inlineCompletion.range.startLineNumber !== inlineCompletion.range.endLineNumber) {\n    // Only single line replacements are supported.\n    return undefined;\n  }\n\n  const sourceLine = textModel.getLineContent(inlineCompletion.range.startLineNumber);\n  const sourceIndentationLength = strings.getLeadingWhitespace(sourceLine).length;\n  const suggestionTouchesIndentation = inlineCompletion.range.startColumn - 1 <= sourceIndentationLength;\n\n  if (suggestionTouchesIndentation) {\n    // source:      ··········[······abc]\n    //                         ^^^^^^^^^ inlineCompletion.range\n    //              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n    //                         ^^^^^^ replacedIndentation.length\n    //                               ^^^ rangeThatDoesNotReplaceIndentation\n    // inlineCompletion.text: '··foo'\n    //                         ^^ suggestionAddedIndentationLength\n    const suggestionAddedIndentationLength = strings.getLeadingWhitespace(inlineCompletion.text).length;\n    const replacedIndentation = sourceLine.substring(inlineCompletion.range.startColumn - 1, sourceIndentationLength);\n    const rangeThatDoesNotReplaceIndentation = Range.fromPositions(inlineCompletion.range.getStartPosition().delta(0, replacedIndentation.length), inlineCompletion.range.getEndPosition());\n    const suggestionWithoutIndentationChange = inlineCompletion.text.startsWith(replacedIndentation) // Adds more indentation without changing existing indentation: We can add ghost text for this\n    ? inlineCompletion.text.substring(replacedIndentation.length) // Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n    : inlineCompletion.text.substring(suggestionAddedIndentationLength);\n    inlineCompletion = {\n      range: rangeThatDoesNotReplaceIndentation,\n      text: suggestionWithoutIndentationChange,\n      command: inlineCompletion.command\n    };\n  } // This is a single line string\n\n\n  const valueToBeReplaced = textModel.getValueInRange(inlineCompletion.range);\n  const changes = cachingDiff(valueToBeReplaced, inlineCompletion.text);\n\n  if (!changes) {\n    // No ghost text in case the diff would be too slow to compute\n    return undefined;\n  }\n\n  const lineNumber = inlineCompletion.range.startLineNumber;\n  const parts = new Array();\n\n  if (mode === 'prefix') {\n    const filteredChanges = changes.filter(c => c.originalLength === 0);\n\n    if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n      // Prefixes only have a single change.\n      return undefined;\n    }\n  }\n\n  const previewStartInCompletionText = inlineCompletion.text.length - previewSuffixLength;\n\n  for (const c of changes) {\n    const insertColumn = inlineCompletion.range.startColumn + c.originalStart + c.originalLength;\n\n    if (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === inlineCompletion.range.startLineNumber && insertColumn < cursorPosition.column) {\n      // No ghost text before cursor\n      return undefined;\n    }\n\n    if (c.originalLength > 0) {\n      return undefined;\n    }\n\n    if (c.modifiedLength === 0) {\n      continue;\n    }\n\n    const modifiedEnd = c.modifiedStart + c.modifiedLength;\n    const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n    const nonPreviewText = inlineCompletion.text.substring(c.modifiedStart, nonPreviewTextEnd);\n    const italicText = inlineCompletion.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n\n    if (nonPreviewText.length > 0) {\n      const lines = strings.splitLines(nonPreviewText);\n      parts.push(new GhostTextPart(insertColumn, lines, false));\n    }\n\n    if (italicText.length > 0) {\n      const lines = strings.splitLines(italicText);\n      parts.push(new GhostTextPart(insertColumn, lines, true));\n    }\n  }\n\n  return new GhostText(lineNumber, parts, 0);\n}\nlet lastRequest = undefined;\n\nfunction cachingDiff(originalValue, newValue) {\n  if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {\n    return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;\n  } else {\n    const changes = smartDiff(originalValue, newValue);\n    lastRequest = {\n      originalValue,\n      newValue,\n      changes\n    };\n    return changes;\n  }\n}\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\n\n\nfunction smartDiff(originalValue, newValue) {\n  if (originalValue.length > 5000 || newValue.length > 5000) {\n    // We don't want to work on strings that are too big\n    return undefined;\n  }\n\n  function getMaxCharCode(val) {\n    let maxCharCode = 0;\n\n    for (let i = 0, len = val.length; i < len; i++) {\n      const charCode = val.charCodeAt(i);\n\n      if (charCode > maxCharCode) {\n        maxCharCode = charCode;\n      }\n    }\n\n    return maxCharCode;\n  }\n\n  const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n\n  function getUniqueCharCode(id) {\n    if (id < 0) {\n      throw new Error('unexpected');\n    }\n\n    return maxCharCode + id + 1;\n  }\n\n  function getElements(source) {\n    let level = 0;\n    let group = 0;\n    const characters = new Int32Array(source.length);\n\n    for (let i = 0, len = source.length; i < len; i++) {\n      const id = group * 100 + level; // TODO support more brackets\n\n      if (source[i] === '(') {\n        characters[i] = getUniqueCharCode(2 * id);\n        level++;\n      } else if (source[i] === ')') {\n        characters[i] = getUniqueCharCode(2 * id + 1);\n\n        if (level === 1) {\n          group++;\n        }\n\n        level = Math.max(level - 1, 0);\n      } else {\n        characters[i] = source.charCodeAt(i);\n      }\n    }\n\n    return characters;\n  }\n\n  const elements1 = getElements(originalValue);\n  const elements2 = getElements(newValue);\n  return new LcsDiff({\n    getElements: () => elements1\n  }, {\n    getElements: () => elements2\n  }).ComputeDiff(false).changes;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionToGhostText.js"],"names":["LcsDiff","strings","Range","GhostText","GhostTextPart","normalizedInlineCompletionsEquals","a","b","range","equalsRange","text","command","inlineCompletionToGhostText","inlineCompletion","textModel","mode","cursorPosition","previewSuffixLength","startLineNumber","endLineNumber","undefined","sourceLine","getLineContent","sourceIndentationLength","getLeadingWhitespace","length","suggestionTouchesIndentation","startColumn","suggestionAddedIndentationLength","replacedIndentation","substring","rangeThatDoesNotReplaceIndentation","fromPositions","getStartPosition","delta","getEndPosition","suggestionWithoutIndentationChange","startsWith","valueToBeReplaced","getValueInRange","changes","cachingDiff","lineNumber","parts","Array","filteredChanges","filter","c","originalLength","originalStart","previewStartInCompletionText","insertColumn","column","modifiedLength","modifiedEnd","modifiedStart","nonPreviewTextEnd","Math","max","min","nonPreviewText","italicText","lines","splitLines","push","lastRequest","originalValue","newValue","smartDiff","getMaxCharCode","val","maxCharCode","i","len","charCode","charCodeAt","getUniqueCharCode","id","Error","getElements","source","level","group","characters","Int32Array","elements1","elements2","ComputeDiff"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../../base/common/diff/diff.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\nexport function normalizedInlineCompletionsEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (!a || !b) {\n        return false;\n    }\n    return a.range.equalsRange(b.range) && a.text === b.text && a.command === b.command;\n}\n/**\n * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n*/\nexport function inlineCompletionToGhostText(inlineCompletion, textModel, mode, cursorPosition, previewSuffixLength = 0) {\n    if (inlineCompletion.range.startLineNumber !== inlineCompletion.range.endLineNumber) {\n        // Only single line replacements are supported.\n        return undefined;\n    }\n    const sourceLine = textModel.getLineContent(inlineCompletion.range.startLineNumber);\n    const sourceIndentationLength = strings.getLeadingWhitespace(sourceLine).length;\n    const suggestionTouchesIndentation = inlineCompletion.range.startColumn - 1 <= sourceIndentationLength;\n    if (suggestionTouchesIndentation) {\n        // source:      ··········[······abc]\n        //                         ^^^^^^^^^ inlineCompletion.range\n        //              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n        //                         ^^^^^^ replacedIndentation.length\n        //                               ^^^ rangeThatDoesNotReplaceIndentation\n        // inlineCompletion.text: '··foo'\n        //                         ^^ suggestionAddedIndentationLength\n        const suggestionAddedIndentationLength = strings.getLeadingWhitespace(inlineCompletion.text).length;\n        const replacedIndentation = sourceLine.substring(inlineCompletion.range.startColumn - 1, sourceIndentationLength);\n        const rangeThatDoesNotReplaceIndentation = Range.fromPositions(inlineCompletion.range.getStartPosition().delta(0, replacedIndentation.length), inlineCompletion.range.getEndPosition());\n        const suggestionWithoutIndentationChange = inlineCompletion.text.startsWith(replacedIndentation)\n            // Adds more indentation without changing existing indentation: We can add ghost text for this\n            ? inlineCompletion.text.substring(replacedIndentation.length)\n            // Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n            : inlineCompletion.text.substring(suggestionAddedIndentationLength);\n        inlineCompletion = {\n            range: rangeThatDoesNotReplaceIndentation,\n            text: suggestionWithoutIndentationChange,\n            command: inlineCompletion.command\n        };\n    }\n    // This is a single line string\n    const valueToBeReplaced = textModel.getValueInRange(inlineCompletion.range);\n    const changes = cachingDiff(valueToBeReplaced, inlineCompletion.text);\n    if (!changes) {\n        // No ghost text in case the diff would be too slow to compute\n        return undefined;\n    }\n    const lineNumber = inlineCompletion.range.startLineNumber;\n    const parts = new Array();\n    if (mode === 'prefix') {\n        const filteredChanges = changes.filter(c => c.originalLength === 0);\n        if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n            // Prefixes only have a single change.\n            return undefined;\n        }\n    }\n    const previewStartInCompletionText = inlineCompletion.text.length - previewSuffixLength;\n    for (const c of changes) {\n        const insertColumn = inlineCompletion.range.startColumn + c.originalStart + c.originalLength;\n        if (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === inlineCompletion.range.startLineNumber && insertColumn < cursorPosition.column) {\n            // No ghost text before cursor\n            return undefined;\n        }\n        if (c.originalLength > 0) {\n            return undefined;\n        }\n        if (c.modifiedLength === 0) {\n            continue;\n        }\n        const modifiedEnd = c.modifiedStart + c.modifiedLength;\n        const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n        const nonPreviewText = inlineCompletion.text.substring(c.modifiedStart, nonPreviewTextEnd);\n        const italicText = inlineCompletion.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n        if (nonPreviewText.length > 0) {\n            const lines = strings.splitLines(nonPreviewText);\n            parts.push(new GhostTextPart(insertColumn, lines, false));\n        }\n        if (italicText.length > 0) {\n            const lines = strings.splitLines(italicText);\n            parts.push(new GhostTextPart(insertColumn, lines, true));\n        }\n    }\n    return new GhostText(lineNumber, parts, 0);\n}\nlet lastRequest = undefined;\nfunction cachingDiff(originalValue, newValue) {\n    if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {\n        return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;\n    }\n    else {\n        const changes = smartDiff(originalValue, newValue);\n        lastRequest = {\n            originalValue,\n            newValue,\n            changes\n        };\n        return changes;\n    }\n}\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue, newValue) {\n    if (originalValue.length > 5000 || newValue.length > 5000) {\n        // We don't want to work on strings that are too big\n        return undefined;\n    }\n    function getMaxCharCode(val) {\n        let maxCharCode = 0;\n        for (let i = 0, len = val.length; i < len; i++) {\n            const charCode = val.charCodeAt(i);\n            if (charCode > maxCharCode) {\n                maxCharCode = charCode;\n            }\n        }\n        return maxCharCode;\n    }\n    const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n    function getUniqueCharCode(id) {\n        if (id < 0) {\n            throw new Error('unexpected');\n        }\n        return maxCharCode + id + 1;\n    }\n    function getElements(source) {\n        let level = 0;\n        let group = 0;\n        const characters = new Int32Array(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            const id = group * 100 + level;\n            // TODO support more brackets\n            if (source[i] === '(') {\n                characters[i] = getUniqueCharCode(2 * id);\n                level++;\n            }\n            else if (source[i] === ')') {\n                characters[i] = getUniqueCharCode(2 * id + 1);\n                if (level === 1) {\n                    group++;\n                }\n                level = Math.max(level - 1, 0);\n            }\n            else {\n                characters[i] = source.charCodeAt(i);\n            }\n        }\n        return characters;\n    }\n    const elements1 = getElements(originalValue);\n    const elements2 = getElements(newValue);\n    return new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\n}\n"]},"metadata":{},"sourceType":"module"}