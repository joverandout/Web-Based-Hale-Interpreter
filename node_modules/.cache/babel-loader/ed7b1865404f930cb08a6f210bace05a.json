{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorWorkerClient } from './editorWorkerService.js';\nimport * as types from '../../../base/common/types.js';\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\n\nexport function createWebWorker(modelService, languageConfigurationService, opts) {\n  return new MonacoWebWorkerImpl(modelService, languageConfigurationService, opts);\n}\n\nclass MonacoWebWorkerImpl extends EditorWorkerClient {\n  constructor(modelService, languageConfigurationService, opts) {\n    super(modelService, opts.keepIdleModels || false, opts.label, languageConfigurationService);\n    this._foreignModuleId = opts.moduleId;\n    this._foreignModuleCreateData = opts.createData || null;\n    this._foreignModuleHost = opts.host || null;\n    this._foreignProxy = null;\n  } // foreign host request\n\n\n  fhr(method, args) {\n    if (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n      return Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n    }\n\n    try {\n      return Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  _getForeignProxy() {\n    if (!this._foreignProxy) {\n      this._foreignProxy = this._getProxy().then(proxy => {\n        const foreignHostMethods = this._foreignModuleHost ? types.getAllMethodNames(this._foreignModuleHost) : [];\n        return proxy.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then(foreignMethods => {\n          this._foreignModuleCreateData = null;\n\n          const proxyMethodRequest = (method, args) => {\n            return proxy.fmr(method, args);\n          };\n\n          const createProxyMethod = (method, proxyMethodRequest) => {\n            return function () {\n              const args = Array.prototype.slice.call(arguments, 0);\n              return proxyMethodRequest(method, args);\n            };\n          };\n\n          const foreignProxy = {};\n\n          for (const foreignMethod of foreignMethods) {\n            foreignProxy[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);\n          }\n\n          return foreignProxy;\n        });\n      });\n    }\n\n    return this._foreignProxy;\n  }\n\n  getProxy() {\n    return this._getForeignProxy();\n  }\n\n  withSyncedResources(resources) {\n    return this._withSyncedResources(resources).then(_ => this.getProxy());\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/browser/services/webWorker.js"],"names":["EditorWorkerClient","types","createWebWorker","modelService","languageConfigurationService","opts","MonacoWebWorkerImpl","constructor","keepIdleModels","label","_foreignModuleId","moduleId","_foreignModuleCreateData","createData","_foreignModuleHost","host","_foreignProxy","fhr","method","args","Promise","reject","Error","resolve","apply","e","_getForeignProxy","_getProxy","then","proxy","foreignHostMethods","getAllMethodNames","loadForeignModule","foreignMethods","proxyMethodRequest","fmr","createProxyMethod","Array","prototype","slice","call","arguments","foreignProxy","foreignMethod","getProxy","withSyncedResources","resources","_withSyncedResources","_"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorWorkerClient } from './editorWorkerService.js';\nimport * as types from '../../../base/common/types.js';\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker(modelService, languageConfigurationService, opts) {\n    return new MonacoWebWorkerImpl(modelService, languageConfigurationService, opts);\n}\nclass MonacoWebWorkerImpl extends EditorWorkerClient {\n    constructor(modelService, languageConfigurationService, opts) {\n        super(modelService, opts.keepIdleModels || false, opts.label, languageConfigurationService);\n        this._foreignModuleId = opts.moduleId;\n        this._foreignModuleCreateData = opts.createData || null;\n        this._foreignModuleHost = opts.host || null;\n        this._foreignProxy = null;\n    }\n    // foreign host request\n    fhr(method, args) {\n        if (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n            return Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n        }\n        try {\n            return Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    _getForeignProxy() {\n        if (!this._foreignProxy) {\n            this._foreignProxy = this._getProxy().then((proxy) => {\n                const foreignHostMethods = this._foreignModuleHost ? types.getAllMethodNames(this._foreignModuleHost) : [];\n                return proxy.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {\n                    this._foreignModuleCreateData = null;\n                    const proxyMethodRequest = (method, args) => {\n                        return proxy.fmr(method, args);\n                    };\n                    const createProxyMethod = (method, proxyMethodRequest) => {\n                        return function () {\n                            const args = Array.prototype.slice.call(arguments, 0);\n                            return proxyMethodRequest(method, args);\n                        };\n                    };\n                    const foreignProxy = {};\n                    for (const foreignMethod of foreignMethods) {\n                        foreignProxy[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);\n                    }\n                    return foreignProxy;\n                });\n            });\n        }\n        return this._foreignProxy;\n    }\n    getProxy() {\n        return this._getForeignProxy();\n    }\n    withSyncedResources(resources) {\n        return this._withSyncedResources(resources).then(_ => this.getProxy());\n    }\n}\n"]},"metadata":{},"sourceType":"module"}