{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from './cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n  static deleteRight(prevEditOperationType, config, model, selections) {\n    const commands = [];\n    let shouldPushStackElementBefore = prevEditOperationType !== 3\n    /* DeletingRight */\n    ;\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      let deleteSelection = selection;\n\n      if (deleteSelection.isEmpty()) {\n        const position = selection.getPosition();\n        const rightOfPosition = MoveOperations.right(config, model, position);\n        deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n      }\n\n      if (deleteSelection.isEmpty()) {\n        // Probably at end of file => ignore\n        commands[i] = null;\n        continue;\n      }\n\n      if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n        shouldPushStackElementBefore = true;\n      }\n\n      commands[i] = new ReplaceCommand(deleteSelection, '');\n    }\n\n    return [shouldPushStackElementBefore, commands];\n  }\n\n  static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n    if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n      return false;\n    }\n\n    if (autoClosingDelete === 'never') {\n      return false;\n    }\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const position = selection.getPosition();\n\n      if (!selection.isEmpty()) {\n        return false;\n      }\n\n      const lineText = model.getLineContent(position.lineNumber);\n\n      if (position.column < 2 || position.column >= lineText.length + 1) {\n        return false;\n      }\n\n      const character = lineText.charAt(position.column - 2);\n      const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n\n      if (!autoClosingPairCandidates) {\n        return false;\n      }\n\n      if (isQuote(character)) {\n        if (autoClosingQuotes === 'never') {\n          return false;\n        }\n      } else {\n        if (autoClosingBrackets === 'never') {\n          return false;\n        }\n      }\n\n      const afterCharacter = lineText.charAt(position.column - 1);\n      let foundAutoClosingPair = false;\n\n      for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n        if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n          foundAutoClosingPair = true;\n        }\n      }\n\n      if (!foundAutoClosingPair) {\n        return false;\n      } // Must delete the pair only if it was automatically inserted by the editor\n\n\n      if (autoClosingDelete === 'auto') {\n        let found = false;\n\n        for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n          const autoClosedCharacter = autoClosedCharacters[j];\n\n          if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  static _runAutoClosingPairDelete(config, model, selections) {\n    const commands = [];\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const position = selections[i].getPosition();\n      const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n      commands[i] = new ReplaceCommand(deleteSelection, '');\n    }\n\n    return [true, commands];\n  }\n\n  static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n    if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n      return this._runAutoClosingPairDelete(config, model, selections);\n    }\n\n    const commands = [];\n    let shouldPushStackElementBefore = prevEditOperationType !== 2\n    /* DeletingLeft */\n    ;\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config); // Ignore empty delete ranges, as they have no effect\n      // They happen if the cursor is at the beginning of the file.\n\n      if (deleteRange.isEmpty()) {\n        commands[i] = null;\n        continue;\n      }\n\n      if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n        shouldPushStackElementBefore = true;\n      }\n\n      commands[i] = new ReplaceCommand(deleteRange, '');\n    }\n\n    return [shouldPushStackElementBefore, commands];\n  }\n\n  static getDeleteRange(selection, model, config) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n\n    const position = selection.getPosition(); // Unintend when using tab stops and cursor is within indentation\n\n    if (config.useTabStops && position.column > 1) {\n      const lineContent = model.getLineContent(position.lineNumber);\n      const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n      const lastIndentationColumn = firstNonWhitespaceIndex === -1 ?\n      /* entire string is whitespace */\n      lineContent.length + 1 : firstNonWhitespaceIndex + 1;\n\n      if (position.column <= lastIndentationColumn) {\n        const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n        const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n        const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n        return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n      }\n    }\n\n    return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n  }\n\n  static getPositionAfterDeleteLeft(position, model) {\n    if (position.column > 1) {\n      // Convert 1-based columns to 0-based offsets and back.\n      const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n      return position.with(undefined, idx + 1);\n    } else if (position.lineNumber > 1) {\n      const newLine = position.lineNumber - 1;\n      return new Position(newLine, model.getLineMaxColumn(newLine));\n    } else {\n      return position;\n    }\n  }\n\n  static cut(config, model, selections) {\n    const commands = [];\n    let lastCutRange = null;\n    selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n\n      if (selection.isEmpty()) {\n        if (config.emptySelectionClipboard) {\n          // This is a full line cut\n          const position = selection.getPosition();\n          let startLineNumber, startColumn, endLineNumber, endColumn;\n\n          if (position.lineNumber < model.getLineCount()) {\n            // Cutting a line in the middle of the model\n            startLineNumber = position.lineNumber;\n            startColumn = 1;\n            endLineNumber = position.lineNumber + 1;\n            endColumn = 1;\n          } else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n            // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n            startLineNumber = position.lineNumber - 1;\n            startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n            endLineNumber = position.lineNumber;\n            endColumn = model.getLineMaxColumn(position.lineNumber);\n          } else {\n            // Cutting the single line that the model contains\n            startLineNumber = position.lineNumber;\n            startColumn = 1;\n            endLineNumber = position.lineNumber;\n            endColumn = model.getLineMaxColumn(position.lineNumber);\n          }\n\n          const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n          lastCutRange = deleteSelection;\n\n          if (!deleteSelection.isEmpty()) {\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n          } else {\n            commands[i] = null;\n          }\n        } else {\n          // Cannot cut empty selection\n          commands[i] = null;\n        }\n      } else {\n        commands[i] = new ReplaceCommand(selection, '');\n      }\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js"],"names":["strings","ReplaceCommand","EditOperationResult","isQuote","CursorColumns","MoveOperations","Range","Position","DeleteOperations","deleteRight","prevEditOperationType","config","model","selections","commands","shouldPushStackElementBefore","i","len","length","selection","deleteSelection","isEmpty","position","getPosition","rightOfPosition","right","lineNumber","column","startLineNumber","endLineNumber","isAutoClosingPairDelete","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","autoClosedCharacters","lineText","getLineContent","character","charAt","autoClosingPairCandidates","get","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","open","close","found","j","lenJ","autoClosedCharacter","startColumn","_runAutoClosingPairDelete","deleteLeft","autoClosingPairs","autoClosingPairsOpenByEnd","deleteRange","getDeleteRange","useTabStops","lineContent","firstNonWhitespaceIndex","lastIndentationColumn","fromVisibleColumn","visibleColumnFromColumn","toVisibleColumn","prevIndentTabStop","indentSize","toColumn","columnFromVisibleColumn","fromPositions","getPositionAfterDeleteLeft","idx","getLeftDeleteOffset","with","undefined","newLine","getLineMaxColumn","cut","lastCutRange","sort","a","b","compare","getStartPosition","getEndPosition","emptySelectionClipboard","endColumn","getLineCount","shouldPushStackElementAfter"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from './cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}