{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\n\nexport class RichEditBracket {\n  constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n    this._richEditBracketBrand = undefined;\n    this.languageId = languageId;\n    this.index = index;\n    this.open = open;\n    this.close = close;\n    this.forwardRegex = forwardRegex;\n    this.reversedRegex = reversedRegex;\n    this._openSet = RichEditBracket._toSet(this.open);\n    this._closeSet = RichEditBracket._toSet(this.close);\n  }\n  /**\n   * Check if the provided `text` is an open bracket in this group.\n   */\n\n\n  isOpen(text) {\n    return this._openSet.has(text);\n  }\n  /**\n   * Check if the provided `text` is a close bracket in this group.\n   */\n\n\n  isClose(text) {\n    return this._closeSet.has(text);\n  }\n\n  static _toSet(arr) {\n    const result = new Set();\n\n    for (const element of arr) {\n      result.add(element);\n    }\n\n    return result;\n  }\n\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\n\nfunction groupFuzzyBrackets(brackets) {\n  const N = brackets.length;\n  brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n  const group = [];\n\n  for (let i = 0; i < N; i++) {\n    group[i] = i;\n  }\n\n  const areOverlapping = (a, b) => {\n    const [aOpen, aClose] = a;\n    const [bOpen, bClose] = b;\n    return aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose;\n  };\n\n  const mergeGroups = (g1, g2) => {\n    const newG = Math.min(g1, g2);\n    const oldG = Math.max(g1, g2);\n\n    for (let i = 0; i < N; i++) {\n      if (group[i] === oldG) {\n        group[i] = newG;\n      }\n    }\n  }; // group together brackets that have the same open or the same close sequence\n\n\n  for (let i = 0; i < N; i++) {\n    const a = brackets[i];\n\n    for (let j = i + 1; j < N; j++) {\n      const b = brackets[j];\n\n      if (areOverlapping(a, b)) {\n        mergeGroups(group[i], group[j]);\n      }\n    }\n  }\n\n  const result = [];\n\n  for (let g = 0; g < N; g++) {\n    const currentOpen = [];\n    const currentClose = [];\n\n    for (let i = 0; i < N; i++) {\n      if (group[i] === g) {\n        const [open, close] = brackets[i];\n        currentOpen.push(open);\n        currentClose.push(close);\n      }\n    }\n\n    if (currentOpen.length > 0) {\n      result.push({\n        open: currentOpen,\n        close: currentClose\n      });\n    }\n  }\n\n  return result;\n}\n\nexport class RichEditBrackets {\n  constructor(languageId, _brackets) {\n    this._richEditBracketsBrand = undefined;\n    const brackets = groupFuzzyBrackets(_brackets);\n    this.brackets = brackets.map((b, index) => {\n      return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n    });\n    this.forwardRegex = getRegexForBrackets(this.brackets);\n    this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n    this.textIsBracket = {};\n    this.textIsOpenBracket = {};\n    this.maxBracketLength = 0;\n\n    for (const bracket of this.brackets) {\n      for (const open of bracket.open) {\n        this.textIsBracket[open] = bracket;\n        this.textIsOpenBracket[open] = true;\n        this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n      }\n\n      for (const close of bracket.close) {\n        this.textIsBracket[close] = bracket;\n        this.textIsOpenBracket[close] = false;\n        this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n      }\n    }\n  }\n\n}\n\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n  for (let i = 0, len = brackets.length; i < len; i++) {\n    if (i === currentIndex) {\n      continue;\n    }\n\n    const bracket = brackets[i];\n\n    for (const open of bracket.open) {\n      if (open.indexOf(str) >= 0) {\n        dest.push(open);\n      }\n    }\n\n    for (const close of bracket.close) {\n      if (close.indexOf(str) >= 0) {\n        dest.push(close);\n      }\n    }\n  }\n}\n\nfunction lengthcmp(a, b) {\n  return a.length - b.length;\n}\n\nfunction unique(arr) {\n  if (arr.length <= 1) {\n    return arr;\n  }\n\n  const result = [];\n  const seen = new Set();\n\n  for (const element of arr) {\n    if (seen.has(element)) {\n      continue;\n    }\n\n    result.push(element);\n    seen.add(element);\n  }\n\n  return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\n\n\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n  // search in all brackets for other brackets that are a superstring of these brackets\n  let pieces = [];\n  pieces = pieces.concat(open);\n  pieces = pieces.concat(close);\n\n  for (let i = 0, len = pieces.length; i < len; i++) {\n    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n  }\n\n  pieces = unique(pieces);\n  pieces.sort(lengthcmp);\n  pieces.reverse();\n  return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\n\n\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n  // search in all brackets for other brackets that are a superstring of these brackets\n  let pieces = [];\n  pieces = pieces.concat(open);\n  pieces = pieces.concat(close);\n\n  for (let i = 0, len = pieces.length; i < len; i++) {\n    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n  }\n\n  pieces = unique(pieces);\n  pieces.sort(lengthcmp);\n  pieces.reverse();\n  return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\n\n\nfunction getRegexForBrackets(brackets) {\n  let pieces = [];\n\n  for (const bracket of brackets) {\n    for (const open of bracket.open) {\n      pieces.push(open);\n    }\n\n    for (const close of bracket.close) {\n      pieces.push(close);\n    }\n  }\n\n  pieces = unique(pieces);\n  return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\n\n\nfunction getReversedRegexForBrackets(brackets) {\n  let pieces = [];\n\n  for (const bracket of brackets) {\n    for (const open of bracket.open) {\n      pieces.push(open);\n    }\n\n    for (const close of bracket.close) {\n      pieces.push(close);\n    }\n  }\n\n  pieces = unique(pieces);\n  return createBracketOrRegExp(pieces.map(toReversedString));\n}\n\nfunction prepareBracketForRegExp(str) {\n  // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n  const insertWordBoundaries = /^[\\w ]+$/.test(str);\n  str = strings.escapeRegExpCharacters(str);\n  return insertWordBoundaries ? `\\\\b${str}\\\\b` : str;\n}\n\nfunction createBracketOrRegExp(pieces) {\n  const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n  return strings.createRegExp(regexStr, true);\n}\n\nconst toReversedString = function () {\n  function reverse(str) {\n    if (stringBuilder.hasTextDecoder) {\n      // create a Uint16Array and then use a TextDecoder to create a string\n      const arr = new Uint16Array(str.length);\n      let offset = 0;\n\n      for (let i = str.length - 1; i >= 0; i--) {\n        arr[offset++] = str.charCodeAt(i);\n      }\n\n      return stringBuilder.getPlatformTextDecoder().decode(arr);\n    } else {\n      const result = [];\n      let resultLen = 0;\n\n      for (let i = str.length - 1; i >= 0; i--) {\n        result[resultLen++] = str.charAt(i);\n      }\n\n      return result.join('');\n    }\n  }\n\n  let lastInput = null;\n  let lastOutput = null;\n  return function toReversedString(str) {\n    if (lastInput !== str) {\n      lastInput = str;\n      lastOutput = reverse(lastInput);\n    }\n\n    return lastOutput;\n  };\n}();\n\nexport class BracketsUtils {\n  static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n    const m = reversedText.match(reversedBracketRegex);\n\n    if (!m) {\n      return null;\n    }\n\n    const matchOffset = reversedText.length - (m.index || 0);\n    const matchLength = m[0].length;\n    const absoluteMatchOffset = offset + matchOffset;\n    return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n  }\n\n  static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n    // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n    const reversedLineText = toReversedString(lineText);\n    const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n    return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n  }\n\n  static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n    const m = text.match(bracketRegex);\n\n    if (!m) {\n      return null;\n    }\n\n    const matchOffset = m.index || 0;\n    const matchLength = m[0].length;\n\n    if (matchLength === 0) {\n      return null;\n    }\n\n    const absoluteMatchOffset = offset + matchOffset;\n    return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n  }\n\n  static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n    const substr = lineText.substring(startOffset, endOffset);\n    return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js"],"names":["strings","stringBuilder","Range","RichEditBracket","constructor","languageId","index","open","close","forwardRegex","reversedRegex","_richEditBracketBrand","undefined","_openSet","_toSet","_closeSet","isOpen","text","has","isClose","arr","result","Set","element","add","groupFuzzyBrackets","brackets","N","length","map","b","toLowerCase","group","i","areOverlapping","a","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","Math","min","oldG","max","j","g","currentOpen","currentClose","push","RichEditBrackets","_brackets","_richEditBracketsBrand","getRegexForBracketPair","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","textIsOpenBracket","maxBracketLength","bracket","collectSuperstrings","str","currentIndex","dest","len","indexOf","lengthcmp","unique","seen","pieces","concat","sort","reverse","createBracketOrRegExp","toReversedString","prepareBracketForRegExp","insertWordBoundaries","test","escapeRegExpCharacters","regexStr","join","createRegExp","hasTextDecoder","Uint16Array","offset","charCodeAt","getPlatformTextDecoder","decode","resultLen","charAt","lastInput","lastOutput","BracketsUtils","_findPrevBracketInText","reversedBracketRegex","lineNumber","reversedText","m","match","matchOffset","matchLength","absoluteMatchOffset","findPrevBracketInRange","lineText","startOffset","endOffset","reversedLineText","reversedSubstr","substring","findNextBracketInText","bracketRegex","findNextBracketInRange","substr"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAZ,MAAyB,oCAAzB;AACA,OAAO,KAAKC,aAAZ,MAA+B,6BAA/B;AACA,SAASC,KAAT,QAAsB,qBAAtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,eAAN,CAAsB;AACzBC,EAAAA,WAAW,CAACC,UAAD,EAAaC,KAAb,EAAoBC,IAApB,EAA0BC,KAA1B,EAAiCC,YAAjC,EAA+CC,aAA/C,EAA8D;AACrE,SAAKC,qBAAL,GAA6BC,SAA7B;AACA,SAAKP,UAAL,GAAkBA,UAAlB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKG,QAAL,GAAgBV,eAAe,CAACW,MAAhB,CAAuB,KAAKP,IAA5B,CAAhB;AACA,SAAKQ,SAAL,GAAiBZ,eAAe,CAACW,MAAhB,CAAuB,KAAKN,KAA5B,CAAjB;AACH;AACD;AACJ;AACA;;;AACIQ,EAAAA,MAAM,CAACC,IAAD,EAAO;AACT,WAAO,KAAKJ,QAAL,CAAcK,GAAd,CAAkBD,IAAlB,CAAP;AACH;AACD;AACJ;AACA;;;AACIE,EAAAA,OAAO,CAACF,IAAD,EAAO;AACV,WAAO,KAAKF,SAAL,CAAeG,GAAf,CAAmBD,IAAnB,CAAP;AACH;;AACY,SAANH,MAAM,CAACM,GAAD,EAAM;AACf,UAAMC,MAAM,GAAG,IAAIC,GAAJ,EAAf;;AACA,SAAK,MAAMC,OAAX,IAAsBH,GAAtB,EAA2B;AACvBC,MAAAA,MAAM,CAACG,GAAP,CAAWD,OAAX;AACH;;AACD,WAAOF,MAAP;AACH;;AA9BwB;AAgC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASI,kBAAT,CAA4BC,QAA5B,EAAsC;AAClC,QAAMC,CAAC,GAAGD,QAAQ,CAACE,MAAnB;AACAF,EAAAA,QAAQ,GAAGA,QAAQ,CAACG,GAAT,CAAaC,CAAC,IAAI,CAACA,CAAC,CAAC,CAAD,CAAD,CAAKC,WAAL,EAAD,EAAqBD,CAAC,CAAC,CAAD,CAAD,CAAKC,WAAL,EAArB,CAAlB,CAAX;AACA,QAAMC,KAAK,GAAG,EAAd;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,CAApB,EAAuBM,CAAC,EAAxB,EAA4B;AACxBD,IAAAA,KAAK,CAACC,CAAD,CAAL,GAAWA,CAAX;AACH;;AACD,QAAMC,cAAc,GAAG,CAACC,CAAD,EAAIL,CAAJ,KAAU;AAC7B,UAAM,CAACM,KAAD,EAAQC,MAAR,IAAkBF,CAAxB;AACA,UAAM,CAACG,KAAD,EAAQC,MAAR,IAAkBT,CAAxB;AACA,WAAQM,KAAK,KAAKE,KAAV,IAAmBF,KAAK,KAAKG,MAA7B,IAAuCF,MAAM,KAAKC,KAAlD,IAA2DD,MAAM,KAAKE,MAA9E;AACH,GAJD;;AAKA,QAAMC,WAAW,GAAG,CAACC,EAAD,EAAKC,EAAL,KAAY;AAC5B,UAAMC,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASJ,EAAT,EAAaC,EAAb,CAAb;AACA,UAAMI,IAAI,GAAGF,IAAI,CAACG,GAAL,CAASN,EAAT,EAAaC,EAAb,CAAb;;AACA,SAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,CAApB,EAAuBM,CAAC,EAAxB,EAA4B;AACxB,UAAID,KAAK,CAACC,CAAD,CAAL,KAAaa,IAAjB,EAAuB;AACnBd,QAAAA,KAAK,CAACC,CAAD,CAAL,GAAWU,IAAX;AACH;AACJ;AACJ,GARD,CAZkC,CAqBlC;;;AACA,OAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,CAApB,EAAuBM,CAAC,EAAxB,EAA4B;AACxB,UAAME,CAAC,GAAGT,QAAQ,CAACO,CAAD,CAAlB;;AACA,SAAK,IAAIe,CAAC,GAAGf,CAAC,GAAG,CAAjB,EAAoBe,CAAC,GAAGrB,CAAxB,EAA2BqB,CAAC,EAA5B,EAAgC;AAC5B,YAAMlB,CAAC,GAAGJ,QAAQ,CAACsB,CAAD,CAAlB;;AACA,UAAId,cAAc,CAACC,CAAD,EAAIL,CAAJ,CAAlB,EAA0B;AACtBU,QAAAA,WAAW,CAACR,KAAK,CAACC,CAAD,CAAN,EAAWD,KAAK,CAACgB,CAAD,CAAhB,CAAX;AACH;AACJ;AACJ;;AACD,QAAM3B,MAAM,GAAG,EAAf;;AACA,OAAK,IAAI4B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,CAApB,EAAuBsB,CAAC,EAAxB,EAA4B;AACxB,UAAMC,WAAW,GAAG,EAApB;AACA,UAAMC,YAAY,GAAG,EAArB;;AACA,SAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,CAApB,EAAuBM,CAAC,EAAxB,EAA4B;AACxB,UAAID,KAAK,CAACC,CAAD,CAAL,KAAagB,CAAjB,EAAoB;AAChB,cAAM,CAAC1C,IAAD,EAAOC,KAAP,IAAgBkB,QAAQ,CAACO,CAAD,CAA9B;AACAiB,QAAAA,WAAW,CAACE,IAAZ,CAAiB7C,IAAjB;AACA4C,QAAAA,YAAY,CAACC,IAAb,CAAkB5C,KAAlB;AACH;AACJ;;AACD,QAAI0C,WAAW,CAACtB,MAAZ,GAAqB,CAAzB,EAA4B;AACxBP,MAAAA,MAAM,CAAC+B,IAAP,CAAY;AACR7C,QAAAA,IAAI,EAAE2C,WADE;AAER1C,QAAAA,KAAK,EAAE2C;AAFC,OAAZ;AAIH;AACJ;;AACD,SAAO9B,MAAP;AACH;;AACD,OAAO,MAAMgC,gBAAN,CAAuB;AAC1BjD,EAAAA,WAAW,CAACC,UAAD,EAAaiD,SAAb,EAAwB;AAC/B,SAAKC,sBAAL,GAA8B3C,SAA9B;AACA,UAAMc,QAAQ,GAAGD,kBAAkB,CAAC6B,SAAD,CAAnC;AACA,SAAK5B,QAAL,GAAgBA,QAAQ,CAACG,GAAT,CAAa,CAACC,CAAD,EAAIxB,KAAJ,KAAc;AACvC,aAAO,IAAIH,eAAJ,CAAoBE,UAApB,EAAgCC,KAAhC,EAAuCwB,CAAC,CAACvB,IAAzC,EAA+CuB,CAAC,CAACtB,KAAjD,EAAwDgD,sBAAsB,CAAC1B,CAAC,CAACvB,IAAH,EAASuB,CAAC,CAACtB,KAAX,EAAkBkB,QAAlB,EAA4BpB,KAA5B,CAA9E,EAAkHmD,8BAA8B,CAAC3B,CAAC,CAACvB,IAAH,EAASuB,CAAC,CAACtB,KAAX,EAAkBkB,QAAlB,EAA4BpB,KAA5B,CAAhJ,CAAP;AACH,KAFe,CAAhB;AAGA,SAAKG,YAAL,GAAoBiD,mBAAmB,CAAC,KAAKhC,QAAN,CAAvC;AACA,SAAKhB,aAAL,GAAqBiD,2BAA2B,CAAC,KAAKjC,QAAN,CAAhD;AACA,SAAKkC,aAAL,GAAqB,EAArB;AACA,SAAKC,iBAAL,GAAyB,EAAzB;AACA,SAAKC,gBAAL,GAAwB,CAAxB;;AACA,SAAK,MAAMC,OAAX,IAAsB,KAAKrC,QAA3B,EAAqC;AACjC,WAAK,MAAMnB,IAAX,IAAmBwD,OAAO,CAACxD,IAA3B,EAAiC;AAC7B,aAAKqD,aAAL,CAAmBrD,IAAnB,IAA2BwD,OAA3B;AACA,aAAKF,iBAAL,CAAuBtD,IAAvB,IAA+B,IAA/B;AACA,aAAKuD,gBAAL,GAAwBlB,IAAI,CAACG,GAAL,CAAS,KAAKe,gBAAd,EAAgCvD,IAAI,CAACqB,MAArC,CAAxB;AACH;;AACD,WAAK,MAAMpB,KAAX,IAAoBuD,OAAO,CAACvD,KAA5B,EAAmC;AAC/B,aAAKoD,aAAL,CAAmBpD,KAAnB,IAA4BuD,OAA5B;AACA,aAAKF,iBAAL,CAAuBrD,KAAvB,IAAgC,KAAhC;AACA,aAAKsD,gBAAL,GAAwBlB,IAAI,CAACG,GAAL,CAAS,KAAKe,gBAAd,EAAgCtD,KAAK,CAACoB,MAAtC,CAAxB;AACH;AACJ;AACJ;;AAxByB;;AA0B9B,SAASoC,mBAAT,CAA6BC,GAA7B,EAAkCvC,QAAlC,EAA4CwC,YAA5C,EAA0DC,IAA1D,EAAgE;AAC5D,OAAK,IAAIlC,CAAC,GAAG,CAAR,EAAWmC,GAAG,GAAG1C,QAAQ,CAACE,MAA/B,EAAuCK,CAAC,GAAGmC,GAA3C,EAAgDnC,CAAC,EAAjD,EAAqD;AACjD,QAAIA,CAAC,KAAKiC,YAAV,EAAwB;AACpB;AACH;;AACD,UAAMH,OAAO,GAAGrC,QAAQ,CAACO,CAAD,CAAxB;;AACA,SAAK,MAAM1B,IAAX,IAAmBwD,OAAO,CAACxD,IAA3B,EAAiC;AAC7B,UAAIA,IAAI,CAAC8D,OAAL,CAAaJ,GAAb,KAAqB,CAAzB,EAA4B;AACxBE,QAAAA,IAAI,CAACf,IAAL,CAAU7C,IAAV;AACH;AACJ;;AACD,SAAK,MAAMC,KAAX,IAAoBuD,OAAO,CAACvD,KAA5B,EAAmC;AAC/B,UAAIA,KAAK,CAAC6D,OAAN,CAAcJ,GAAd,KAAsB,CAA1B,EAA6B;AACzBE,QAAAA,IAAI,CAACf,IAAL,CAAU5C,KAAV;AACH;AACJ;AACJ;AACJ;;AACD,SAAS8D,SAAT,CAAmBnC,CAAnB,EAAsBL,CAAtB,EAAyB;AACrB,SAAOK,CAAC,CAACP,MAAF,GAAWE,CAAC,CAACF,MAApB;AACH;;AACD,SAAS2C,MAAT,CAAgBnD,GAAhB,EAAqB;AACjB,MAAIA,GAAG,CAACQ,MAAJ,IAAc,CAAlB,EAAqB;AACjB,WAAOR,GAAP;AACH;;AACD,QAAMC,MAAM,GAAG,EAAf;AACA,QAAMmD,IAAI,GAAG,IAAIlD,GAAJ,EAAb;;AACA,OAAK,MAAMC,OAAX,IAAsBH,GAAtB,EAA2B;AACvB,QAAIoD,IAAI,CAACtD,GAAL,CAASK,OAAT,CAAJ,EAAuB;AACnB;AACH;;AACDF,IAAAA,MAAM,CAAC+B,IAAP,CAAY7B,OAAZ;AACAiD,IAAAA,IAAI,CAAChD,GAAL,CAASD,OAAT;AACH;;AACD,SAAOF,MAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmC,sBAAT,CAAgCjD,IAAhC,EAAsCC,KAAtC,EAA6CkB,QAA7C,EAAuDwC,YAAvD,EAAqE;AACjE;AACA,MAAIO,MAAM,GAAG,EAAb;AACAA,EAAAA,MAAM,GAAGA,MAAM,CAACC,MAAP,CAAcnE,IAAd,CAAT;AACAkE,EAAAA,MAAM,GAAGA,MAAM,CAACC,MAAP,CAAclE,KAAd,CAAT;;AACA,OAAK,IAAIyB,CAAC,GAAG,CAAR,EAAWmC,GAAG,GAAGK,MAAM,CAAC7C,MAA7B,EAAqCK,CAAC,GAAGmC,GAAzC,EAA8CnC,CAAC,EAA/C,EAAmD;AAC/C+B,IAAAA,mBAAmB,CAACS,MAAM,CAACxC,CAAD,CAAP,EAAYP,QAAZ,EAAsBwC,YAAtB,EAAoCO,MAApC,CAAnB;AACH;;AACDA,EAAAA,MAAM,GAAGF,MAAM,CAACE,MAAD,CAAf;AACAA,EAAAA,MAAM,CAACE,IAAP,CAAYL,SAAZ;AACAG,EAAAA,MAAM,CAACG,OAAP;AACA,SAAOC,qBAAqB,CAACJ,MAAD,CAA5B;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAShB,8BAAT,CAAwClD,IAAxC,EAA8CC,KAA9C,EAAqDkB,QAArD,EAA+DwC,YAA/D,EAA6E;AACzE;AACA,MAAIO,MAAM,GAAG,EAAb;AACAA,EAAAA,MAAM,GAAGA,MAAM,CAACC,MAAP,CAAcnE,IAAd,CAAT;AACAkE,EAAAA,MAAM,GAAGA,MAAM,CAACC,MAAP,CAAclE,KAAd,CAAT;;AACA,OAAK,IAAIyB,CAAC,GAAG,CAAR,EAAWmC,GAAG,GAAGK,MAAM,CAAC7C,MAA7B,EAAqCK,CAAC,GAAGmC,GAAzC,EAA8CnC,CAAC,EAA/C,EAAmD;AAC/C+B,IAAAA,mBAAmB,CAACS,MAAM,CAACxC,CAAD,CAAP,EAAYP,QAAZ,EAAsBwC,YAAtB,EAAoCO,MAApC,CAAnB;AACH;;AACDA,EAAAA,MAAM,GAAGF,MAAM,CAACE,MAAD,CAAf;AACAA,EAAAA,MAAM,CAACE,IAAP,CAAYL,SAAZ;AACAG,EAAAA,MAAM,CAACG,OAAP;AACA,SAAOC,qBAAqB,CAACJ,MAAM,CAAC5C,GAAP,CAAWiD,gBAAX,CAAD,CAA5B;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASpB,mBAAT,CAA6BhC,QAA7B,EAAuC;AACnC,MAAI+C,MAAM,GAAG,EAAb;;AACA,OAAK,MAAMV,OAAX,IAAsBrC,QAAtB,EAAgC;AAC5B,SAAK,MAAMnB,IAAX,IAAmBwD,OAAO,CAACxD,IAA3B,EAAiC;AAC7BkE,MAAAA,MAAM,CAACrB,IAAP,CAAY7C,IAAZ;AACH;;AACD,SAAK,MAAMC,KAAX,IAAoBuD,OAAO,CAACvD,KAA5B,EAAmC;AAC/BiE,MAAAA,MAAM,CAACrB,IAAP,CAAY5C,KAAZ;AACH;AACJ;;AACDiE,EAAAA,MAAM,GAAGF,MAAM,CAACE,MAAD,CAAf;AACA,SAAOI,qBAAqB,CAACJ,MAAD,CAA5B;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASd,2BAAT,CAAqCjC,QAArC,EAA+C;AAC3C,MAAI+C,MAAM,GAAG,EAAb;;AACA,OAAK,MAAMV,OAAX,IAAsBrC,QAAtB,EAAgC;AAC5B,SAAK,MAAMnB,IAAX,IAAmBwD,OAAO,CAACxD,IAA3B,EAAiC;AAC7BkE,MAAAA,MAAM,CAACrB,IAAP,CAAY7C,IAAZ;AACH;;AACD,SAAK,MAAMC,KAAX,IAAoBuD,OAAO,CAACvD,KAA5B,EAAmC;AAC/BiE,MAAAA,MAAM,CAACrB,IAAP,CAAY5C,KAAZ;AACH;AACJ;;AACDiE,EAAAA,MAAM,GAAGF,MAAM,CAACE,MAAD,CAAf;AACA,SAAOI,qBAAqB,CAACJ,MAAM,CAAC5C,GAAP,CAAWiD,gBAAX,CAAD,CAA5B;AACH;;AACD,SAASC,uBAAT,CAAiCd,GAAjC,EAAsC;AAClC;AACA,QAAMe,oBAAoB,GAAI,WAAWC,IAAX,CAAgBhB,GAAhB,CAA9B;AACAA,EAAAA,GAAG,GAAGjE,OAAO,CAACkF,sBAAR,CAA+BjB,GAA/B,CAAN;AACA,SAAQe,oBAAoB,GAAI,MAAKf,GAAI,KAAb,GAAoBA,GAAhD;AACH;;AACD,SAASY,qBAAT,CAA+BJ,MAA/B,EAAuC;AACnC,QAAMU,QAAQ,GAAI,IAAGV,MAAM,CAAC5C,GAAP,CAAWkD,uBAAX,EAAoCK,IAApC,CAAyC,KAAzC,CAAgD,GAArE;AACA,SAAOpF,OAAO,CAACqF,YAAR,CAAqBF,QAArB,EAA+B,IAA/B,CAAP;AACH;;AACD,MAAML,gBAAgB,GAAI,YAAY;AAClC,WAASF,OAAT,CAAiBX,GAAjB,EAAsB;AAClB,QAAIhE,aAAa,CAACqF,cAAlB,EAAkC;AAC9B;AACA,YAAMlE,GAAG,GAAG,IAAImE,WAAJ,CAAgBtB,GAAG,CAACrC,MAApB,CAAZ;AACA,UAAI4D,MAAM,GAAG,CAAb;;AACA,WAAK,IAAIvD,CAAC,GAAGgC,GAAG,CAACrC,MAAJ,GAAa,CAA1B,EAA6BK,CAAC,IAAI,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;AACtCb,QAAAA,GAAG,CAACoE,MAAM,EAAP,CAAH,GAAgBvB,GAAG,CAACwB,UAAJ,CAAexD,CAAf,CAAhB;AACH;;AACD,aAAOhC,aAAa,CAACyF,sBAAd,GAAuCC,MAAvC,CAA8CvE,GAA9C,CAAP;AACH,KARD,MASK;AACD,YAAMC,MAAM,GAAG,EAAf;AACA,UAAIuE,SAAS,GAAG,CAAhB;;AACA,WAAK,IAAI3D,CAAC,GAAGgC,GAAG,CAACrC,MAAJ,GAAa,CAA1B,EAA6BK,CAAC,IAAI,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;AACtCZ,QAAAA,MAAM,CAACuE,SAAS,EAAV,CAAN,GAAsB3B,GAAG,CAAC4B,MAAJ,CAAW5D,CAAX,CAAtB;AACH;;AACD,aAAOZ,MAAM,CAAC+D,IAAP,CAAY,EAAZ,CAAP;AACH;AACJ;;AACD,MAAIU,SAAS,GAAG,IAAhB;AACA,MAAIC,UAAU,GAAG,IAAjB;AACA,SAAO,SAASjB,gBAAT,CAA0Bb,GAA1B,EAA+B;AAClC,QAAI6B,SAAS,KAAK7B,GAAlB,EAAuB;AACnB6B,MAAAA,SAAS,GAAG7B,GAAZ;AACA8B,MAAAA,UAAU,GAAGnB,OAAO,CAACkB,SAAD,CAApB;AACH;;AACD,WAAOC,UAAP;AACH,GAND;AAOH,CA7BwB,EAAzB;;AA8BA,OAAO,MAAMC,aAAN,CAAoB;AACM,SAAtBC,sBAAsB,CAACC,oBAAD,EAAuBC,UAAvB,EAAmCC,YAAnC,EAAiDZ,MAAjD,EAAyD;AAClF,UAAMa,CAAC,GAAGD,YAAY,CAACE,KAAb,CAAmBJ,oBAAnB,CAAV;;AACA,QAAI,CAACG,CAAL,EAAQ;AACJ,aAAO,IAAP;AACH;;AACD,UAAME,WAAW,GAAGH,YAAY,CAACxE,MAAb,IAAuByE,CAAC,CAAC/F,KAAF,IAAW,CAAlC,CAApB;AACA,UAAMkG,WAAW,GAAGH,CAAC,CAAC,CAAD,CAAD,CAAKzE,MAAzB;AACA,UAAM6E,mBAAmB,GAAGjB,MAAM,GAAGe,WAArC;AACA,WAAO,IAAIrG,KAAJ,CAAUiG,UAAV,EAAsBM,mBAAmB,GAAGD,WAAtB,GAAoC,CAA1D,EAA6DL,UAA7D,EAAyEM,mBAAmB,GAAG,CAA/F,CAAP;AACH;;AAC4B,SAAtBC,sBAAsB,CAACR,oBAAD,EAAuBC,UAAvB,EAAmCQ,QAAnC,EAA6CC,WAA7C,EAA0DC,SAA1D,EAAqE;AAC9F;AACA,UAAMC,gBAAgB,GAAGhC,gBAAgB,CAAC6B,QAAD,CAAzC;AACA,UAAMI,cAAc,GAAGD,gBAAgB,CAACE,SAAjB,CAA2BL,QAAQ,CAAC/E,MAAT,GAAkBiF,SAA7C,EAAwDF,QAAQ,CAAC/E,MAAT,GAAkBgF,WAA1E,CAAvB;AACA,WAAO,KAAKX,sBAAL,CAA4BC,oBAA5B,EAAkDC,UAAlD,EAA8DY,cAA9D,EAA8EH,WAA9E,CAAP;AACH;;AAC2B,SAArBK,qBAAqB,CAACC,YAAD,EAAef,UAAf,EAA2BlF,IAA3B,EAAiCuE,MAAjC,EAAyC;AACjE,UAAMa,CAAC,GAAGpF,IAAI,CAACqF,KAAL,CAAWY,YAAX,CAAV;;AACA,QAAI,CAACb,CAAL,EAAQ;AACJ,aAAO,IAAP;AACH;;AACD,UAAME,WAAW,GAAGF,CAAC,CAAC/F,KAAF,IAAW,CAA/B;AACA,UAAMkG,WAAW,GAAGH,CAAC,CAAC,CAAD,CAAD,CAAKzE,MAAzB;;AACA,QAAI4E,WAAW,KAAK,CAApB,EAAuB;AACnB,aAAO,IAAP;AACH;;AACD,UAAMC,mBAAmB,GAAGjB,MAAM,GAAGe,WAArC;AACA,WAAO,IAAIrG,KAAJ,CAAUiG,UAAV,EAAsBM,mBAAmB,GAAG,CAA5C,EAA+CN,UAA/C,EAA2DM,mBAAmB,GAAG,CAAtB,GAA0BD,WAArF,CAAP;AACH;;AAC4B,SAAtBW,sBAAsB,CAACD,YAAD,EAAef,UAAf,EAA2BQ,QAA3B,EAAqCC,WAArC,EAAkDC,SAAlD,EAA6D;AACtF,UAAMO,MAAM,GAAGT,QAAQ,CAACK,SAAT,CAAmBJ,WAAnB,EAAgCC,SAAhC,CAAf;AACA,WAAO,KAAKI,qBAAL,CAA2BC,YAA3B,EAAyCf,UAAzC,EAAqDiB,MAArD,EAA6DR,WAA7D,CAAP;AACH;;AAjCsB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        if (stringBuilder.hasTextDecoder) {\n            // create a Uint16Array and then use a TextDecoder to create a string\n            const arr = new Uint16Array(str.length);\n            let offset = 0;\n            for (let i = str.length - 1; i >= 0; i--) {\n                arr[offset++] = str.charCodeAt(i);\n            }\n            return stringBuilder.getPlatformTextDecoder().decode(arr);\n        }\n        else {\n            const result = [];\n            let resultLen = 0;\n            for (let i = str.length - 1; i >= 0; i--) {\n                result[resultLen++] = str.charAt(i);\n            }\n            return result.join('');\n        }\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}