{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './selections.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { editorInactiveSelection, editorSelectionBackground, editorSelectionForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\n\nclass HorizontalRangeWithStyle {\n  constructor(other) {\n    this.left = other.left;\n    this.width = other.width;\n    this.startStyle = null;\n    this.endStyle = null;\n  }\n\n}\n\nclass LineVisibleRangesWithStyle {\n  constructor(lineNumber, ranges) {\n    this.lineNumber = lineNumber;\n    this.ranges = ranges;\n  }\n\n}\n\nfunction toStyledRange(item) {\n  return new HorizontalRangeWithStyle(item);\n}\n\nfunction toStyled(item) {\n  return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));\n}\n\nexport class SelectionsOverlay extends DynamicViewOverlay {\n  constructor(context) {\n    super();\n    this._previousFrameVisibleRangesWithStyle = [];\n    this._context = context;\n    const options = this._context.configuration.options;\n    this._lineHeight = options.get(59\n    /* lineHeight */\n    );\n    this._roundedSelection = options.get(90\n    /* roundedSelection */\n    );\n    this._typicalHalfwidthCharacterWidth = options.get(44\n    /* fontInfo */\n    ).typicalHalfwidthCharacterWidth;\n    this._selections = [];\n    this._renderResult = null;\n\n    this._context.addEventHandler(this);\n  }\n\n  dispose() {\n    this._context.removeEventHandler(this);\n\n    this._renderResult = null;\n    super.dispose();\n  } // --- begin event handlers\n\n\n  onConfigurationChanged(e) {\n    const options = this._context.configuration.options;\n    this._lineHeight = options.get(59\n    /* lineHeight */\n    );\n    this._roundedSelection = options.get(90\n    /* roundedSelection */\n    );\n    this._typicalHalfwidthCharacterWidth = options.get(44\n    /* fontInfo */\n    ).typicalHalfwidthCharacterWidth;\n    return true;\n  }\n\n  onCursorStateChanged(e) {\n    this._selections = e.selections.slice(0);\n    return true;\n  }\n\n  onDecorationsChanged(e) {\n    // true for inline decorations that can end up relayouting text\n    return true; //e.inlineDecorationsChanged;\n  }\n\n  onFlushed(e) {\n    return true;\n  }\n\n  onLinesChanged(e) {\n    return true;\n  }\n\n  onLinesDeleted(e) {\n    return true;\n  }\n\n  onLinesInserted(e) {\n    return true;\n  }\n\n  onScrollChanged(e) {\n    return e.scrollTopChanged;\n  }\n\n  onZonesChanged(e) {\n    return true;\n  } // --- end event handlers\n\n\n  _visibleRangesHaveGaps(linesVisibleRanges) {\n    for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {\n      const lineVisibleRanges = linesVisibleRanges[i];\n\n      if (lineVisibleRanges.ranges.length > 1) {\n        // There are two ranges on the same line\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _enrichVisibleRangesWithStyle(viewport, linesVisibleRanges, previousFrame) {\n    const epsilon = this._typicalHalfwidthCharacterWidth / 4;\n    let previousFrameTop = null;\n    let previousFrameBottom = null;\n\n    if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {\n      const topLineNumber = linesVisibleRanges[0].lineNumber;\n\n      if (topLineNumber === viewport.startLineNumber) {\n        for (let i = 0; !previousFrameTop && i < previousFrame.length; i++) {\n          if (previousFrame[i].lineNumber === topLineNumber) {\n            previousFrameTop = previousFrame[i].ranges[0];\n          }\n        }\n      }\n\n      const bottomLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;\n\n      if (bottomLineNumber === viewport.endLineNumber) {\n        for (let i = previousFrame.length - 1; !previousFrameBottom && i >= 0; i--) {\n          if (previousFrame[i].lineNumber === bottomLineNumber) {\n            previousFrameBottom = previousFrame[i].ranges[0];\n          }\n        }\n      }\n\n      if (previousFrameTop && !previousFrameTop.startStyle) {\n        previousFrameTop = null;\n      }\n\n      if (previousFrameBottom && !previousFrameBottom.startStyle) {\n        previousFrameBottom = null;\n      }\n    }\n\n    for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {\n      // We know for a fact that there is precisely one range on each line\n      const curLineRange = linesVisibleRanges[i].ranges[0];\n      const curLeft = curLineRange.left;\n      const curRight = curLineRange.left + curLineRange.width;\n      const startStyle = {\n        top: 0\n        /* EXTERN */\n        ,\n        bottom: 0\n        /* EXTERN */\n\n      };\n      const endStyle = {\n        top: 0\n        /* EXTERN */\n        ,\n        bottom: 0\n        /* EXTERN */\n\n      };\n\n      if (i > 0) {\n        // Look above\n        const prevLeft = linesVisibleRanges[i - 1].ranges[0].left;\n        const prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;\n\n        if (abs(curLeft - prevLeft) < epsilon) {\n          startStyle.top = 2\n          /* FLAT */\n          ;\n        } else if (curLeft > prevLeft) {\n          startStyle.top = 1\n          /* INTERN */\n          ;\n        }\n\n        if (abs(curRight - prevRight) < epsilon) {\n          endStyle.top = 2\n          /* FLAT */\n          ;\n        } else if (prevLeft < curRight && curRight < prevRight) {\n          endStyle.top = 1\n          /* INTERN */\n          ;\n        }\n      } else if (previousFrameTop) {\n        // Accept some hiccups near the viewport edges to save on repaints\n        startStyle.top = previousFrameTop.startStyle.top;\n        endStyle.top = previousFrameTop.endStyle.top;\n      }\n\n      if (i + 1 < len) {\n        // Look below\n        const nextLeft = linesVisibleRanges[i + 1].ranges[0].left;\n        const nextRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width;\n\n        if (abs(curLeft - nextLeft) < epsilon) {\n          startStyle.bottom = 2\n          /* FLAT */\n          ;\n        } else if (nextLeft < curLeft && curLeft < nextRight) {\n          startStyle.bottom = 1\n          /* INTERN */\n          ;\n        }\n\n        if (abs(curRight - nextRight) < epsilon) {\n          endStyle.bottom = 2\n          /* FLAT */\n          ;\n        } else if (curRight < nextRight) {\n          endStyle.bottom = 1\n          /* INTERN */\n          ;\n        }\n      } else if (previousFrameBottom) {\n        // Accept some hiccups near the viewport edges to save on repaints\n        startStyle.bottom = previousFrameBottom.startStyle.bottom;\n        endStyle.bottom = previousFrameBottom.endStyle.bottom;\n      }\n\n      curLineRange.startStyle = startStyle;\n      curLineRange.endStyle = endStyle;\n    }\n  }\n\n  _getVisibleRangesWithStyle(selection, ctx, previousFrame) {\n    const _linesVisibleRanges = ctx.linesVisibleRangesForRange(selection, true) || [];\n\n    const linesVisibleRanges = _linesVisibleRanges.map(toStyled);\n\n    const visibleRangesHaveGaps = this._visibleRangesHaveGaps(linesVisibleRanges);\n\n    if (!visibleRangesHaveGaps && this._roundedSelection) {\n      this._enrichVisibleRangesWithStyle(ctx.visibleRange, linesVisibleRanges, previousFrame);\n    } // The visible ranges are sorted TOP-BOTTOM and LEFT-RIGHT\n\n\n    return linesVisibleRanges;\n  }\n\n  _createSelectionPiece(top, height, className, left, width) {\n    return '<div class=\"cslr ' + className + '\" style=\"top:' + top.toString() + 'px;left:' + left.toString() + 'px;width:' + width.toString() + 'px;height:' + height + 'px;\"></div>';\n  }\n\n  _actualRenderOneSelection(output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {\n    if (visibleRanges.length === 0) {\n      return;\n    }\n\n    const visibleRangesHaveStyle = !!visibleRanges[0].ranges[0].startStyle;\n\n    const fullLineHeight = this._lineHeight.toString();\n\n    const reducedLineHeight = (this._lineHeight - 1).toString();\n    const firstLineNumber = visibleRanges[0].lineNumber;\n    const lastLineNumber = visibleRanges[visibleRanges.length - 1].lineNumber;\n\n    for (let i = 0, len = visibleRanges.length; i < len; i++) {\n      const lineVisibleRanges = visibleRanges[i];\n      const lineNumber = lineVisibleRanges.lineNumber;\n      const lineIndex = lineNumber - visibleStartLineNumber;\n      const lineHeight = hasMultipleSelections ? lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight : fullLineHeight;\n      const top = hasMultipleSelections ? lineNumber === firstLineNumber ? 1 : 0 : 0;\n      let innerCornerOutput = '';\n      let restOfSelectionOutput = '';\n\n      for (let j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {\n        const visibleRange = lineVisibleRanges.ranges[j];\n\n        if (visibleRangesHaveStyle) {\n          const startStyle = visibleRange.startStyle;\n          const endStyle = visibleRange.endStyle;\n\n          if (startStyle.top === 1\n          /* INTERN */\n          || startStyle.bottom === 1\n          /* INTERN */\n          ) {\n            // Reverse rounded corner to the left\n            // First comes the selection (blue layer)\n            innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH); // Second comes the background (white layer) with inverse border radius\n\n            let className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n\n            if (startStyle.top === 1\n            /* INTERN */\n            ) {\n              className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n            }\n\n            if (startStyle.bottom === 1\n            /* INTERN */\n            ) {\n              className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n            }\n\n            innerCornerOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n          }\n\n          if (endStyle.top === 1\n          /* INTERN */\n          || endStyle.bottom === 1\n          /* INTERN */\n          ) {\n            // Reverse rounded corner to the right\n            // First comes the selection (blue layer)\n            innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH); // Second comes the background (white layer) with inverse border radius\n\n            let className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n\n            if (endStyle.top === 1\n            /* INTERN */\n            ) {\n              className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n            }\n\n            if (endStyle.bottom === 1\n            /* INTERN */\n            ) {\n              className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n            }\n\n            innerCornerOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n          }\n        }\n\n        let className = SelectionsOverlay.SELECTION_CLASS_NAME;\n\n        if (visibleRangesHaveStyle) {\n          const startStyle = visibleRange.startStyle;\n          const endStyle = visibleRange.endStyle;\n\n          if (startStyle.top === 0\n          /* EXTERN */\n          ) {\n            className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n          }\n\n          if (startStyle.bottom === 0\n          /* EXTERN */\n          ) {\n            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n          }\n\n          if (endStyle.top === 0\n          /* EXTERN */\n          ) {\n            className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n          }\n\n          if (endStyle.bottom === 0\n          /* EXTERN */\n          ) {\n            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n          }\n        }\n\n        restOfSelectionOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left, visibleRange.width);\n      }\n\n      output2[lineIndex][0] += innerCornerOutput;\n      output2[lineIndex][1] += restOfSelectionOutput;\n    }\n  }\n\n  prepareRender(ctx) {\n    // Build HTML for inner corners separate from HTML for the rest of selections,\n    // as the inner corner HTML can interfere with that of other selections.\n    // In final render, make sure to place the inner corner HTML before the rest of selection HTML. See issue #77777.\n    const output = [];\n    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n\n    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n      const lineIndex = lineNumber - visibleStartLineNumber;\n      output[lineIndex] = ['', ''];\n    }\n\n    const thisFrameVisibleRangesWithStyle = [];\n\n    for (let i = 0, len = this._selections.length; i < len; i++) {\n      const selection = this._selections[i];\n\n      if (selection.isEmpty()) {\n        thisFrameVisibleRangesWithStyle[i] = null;\n        continue;\n      }\n\n      const visibleRangesWithStyle = this._getVisibleRangesWithStyle(selection, ctx, this._previousFrameVisibleRangesWithStyle[i]);\n\n      thisFrameVisibleRangesWithStyle[i] = visibleRangesWithStyle;\n\n      this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, visibleRangesWithStyle);\n    }\n\n    this._previousFrameVisibleRangesWithStyle = thisFrameVisibleRangesWithStyle;\n    this._renderResult = output.map(([internalCorners, restOfSelection]) => internalCorners + restOfSelection);\n  }\n\n  render(startLineNumber, lineNumber) {\n    if (!this._renderResult) {\n      return '';\n    }\n\n    const lineIndex = lineNumber - startLineNumber;\n\n    if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n      return '';\n    }\n\n    return this._renderResult[lineIndex];\n  }\n\n}\nSelectionsOverlay.SELECTION_CLASS_NAME = 'selected-text';\nSelectionsOverlay.SELECTION_TOP_LEFT = 'top-left-radius';\nSelectionsOverlay.SELECTION_BOTTOM_LEFT = 'bottom-left-radius';\nSelectionsOverlay.SELECTION_TOP_RIGHT = 'top-right-radius';\nSelectionsOverlay.SELECTION_BOTTOM_RIGHT = 'bottom-right-radius';\nSelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = 'monaco-editor-background';\nSelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;\nregisterThemingParticipant((theme, collector) => {\n  const editorSelectionColor = theme.getColor(editorSelectionBackground);\n\n  if (editorSelectionColor) {\n    collector.addRule(`.monaco-editor .focused .selected-text { background-color: ${editorSelectionColor}; }`);\n  }\n\n  const editorInactiveSelectionColor = theme.getColor(editorInactiveSelection);\n\n  if (editorInactiveSelectionColor) {\n    collector.addRule(`.monaco-editor .selected-text { background-color: ${editorInactiveSelectionColor}; }`);\n  }\n\n  const editorSelectionForegroundColor = theme.getColor(editorSelectionForeground);\n\n  if (editorSelectionForegroundColor && !editorSelectionForegroundColor.isTransparent()) {\n    collector.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${editorSelectionForegroundColor}; }`);\n  }\n});\n\nfunction abs(n) {\n  return n < 0 ? -n : n;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/selections/selections.js"],"names":["DynamicViewOverlay","editorInactiveSelection","editorSelectionBackground","editorSelectionForeground","registerThemingParticipant","HorizontalRangeWithStyle","constructor","other","left","width","startStyle","endStyle","LineVisibleRangesWithStyle","lineNumber","ranges","toStyledRange","item","toStyled","map","SelectionsOverlay","context","_previousFrameVisibleRangesWithStyle","_context","options","configuration","_lineHeight","get","_roundedSelection","_typicalHalfwidthCharacterWidth","typicalHalfwidthCharacterWidth","_selections","_renderResult","addEventHandler","dispose","removeEventHandler","onConfigurationChanged","e","onCursorStateChanged","selections","slice","onDecorationsChanged","onFlushed","onLinesChanged","onLinesDeleted","onLinesInserted","onScrollChanged","scrollTopChanged","onZonesChanged","_visibleRangesHaveGaps","linesVisibleRanges","i","len","length","lineVisibleRanges","_enrichVisibleRangesWithStyle","viewport","previousFrame","epsilon","previousFrameTop","previousFrameBottom","topLineNumber","startLineNumber","bottomLineNumber","endLineNumber","curLineRange","curLeft","curRight","top","bottom","prevLeft","prevRight","abs","nextLeft","nextRight","_getVisibleRangesWithStyle","selection","ctx","_linesVisibleRanges","linesVisibleRangesForRange","visibleRangesHaveGaps","visibleRange","_createSelectionPiece","height","className","toString","_actualRenderOneSelection","output2","visibleStartLineNumber","hasMultipleSelections","visibleRanges","visibleRangesHaveStyle","fullLineHeight","reducedLineHeight","firstLineNumber","lastLineNumber","lineIndex","lineHeight","innerCornerOutput","restOfSelectionOutput","j","lenJ","SELECTION_CLASS_NAME","ROUNDED_PIECE_WIDTH","EDITOR_BACKGROUND_CLASS_NAME","SELECTION_TOP_RIGHT","SELECTION_BOTTOM_RIGHT","SELECTION_TOP_LEFT","SELECTION_BOTTOM_LEFT","prepareRender","output","visibleEndLineNumber","thisFrameVisibleRangesWithStyle","isEmpty","visibleRangesWithStyle","internalCorners","restOfSelection","render","theme","collector","editorSelectionColor","getColor","addRule","editorInactiveSelectionColor","editorSelectionForegroundColor","isTransparent","n"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './selections.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { editorInactiveSelection, editorSelectionBackground, editorSelectionForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nclass HorizontalRangeWithStyle {\n    constructor(other) {\n        this.left = other.left;\n        this.width = other.width;\n        this.startStyle = null;\n        this.endStyle = null;\n    }\n}\nclass LineVisibleRangesWithStyle {\n    constructor(lineNumber, ranges) {\n        this.lineNumber = lineNumber;\n        this.ranges = ranges;\n    }\n}\nfunction toStyledRange(item) {\n    return new HorizontalRangeWithStyle(item);\n}\nfunction toStyled(item) {\n    return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));\n}\nexport class SelectionsOverlay extends DynamicViewOverlay {\n    constructor(context) {\n        super();\n        this._previousFrameVisibleRangesWithStyle = [];\n        this._context = context;\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(59 /* lineHeight */);\n        this._roundedSelection = options.get(90 /* roundedSelection */);\n        this._typicalHalfwidthCharacterWidth = options.get(44 /* fontInfo */).typicalHalfwidthCharacterWidth;\n        this._selections = [];\n        this._renderResult = null;\n        this._context.addEventHandler(this);\n    }\n    dispose() {\n        this._context.removeEventHandler(this);\n        this._renderResult = null;\n        super.dispose();\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        this._lineHeight = options.get(59 /* lineHeight */);\n        this._roundedSelection = options.get(90 /* roundedSelection */);\n        this._typicalHalfwidthCharacterWidth = options.get(44 /* fontInfo */).typicalHalfwidthCharacterWidth;\n        return true;\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections.slice(0);\n        return true;\n    }\n    onDecorationsChanged(e) {\n        // true for inline decorations that can end up relayouting text\n        return true; //e.inlineDecorationsChanged;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    _visibleRangesHaveGaps(linesVisibleRanges) {\n        for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {\n            const lineVisibleRanges = linesVisibleRanges[i];\n            if (lineVisibleRanges.ranges.length > 1) {\n                // There are two ranges on the same line\n                return true;\n            }\n        }\n        return false;\n    }\n    _enrichVisibleRangesWithStyle(viewport, linesVisibleRanges, previousFrame) {\n        const epsilon = this._typicalHalfwidthCharacterWidth / 4;\n        let previousFrameTop = null;\n        let previousFrameBottom = null;\n        if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {\n            const topLineNumber = linesVisibleRanges[0].lineNumber;\n            if (topLineNumber === viewport.startLineNumber) {\n                for (let i = 0; !previousFrameTop && i < previousFrame.length; i++) {\n                    if (previousFrame[i].lineNumber === topLineNumber) {\n                        previousFrameTop = previousFrame[i].ranges[0];\n                    }\n                }\n            }\n            const bottomLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;\n            if (bottomLineNumber === viewport.endLineNumber) {\n                for (let i = previousFrame.length - 1; !previousFrameBottom && i >= 0; i--) {\n                    if (previousFrame[i].lineNumber === bottomLineNumber) {\n                        previousFrameBottom = previousFrame[i].ranges[0];\n                    }\n                }\n            }\n            if (previousFrameTop && !previousFrameTop.startStyle) {\n                previousFrameTop = null;\n            }\n            if (previousFrameBottom && !previousFrameBottom.startStyle) {\n                previousFrameBottom = null;\n            }\n        }\n        for (let i = 0, len = linesVisibleRanges.length; i < len; i++) {\n            // We know for a fact that there is precisely one range on each line\n            const curLineRange = linesVisibleRanges[i].ranges[0];\n            const curLeft = curLineRange.left;\n            const curRight = curLineRange.left + curLineRange.width;\n            const startStyle = {\n                top: 0 /* EXTERN */,\n                bottom: 0 /* EXTERN */\n            };\n            const endStyle = {\n                top: 0 /* EXTERN */,\n                bottom: 0 /* EXTERN */\n            };\n            if (i > 0) {\n                // Look above\n                const prevLeft = linesVisibleRanges[i - 1].ranges[0].left;\n                const prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;\n                if (abs(curLeft - prevLeft) < epsilon) {\n                    startStyle.top = 2 /* FLAT */;\n                }\n                else if (curLeft > prevLeft) {\n                    startStyle.top = 1 /* INTERN */;\n                }\n                if (abs(curRight - prevRight) < epsilon) {\n                    endStyle.top = 2 /* FLAT */;\n                }\n                else if (prevLeft < curRight && curRight < prevRight) {\n                    endStyle.top = 1 /* INTERN */;\n                }\n            }\n            else if (previousFrameTop) {\n                // Accept some hiccups near the viewport edges to save on repaints\n                startStyle.top = previousFrameTop.startStyle.top;\n                endStyle.top = previousFrameTop.endStyle.top;\n            }\n            if (i + 1 < len) {\n                // Look below\n                const nextLeft = linesVisibleRanges[i + 1].ranges[0].left;\n                const nextRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width;\n                if (abs(curLeft - nextLeft) < epsilon) {\n                    startStyle.bottom = 2 /* FLAT */;\n                }\n                else if (nextLeft < curLeft && curLeft < nextRight) {\n                    startStyle.bottom = 1 /* INTERN */;\n                }\n                if (abs(curRight - nextRight) < epsilon) {\n                    endStyle.bottom = 2 /* FLAT */;\n                }\n                else if (curRight < nextRight) {\n                    endStyle.bottom = 1 /* INTERN */;\n                }\n            }\n            else if (previousFrameBottom) {\n                // Accept some hiccups near the viewport edges to save on repaints\n                startStyle.bottom = previousFrameBottom.startStyle.bottom;\n                endStyle.bottom = previousFrameBottom.endStyle.bottom;\n            }\n            curLineRange.startStyle = startStyle;\n            curLineRange.endStyle = endStyle;\n        }\n    }\n    _getVisibleRangesWithStyle(selection, ctx, previousFrame) {\n        const _linesVisibleRanges = ctx.linesVisibleRangesForRange(selection, true) || [];\n        const linesVisibleRanges = _linesVisibleRanges.map(toStyled);\n        const visibleRangesHaveGaps = this._visibleRangesHaveGaps(linesVisibleRanges);\n        if (!visibleRangesHaveGaps && this._roundedSelection) {\n            this._enrichVisibleRangesWithStyle(ctx.visibleRange, linesVisibleRanges, previousFrame);\n        }\n        // The visible ranges are sorted TOP-BOTTOM and LEFT-RIGHT\n        return linesVisibleRanges;\n    }\n    _createSelectionPiece(top, height, className, left, width) {\n        return ('<div class=\"cslr '\n            + className\n            + '\" style=\"top:'\n            + top.toString()\n            + 'px;left:'\n            + left.toString()\n            + 'px;width:'\n            + width.toString()\n            + 'px;height:'\n            + height\n            + 'px;\"></div>');\n    }\n    _actualRenderOneSelection(output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {\n        if (visibleRanges.length === 0) {\n            return;\n        }\n        const visibleRangesHaveStyle = !!visibleRanges[0].ranges[0].startStyle;\n        const fullLineHeight = (this._lineHeight).toString();\n        const reducedLineHeight = (this._lineHeight - 1).toString();\n        const firstLineNumber = visibleRanges[0].lineNumber;\n        const lastLineNumber = visibleRanges[visibleRanges.length - 1].lineNumber;\n        for (let i = 0, len = visibleRanges.length; i < len; i++) {\n            const lineVisibleRanges = visibleRanges[i];\n            const lineNumber = lineVisibleRanges.lineNumber;\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            const lineHeight = hasMultipleSelections ? (lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight) : fullLineHeight;\n            const top = hasMultipleSelections ? (lineNumber === firstLineNumber ? 1 : 0) : 0;\n            let innerCornerOutput = '';\n            let restOfSelectionOutput = '';\n            for (let j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {\n                const visibleRange = lineVisibleRanges.ranges[j];\n                if (visibleRangesHaveStyle) {\n                    const startStyle = visibleRange.startStyle;\n                    const endStyle = visibleRange.endStyle;\n                    if (startStyle.top === 1 /* INTERN */ || startStyle.bottom === 1 /* INTERN */) {\n                        // Reverse rounded corner to the left\n                        // First comes the selection (blue layer)\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                        // Second comes the background (white layer) with inverse border radius\n                        let className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n                        if (startStyle.top === 1 /* INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n                        }\n                        if (startStyle.bottom === 1 /* INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n                        }\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                    }\n                    if (endStyle.top === 1 /* INTERN */ || endStyle.bottom === 1 /* INTERN */) {\n                        // Reverse rounded corner to the right\n                        // First comes the selection (blue layer)\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                        // Second comes the background (white layer) with inverse border radius\n                        let className = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n                        if (endStyle.top === 1 /* INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n                        }\n                        if (endStyle.bottom === 1 /* INTERN */) {\n                            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n                        }\n                        innerCornerOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n                    }\n                }\n                let className = SelectionsOverlay.SELECTION_CLASS_NAME;\n                if (visibleRangesHaveStyle) {\n                    const startStyle = visibleRange.startStyle;\n                    const endStyle = visibleRange.endStyle;\n                    if (startStyle.top === 0 /* EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n                    }\n                    if (startStyle.bottom === 0 /* EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n                    }\n                    if (endStyle.top === 0 /* EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n                    }\n                    if (endStyle.bottom === 0 /* EXTERN */) {\n                        className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n                    }\n                }\n                restOfSelectionOutput += this._createSelectionPiece(top, lineHeight, className, visibleRange.left, visibleRange.width);\n            }\n            output2[lineIndex][0] += innerCornerOutput;\n            output2[lineIndex][1] += restOfSelectionOutput;\n        }\n    }\n    prepareRender(ctx) {\n        // Build HTML for inner corners separate from HTML for the rest of selections,\n        // as the inner corner HTML can interfere with that of other selections.\n        // In final render, make sure to place the inner corner HTML before the rest of selection HTML. See issue #77777.\n        const output = [];\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            output[lineIndex] = ['', ''];\n        }\n        const thisFrameVisibleRangesWithStyle = [];\n        for (let i = 0, len = this._selections.length; i < len; i++) {\n            const selection = this._selections[i];\n            if (selection.isEmpty()) {\n                thisFrameVisibleRangesWithStyle[i] = null;\n                continue;\n            }\n            const visibleRangesWithStyle = this._getVisibleRangesWithStyle(selection, ctx, this._previousFrameVisibleRangesWithStyle[i]);\n            thisFrameVisibleRangesWithStyle[i] = visibleRangesWithStyle;\n            this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, visibleRangesWithStyle);\n        }\n        this._previousFrameVisibleRangesWithStyle = thisFrameVisibleRangesWithStyle;\n        this._renderResult = output.map(([internalCorners, restOfSelection]) => internalCorners + restOfSelection);\n    }\n    render(startLineNumber, lineNumber) {\n        if (!this._renderResult) {\n            return '';\n        }\n        const lineIndex = lineNumber - startLineNumber;\n        if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n            return '';\n        }\n        return this._renderResult[lineIndex];\n    }\n}\nSelectionsOverlay.SELECTION_CLASS_NAME = 'selected-text';\nSelectionsOverlay.SELECTION_TOP_LEFT = 'top-left-radius';\nSelectionsOverlay.SELECTION_BOTTOM_LEFT = 'bottom-left-radius';\nSelectionsOverlay.SELECTION_TOP_RIGHT = 'top-right-radius';\nSelectionsOverlay.SELECTION_BOTTOM_RIGHT = 'bottom-right-radius';\nSelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = 'monaco-editor-background';\nSelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;\nregisterThemingParticipant((theme, collector) => {\n    const editorSelectionColor = theme.getColor(editorSelectionBackground);\n    if (editorSelectionColor) {\n        collector.addRule(`.monaco-editor .focused .selected-text { background-color: ${editorSelectionColor}; }`);\n    }\n    const editorInactiveSelectionColor = theme.getColor(editorInactiveSelection);\n    if (editorInactiveSelectionColor) {\n        collector.addRule(`.monaco-editor .selected-text { background-color: ${editorInactiveSelectionColor}; }`);\n    }\n    const editorSelectionForegroundColor = theme.getColor(editorSelectionForeground);\n    if (editorSelectionForegroundColor && !editorSelectionForegroundColor.isTransparent()) {\n        collector.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${editorSelectionForegroundColor}; }`);\n    }\n});\nfunction abs(n) {\n    return n < 0 ? -n : n;\n}\n"]},"metadata":{},"sourceType":"module"}