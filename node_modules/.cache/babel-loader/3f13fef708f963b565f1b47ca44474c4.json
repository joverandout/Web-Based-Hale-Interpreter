{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n  constructor() {\n    this.spacesDiff = 0;\n    this.looksLikeAlignment = false;\n  }\n\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\n\n\nfunction spacesDiff(a, aLength, b, bLength, result) {\n  result.spacesDiff = 0;\n  result.looksLikeAlignment = false; // This can go both ways (e.g.):\n  //  - a: \"\\t\"\n  //  - b: \"\\t    \"\n  //  => This should count 1 tab and 4 spaces\n\n  let i;\n\n  for (i = 0; i < aLength && i < bLength; i++) {\n    const aCharCode = a.charCodeAt(i);\n    const bCharCode = b.charCodeAt(i);\n\n    if (aCharCode !== bCharCode) {\n      break;\n    }\n  }\n\n  let aSpacesCnt = 0,\n      aTabsCount = 0;\n\n  for (let j = i; j < aLength; j++) {\n    const aCharCode = a.charCodeAt(j);\n\n    if (aCharCode === 32\n    /* Space */\n    ) {\n      aSpacesCnt++;\n    } else {\n      aTabsCount++;\n    }\n  }\n\n  let bSpacesCnt = 0,\n      bTabsCount = 0;\n\n  for (let j = i; j < bLength; j++) {\n    const bCharCode = b.charCodeAt(j);\n\n    if (bCharCode === 32\n    /* Space */\n    ) {\n      bSpacesCnt++;\n    } else {\n      bTabsCount++;\n    }\n  }\n\n  if (aSpacesCnt > 0 && aTabsCount > 0) {\n    return;\n  }\n\n  if (bSpacesCnt > 0 && bTabsCount > 0) {\n    return;\n  }\n\n  const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n  const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n\n  if (tabsDiff === 0) {\n    // check if the indentation difference might be caused by alignment reasons\n    // sometime folks like to align their code, but this should not be used as a hint\n    result.spacesDiff = spacesDiff;\n\n    if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n      if (b.charCodeAt(bSpacesCnt) !== 32\n      /* Space */\n      && a.charCodeAt(bSpacesCnt - 1) === 32\n      /* Space */\n      ) {\n        if (a.charCodeAt(a.length - 1) === 44\n        /* Comma */\n        ) {\n          // This looks like an alignment desire: e.g.\n          // const a = b + c,\n          //       d = b - c;\n          result.looksLikeAlignment = true;\n        }\n      }\n    }\n\n    return;\n  }\n\n  if (spacesDiff % tabsDiff === 0) {\n    result.spacesDiff = spacesDiff / tabsDiff;\n    return;\n  }\n}\n\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n  // Look at most at the first 10k lines\n  const linesCount = Math.min(source.getLineCount(), 10000);\n  let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n\n  let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n\n  let previousLineText = ''; // content of latest line that contained non-whitespace chars\n\n  let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n\n  const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n\n  const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n\n  const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n\n  const tmp = new SpacesDiffResult();\n\n  for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n    const currentLineLength = source.getLineLength(lineNumber);\n    const currentLineText = source.getLineContent(lineNumber); // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n    // checking charCode on chunks directly is cheaper.\n\n    const useCurrentLineText = currentLineLength <= 65536;\n    let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n\n    let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n\n    let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n\n    let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n\n    for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n      const charCode = useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j);\n\n      if (charCode === 9\n      /* Tab */\n      ) {\n        currentLineTabsCount++;\n      } else if (charCode === 32\n      /* Space */\n      ) {\n        currentLineSpacesCount++;\n      } else {\n        // Hit non whitespace character on this line\n        currentLineHasContent = true;\n        currentLineIndentation = j;\n        break;\n      }\n    } // Ignore empty or only whitespace lines\n\n\n    if (!currentLineHasContent) {\n      continue;\n    }\n\n    if (currentLineTabsCount > 0) {\n      linesIndentedWithTabsCount++;\n    } else if (currentLineSpacesCount > 1) {\n      linesIndentedWithSpacesCount++;\n    }\n\n    spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n\n    if (tmp.looksLikeAlignment) {\n      // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n      //\n      // - item1\n      //   - item2\n      //\n      // otherwise skip this line entirely\n      //\n      // const a = 1,\n      //       b = 2;\n      if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n        continue;\n      }\n    }\n\n    const currentSpacesDiff = tmp.spacesDiff;\n\n    if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n      spacesDiffCount[currentSpacesDiff]++;\n    }\n\n    previousLineText = currentLineText;\n    previousLineIndentation = currentLineIndentation;\n  }\n\n  let insertSpaces = defaultInsertSpaces;\n\n  if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n    insertSpaces = linesIndentedWithTabsCount < linesIndentedWithSpacesCount;\n  }\n\n  let tabSize = defaultTabSize; // Guess tabSize only if inserting spaces...\n\n  if (insertSpaces) {\n    let tabSizeScore = insertSpaces ? 0 : 0.1 * linesCount; // console.log(\"score threshold: \" + tabSizeScore);\n\n    ALLOWED_TAB_SIZE_GUESSES.forEach(possibleTabSize => {\n      const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n\n      if (possibleTabSizeScore > tabSizeScore) {\n        tabSizeScore = possibleTabSizeScore;\n        tabSize = possibleTabSize;\n      }\n    }); // Let a tabSize of 2 win even if it is not the maximum\n    // (only in case 4 was guessed)\n\n    if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n      tabSize = 2;\n    }\n  } // console.log('--------------------------');\n  // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n  // console.log('spacesDiffCount: ' + spacesDiffCount);\n  // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n\n\n  return {\n    insertSpaces: insertSpaces,\n    tabSize: tabSize\n  };\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js"],"names":["SpacesDiffResult","constructor","spacesDiff","looksLikeAlignment","a","aLength","b","bLength","result","i","aCharCode","charCodeAt","bCharCode","aSpacesCnt","aTabsCount","j","bSpacesCnt","bTabsCount","tabsDiff","Math","abs","length","guessIndentation","source","defaultTabSize","defaultInsertSpaces","linesCount","min","getLineCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineText","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","MAX_ALLOWED_TAB_SIZE_GUESS","spacesDiffCount","tmp","lineNumber","currentLineLength","getLineLength","currentLineText","getLineContent","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","lenJ","charCode","getLineCharCode","currentSpacesDiff","insertSpaces","tabSize","tabSizeScore","forEach","possibleTabSize","possibleTabSizeScore"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n"]},"metadata":{},"sourceType":"module"}