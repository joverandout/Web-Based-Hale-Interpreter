{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from './viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n  if (lineBreakData === null) {\n    // No mapping needed\n    if (isVisible) {\n      return IdentityModelLineProjection.INSTANCE;\n    }\n\n    return HiddenModelLineProjection.INSTANCE;\n  } else {\n    return new ModelLineProjection(lineBreakData, isVisible);\n  }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\n\nclass ModelLineProjection {\n  constructor(lineBreakData, isVisible) {\n    this._projectionData = lineBreakData;\n    this._isVisible = isVisible;\n  }\n\n  isVisible() {\n    return this._isVisible;\n  }\n\n  setVisible(isVisible) {\n    this._isVisible = isVisible;\n    return this;\n  }\n\n  getProjectionData() {\n    return this._projectionData;\n  }\n\n  getViewLineCount() {\n    if (!this._isVisible) {\n      return 0;\n    }\n\n    return this._projectionData.getOutputLineCount();\n  }\n\n  getViewLineContent(model, modelLineNumber, outputLineIndex) {\n    this._assertVisible();\n\n    const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n    const endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n    let r;\n\n    if (this._projectionData.injectionOffsets !== null) {\n      const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));\n\n      const lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n      r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n    } else {\n      r = model.getValueInRange({\n        startLineNumber: modelLineNumber,\n        startColumn: startOffsetInInputWithInjections + 1,\n        endLineNumber: modelLineNumber,\n        endColumn: endOffsetInInputWithInjections + 1\n      });\n    }\n\n    if (outputLineIndex > 0) {\n      r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n    }\n\n    return r;\n  }\n\n  getViewLineLength(model, modelLineNumber, outputLineIndex) {\n    this._assertVisible();\n\n    return this._projectionData.getLineLength(outputLineIndex);\n  }\n\n  getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n    this._assertVisible();\n\n    return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n  }\n\n  getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n    this._assertVisible();\n\n    return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n  }\n  /**\n   * Try using {@link getViewLinesData} instead.\n  */\n\n\n  getViewLineData(model, modelLineNumber, outputLineIndex) {\n    const arr = new Array();\n    this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n    return arr[0];\n  }\n\n  getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n    this._assertVisible();\n\n    const lineBreakData = this._projectionData;\n    const injectionOffsets = lineBreakData.injectionOffsets;\n    const injectionOptions = lineBreakData.injectionOptions;\n    let inlineDecorationsPerOutputLine = null;\n\n    if (injectionOffsets) {\n      inlineDecorationsPerOutputLine = [];\n      let totalInjectedTextLengthBefore = 0;\n      let currentInjectedOffset = 0;\n\n      for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n        const inlineDecorations = new Array();\n        inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n        const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n\n        while (currentInjectedOffset < injectionOffsets.length) {\n          const length = injectionOptions[currentInjectedOffset].content.length;\n          const injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n          const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n\n          if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n            // Injected text only starts in later wrapped lines.\n            break;\n          }\n\n          if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n            // Injected text ends after or in this line (but also starts in or before this line).\n            const options = injectionOptions[currentInjectedOffset];\n\n            if (options.inlineClassName) {\n              const offset = outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0;\n              const start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n              const end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections);\n\n              if (start !== end) {\n                inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n              }\n            }\n          }\n\n          if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n            totalInjectedTextLengthBefore += length;\n            currentInjectedOffset++;\n          } else {\n            // injected text breaks into next line, process it again\n            break;\n          }\n        }\n      }\n    }\n\n    let lineWithInjections;\n\n    if (injectionOffsets) {\n      lineWithInjections = model.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n        offset,\n        text: injectionOptions[idx].content,\n        tokenMetadata: LineTokens.defaultTokenMetadata\n      })));\n    } else {\n      lineWithInjections = model.getLineTokens(modelLineNumber);\n    }\n\n    for (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n      const globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n\n      if (!needed[globalIndex]) {\n        result[globalIndex] = null;\n        continue;\n      }\n\n      result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n    }\n  }\n\n  _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n    this._assertVisible();\n\n    const lineBreakData = this._projectionData;\n    const deltaStartIndex = outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0;\n    const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n    const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n    const tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n    let lineContent = tokens.getLineContent();\n\n    if (outputLineIndex > 0) {\n      lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n    }\n\n    const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    const maxColumn = lineContent.length + 1;\n    const continuesWithWrappedLine = outputLineIndex + 1 < this.getViewLineCount();\n    const startVisibleColumn = outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1];\n    return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n  }\n\n  getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n    this._assertVisible();\n\n    return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n  }\n\n  getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2\n  /* None */\n  ) {\n    this._assertVisible();\n\n    const r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n\n    return r.toPosition(deltaLineNumber);\n  }\n\n  getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n    this._assertVisible();\n\n    const r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n\n    return deltaLineNumber + r.outputLineIndex;\n  }\n\n  normalizePosition(outputLineIndex, outputPosition, affinity) {\n    const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n\n    const normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n\n    const result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n    return result;\n  }\n\n  getInjectedTextAt(outputLineIndex, outputColumn) {\n    return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n  }\n\n  _assertVisible() {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n  }\n\n}\n/**\n * This projection does not change the model line.\n*/\n\n\nclass IdentityModelLineProjection {\n  constructor() {}\n\n  isVisible() {\n    return true;\n  }\n\n  setVisible(isVisible) {\n    if (isVisible) {\n      return this;\n    }\n\n    return HiddenModelLineProjection.INSTANCE;\n  }\n\n  getProjectionData() {\n    return null;\n  }\n\n  getViewLineCount() {\n    return 1;\n  }\n\n  getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineContent(modelLineNumber);\n  }\n\n  getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineLength(modelLineNumber);\n  }\n\n  getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineMinColumn(modelLineNumber);\n  }\n\n  getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineMaxColumn(modelLineNumber);\n  }\n\n  getViewLineData(model, modelLineNumber, _outputLineIndex) {\n    const lineTokens = model.getLineTokens(modelLineNumber);\n    const lineContent = lineTokens.getLineContent();\n    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n  }\n\n  getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n    if (!needed[globalStartIndex]) {\n      result[globalStartIndex] = null;\n      return;\n    }\n\n    result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n  }\n\n  getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n    return outputColumn;\n  }\n\n  getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n    return new Position(deltaLineNumber, inputColumn);\n  }\n\n  getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n    return deltaLineNumber;\n  }\n\n  normalizePosition(outputLineIndex, outputPosition, affinity) {\n    return outputPosition;\n  }\n\n  getInjectedTextAt(_outputLineIndex, _outputColumn) {\n    return null;\n  }\n\n}\n\nIdentityModelLineProjection.INSTANCE = new IdentityModelLineProjection();\n/**\n * This projection hides the model line.\n */\n\nclass HiddenModelLineProjection {\n  constructor() {}\n\n  isVisible() {\n    return false;\n  }\n\n  setVisible(isVisible) {\n    if (!isVisible) {\n      return this;\n    }\n\n    return IdentityModelLineProjection.INSTANCE;\n  }\n\n  getProjectionData() {\n    return null;\n  }\n\n  getViewLineCount() {\n    return 0;\n  }\n\n  getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n\n  getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n\n  getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n\n  getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n\n  getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n\n  getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n    throw new Error('Not supported');\n  }\n\n  getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n    throw new Error('Not supported');\n  }\n\n  getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n    throw new Error('Not supported');\n  }\n\n  getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n    throw new Error('Not supported');\n  }\n\n  normalizePosition(outputLineIndex, outputPosition, affinity) {\n    throw new Error('Not supported');\n  }\n\n  getInjectedTextAt(_outputLineIndex, _outputColumn) {\n    throw new Error('Not supported');\n  }\n\n}\n\nHiddenModelLineProjection.INSTANCE = new HiddenModelLineProjection();\nlet _spaces = [''];\n\nfunction spaces(count) {\n  if (count >= _spaces.length) {\n    for (let i = 1; i <= count; i++) {\n      _spaces[i] = _makeSpaces(i);\n    }\n  }\n\n  return _spaces[count];\n}\n\nfunction _makeSpaces(count) {\n  return new Array(count + 1).join(' ');\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjection.js"],"names":["LineTokens","Position","LineInjectedText","SingleLineInlineDecoration","ViewLineData","createModelLineProjection","lineBreakData","isVisible","IdentityModelLineProjection","INSTANCE","HiddenModelLineProjection","ModelLineProjection","constructor","_projectionData","_isVisible","setVisible","getProjectionData","getViewLineCount","getOutputLineCount","getViewLineContent","model","modelLineNumber","outputLineIndex","_assertVisible","startOffsetInInputWithInjections","breakOffsets","endOffsetInInputWithInjections","r","injectionOffsets","injectedTexts","map","offset","idx","injectionOptions","lineWithInjections","applyInjectedText","getLineContent","substring","getValueInRange","startLineNumber","startColumn","endLineNumber","endColumn","spaces","wrappedTextIndentLength","getViewLineLength","getLineLength","getViewLineMinColumn","_model","_modelLineNumber","getMinOutputOffset","getViewLineMaxColumn","getMaxOutputOffset","getViewLineData","arr","Array","getViewLinesData","outputLineIdx","lineCount","globalStartIndex","needed","result","inlineDecorationsPerOutputLine","totalInjectedTextLengthBefore","currentInjectedOffset","inlineDecorations","lineStartOffsetInInputWithInjections","lineEndOffsetInInputWithInjections","length","content","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","options","inlineClassName","start","Math","max","end","min","push","inlineClassNameAffectsLetterSpacing","getLineTokens","withInserted","text","tokenMetadata","defaultTokenMetadata","globalIndex","_getViewLineData","deltaStartIndex","tokens","sliceAndInflate","lineContent","minColumn","maxColumn","continuesWithWrappedLine","startVisibleColumn","breakOffsetsVisibleColumn","getModelColumnOfViewPosition","outputColumn","translateToInputOffset","getViewPositionOfModelPosition","deltaLineNumber","inputColumn","affinity","translateToOutputPosition","toPosition","getViewLineNumberOfModelPosition","normalizePosition","outputPosition","baseViewLineNumber","lineNumber","normalizedOutputPosition","normalizeOutputPosition","column","getInjectedTextAt","getInjectedText","Error","_outputLineIndex","getLineMinColumn","getLineMaxColumn","lineTokens","inflate","_fromOuputLineIndex","_toOutputLineIndex","_inputColumn","_outputColumn","_globalStartIndex","_needed","_result","_deltaLineNumber","_spaces","count","i","_makeSpaces","join"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from './viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return IdentityModelLineProjection.INSTANCE;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    else {\n        return new ModelLineProjection(lineBreakData, isVisible);\n    }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection {\n    constructor(lineBreakData, isVisible) {\n        this._projectionData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getProjectionData() {\n        return this._projectionData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._projectionData.getOutputLineCount();\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n        let r;\n        if (this._projectionData.injectionOffsets !== null) {\n            const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));\n            const lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n            r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n        }\n        else {\n            r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffsetInInputWithInjections + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffsetInInputWithInjections + 1\n            });\n        }\n        if (outputLineIndex > 0) {\n            r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getLineLength(outputLineIndex);\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n    }\n    /**\n     * Try using {@link getViewLinesData} instead.\n    */\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        const arr = new Array();\n        this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n        return arr[0];\n    }\n    getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const injectionOffsets = lineBreakData.injectionOffsets;\n        const injectionOptions = lineBreakData.injectionOptions;\n        let inlineDecorationsPerOutputLine = null;\n        if (injectionOffsets) {\n            inlineDecorationsPerOutputLine = [];\n            let totalInjectedTextLengthBefore = 0;\n            let currentInjectedOffset = 0;\n            for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n                const inlineDecorations = new Array();\n                inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n                const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n                const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n                while (currentInjectedOffset < injectionOffsets.length) {\n                    const length = injectionOptions[currentInjectedOffset].content.length;\n                    const injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n                    const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n                    if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n                        // Injected text only starts in later wrapped lines.\n                        break;\n                    }\n                    if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n                        // Injected text ends after or in this line (but also starts in or before this line).\n                        const options = injectionOptions[currentInjectedOffset];\n                        if (options.inlineClassName) {\n                            const offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n                            const start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n                            const end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections);\n                            if (start !== end) {\n                                inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                            }\n                        }\n                    }\n                    if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n                        totalInjectedTextLengthBefore += length;\n                        currentInjectedOffset++;\n                    }\n                    else {\n                        // injected text breaks into next line, process it again\n                        break;\n                    }\n                }\n            }\n        }\n        let lineWithInjections;\n        if (injectionOffsets) {\n            lineWithInjections = model.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n                offset,\n                text: injectionOptions[idx].content,\n                tokenMetadata: LineTokens.defaultTokenMetadata\n            })));\n        }\n        else {\n            lineWithInjections = model.getLineTokens(modelLineNumber);\n        }\n        for (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n            const globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n        }\n    }\n    _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n        const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n        const tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n        let lineContent = tokens.getLineContent();\n        if (outputLineIndex > 0) {\n            lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n        const maxColumn = lineContent.length + 1;\n        const continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        this._assertVisible();\n        return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2 /* None */) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n        return r.toPosition(deltaLineNumber);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n        return deltaLineNumber + r.outputLineIndex;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n        const normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n        const result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n        return result;\n    }\n    getInjectedTextAt(outputLineIndex, outputColumn) {\n        return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n    _assertVisible() {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n    }\n}\n/**\n * This projection does not change the model line.\n*/\nclass IdentityModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        const lineTokens = model.getLineTokens(modelLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        return outputPosition;\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        return null;\n    }\n}\nIdentityModelLineProjection.INSTANCE = new IdentityModelLineProjection();\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return IdentityModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        throw new Error('Not supported');\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n}\nHiddenModelLineProjection.INSTANCE = new HiddenModelLineProjection();\nlet _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\n"]},"metadata":{},"sourceType":"module"}