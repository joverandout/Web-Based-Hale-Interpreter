{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as DOM from './dom.js';\nexport function renderText(text, options = {}) {\n  const element = createElement(options);\n  element.textContent = text;\n  return element;\n}\nexport function renderFormattedText(formattedText, options = {}) {\n  const element = createElement(options);\n\n  _renderFormattedText(element, parseFormattedText(formattedText, !!options.renderCodeSegments), options.actionHandler, options.renderCodeSegments);\n\n  return element;\n}\nexport function createElement(options) {\n  const tagName = options.inline ? 'span' : 'div';\n  const element = document.createElement(tagName);\n\n  if (options.className) {\n    element.className = options.className;\n  }\n\n  return element;\n}\n\nclass StringStream {\n  constructor(source) {\n    this.source = source;\n    this.index = 0;\n  }\n\n  eos() {\n    return this.index >= this.source.length;\n  }\n\n  next() {\n    const next = this.peek();\n    this.advance();\n    return next;\n  }\n\n  peek() {\n    return this.source[this.index];\n  }\n\n  advance() {\n    this.index++;\n  }\n\n}\n\nfunction _renderFormattedText(element, treeNode, actionHandler, renderCodeSegments) {\n  let child;\n\n  if (treeNode.type === 2\n  /* Text */\n  ) {\n    child = document.createTextNode(treeNode.content || '');\n  } else if (treeNode.type === 3\n  /* Bold */\n  ) {\n    child = document.createElement('b');\n  } else if (treeNode.type === 4\n  /* Italics */\n  ) {\n    child = document.createElement('i');\n  } else if (treeNode.type === 7\n  /* Code */\n  && renderCodeSegments) {\n    child = document.createElement('code');\n  } else if (treeNode.type === 5\n  /* Action */\n  && actionHandler) {\n    const a = document.createElement('a');\n    actionHandler.disposables.add(DOM.addStandardDisposableListener(a, 'click', event => {\n      actionHandler.callback(String(treeNode.index), event);\n    }));\n    child = a;\n  } else if (treeNode.type === 8\n  /* NewLine */\n  ) {\n    child = document.createElement('br');\n  } else if (treeNode.type === 1\n  /* Root */\n  ) {\n    child = element;\n  }\n\n  if (child && element !== child) {\n    element.appendChild(child);\n  }\n\n  if (child && Array.isArray(treeNode.children)) {\n    treeNode.children.forEach(nodeChild => {\n      _renderFormattedText(child, nodeChild, actionHandler, renderCodeSegments);\n    });\n  }\n}\n\nfunction parseFormattedText(content, parseCodeSegments) {\n  const root = {\n    type: 1\n    /* Root */\n    ,\n    children: []\n  };\n  let actionViewItemIndex = 0;\n  let current = root;\n  const stack = [];\n  const stream = new StringStream(content);\n\n  while (!stream.eos()) {\n    let next = stream.next();\n    const isEscapedFormatType = next === '\\\\' && formatTagType(stream.peek(), parseCodeSegments) !== 0\n    /* Invalid */\n    ;\n\n    if (isEscapedFormatType) {\n      next = stream.next(); // unread the backslash if it escapes a format tag type\n    }\n\n    if (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {\n      stream.advance();\n\n      if (current.type === 2\n      /* Text */\n      ) {\n        current = stack.pop();\n      }\n\n      const type = formatTagType(next, parseCodeSegments);\n\n      if (current.type === type || current.type === 5\n      /* Action */\n      && type === 6\n      /* ActionClose */\n      ) {\n        current = stack.pop();\n      } else {\n        const newCurrent = {\n          type: type,\n          children: []\n        };\n\n        if (type === 5\n        /* Action */\n        ) {\n          newCurrent.index = actionViewItemIndex;\n          actionViewItemIndex++;\n        }\n\n        current.children.push(newCurrent);\n        stack.push(current);\n        current = newCurrent;\n      }\n    } else if (next === '\\n') {\n      if (current.type === 2\n      /* Text */\n      ) {\n        current = stack.pop();\n      }\n\n      current.children.push({\n        type: 8\n        /* NewLine */\n\n      });\n    } else {\n      if (current.type !== 2\n      /* Text */\n      ) {\n        const textCurrent = {\n          type: 2\n          /* Text */\n          ,\n          content: next\n        };\n        current.children.push(textCurrent);\n        stack.push(current);\n        current = textCurrent;\n      } else {\n        current.content += next;\n      }\n    }\n  }\n\n  if (current.type === 2\n  /* Text */\n  ) {\n    current = stack.pop();\n  }\n\n  if (stack.length) {// incorrectly formatted string literal\n  }\n\n  return root;\n}\n\nfunction isFormatTag(char, supportCodeSegments) {\n  return formatTagType(char, supportCodeSegments) !== 0\n  /* Invalid */\n  ;\n}\n\nfunction formatTagType(char, supportCodeSegments) {\n  switch (char) {\n    case '*':\n      return 3\n      /* Bold */\n      ;\n\n    case '_':\n      return 4\n      /* Italics */\n      ;\n\n    case '[':\n      return 5\n      /* Action */\n      ;\n\n    case ']':\n      return 6\n      /* ActionClose */\n      ;\n\n    case '`':\n      return supportCodeSegments ? 7\n      /* Code */\n      : 0\n      /* Invalid */\n      ;\n\n    default:\n      return 0\n      /* Invalid */\n      ;\n  }\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/base/browser/formattedTextRenderer.js"],"names":["DOM","renderText","text","options","element","createElement","textContent","renderFormattedText","formattedText","_renderFormattedText","parseFormattedText","renderCodeSegments","actionHandler","tagName","inline","document","className","StringStream","constructor","source","index","eos","length","next","peek","advance","treeNode","child","type","createTextNode","content","a","disposables","add","addStandardDisposableListener","event","callback","String","appendChild","Array","isArray","children","forEach","nodeChild","parseCodeSegments","root","actionViewItemIndex","current","stack","stream","isEscapedFormatType","formatTagType","isFormatTag","pop","newCurrent","push","textCurrent","char","supportCodeSegments"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as DOM from './dom.js';\nexport function renderText(text, options = {}) {\n    const element = createElement(options);\n    element.textContent = text;\n    return element;\n}\nexport function renderFormattedText(formattedText, options = {}) {\n    const element = createElement(options);\n    _renderFormattedText(element, parseFormattedText(formattedText, !!options.renderCodeSegments), options.actionHandler, options.renderCodeSegments);\n    return element;\n}\nexport function createElement(options) {\n    const tagName = options.inline ? 'span' : 'div';\n    const element = document.createElement(tagName);\n    if (options.className) {\n        element.className = options.className;\n    }\n    return element;\n}\nclass StringStream {\n    constructor(source) {\n        this.source = source;\n        this.index = 0;\n    }\n    eos() {\n        return this.index >= this.source.length;\n    }\n    next() {\n        const next = this.peek();\n        this.advance();\n        return next;\n    }\n    peek() {\n        return this.source[this.index];\n    }\n    advance() {\n        this.index++;\n    }\n}\nfunction _renderFormattedText(element, treeNode, actionHandler, renderCodeSegments) {\n    let child;\n    if (treeNode.type === 2 /* Text */) {\n        child = document.createTextNode(treeNode.content || '');\n    }\n    else if (treeNode.type === 3 /* Bold */) {\n        child = document.createElement('b');\n    }\n    else if (treeNode.type === 4 /* Italics */) {\n        child = document.createElement('i');\n    }\n    else if (treeNode.type === 7 /* Code */ && renderCodeSegments) {\n        child = document.createElement('code');\n    }\n    else if (treeNode.type === 5 /* Action */ && actionHandler) {\n        const a = document.createElement('a');\n        actionHandler.disposables.add(DOM.addStandardDisposableListener(a, 'click', (event) => {\n            actionHandler.callback(String(treeNode.index), event);\n        }));\n        child = a;\n    }\n    else if (treeNode.type === 8 /* NewLine */) {\n        child = document.createElement('br');\n    }\n    else if (treeNode.type === 1 /* Root */) {\n        child = element;\n    }\n    if (child && element !== child) {\n        element.appendChild(child);\n    }\n    if (child && Array.isArray(treeNode.children)) {\n        treeNode.children.forEach((nodeChild) => {\n            _renderFormattedText(child, nodeChild, actionHandler, renderCodeSegments);\n        });\n    }\n}\nfunction parseFormattedText(content, parseCodeSegments) {\n    const root = {\n        type: 1 /* Root */,\n        children: []\n    };\n    let actionViewItemIndex = 0;\n    let current = root;\n    const stack = [];\n    const stream = new StringStream(content);\n    while (!stream.eos()) {\n        let next = stream.next();\n        const isEscapedFormatType = (next === '\\\\' && formatTagType(stream.peek(), parseCodeSegments) !== 0 /* Invalid */);\n        if (isEscapedFormatType) {\n            next = stream.next(); // unread the backslash if it escapes a format tag type\n        }\n        if (!isEscapedFormatType && isFormatTag(next, parseCodeSegments) && next === stream.peek()) {\n            stream.advance();\n            if (current.type === 2 /* Text */) {\n                current = stack.pop();\n            }\n            const type = formatTagType(next, parseCodeSegments);\n            if (current.type === type || (current.type === 5 /* Action */ && type === 6 /* ActionClose */)) {\n                current = stack.pop();\n            }\n            else {\n                const newCurrent = {\n                    type: type,\n                    children: []\n                };\n                if (type === 5 /* Action */) {\n                    newCurrent.index = actionViewItemIndex;\n                    actionViewItemIndex++;\n                }\n                current.children.push(newCurrent);\n                stack.push(current);\n                current = newCurrent;\n            }\n        }\n        else if (next === '\\n') {\n            if (current.type === 2 /* Text */) {\n                current = stack.pop();\n            }\n            current.children.push({\n                type: 8 /* NewLine */\n            });\n        }\n        else {\n            if (current.type !== 2 /* Text */) {\n                const textCurrent = {\n                    type: 2 /* Text */,\n                    content: next\n                };\n                current.children.push(textCurrent);\n                stack.push(current);\n                current = textCurrent;\n            }\n            else {\n                current.content += next;\n            }\n        }\n    }\n    if (current.type === 2 /* Text */) {\n        current = stack.pop();\n    }\n    if (stack.length) {\n        // incorrectly formatted string literal\n    }\n    return root;\n}\nfunction isFormatTag(char, supportCodeSegments) {\n    return formatTagType(char, supportCodeSegments) !== 0 /* Invalid */;\n}\nfunction formatTagType(char, supportCodeSegments) {\n    switch (char) {\n        case '*':\n            return 3 /* Bold */;\n        case '_':\n            return 4 /* Italics */;\n        case '[':\n            return 5 /* Action */;\n        case ']':\n            return 6 /* ActionClose */;\n        case '`':\n            return supportCodeSegments ? 7 /* Code */ : 0 /* Invalid */;\n        default:\n            return 0 /* Invalid */;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}