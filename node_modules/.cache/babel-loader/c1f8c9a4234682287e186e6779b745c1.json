{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { coalesce } from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';\nimport { clearLanguageAssociations, getMimeTypes, registerLanguageAssociation } from './languagesAssociations.js';\nimport { ModesRegistry, PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst NULL_LANGUAGE_ID = 'vs.editor.nullLanguage';\nexport class LanguageIdCodec {\n  constructor() {\n    this._languageIdToLanguage = [];\n    this._languageToLanguageId = new Map();\n\n    this._register(NULL_LANGUAGE_ID, 0\n    /* Null */\n    );\n\n    this._register(PLAINTEXT_LANGUAGE_ID, 1\n    /* PlainText */\n    );\n\n    this._nextLanguageId = 2;\n  }\n\n  _register(language, languageId) {\n    this._languageIdToLanguage[languageId] = language;\n\n    this._languageToLanguageId.set(language, languageId);\n  }\n\n  register(language) {\n    if (this._languageToLanguageId.has(language)) {\n      return;\n    }\n\n    const languageId = this._nextLanguageId++;\n\n    this._register(language, languageId);\n  }\n\n  encodeLanguageId(languageId) {\n    return this._languageToLanguageId.get(languageId) || 0\n    /* Null */\n    ;\n  }\n\n  decodeLanguageId(languageId) {\n    return this._languageIdToLanguage[languageId] || NULL_LANGUAGE_ID;\n  }\n\n}\nexport class LanguagesRegistry extends Disposable {\n  constructor(useModesRegistry = true, warnOnOverwrite = false) {\n    super();\n    this._onDidChange = this._register(new Emitter());\n    this.onDidChange = this._onDidChange.event;\n    LanguagesRegistry.instanceCount++;\n    this._warnOnOverwrite = warnOnOverwrite;\n    this.languageIdCodec = new LanguageIdCodec();\n    this._dynamicLanguages = [];\n    this._languages = {};\n    this._mimeTypesMap = {};\n    this._nameMap = {};\n    this._lowercaseNameMap = {};\n\n    if (useModesRegistry) {\n      this._initializeFromRegistry();\n\n      this._register(ModesRegistry.onDidChangeLanguages(m => {\n        this._initializeFromRegistry();\n      }));\n    }\n  }\n\n  dispose() {\n    LanguagesRegistry.instanceCount--;\n    super.dispose();\n  }\n\n  _initializeFromRegistry() {\n    this._languages = {};\n    this._mimeTypesMap = {};\n    this._nameMap = {};\n    this._lowercaseNameMap = {};\n    clearLanguageAssociations();\n    const desc = [].concat(ModesRegistry.getLanguages()).concat(this._dynamicLanguages);\n\n    this._registerLanguages(desc);\n  }\n\n  _registerLanguages(desc) {\n    for (const d of desc) {\n      this._registerLanguage(d);\n    } // Rebuild fast path maps\n\n\n    this._mimeTypesMap = {};\n    this._nameMap = {};\n    this._lowercaseNameMap = {};\n    Object.keys(this._languages).forEach(langId => {\n      const language = this._languages[langId];\n\n      if (language.name) {\n        this._nameMap[language.name] = language.identifier;\n      }\n\n      language.aliases.forEach(alias => {\n        this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;\n      });\n      language.mimetypes.forEach(mimetype => {\n        this._mimeTypesMap[mimetype] = language.identifier;\n      });\n    });\n    Registry.as(Extensions.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds());\n\n    this._onDidChange.fire();\n  }\n\n  _registerLanguage(lang) {\n    const langId = lang.id;\n    let resolvedLanguage;\n\n    if (hasOwnProperty.call(this._languages, langId)) {\n      resolvedLanguage = this._languages[langId];\n    } else {\n      this.languageIdCodec.register(langId);\n      resolvedLanguage = {\n        identifier: langId,\n        name: null,\n        mimetypes: [],\n        aliases: [],\n        extensions: [],\n        filenames: [],\n        configurationFiles: [],\n        icons: []\n      };\n      this._languages[langId] = resolvedLanguage;\n    }\n\n    this._mergeLanguage(resolvedLanguage, lang);\n  }\n\n  _mergeLanguage(resolvedLanguage, lang) {\n    const langId = lang.id;\n    let primaryMime = null;\n\n    if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {\n      resolvedLanguage.mimetypes.push(...lang.mimetypes);\n      primaryMime = lang.mimetypes[0];\n    }\n\n    if (!primaryMime) {\n      primaryMime = `text/x-${langId}`;\n      resolvedLanguage.mimetypes.push(primaryMime);\n    }\n\n    if (Array.isArray(lang.extensions)) {\n      if (lang.configuration) {\n        // insert first as this appears to be the 'primary' language definition\n        resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);\n      } else {\n        resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);\n      }\n\n      for (let extension of lang.extensions) {\n        registerLanguageAssociation({\n          id: langId,\n          mime: primaryMime,\n          extension: extension\n        }, this._warnOnOverwrite);\n      }\n    }\n\n    if (Array.isArray(lang.filenames)) {\n      for (let filename of lang.filenames) {\n        registerLanguageAssociation({\n          id: langId,\n          mime: primaryMime,\n          filename: filename\n        }, this._warnOnOverwrite);\n        resolvedLanguage.filenames.push(filename);\n      }\n    }\n\n    if (Array.isArray(lang.filenamePatterns)) {\n      for (let filenamePattern of lang.filenamePatterns) {\n        registerLanguageAssociation({\n          id: langId,\n          mime: primaryMime,\n          filepattern: filenamePattern\n        }, this._warnOnOverwrite);\n      }\n    }\n\n    if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {\n      let firstLineRegexStr = lang.firstLine;\n\n      if (firstLineRegexStr.charAt(0) !== '^') {\n        firstLineRegexStr = '^' + firstLineRegexStr;\n      }\n\n      try {\n        const firstLineRegex = new RegExp(firstLineRegexStr);\n\n        if (!regExpLeadsToEndlessLoop(firstLineRegex)) {\n          registerLanguageAssociation({\n            id: langId,\n            mime: primaryMime,\n            firstline: firstLineRegex\n          }, this._warnOnOverwrite);\n        }\n      } catch (err) {\n        // Most likely, the regex was bad\n        onUnexpectedError(err);\n      }\n    }\n\n    resolvedLanguage.aliases.push(langId);\n    let langAliases = null;\n\n    if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {\n      if (lang.aliases.length === 0) {\n        // signal that this language should not get a name\n        langAliases = [null];\n      } else {\n        langAliases = lang.aliases;\n      }\n    }\n\n    if (langAliases !== null) {\n      for (const langAlias of langAliases) {\n        if (!langAlias || langAlias.length === 0) {\n          continue;\n        }\n\n        resolvedLanguage.aliases.push(langAlias);\n      }\n    }\n\n    const containsAliases = langAliases !== null && langAliases.length > 0;\n\n    if (containsAliases && langAliases[0] === null) {// signal that this language should not get a name\n    } else {\n      const bestName = (containsAliases ? langAliases[0] : null) || langId;\n\n      if (containsAliases || !resolvedLanguage.name) {\n        resolvedLanguage.name = bestName;\n      }\n    }\n\n    if (lang.configuration) {\n      resolvedLanguage.configurationFiles.push(lang.configuration);\n    }\n\n    if (lang.icon) {\n      resolvedLanguage.icons.push(lang.icon);\n    }\n  }\n\n  isRegisteredLanguageId(languageId) {\n    if (!languageId) {\n      return false;\n    }\n\n    return hasOwnProperty.call(this._languages, languageId);\n  }\n\n  getRegisteredLanguageIds() {\n    return Object.keys(this._languages);\n  }\n\n  getLanguageIdByLanguageName(languageName) {\n    const languageNameLower = languageName.toLowerCase();\n\n    if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {\n      return null;\n    }\n\n    return this._lowercaseNameMap[languageNameLower];\n  }\n\n  getLanguageIdByMimeType(mimeType) {\n    if (!mimeType) {\n      return null;\n    }\n\n    if (hasOwnProperty.call(this._mimeTypesMap, mimeType)) {\n      return this._mimeTypesMap[mimeType];\n    }\n\n    return null;\n  }\n\n  guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {\n    if (!resource && !firstLine) {\n      return [];\n    }\n\n    const mimeTypes = getMimeTypes(resource, firstLine);\n    return coalesce(mimeTypes.map(mimeType => this.getLanguageIdByMimeType(mimeType)));\n  }\n\n}\nLanguagesRegistry.instanceCount = 0;","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js"],"names":["coalesce","onUnexpectedError","Emitter","Disposable","regExpLeadsToEndlessLoop","clearLanguageAssociations","getMimeTypes","registerLanguageAssociation","ModesRegistry","PLAINTEXT_LANGUAGE_ID","Extensions","Registry","hasOwnProperty","Object","prototype","NULL_LANGUAGE_ID","LanguageIdCodec","constructor","_languageIdToLanguage","_languageToLanguageId","Map","_register","_nextLanguageId","language","languageId","set","register","has","encodeLanguageId","get","decodeLanguageId","LanguagesRegistry","useModesRegistry","warnOnOverwrite","_onDidChange","onDidChange","event","instanceCount","_warnOnOverwrite","languageIdCodec","_dynamicLanguages","_languages","_mimeTypesMap","_nameMap","_lowercaseNameMap","_initializeFromRegistry","onDidChangeLanguages","m","dispose","desc","concat","getLanguages","_registerLanguages","d","_registerLanguage","keys","forEach","langId","name","identifier","aliases","alias","toLowerCase","mimetypes","mimetype","as","Configuration","registerOverrideIdentifiers","getRegisteredLanguageIds","fire","lang","id","resolvedLanguage","call","extensions","filenames","configurationFiles","icons","_mergeLanguage","primaryMime","Array","isArray","length","push","configuration","extension","mime","filename","filenamePatterns","filenamePattern","filepattern","firstLine","firstLineRegexStr","charAt","firstLineRegex","RegExp","firstline","err","langAliases","langAlias","containsAliases","bestName","icon","isRegisteredLanguageId","getLanguageIdByLanguageName","languageName","languageNameLower","getLanguageIdByMimeType","mimeType","guessLanguageIdByFilepathOrFirstLine","resource","mimeTypes","map"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { coalesce } from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';\nimport { clearLanguageAssociations, getMimeTypes, registerLanguageAssociation } from './languagesAssociations.js';\nimport { ModesRegistry, PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst NULL_LANGUAGE_ID = 'vs.editor.nullLanguage';\nexport class LanguageIdCodec {\n    constructor() {\n        this._languageIdToLanguage = [];\n        this._languageToLanguageId = new Map();\n        this._register(NULL_LANGUAGE_ID, 0 /* Null */);\n        this._register(PLAINTEXT_LANGUAGE_ID, 1 /* PlainText */);\n        this._nextLanguageId = 2;\n    }\n    _register(language, languageId) {\n        this._languageIdToLanguage[languageId] = language;\n        this._languageToLanguageId.set(language, languageId);\n    }\n    register(language) {\n        if (this._languageToLanguageId.has(language)) {\n            return;\n        }\n        const languageId = this._nextLanguageId++;\n        this._register(language, languageId);\n    }\n    encodeLanguageId(languageId) {\n        return this._languageToLanguageId.get(languageId) || 0 /* Null */;\n    }\n    decodeLanguageId(languageId) {\n        return this._languageIdToLanguage[languageId] || NULL_LANGUAGE_ID;\n    }\n}\nexport class LanguagesRegistry extends Disposable {\n    constructor(useModesRegistry = true, warnOnOverwrite = false) {\n        super();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        LanguagesRegistry.instanceCount++;\n        this._warnOnOverwrite = warnOnOverwrite;\n        this.languageIdCodec = new LanguageIdCodec();\n        this._dynamicLanguages = [];\n        this._languages = {};\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        if (useModesRegistry) {\n            this._initializeFromRegistry();\n            this._register(ModesRegistry.onDidChangeLanguages((m) => {\n                this._initializeFromRegistry();\n            }));\n        }\n    }\n    dispose() {\n        LanguagesRegistry.instanceCount--;\n        super.dispose();\n    }\n    _initializeFromRegistry() {\n        this._languages = {};\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        clearLanguageAssociations();\n        const desc = [].concat(ModesRegistry.getLanguages()).concat(this._dynamicLanguages);\n        this._registerLanguages(desc);\n    }\n    _registerLanguages(desc) {\n        for (const d of desc) {\n            this._registerLanguage(d);\n        }\n        // Rebuild fast path maps\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        Object.keys(this._languages).forEach((langId) => {\n            const language = this._languages[langId];\n            if (language.name) {\n                this._nameMap[language.name] = language.identifier;\n            }\n            language.aliases.forEach((alias) => {\n                this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;\n            });\n            language.mimetypes.forEach((mimetype) => {\n                this._mimeTypesMap[mimetype] = language.identifier;\n            });\n        });\n        Registry.as(Extensions.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds());\n        this._onDidChange.fire();\n    }\n    _registerLanguage(lang) {\n        const langId = lang.id;\n        let resolvedLanguage;\n        if (hasOwnProperty.call(this._languages, langId)) {\n            resolvedLanguage = this._languages[langId];\n        }\n        else {\n            this.languageIdCodec.register(langId);\n            resolvedLanguage = {\n                identifier: langId,\n                name: null,\n                mimetypes: [],\n                aliases: [],\n                extensions: [],\n                filenames: [],\n                configurationFiles: [],\n                icons: []\n            };\n            this._languages[langId] = resolvedLanguage;\n        }\n        this._mergeLanguage(resolvedLanguage, lang);\n    }\n    _mergeLanguage(resolvedLanguage, lang) {\n        const langId = lang.id;\n        let primaryMime = null;\n        if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {\n            resolvedLanguage.mimetypes.push(...lang.mimetypes);\n            primaryMime = lang.mimetypes[0];\n        }\n        if (!primaryMime) {\n            primaryMime = `text/x-${langId}`;\n            resolvedLanguage.mimetypes.push(primaryMime);\n        }\n        if (Array.isArray(lang.extensions)) {\n            if (lang.configuration) {\n                // insert first as this appears to be the 'primary' language definition\n                resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);\n            }\n            else {\n                resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);\n            }\n            for (let extension of lang.extensions) {\n                registerLanguageAssociation({ id: langId, mime: primaryMime, extension: extension }, this._warnOnOverwrite);\n            }\n        }\n        if (Array.isArray(lang.filenames)) {\n            for (let filename of lang.filenames) {\n                registerLanguageAssociation({ id: langId, mime: primaryMime, filename: filename }, this._warnOnOverwrite);\n                resolvedLanguage.filenames.push(filename);\n            }\n        }\n        if (Array.isArray(lang.filenamePatterns)) {\n            for (let filenamePattern of lang.filenamePatterns) {\n                registerLanguageAssociation({ id: langId, mime: primaryMime, filepattern: filenamePattern }, this._warnOnOverwrite);\n            }\n        }\n        if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {\n            let firstLineRegexStr = lang.firstLine;\n            if (firstLineRegexStr.charAt(0) !== '^') {\n                firstLineRegexStr = '^' + firstLineRegexStr;\n            }\n            try {\n                const firstLineRegex = new RegExp(firstLineRegexStr);\n                if (!regExpLeadsToEndlessLoop(firstLineRegex)) {\n                    registerLanguageAssociation({ id: langId, mime: primaryMime, firstline: firstLineRegex }, this._warnOnOverwrite);\n                }\n            }\n            catch (err) {\n                // Most likely, the regex was bad\n                onUnexpectedError(err);\n            }\n        }\n        resolvedLanguage.aliases.push(langId);\n        let langAliases = null;\n        if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {\n            if (lang.aliases.length === 0) {\n                // signal that this language should not get a name\n                langAliases = [null];\n            }\n            else {\n                langAliases = lang.aliases;\n            }\n        }\n        if (langAliases !== null) {\n            for (const langAlias of langAliases) {\n                if (!langAlias || langAlias.length === 0) {\n                    continue;\n                }\n                resolvedLanguage.aliases.push(langAlias);\n            }\n        }\n        const containsAliases = (langAliases !== null && langAliases.length > 0);\n        if (containsAliases && langAliases[0] === null) {\n            // signal that this language should not get a name\n        }\n        else {\n            const bestName = (containsAliases ? langAliases[0] : null) || langId;\n            if (containsAliases || !resolvedLanguage.name) {\n                resolvedLanguage.name = bestName;\n            }\n        }\n        if (lang.configuration) {\n            resolvedLanguage.configurationFiles.push(lang.configuration);\n        }\n        if (lang.icon) {\n            resolvedLanguage.icons.push(lang.icon);\n        }\n    }\n    isRegisteredLanguageId(languageId) {\n        if (!languageId) {\n            return false;\n        }\n        return hasOwnProperty.call(this._languages, languageId);\n    }\n    getRegisteredLanguageIds() {\n        return Object.keys(this._languages);\n    }\n    getLanguageIdByLanguageName(languageName) {\n        const languageNameLower = languageName.toLowerCase();\n        if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {\n            return null;\n        }\n        return this._lowercaseNameMap[languageNameLower];\n    }\n    getLanguageIdByMimeType(mimeType) {\n        if (!mimeType) {\n            return null;\n        }\n        if (hasOwnProperty.call(this._mimeTypesMap, mimeType)) {\n            return this._mimeTypesMap[mimeType];\n        }\n        return null;\n    }\n    guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {\n        if (!resource && !firstLine) {\n            return [];\n        }\n        const mimeTypes = getMimeTypes(resource, firstLine);\n        return coalesce(mimeTypes.map(mimeType => this.getLanguageIdByMimeType(mimeType)));\n    }\n}\nLanguagesRegistry.instanceCount = 0;\n"]},"metadata":{},"sourceType":"module"}