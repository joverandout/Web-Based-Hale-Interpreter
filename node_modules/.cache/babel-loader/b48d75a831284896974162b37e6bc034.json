{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { CancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { InlayHintsProviderRegistry } from '../../../common/languages.js';\nexport class InlayHintAnchor {\n  constructor(range, direction) {\n    this.range = range;\n    this.direction = direction;\n  }\n\n}\nexport class InlayHintItem {\n  constructor(hint, anchor, provider) {\n    this.hint = hint;\n    this.anchor = anchor;\n    this.provider = provider;\n    this._isResolved = false;\n  }\n\n  with(delta) {\n    const result = new InlayHintItem(this.hint, delta.anchor, this.provider);\n    result._isResolved = this._isResolved;\n    result._currentResolve = this._currentResolve;\n    return result;\n  }\n\n  resolve(token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.provider.resolveInlayHint !== 'function') {\n        return;\n      }\n\n      if (this._currentResolve) {\n        // wait for an active resolve operation and try again\n        // when that's done.\n        yield this._currentResolve;\n\n        if (token.isCancellationRequested) {\n          return;\n        }\n\n        return this.resolve(token);\n      }\n\n      if (!this._isResolved) {\n        this._currentResolve = this._doResolve(token).finally(() => this._currentResolve = undefined);\n      }\n\n      yield this._currentResolve;\n    });\n  }\n\n  _doResolve(token) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const newHint = yield Promise.resolve(this.provider.resolveInlayHint(this.hint, token));\n        this.hint.tooltip = (_a = newHint === null || newHint === void 0 ? void 0 : newHint.tooltip) !== null && _a !== void 0 ? _a : this.hint.tooltip;\n        this.hint.label = (_b = newHint === null || newHint === void 0 ? void 0 : newHint.label) !== null && _b !== void 0 ? _b : this.hint.label;\n        this._isResolved = true;\n      } catch (err) {\n        onUnexpectedExternalError(err);\n        this._isResolved = false;\n      }\n    });\n  }\n\n}\nexport class InlayHintsFragments {\n  constructor(ranges, data, model) {\n    this._disposables = new DisposableStore();\n    this.ranges = ranges;\n    this.provider = new Set();\n    const items = [];\n\n    for (const [list, provider] of data) {\n      this._disposables.add(list);\n\n      this.provider.add(provider);\n\n      for (const hint of list.hints) {\n        // compute the range to which the item should be attached to\n        let position = model.validatePosition(hint.position);\n        let direction = 'before';\n\n        const wordRange = InlayHintsFragments._getRangeAtPosition(model, position);\n\n        let range;\n\n        if (wordRange.getStartPosition().isBefore(position)) {\n          range = Range.fromPositions(wordRange.getStartPosition(), position);\n          direction = 'after';\n        } else {\n          range = Range.fromPositions(position, wordRange.getEndPosition());\n          direction = 'before';\n        }\n\n        items.push(new InlayHintItem(hint, new InlayHintAnchor(range, direction), provider));\n      }\n    }\n\n    this.items = items.sort((a, b) => Position.compare(a.hint.position, b.hint.position));\n  }\n\n  static create(model, ranges, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const data = [];\n      const promises = InlayHintsProviderRegistry.ordered(model).reverse().map(provider => ranges.map(range => __awaiter(this, void 0, void 0, function* () {\n        try {\n          const result = yield provider.provideInlayHints(model, range, token);\n\n          if (result === null || result === void 0 ? void 0 : result.hints.length) {\n            data.push([result, provider]);\n          }\n        } catch (err) {\n          onUnexpectedExternalError(err);\n        }\n      })));\n      yield Promise.all(promises.flat());\n\n      if (token.isCancellationRequested || model.isDisposed()) {\n        throw new CancellationError();\n      }\n\n      return new InlayHintsFragments(ranges, data, model);\n    });\n  }\n\n  dispose() {\n    this._disposables.dispose();\n  }\n\n  static _getRangeAtPosition(model, position) {\n    const line = position.lineNumber;\n    const word = model.getWordAtPosition(position);\n\n    if (word) {\n      // always prefer the word range\n      return new Range(line, word.startColumn, line, word.endColumn);\n    }\n\n    model.tokenizeIfCheap(line);\n    const tokens = model.getLineTokens(line);\n    const offset = position.column - 1;\n    const idx = tokens.findTokenIndexAtOffset(offset);\n    let start = tokens.getStartOffset(idx);\n    let end = tokens.getEndOffset(idx);\n\n    if (end - start === 1) {\n      // single character token, when at its end try leading/trailing token instead\n      if (start === offset && idx > 1) {\n        // leading token\n        start = tokens.getStartOffset(idx - 1);\n        end = tokens.getEndOffset(idx - 1);\n      } else if (end === offset && idx < tokens.getCount() - 1) {\n        // trailing token\n        start = tokens.getStartOffset(idx + 1);\n        end = tokens.getEndOffset(idx + 1);\n      }\n    }\n\n    return new Range(line, start + 1, line, end + 1);\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHints.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","CancellationError","onUnexpectedExternalError","DisposableStore","Position","Range","InlayHintsProviderRegistry","InlayHintAnchor","constructor","range","direction","InlayHintItem","hint","anchor","provider","_isResolved","with","delta","_currentResolve","token","resolveInlayHint","isCancellationRequested","_doResolve","finally","undefined","_a","_b","newHint","tooltip","label","err","InlayHintsFragments","ranges","data","model","_disposables","Set","items","list","add","hints","position","validatePosition","wordRange","_getRangeAtPosition","getStartPosition","isBefore","fromPositions","getEndPosition","push","sort","a","b","compare","create","promises","ordered","reverse","map","provideInlayHints","length","all","flat","isDisposed","dispose","line","lineNumber","word","getWordAtPosition","startColumn","endColumn","tokenizeIfCheap","tokens","getLineTokens","offset","column","idx","findTokenIndexAtOffset","start","getStartOffset","end","getEndOffset","getCount"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { InlayHintsProviderRegistry } from '../../../common/languages.js';\nexport class InlayHintAnchor {\n    constructor(range, direction) {\n        this.range = range;\n        this.direction = direction;\n    }\n}\nexport class InlayHintItem {\n    constructor(hint, anchor, provider) {\n        this.hint = hint;\n        this.anchor = anchor;\n        this.provider = provider;\n        this._isResolved = false;\n    }\n    with(delta) {\n        const result = new InlayHintItem(this.hint, delta.anchor, this.provider);\n        result._isResolved = this._isResolved;\n        result._currentResolve = this._currentResolve;\n        return result;\n    }\n    resolve(token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.provider.resolveInlayHint !== 'function') {\n                return;\n            }\n            if (this._currentResolve) {\n                // wait for an active resolve operation and try again\n                // when that's done.\n                yield this._currentResolve;\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                return this.resolve(token);\n            }\n            if (!this._isResolved) {\n                this._currentResolve = this._doResolve(token)\n                    .finally(() => this._currentResolve = undefined);\n            }\n            yield this._currentResolve;\n        });\n    }\n    _doResolve(token) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const newHint = yield Promise.resolve(this.provider.resolveInlayHint(this.hint, token));\n                this.hint.tooltip = (_a = newHint === null || newHint === void 0 ? void 0 : newHint.tooltip) !== null && _a !== void 0 ? _a : this.hint.tooltip;\n                this.hint.label = (_b = newHint === null || newHint === void 0 ? void 0 : newHint.label) !== null && _b !== void 0 ? _b : this.hint.label;\n                this._isResolved = true;\n            }\n            catch (err) {\n                onUnexpectedExternalError(err);\n                this._isResolved = false;\n            }\n        });\n    }\n}\nexport class InlayHintsFragments {\n    constructor(ranges, data, model) {\n        this._disposables = new DisposableStore();\n        this.ranges = ranges;\n        this.provider = new Set();\n        const items = [];\n        for (const [list, provider] of data) {\n            this._disposables.add(list);\n            this.provider.add(provider);\n            for (const hint of list.hints) {\n                // compute the range to which the item should be attached to\n                let position = model.validatePosition(hint.position);\n                let direction = 'before';\n                const wordRange = InlayHintsFragments._getRangeAtPosition(model, position);\n                let range;\n                if (wordRange.getStartPosition().isBefore(position)) {\n                    range = Range.fromPositions(wordRange.getStartPosition(), position);\n                    direction = 'after';\n                }\n                else {\n                    range = Range.fromPositions(position, wordRange.getEndPosition());\n                    direction = 'before';\n                }\n                items.push(new InlayHintItem(hint, new InlayHintAnchor(range, direction), provider));\n            }\n        }\n        this.items = items.sort((a, b) => Position.compare(a.hint.position, b.hint.position));\n    }\n    static create(model, ranges, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = [];\n            const promises = InlayHintsProviderRegistry.ordered(model).reverse().map(provider => ranges.map((range) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const result = yield provider.provideInlayHints(model, range, token);\n                    if (result === null || result === void 0 ? void 0 : result.hints.length) {\n                        data.push([result, provider]);\n                    }\n                }\n                catch (err) {\n                    onUnexpectedExternalError(err);\n                }\n            })));\n            yield Promise.all(promises.flat());\n            if (token.isCancellationRequested || model.isDisposed()) {\n                throw new CancellationError();\n            }\n            return new InlayHintsFragments(ranges, data, model);\n        });\n    }\n    dispose() {\n        this._disposables.dispose();\n    }\n    static _getRangeAtPosition(model, position) {\n        const line = position.lineNumber;\n        const word = model.getWordAtPosition(position);\n        if (word) {\n            // always prefer the word range\n            return new Range(line, word.startColumn, line, word.endColumn);\n        }\n        model.tokenizeIfCheap(line);\n        const tokens = model.getLineTokens(line);\n        const offset = position.column - 1;\n        const idx = tokens.findTokenIndexAtOffset(offset);\n        let start = tokens.getStartOffset(idx);\n        let end = tokens.getEndOffset(idx);\n        if (end - start === 1) {\n            // single character token, when at its end try leading/trailing token instead\n            if (start === offset && idx > 1) {\n                // leading token\n                start = tokens.getStartOffset(idx - 1);\n                end = tokens.getEndOffset(idx - 1);\n            }\n            else if (end === offset && idx < tokens.getCount() - 1) {\n                // trailing token\n                start = tokens.getStartOffset(idx + 1);\n                end = tokens.getEndOffset(idx + 1);\n            }\n        }\n        return new Range(line, start + 1, line, end + 1);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}