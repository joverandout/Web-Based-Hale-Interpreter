{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\n\nfunction reverseEndianness(arr) {\n  for (let i = 0, len = arr.length; i < len; i += 4) {\n    // flip bytes 0<->3 and 1<->2\n    const b0 = arr[i + 0];\n    const b1 = arr[i + 1];\n    const b2 = arr[i + 2];\n    const b3 = arr[i + 3];\n    arr[i + 0] = b3;\n    arr[i + 1] = b2;\n    arr[i + 2] = b1;\n    arr[i + 3] = b0;\n  }\n}\n\nfunction toLittleEndianBuffer(arr) {\n  const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n\n  if (!platform.isLittleEndian()) {\n    // the byte order must be changed\n    reverseEndianness(uint8Arr);\n  }\n\n  return VSBuffer.wrap(uint8Arr);\n}\n\nexport function encodeSemanticTokensDto(semanticTokens) {\n  const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n  let offset = 0;\n  dest[offset++] = semanticTokens.id;\n\n  if (semanticTokens.type === 'full') {\n    dest[offset++] = 1\n    /* Full */\n    ;\n    dest[offset++] = semanticTokens.data.length;\n    dest.set(semanticTokens.data, offset);\n    offset += semanticTokens.data.length;\n  } else {\n    dest[offset++] = 2\n    /* Delta */\n    ;\n    dest[offset++] = semanticTokens.deltas.length;\n\n    for (const delta of semanticTokens.deltas) {\n      dest[offset++] = delta.start;\n      dest[offset++] = delta.deleteCount;\n\n      if (delta.data) {\n        dest[offset++] = delta.data.length;\n        dest.set(delta.data, offset);\n        offset += delta.data.length;\n      } else {\n        dest[offset++] = 0;\n      }\n    }\n  }\n\n  return toLittleEndianBuffer(dest);\n}\n\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n  let result = 0;\n  result += +1 // id\n  + 1 // type\n  ;\n\n  if (semanticTokens.type === 'full') {\n    result += +1 // data length\n    + semanticTokens.data.length;\n  } else {\n    result += +1 // delta count\n    ;\n    result += (+1 // start\n    + 1 // deleteCount\n    + 1 // data length\n    ) * semanticTokens.deltas.length;\n\n    for (const delta of semanticTokens.deltas) {\n      if (delta.data) {\n        result += delta.data.length;\n      }\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js"],"names":["VSBuffer","platform","reverseEndianness","arr","i","len","length","b0","b1","b2","b3","toLittleEndianBuffer","uint8Arr","Uint8Array","buffer","byteOffset","isLittleEndian","wrap","encodeSemanticTokensDto","semanticTokens","dest","Uint32Array","encodeSemanticTokensDtoSize","offset","id","type","data","set","deltas","delta","start","deleteCount","result"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\nfunction reverseEndianness(arr) {\n    for (let i = 0, len = arr.length; i < len; i += 4) {\n        // flip bytes 0<->3 and 1<->2\n        const b0 = arr[i + 0];\n        const b1 = arr[i + 1];\n        const b2 = arr[i + 2];\n        const b3 = arr[i + 3];\n        arr[i + 0] = b3;\n        arr[i + 1] = b2;\n        arr[i + 2] = b1;\n        arr[i + 3] = b0;\n    }\n}\nfunction toLittleEndianBuffer(arr) {\n    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n    if (!platform.isLittleEndian()) {\n        // the byte order must be changed\n        reverseEndianness(uint8Arr);\n    }\n    return VSBuffer.wrap(uint8Arr);\n}\nexport function encodeSemanticTokensDto(semanticTokens) {\n    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n    let offset = 0;\n    dest[offset++] = semanticTokens.id;\n    if (semanticTokens.type === 'full') {\n        dest[offset++] = 1 /* Full */;\n        dest[offset++] = semanticTokens.data.length;\n        dest.set(semanticTokens.data, offset);\n        offset += semanticTokens.data.length;\n    }\n    else {\n        dest[offset++] = 2 /* Delta */;\n        dest[offset++] = semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            dest[offset++] = delta.start;\n            dest[offset++] = delta.deleteCount;\n            if (delta.data) {\n                dest[offset++] = delta.data.length;\n                dest.set(delta.data, offset);\n                offset += delta.data.length;\n            }\n            else {\n                dest[offset++] = 0;\n            }\n        }\n    }\n    return toLittleEndianBuffer(dest);\n}\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n    let result = 0;\n    result += (+1 // id\n        + 1 // type\n    );\n    if (semanticTokens.type === 'full') {\n        result += (+1 // data length\n            + semanticTokens.data.length);\n    }\n    else {\n        result += (+1 // delta count\n        );\n        result += (+1 // start\n            + 1 // deleteCount\n            + 1 // data length\n        ) * semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            if (delta.data) {\n                result += delta.data.length;\n            }\n        }\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}