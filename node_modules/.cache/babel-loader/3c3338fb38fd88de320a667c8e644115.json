{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../languages.js';\n/**\n * Represents contiguous tokens in a text model.\n */\n\nexport class ContiguousTokensStore {\n  constructor(languageIdCodec) {\n    this._lineTokens = [];\n    this._len = 0;\n    this._languageIdCodec = languageIdCodec;\n  }\n\n  flush() {\n    this._lineTokens = [];\n    this._len = 0;\n  }\n\n  getTokens(topLevelLanguageId, lineIndex, lineText) {\n    let rawLineTokens = null;\n\n    if (lineIndex < this._len) {\n      rawLineTokens = this._lineTokens[lineIndex];\n    }\n\n    if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n      return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n    }\n\n    const lineTokens = new Uint32Array(2);\n    lineTokens[0] = lineText.length;\n    lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n    return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n  }\n\n  static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n    const tokens = _tokens ? toUint32Array(_tokens) : null;\n\n    if (lineTextLength === 0) {\n      let hasDifferentLanguageId = false;\n\n      if (tokens && tokens.length > 1) {\n        hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;\n      }\n\n      if (!hasDifferentLanguageId) {\n        return EMPTY_LINE_TOKENS;\n      }\n    }\n\n    if (!tokens || tokens.length === 0) {\n      const tokens = new Uint32Array(2);\n      tokens[0] = lineTextLength;\n      tokens[1] = getDefaultMetadata(topLevelLanguageId);\n      return tokens.buffer;\n    } // Ensure the last token covers the end of the text\n\n\n    tokens[tokens.length - 2] = lineTextLength;\n\n    if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n      // Store directly the ArrayBuffer pointer to save an object\n      return tokens.buffer;\n    }\n\n    return tokens;\n  }\n\n  _ensureLine(lineIndex) {\n    while (lineIndex >= this._len) {\n      this._lineTokens[this._len] = null;\n      this._len++;\n    }\n  }\n\n  _deleteLines(start, deleteCount) {\n    if (deleteCount === 0) {\n      return;\n    }\n\n    if (start + deleteCount > this._len) {\n      deleteCount = this._len - start;\n    }\n\n    this._lineTokens.splice(start, deleteCount);\n\n    this._len -= deleteCount;\n  }\n\n  _insertLines(insertIndex, insertCount) {\n    if (insertCount === 0) {\n      return;\n    }\n\n    const lineTokens = [];\n\n    for (let i = 0; i < insertCount; i++) {\n      lineTokens[i] = null;\n    }\n\n    this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n    this._len += insertCount;\n  }\n\n  setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n    const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n\n    this._ensureLine(lineIndex);\n\n    const oldTokens = this._lineTokens[lineIndex];\n    this._lineTokens[lineIndex] = tokens;\n\n    if (checkEquality) {\n      return !ContiguousTokensStore._equals(oldTokens, tokens);\n    }\n\n    return false;\n  }\n\n  static _equals(_a, _b) {\n    if (!_a || !_b) {\n      return !_a && !_b;\n    }\n\n    const a = toUint32Array(_a);\n    const b = toUint32Array(_b);\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0, len = a.length; i < len; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  } //#region Editing\n\n\n  acceptEdit(range, eolCount, firstLineLength) {\n    this._acceptDeleteRange(range);\n\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n  }\n\n  _acceptDeleteRange(range) {\n    const firstLineIndex = range.startLineNumber - 1;\n\n    if (firstLineIndex >= this._len) {\n      return;\n    }\n\n    if (range.startLineNumber === range.endLineNumber) {\n      if (range.startColumn === range.endColumn) {\n        // Nothing to delete\n        return;\n      }\n\n      this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n      return;\n    }\n\n    this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n    const lastLineIndex = range.endLineNumber - 1;\n    let lastLineTokens = null;\n\n    if (lastLineIndex < this._len) {\n      lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n    } // Take remaining text on last line and append it to remaining text on first line\n\n\n    this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens); // Delete middle lines\n\n    this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n  }\n\n  _acceptInsertText(position, eolCount, firstLineLength) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      // Nothing to insert\n      return;\n    }\n\n    const lineIndex = position.lineNumber - 1;\n\n    if (lineIndex >= this._len) {\n      return;\n    }\n\n    if (eolCount === 0) {\n      // Inserting text on one line\n      this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n      return;\n    }\n\n    this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n    this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n\n    this._insertLines(position.lineNumber, eolCount);\n  }\n\n}\n\nfunction getDefaultMetadata(topLevelLanguageId) {\n  return (topLevelLanguageId << 0\n  /* LANGUAGEID_OFFSET */\n  | 0\n  /* Other */\n  << 8\n  /* TOKEN_TYPE_OFFSET */\n  | 0\n  /* None */\n  << 10\n  /* FONT_STYLE_OFFSET */\n  | 1\n  /* DefaultForeground */\n  << 14\n  /* FOREGROUND_OFFSET */\n  | 2\n  /* DefaultBackground */\n  << 23\n  /* BACKGROUND_OFFSET */\n  ) >>> 0;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js"],"names":["arrays","Position","ContiguousTokensEditing","EMPTY_LINE_TOKENS","toUint32Array","LineTokens","TokenMetadata","ContiguousTokensStore","constructor","languageIdCodec","_lineTokens","_len","_languageIdCodec","flush","getTokens","topLevelLanguageId","lineIndex","lineText","rawLineTokens","lineTokens","Uint32Array","length","getDefaultMetadata","encodeLanguageId","_massageTokens","lineTextLength","_tokens","tokens","hasDifferentLanguageId","getLanguageId","buffer","byteOffset","byteLength","_ensureLine","_deleteLines","start","deleteCount","splice","_insertLines","insertIndex","insertCount","i","arrayInsert","setTokens","checkEquality","oldTokens","_equals","_a","_b","a","b","len","acceptEdit","range","eolCount","firstLineLength","_acceptDeleteRange","_acceptInsertText","startLineNumber","startColumn","firstLineIndex","endLineNumber","endColumn","delete","deleteEnding","lastLineIndex","lastLineTokens","deleteBeginning","append","position","lineNumber","insert","column"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../languages.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\n        | (0 /* None */ << 10 /* FONT_STYLE_OFFSET */)\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n}\n"]},"metadata":{},"sourceType":"module"}