{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as languages from '../../../common/languages.js';\nimport { NullState } from '../../../common/languages/nullMode.js';\nimport * as monarchCommon from './monarchCommon.js';\nconst CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\n\nclass MonarchStackElementFactory {\n  constructor(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n\n  static create(parent, state) {\n    return this._INSTANCE.create(parent, state);\n  }\n\n  create(parent, state) {\n    if (parent !== null && parent.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchStackElement(parent, state);\n    }\n\n    let stackElementId = MonarchStackElement.getStackElementId(parent);\n\n    if (stackElementId.length > 0) {\n      stackElementId += '|';\n    }\n\n    stackElementId += state;\n    let result = this._entries[stackElementId];\n\n    if (result) {\n      return result;\n    }\n\n    result = new MonarchStackElement(parent, state);\n    this._entries[stackElementId] = result;\n    return result;\n  }\n\n}\n\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\n\nclass MonarchStackElement {\n  constructor(parent, state) {\n    this.parent = parent;\n    this.state = state;\n    this.depth = (this.parent ? this.parent.depth : 0) + 1;\n  }\n\n  static getStackElementId(element) {\n    let result = '';\n\n    while (element !== null) {\n      if (result.length > 0) {\n        result += '|';\n      }\n\n      result += element.state;\n      element = element.parent;\n    }\n\n    return result;\n  }\n\n  static _equals(a, b) {\n    while (a !== null && b !== null) {\n      if (a === b) {\n        return true;\n      }\n\n      if (a.state !== b.state) {\n        return false;\n      }\n\n      a = a.parent;\n      b = b.parent;\n    }\n\n    if (a === null && b === null) {\n      return true;\n    }\n\n    return false;\n  }\n\n  equals(other) {\n    return MonarchStackElement._equals(this, other);\n  }\n\n  push(state) {\n    return MonarchStackElementFactory.create(this, state);\n  }\n\n  pop() {\n    return this.parent;\n  }\n\n  popall() {\n    let result = this;\n\n    while (result.parent) {\n      result = result.parent;\n    }\n\n    return result;\n  }\n\n  switchTo(state) {\n    return MonarchStackElementFactory.create(this.parent, state);\n  }\n\n}\n\nclass EmbeddedLanguageData {\n  constructor(languageId, state) {\n    this.languageId = languageId;\n    this.state = state;\n  }\n\n  equals(other) {\n    return this.languageId === other.languageId && this.state.equals(other.state);\n  }\n\n  clone() {\n    const stateClone = this.state.clone(); // save an object\n\n    if (stateClone === this.state) {\n      return this;\n    }\n\n    return new EmbeddedLanguageData(this.languageId, this.state);\n  }\n\n}\n/**\n * Reuse the same line states up to a certain depth.\n */\n\n\nclass MonarchLineStateFactory {\n  constructor(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n\n  static create(stack, embeddedLanguageData) {\n    return this._INSTANCE.create(stack, embeddedLanguageData);\n  }\n\n  create(stack, embeddedLanguageData) {\n    if (embeddedLanguageData !== null) {\n      // no caching when embedding\n      return new MonarchLineState(stack, embeddedLanguageData);\n    }\n\n    if (stack !== null && stack.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchLineState(stack, embeddedLanguageData);\n    }\n\n    const stackElementId = MonarchStackElement.getStackElementId(stack);\n    let result = this._entries[stackElementId];\n\n    if (result) {\n      return result;\n    }\n\n    result = new MonarchLineState(stack, null);\n    this._entries[stackElementId] = result;\n    return result;\n  }\n\n}\n\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\n\nclass MonarchLineState {\n  constructor(stack, embeddedLanguageData) {\n    this.stack = stack;\n    this.embeddedLanguageData = embeddedLanguageData;\n  }\n\n  clone() {\n    const embeddedlanguageDataClone = this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null; // save an object\n\n    if (embeddedlanguageDataClone === this.embeddedLanguageData) {\n      return this;\n    }\n\n    return MonarchLineStateFactory.create(this.stack, this.embeddedLanguageData);\n  }\n\n  equals(other) {\n    if (!(other instanceof MonarchLineState)) {\n      return false;\n    }\n\n    if (!this.stack.equals(other.stack)) {\n      return false;\n    }\n\n    if (this.embeddedLanguageData === null && other.embeddedLanguageData === null) {\n      return true;\n    }\n\n    if (this.embeddedLanguageData === null || other.embeddedLanguageData === null) {\n      return false;\n    }\n\n    return this.embeddedLanguageData.equals(other.embeddedLanguageData);\n  }\n\n}\n\nclass MonarchClassicTokensCollector {\n  constructor() {\n    this._tokens = [];\n    this._languageId = null;\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n  }\n\n  enterLanguage(languageId) {\n    this._languageId = languageId;\n  }\n\n  emit(startOffset, type) {\n    if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {\n      return;\n    }\n\n    this._lastTokenType = type;\n    this._lastTokenLanguage = this._languageId;\n\n    this._tokens.push(new languages.Token(startOffset, type, this._languageId));\n  }\n\n  nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n    const nestedLanguageId = embeddedLanguageData.languageId;\n    const embeddedModeState = embeddedLanguageData.state;\n    const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n\n    if (!nestedLanguageTokenizationSupport) {\n      this.enterLanguage(nestedLanguageId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n\n    const nestedResult = nestedLanguageTokenizationSupport.tokenize(embeddedLanguageLine, hasEOL, embeddedModeState);\n\n    if (offsetDelta !== 0) {\n      for (const token of nestedResult.tokens) {\n        this._tokens.push(new languages.Token(token.offset + offsetDelta, token.type, token.language));\n      }\n    } else {\n      this._tokens = this._tokens.concat(nestedResult.tokens);\n    }\n\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n    this._languageId = null;\n    return nestedResult.endState;\n  }\n\n  finalize(endState) {\n    return new languages.TokenizationResult(this._tokens, endState);\n  }\n\n}\n\nclass MonarchModernTokensCollector {\n  constructor(languageService, theme) {\n    this._languageService = languageService;\n    this._theme = theme;\n    this._prependTokens = null;\n    this._tokens = [];\n    this._currentLanguageId = 0\n    /* Null */\n    ;\n    this._lastTokenMetadata = 0;\n  }\n\n  enterLanguage(languageId) {\n    this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n  }\n\n  emit(startOffset, type) {\n    const metadata = this._theme.match(this._currentLanguageId, type);\n\n    if (this._lastTokenMetadata === metadata) {\n      return;\n    }\n\n    this._lastTokenMetadata = metadata;\n\n    this._tokens.push(startOffset);\n\n    this._tokens.push(metadata);\n  }\n\n  static _merge(a, b, c) {\n    const aLen = a !== null ? a.length : 0;\n    const bLen = b.length;\n    const cLen = c !== null ? c.length : 0;\n\n    if (aLen === 0 && bLen === 0 && cLen === 0) {\n      return new Uint32Array(0);\n    }\n\n    if (aLen === 0 && bLen === 0) {\n      return c;\n    }\n\n    if (bLen === 0 && cLen === 0) {\n      return a;\n    }\n\n    const result = new Uint32Array(aLen + bLen + cLen);\n\n    if (a !== null) {\n      result.set(a);\n    }\n\n    for (let i = 0; i < bLen; i++) {\n      result[aLen + i] = b[i];\n    }\n\n    if (c !== null) {\n      result.set(c, aLen + bLen);\n    }\n\n    return result;\n  }\n\n  nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n    const nestedLanguageId = embeddedLanguageData.languageId;\n    const embeddedModeState = embeddedLanguageData.state;\n    const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n\n    if (!nestedLanguageTokenizationSupport) {\n      this.enterLanguage(nestedLanguageId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n\n    const nestedResult = nestedLanguageTokenizationSupport.tokenizeEncoded(embeddedLanguageLine, hasEOL, embeddedModeState);\n\n    if (offsetDelta !== 0) {\n      for (let i = 0, len = nestedResult.tokens.length; i < len; i += 2) {\n        nestedResult.tokens[i] += offsetDelta;\n      }\n    }\n\n    this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n    this._tokens = [];\n    this._currentLanguageId = 0;\n    this._lastTokenMetadata = 0;\n    return nestedResult.endState;\n  }\n\n  finalize(endState) {\n    return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n  }\n\n}\n\nexport class MonarchTokenizer {\n  constructor(languageService, standaloneThemeService, languageId, lexer) {\n    this._languageService = languageService;\n    this._standaloneThemeService = standaloneThemeService;\n    this._languageId = languageId;\n    this._lexer = lexer;\n    this._embeddedLanguages = Object.create(null);\n    this.embeddedLoaded = Promise.resolve(undefined); // Set up listening for embedded modes\n\n    let emitting = false;\n    this._tokenizationRegistryListener = languages.TokenizationRegistry.onDidChange(e => {\n      if (emitting) {\n        return;\n      }\n\n      let isOneOfMyEmbeddedModes = false;\n\n      for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n        const language = e.changedLanguages[i];\n\n        if (this._embeddedLanguages[language]) {\n          isOneOfMyEmbeddedModes = true;\n          break;\n        }\n      }\n\n      if (isOneOfMyEmbeddedModes) {\n        emitting = true;\n        languages.TokenizationRegistry.fire([this._languageId]);\n        emitting = false;\n      }\n    });\n  }\n\n  dispose() {\n    this._tokenizationRegistryListener.dispose();\n  }\n\n  getLoadStatus() {\n    const promises = [];\n\n    for (let nestedLanguageId in this._embeddedLanguages) {\n      const tokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n\n      if (tokenizationSupport) {\n        // The nested language is already loaded\n        if (tokenizationSupport instanceof MonarchTokenizer) {\n          const nestedModeStatus = tokenizationSupport.getLoadStatus();\n\n          if (nestedModeStatus.loaded === false) {\n            promises.push(nestedModeStatus.promise);\n          }\n        }\n\n        continue;\n      }\n\n      if (!languages.TokenizationRegistry.isResolved(nestedLanguageId)) {\n        // The nested language is in the process of being loaded\n        promises.push(languages.TokenizationRegistry.getOrCreate(nestedLanguageId));\n      }\n    }\n\n    if (promises.length === 0) {\n      return {\n        loaded: true\n      };\n    }\n\n    return {\n      loaded: false,\n      promise: Promise.all(promises).then(_ => undefined)\n    };\n  }\n\n  getInitialState() {\n    const rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n    return MonarchLineStateFactory.create(rootState, null);\n  }\n\n  tokenize(line, hasEOL, lineState) {\n    const tokensCollector = new MonarchClassicTokensCollector();\n\n    const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n\n    return tokensCollector.finalize(endLineState);\n  }\n\n  tokenizeEncoded(line, hasEOL, lineState) {\n    const tokensCollector = new MonarchModernTokensCollector(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme);\n\n    const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n\n    return tokensCollector.finalize(endLineState);\n  }\n\n  _tokenize(line, hasEOL, lineState, collector) {\n    if (lineState.embeddedLanguageData) {\n      return this._nestedTokenize(line, hasEOL, lineState, 0, collector);\n    } else {\n      return this._myTokenize(line, hasEOL, lineState, 0, collector);\n    }\n  }\n\n  _findLeavingNestedLanguageOffset(line, state) {\n    let rules = this._lexer.tokenizer[state.stack.state];\n\n    if (!rules) {\n      rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n\n      if (!rules) {\n        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n      }\n    }\n\n    let popOffset = -1;\n    let hasEmbeddedPopRule = false;\n\n    for (const rule of rules) {\n      if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n        continue;\n      }\n\n      hasEmbeddedPopRule = true;\n      let regex = rule.regex;\n      const regexSource = rule.regex.source;\n\n      if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n        const flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n      }\n\n      const result = line.search(regex);\n\n      if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {\n        continue;\n      }\n\n      if (popOffset === -1 || result < popOffset) {\n        popOffset = result;\n      }\n    }\n\n    if (!hasEmbeddedPopRule) {\n      throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n    }\n\n    return popOffset;\n  }\n\n  _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n    const popOffset = this._findLeavingNestedLanguageOffset(line, lineState);\n\n    if (popOffset === -1) {\n      // tokenization will not leave nested language\n      const nestedEndState = tokensCollector.nestedLanguageTokenize(line, hasEOL, lineState.embeddedLanguageData, offsetDelta);\n      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedLanguageData(lineState.embeddedLanguageData.languageId, nestedEndState));\n    }\n\n    const nestedLanguageLine = line.substring(0, popOffset);\n\n    if (nestedLanguageLine.length > 0) {\n      // tokenize with the nested language\n      tokensCollector.nestedLanguageTokenize(nestedLanguageLine, false, lineState.embeddedLanguageData, offsetDelta);\n    }\n\n    const restOfTheLine = line.substring(popOffset);\n    return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n  }\n\n  _safeRuleName(rule) {\n    if (rule) {\n      return rule.name;\n    }\n\n    return '(unknown)';\n  }\n\n  _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n    tokensCollector.enterLanguage(this._languageId);\n    const lineWithoutLFLength = lineWithoutLF.length;\n    const line = hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF;\n    const lineLength = line.length;\n    let embeddedLanguageData = lineState.embeddedLanguageData;\n    let stack = lineState.stack;\n    let pos = 0;\n    let groupMatching = null; // See https://github.com/microsoft/monaco-editor/issues/1235\n    // Evaluate rules at least once for an empty line\n\n    let forceEvaluation = true;\n\n    while (forceEvaluation || pos < lineLength) {\n      const pos0 = pos;\n      const stackLen0 = stack.depth;\n      const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n      const state = stack.state;\n      let matches = null;\n      let matched = null;\n      let action = null;\n      let rule = null;\n      let enteringEmbeddedLanguage = null; // check if we need to process group matches first\n\n      if (groupMatching) {\n        matches = groupMatching.matches;\n        const groupEntry = groupMatching.groups.shift();\n        matched = groupEntry.matched;\n        action = groupEntry.action;\n        rule = groupMatching.rule; // cleanup if necessary\n\n        if (groupMatching.groups.length === 0) {\n          groupMatching = null;\n        }\n      } else {\n        // otherwise we match on the token stream\n        if (!forceEvaluation && pos >= lineLength) {\n          // nothing to do\n          break;\n        }\n\n        forceEvaluation = false; // get the rules for this state\n\n        let rules = this._lexer.tokenizer[state];\n\n        if (!rules) {\n          rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n\n          if (!rules) {\n            throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n          }\n        } // try each rule until we match\n\n\n        let restOfLine = line.substr(pos);\n\n        for (const rule of rules) {\n          if (pos === 0 || !rule.matchOnlyAtLineStart) {\n            matches = restOfLine.match(rule.regex);\n\n            if (matches) {\n              matched = matches[0];\n              action = rule.action;\n              break;\n            }\n          }\n        }\n      } // We matched 'rule' with 'matches' and 'action'\n\n\n      if (!matches) {\n        matches = [''];\n        matched = '';\n      }\n\n      if (!action) {\n        // bad: we didn't match anything, and there is no action to take\n        // we need to advance the stream or we get progress trouble\n        if (pos < lineLength) {\n          matches = [line.charAt(pos)];\n          matched = matches[0];\n        }\n\n        action = this._lexer.defaultToken;\n      }\n\n      if (matched === null) {\n        // should never happen, needed for strict null checking\n        break;\n      } // advance stream\n\n\n      pos += matched.length; // maybe call action function (used for 'cases')\n\n      while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n        action = action.test(matched, matches, state, pos === lineLength);\n      }\n\n      let result = null; // set the result: either a string or an array of actions\n\n      if (typeof action === 'string' || Array.isArray(action)) {\n        result = action;\n      } else if (action.group) {\n        result = action.group;\n      } else if (action.token !== null && action.token !== undefined) {\n        // do $n replacements?\n        if (action.tokenSubst) {\n          result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n        } else {\n          result = action.token;\n        } // enter embedded language?\n\n\n        if (action.nextEmbedded) {\n          if (action.nextEmbedded === '@pop') {\n            if (!embeddedLanguageData) {\n              throw monarchCommon.createError(this._lexer, 'cannot pop embedded language if not inside one');\n            }\n\n            embeddedLanguageData = null;\n          } else if (embeddedLanguageData) {\n            throw monarchCommon.createError(this._lexer, 'cannot enter embedded language from within an embedded language');\n          } else {\n            enteringEmbeddedLanguage = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n          }\n        } // state transformations\n\n\n        if (action.goBack) {\n          // back up the stream..\n          pos = Math.max(0, pos - action.goBack);\n        }\n\n        if (action.switchTo && typeof action.switchTo === 'string') {\n          let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n\n          if (nextState[0] === '@') {\n            nextState = nextState.substr(1); // peel off starting '@'\n          }\n\n          if (!monarchCommon.findRules(this._lexer, nextState)) {\n            throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n          } else {\n            stack = stack.switchTo(nextState);\n          }\n        } else if (action.transform && typeof action.transform === 'function') {\n          throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n        } else if (action.next) {\n          if (action.next === '@push') {\n            if (stack.depth >= this._lexer.maxStack) {\n              throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' + stack.state + ',' + stack.parent.state + ',...]');\n            } else {\n              stack = stack.push(state);\n            }\n          } else if (action.next === '@pop') {\n            if (stack.depth <= 1) {\n              throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.pop();\n            }\n          } else if (action.next === '@popall') {\n            stack = stack.popall();\n          } else {\n            let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n\n            if (nextState[0] === '@') {\n              nextState = nextState.substr(1); // peel off starting '@'\n            }\n\n            if (!monarchCommon.findRules(this._lexer, nextState)) {\n              throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.push(nextState);\n            }\n          }\n        }\n\n        if (action.log && typeof action.log === 'string') {\n          monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n        }\n      } // check result\n\n\n      if (result === null) {\n        throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n      }\n\n      const computeNewStateForEmbeddedLanguage = enteringEmbeddedLanguage => {\n        // support language names, mime types, and language ids\n        const languageId = this._languageService.getLanguageIdByLanguageName(enteringEmbeddedLanguage) || this._languageService.getLanguageIdByMimeType(enteringEmbeddedLanguage) || enteringEmbeddedLanguage;\n\n        const embeddedLanguageData = this._getNestedEmbeddedLanguageData(languageId);\n\n        if (pos < lineLength) {\n          // there is content from the embedded language on this line\n          const restOfLine = lineWithoutLF.substr(pos);\n          return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedLanguageData), offsetDelta + pos, tokensCollector);\n        } else {\n          return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n        }\n      }; // is the result a group match?\n\n\n      if (Array.isArray(result)) {\n        if (groupMatching && groupMatching.groups.length > 0) {\n          throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n        }\n\n        if (matches.length !== result.length + 1) {\n          throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n        }\n\n        let totalLen = 0;\n\n        for (let i = 1; i < matches.length; i++) {\n          totalLen += matches[i].length;\n        }\n\n        if (totalLen !== matched.length) {\n          throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n        }\n\n        groupMatching = {\n          rule: rule,\n          matches: matches,\n          groups: []\n        };\n\n        for (let i = 0; i < result.length; i++) {\n          groupMatching.groups[i] = {\n            action: result[i],\n            matched: matches[i + 1]\n          };\n        }\n\n        pos -= matched.length; // call recursively to initiate first result match\n\n        continue;\n      } else {\n        // regular result\n        // check for '@rematch'\n        if (result === '@rematch') {\n          pos -= matched.length;\n          matched = ''; // better set the next state too..\n\n          matches = null;\n          result = ''; // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n          // a state transition should occur.\n\n          if (enteringEmbeddedLanguage !== null) {\n            return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n          }\n        } // check progress\n\n\n        if (matched.length === 0) {\n          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n            continue;\n          } else {\n            throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n          }\n        } // return the result (and check for brace matching)\n        // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n\n\n        let tokenType = null;\n\n        if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n          const rest = result.substr('@brackets'.length);\n          const bracket = findBracket(this._lexer, matched);\n\n          if (!bracket) {\n            throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n          }\n\n          tokenType = monarchCommon.sanitize(bracket.token + rest);\n        } else {\n          const token = result === '' ? '' : result + this._lexer.tokenPostfix;\n          tokenType = monarchCommon.sanitize(token);\n        }\n\n        if (pos0 < lineWithoutLFLength) {\n          tokensCollector.emit(pos0 + offsetDelta, tokenType);\n        }\n      }\n\n      if (enteringEmbeddedLanguage !== null) {\n        return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n      }\n    }\n\n    return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n  }\n\n  _getNestedEmbeddedLanguageData(languageId) {\n    if (!this._languageService.isRegisteredLanguageId(languageId)) {\n      return new EmbeddedLanguageData(languageId, NullState);\n    }\n\n    if (languageId !== this._languageId) {\n      // Fire language loading event\n      languages.TokenizationRegistry.getOrCreate(languageId);\n      this._embeddedLanguages[languageId] = true;\n    }\n\n    const tokenizationSupport = languages.TokenizationRegistry.get(languageId);\n\n    if (tokenizationSupport) {\n      return new EmbeddedLanguageData(languageId, tokenizationSupport.getInitialState());\n    }\n\n    return new EmbeddedLanguageData(languageId, NullState);\n  }\n\n}\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\n\nfunction findBracket(lexer, matched) {\n  if (!matched) {\n    return null;\n  }\n\n  matched = monarchCommon.fixCase(lexer, matched);\n  const brackets = lexer.brackets;\n\n  for (const bracket of brackets) {\n    if (bracket.open === matched) {\n      return {\n        token: bracket.token,\n        bracketType: 1\n        /* Open */\n\n      };\n    } else if (bracket.close === matched) {\n      return {\n        token: bracket.token,\n        bracketType: -1\n        /* Close */\n\n      };\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js"],"names":["languages","NullState","monarchCommon","CACHE_STACK_DEPTH","MonarchStackElementFactory","constructor","maxCacheDepth","_maxCacheDepth","_entries","Object","create","parent","state","_INSTANCE","depth","MonarchStackElement","stackElementId","getStackElementId","length","result","element","_equals","a","b","equals","other","push","pop","popall","switchTo","EmbeddedLanguageData","languageId","clone","stateClone","MonarchLineStateFactory","stack","embeddedLanguageData","MonarchLineState","embeddedlanguageDataClone","MonarchClassicTokensCollector","_tokens","_languageId","_lastTokenType","_lastTokenLanguage","enterLanguage","emit","startOffset","type","Token","nestedLanguageTokenize","embeddedLanguageLine","hasEOL","offsetDelta","nestedLanguageId","embeddedModeState","nestedLanguageTokenizationSupport","TokenizationRegistry","get","nestedResult","tokenize","token","tokens","offset","language","concat","endState","finalize","TokenizationResult","MonarchModernTokensCollector","languageService","theme","_languageService","_theme","_prependTokens","_currentLanguageId","_lastTokenMetadata","languageIdCodec","encodeLanguageId","metadata","match","_merge","c","aLen","bLen","cLen","Uint32Array","set","i","tokenizeEncoded","len","EncodedTokenizationResult","MonarchTokenizer","standaloneThemeService","lexer","_standaloneThemeService","_lexer","_embeddedLanguages","embeddedLoaded","Promise","resolve","undefined","emitting","_tokenizationRegistryListener","onDidChange","e","isOneOfMyEmbeddedModes","changedLanguages","fire","dispose","getLoadStatus","promises","tokenizationSupport","nestedModeStatus","loaded","promise","isResolved","getOrCreate","all","then","_","getInitialState","rootState","start","line","lineState","tokensCollector","endLineState","_tokenize","getColorTheme","tokenTheme","collector","_nestedTokenize","_myTokenize","_findLeavingNestedLanguageOffset","rules","tokenizer","findRules","createError","popOffset","hasEmbeddedPopRule","rule","isIAction","action","nextEmbedded","regex","regexSource","source","substr","flags","ignoreCase","unicode","RegExp","search","matchOnlyAtLineStart","nestedEndState","nestedLanguageLine","substring","restOfTheLine","_safeRuleName","name","lineWithoutLF","lineWithoutLFLength","includeLF","lineLength","pos","groupMatching","forceEvaluation","pos0","stackLen0","groupLen0","groups","matches","matched","enteringEmbeddedLanguage","groupEntry","shift","restOfLine","charAt","defaultToken","isFuzzyAction","test","Array","isArray","group","tokenSubst","substituteMatches","goBack","Math","max","nextState","transform","next","maxStack","log","computeNewStateForEmbeddedLanguage","getLanguageIdByLanguageName","getLanguageIdByMimeType","_getNestedEmbeddedLanguageData","totalLen","tokenType","isString","indexOf","rest","bracket","findBracket","sanitize","tokenPostfix","isRegisteredLanguageId","fixCase","brackets","open","bracketType","close"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as languages from '../../../common/languages.js';\nimport { NullState } from '../../../common/languages/nullMode.js';\nimport * as monarchCommon from './monarchCommon.js';\nconst CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\nclass MonarchStackElementFactory {\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    static create(parent, state) {\n        return this._INSTANCE.create(parent, state);\n    }\n    create(parent, state) {\n        if (parent !== null && parent.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchStackElement(parent, state);\n        }\n        let stackElementId = MonarchStackElement.getStackElementId(parent);\n        if (stackElementId.length > 0) {\n            stackElementId += '|';\n        }\n        stackElementId += state;\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchStackElement(parent, state);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\nclass MonarchStackElement {\n    constructor(parent, state) {\n        this.parent = parent;\n        this.state = state;\n        this.depth = (this.parent ? this.parent.depth : 0) + 1;\n    }\n    static getStackElementId(element) {\n        let result = '';\n        while (element !== null) {\n            if (result.length > 0) {\n                result += '|';\n            }\n            result += element.state;\n            element = element.parent;\n        }\n        return result;\n    }\n    static _equals(a, b) {\n        while (a !== null && b !== null) {\n            if (a === b) {\n                return true;\n            }\n            if (a.state !== b.state) {\n                return false;\n            }\n            a = a.parent;\n            b = b.parent;\n        }\n        if (a === null && b === null) {\n            return true;\n        }\n        return false;\n    }\n    equals(other) {\n        return MonarchStackElement._equals(this, other);\n    }\n    push(state) {\n        return MonarchStackElementFactory.create(this, state);\n    }\n    pop() {\n        return this.parent;\n    }\n    popall() {\n        let result = this;\n        while (result.parent) {\n            result = result.parent;\n        }\n        return result;\n    }\n    switchTo(state) {\n        return MonarchStackElementFactory.create(this.parent, state);\n    }\n}\nclass EmbeddedLanguageData {\n    constructor(languageId, state) {\n        this.languageId = languageId;\n        this.state = state;\n    }\n    equals(other) {\n        return (this.languageId === other.languageId\n            && this.state.equals(other.state));\n    }\n    clone() {\n        const stateClone = this.state.clone();\n        // save an object\n        if (stateClone === this.state) {\n            return this;\n        }\n        return new EmbeddedLanguageData(this.languageId, this.state);\n    }\n}\n/**\n * Reuse the same line states up to a certain depth.\n */\nclass MonarchLineStateFactory {\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    static create(stack, embeddedLanguageData) {\n        return this._INSTANCE.create(stack, embeddedLanguageData);\n    }\n    create(stack, embeddedLanguageData) {\n        if (embeddedLanguageData !== null) {\n            // no caching when embedding\n            return new MonarchLineState(stack, embeddedLanguageData);\n        }\n        if (stack !== null && stack.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchLineState(stack, embeddedLanguageData);\n        }\n        const stackElementId = MonarchStackElement.getStackElementId(stack);\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchLineState(stack, null);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\nclass MonarchLineState {\n    constructor(stack, embeddedLanguageData) {\n        this.stack = stack;\n        this.embeddedLanguageData = embeddedLanguageData;\n    }\n    clone() {\n        const embeddedlanguageDataClone = this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null;\n        // save an object\n        if (embeddedlanguageDataClone === this.embeddedLanguageData) {\n            return this;\n        }\n        return MonarchLineStateFactory.create(this.stack, this.embeddedLanguageData);\n    }\n    equals(other) {\n        if (!(other instanceof MonarchLineState)) {\n            return false;\n        }\n        if (!this.stack.equals(other.stack)) {\n            return false;\n        }\n        if (this.embeddedLanguageData === null && other.embeddedLanguageData === null) {\n            return true;\n        }\n        if (this.embeddedLanguageData === null || other.embeddedLanguageData === null) {\n            return false;\n        }\n        return this.embeddedLanguageData.equals(other.embeddedLanguageData);\n    }\n}\nclass MonarchClassicTokensCollector {\n    constructor() {\n        this._tokens = [];\n        this._languageId = null;\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n    }\n    enterLanguage(languageId) {\n        this._languageId = languageId;\n    }\n    emit(startOffset, type) {\n        if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {\n            return;\n        }\n        this._lastTokenType = type;\n        this._lastTokenLanguage = this._languageId;\n        this._tokens.push(new languages.Token(startOffset, type, this._languageId));\n    }\n    nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n        const nestedLanguageId = embeddedLanguageData.languageId;\n        const embeddedModeState = embeddedLanguageData.state;\n        const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (!nestedLanguageTokenizationSupport) {\n            this.enterLanguage(nestedLanguageId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        const nestedResult = nestedLanguageTokenizationSupport.tokenize(embeddedLanguageLine, hasEOL, embeddedModeState);\n        if (offsetDelta !== 0) {\n            for (const token of nestedResult.tokens) {\n                this._tokens.push(new languages.Token(token.offset + offsetDelta, token.type, token.language));\n            }\n        }\n        else {\n            this._tokens = this._tokens.concat(nestedResult.tokens);\n        }\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n        this._languageId = null;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new languages.TokenizationResult(this._tokens, endState);\n    }\n}\nclass MonarchModernTokensCollector {\n    constructor(languageService, theme) {\n        this._languageService = languageService;\n        this._theme = theme;\n        this._prependTokens = null;\n        this._tokens = [];\n        this._currentLanguageId = 0 /* Null */;\n        this._lastTokenMetadata = 0;\n    }\n    enterLanguage(languageId) {\n        this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n    }\n    emit(startOffset, type) {\n        const metadata = this._theme.match(this._currentLanguageId, type);\n        if (this._lastTokenMetadata === metadata) {\n            return;\n        }\n        this._lastTokenMetadata = metadata;\n        this._tokens.push(startOffset);\n        this._tokens.push(metadata);\n    }\n    static _merge(a, b, c) {\n        const aLen = (a !== null ? a.length : 0);\n        const bLen = b.length;\n        const cLen = (c !== null ? c.length : 0);\n        if (aLen === 0 && bLen === 0 && cLen === 0) {\n            return new Uint32Array(0);\n        }\n        if (aLen === 0 && bLen === 0) {\n            return c;\n        }\n        if (bLen === 0 && cLen === 0) {\n            return a;\n        }\n        const result = new Uint32Array(aLen + bLen + cLen);\n        if (a !== null) {\n            result.set(a);\n        }\n        for (let i = 0; i < bLen; i++) {\n            result[aLen + i] = b[i];\n        }\n        if (c !== null) {\n            result.set(c, aLen + bLen);\n        }\n        return result;\n    }\n    nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n        const nestedLanguageId = embeddedLanguageData.languageId;\n        const embeddedModeState = embeddedLanguageData.state;\n        const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (!nestedLanguageTokenizationSupport) {\n            this.enterLanguage(nestedLanguageId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        const nestedResult = nestedLanguageTokenizationSupport.tokenizeEncoded(embeddedLanguageLine, hasEOL, embeddedModeState);\n        if (offsetDelta !== 0) {\n            for (let i = 0, len = nestedResult.tokens.length; i < len; i += 2) {\n                nestedResult.tokens[i] += offsetDelta;\n            }\n        }\n        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n        this._tokens = [];\n        this._currentLanguageId = 0;\n        this._lastTokenMetadata = 0;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n    }\n}\nexport class MonarchTokenizer {\n    constructor(languageService, standaloneThemeService, languageId, lexer) {\n        this._languageService = languageService;\n        this._standaloneThemeService = standaloneThemeService;\n        this._languageId = languageId;\n        this._lexer = lexer;\n        this._embeddedLanguages = Object.create(null);\n        this.embeddedLoaded = Promise.resolve(undefined);\n        // Set up listening for embedded modes\n        let emitting = false;\n        this._tokenizationRegistryListener = languages.TokenizationRegistry.onDidChange((e) => {\n            if (emitting) {\n                return;\n            }\n            let isOneOfMyEmbeddedModes = false;\n            for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n                const language = e.changedLanguages[i];\n                if (this._embeddedLanguages[language]) {\n                    isOneOfMyEmbeddedModes = true;\n                    break;\n                }\n            }\n            if (isOneOfMyEmbeddedModes) {\n                emitting = true;\n                languages.TokenizationRegistry.fire([this._languageId]);\n                emitting = false;\n            }\n        });\n    }\n    dispose() {\n        this._tokenizationRegistryListener.dispose();\n    }\n    getLoadStatus() {\n        const promises = [];\n        for (let nestedLanguageId in this._embeddedLanguages) {\n            const tokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n            if (tokenizationSupport) {\n                // The nested language is already loaded\n                if (tokenizationSupport instanceof MonarchTokenizer) {\n                    const nestedModeStatus = tokenizationSupport.getLoadStatus();\n                    if (nestedModeStatus.loaded === false) {\n                        promises.push(nestedModeStatus.promise);\n                    }\n                }\n                continue;\n            }\n            if (!languages.TokenizationRegistry.isResolved(nestedLanguageId)) {\n                // The nested language is in the process of being loaded\n                promises.push(languages.TokenizationRegistry.getOrCreate(nestedLanguageId));\n            }\n        }\n        if (promises.length === 0) {\n            return {\n                loaded: true\n            };\n        }\n        return {\n            loaded: false,\n            promise: Promise.all(promises).then(_ => undefined)\n        };\n    }\n    getInitialState() {\n        const rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n        return MonarchLineStateFactory.create(rootState, null);\n    }\n    tokenize(line, hasEOL, lineState) {\n        const tokensCollector = new MonarchClassicTokensCollector();\n        const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    tokenizeEncoded(line, hasEOL, lineState) {\n        const tokensCollector = new MonarchModernTokensCollector(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme);\n        const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    _tokenize(line, hasEOL, lineState, collector) {\n        if (lineState.embeddedLanguageData) {\n            return this._nestedTokenize(line, hasEOL, lineState, 0, collector);\n        }\n        else {\n            return this._myTokenize(line, hasEOL, lineState, 0, collector);\n        }\n    }\n    _findLeavingNestedLanguageOffset(line, state) {\n        let rules = this._lexer.tokenizer[state.stack.state];\n        if (!rules) {\n            rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n            if (!rules) {\n                throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n            }\n        }\n        let popOffset = -1;\n        let hasEmbeddedPopRule = false;\n        for (const rule of rules) {\n            if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n                continue;\n            }\n            hasEmbeddedPopRule = true;\n            let regex = rule.regex;\n            const regexSource = rule.regex.source;\n            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n                const flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n            }\n            const result = line.search(regex);\n            if (result === -1 || (result !== 0 && rule.matchOnlyAtLineStart)) {\n                continue;\n            }\n            if (popOffset === -1 || result < popOffset) {\n                popOffset = result;\n            }\n        }\n        if (!hasEmbeddedPopRule) {\n            throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n        }\n        return popOffset;\n    }\n    _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n        const popOffset = this._findLeavingNestedLanguageOffset(line, lineState);\n        if (popOffset === -1) {\n            // tokenization will not leave nested language\n            const nestedEndState = tokensCollector.nestedLanguageTokenize(line, hasEOL, lineState.embeddedLanguageData, offsetDelta);\n            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedLanguageData(lineState.embeddedLanguageData.languageId, nestedEndState));\n        }\n        const nestedLanguageLine = line.substring(0, popOffset);\n        if (nestedLanguageLine.length > 0) {\n            // tokenize with the nested language\n            tokensCollector.nestedLanguageTokenize(nestedLanguageLine, false, lineState.embeddedLanguageData, offsetDelta);\n        }\n        const restOfTheLine = line.substring(popOffset);\n        return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n    }\n    _safeRuleName(rule) {\n        if (rule) {\n            return rule.name;\n        }\n        return '(unknown)';\n    }\n    _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n        tokensCollector.enterLanguage(this._languageId);\n        const lineWithoutLFLength = lineWithoutLF.length;\n        const line = (hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF);\n        const lineLength = line.length;\n        let embeddedLanguageData = lineState.embeddedLanguageData;\n        let stack = lineState.stack;\n        let pos = 0;\n        let groupMatching = null;\n        // See https://github.com/microsoft/monaco-editor/issues/1235\n        // Evaluate rules at least once for an empty line\n        let forceEvaluation = true;\n        while (forceEvaluation || pos < lineLength) {\n            const pos0 = pos;\n            const stackLen0 = stack.depth;\n            const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n            const state = stack.state;\n            let matches = null;\n            let matched = null;\n            let action = null;\n            let rule = null;\n            let enteringEmbeddedLanguage = null;\n            // check if we need to process group matches first\n            if (groupMatching) {\n                matches = groupMatching.matches;\n                const groupEntry = groupMatching.groups.shift();\n                matched = groupEntry.matched;\n                action = groupEntry.action;\n                rule = groupMatching.rule;\n                // cleanup if necessary\n                if (groupMatching.groups.length === 0) {\n                    groupMatching = null;\n                }\n            }\n            else {\n                // otherwise we match on the token stream\n                if (!forceEvaluation && pos >= lineLength) {\n                    // nothing to do\n                    break;\n                }\n                forceEvaluation = false;\n                // get the rules for this state\n                let rules = this._lexer.tokenizer[state];\n                if (!rules) {\n                    rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n                    if (!rules) {\n                        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n                    }\n                }\n                // try each rule until we match\n                let restOfLine = line.substr(pos);\n                for (const rule of rules) {\n                    if (pos === 0 || !rule.matchOnlyAtLineStart) {\n                        matches = restOfLine.match(rule.regex);\n                        if (matches) {\n                            matched = matches[0];\n                            action = rule.action;\n                            break;\n                        }\n                    }\n                }\n            }\n            // We matched 'rule' with 'matches' and 'action'\n            if (!matches) {\n                matches = [''];\n                matched = '';\n            }\n            if (!action) {\n                // bad: we didn't match anything, and there is no action to take\n                // we need to advance the stream or we get progress trouble\n                if (pos < lineLength) {\n                    matches = [line.charAt(pos)];\n                    matched = matches[0];\n                }\n                action = this._lexer.defaultToken;\n            }\n            if (matched === null) {\n                // should never happen, needed for strict null checking\n                break;\n            }\n            // advance stream\n            pos += matched.length;\n            // maybe call action function (used for 'cases')\n            while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n                action = action.test(matched, matches, state, pos === lineLength);\n            }\n            let result = null;\n            // set the result: either a string or an array of actions\n            if (typeof action === 'string' || Array.isArray(action)) {\n                result = action;\n            }\n            else if (action.group) {\n                result = action.group;\n            }\n            else if (action.token !== null && action.token !== undefined) {\n                // do $n replacements?\n                if (action.tokenSubst) {\n                    result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n                }\n                else {\n                    result = action.token;\n                }\n                // enter embedded language?\n                if (action.nextEmbedded) {\n                    if (action.nextEmbedded === '@pop') {\n                        if (!embeddedLanguageData) {\n                            throw monarchCommon.createError(this._lexer, 'cannot pop embedded language if not inside one');\n                        }\n                        embeddedLanguageData = null;\n                    }\n                    else if (embeddedLanguageData) {\n                        throw monarchCommon.createError(this._lexer, 'cannot enter embedded language from within an embedded language');\n                    }\n                    else {\n                        enteringEmbeddedLanguage = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n                    }\n                }\n                // state transformations\n                if (action.goBack) { // back up the stream..\n                    pos = Math.max(0, pos - action.goBack);\n                }\n                if (action.switchTo && typeof action.switchTo === 'string') {\n                    let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n                    if (nextState[0] === '@') {\n                        nextState = nextState.substr(1); // peel off starting '@'\n                    }\n                    if (!monarchCommon.findRules(this._lexer, nextState)) {\n                        throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                    }\n                    else {\n                        stack = stack.switchTo(nextState);\n                    }\n                }\n                else if (action.transform && typeof action.transform === 'function') {\n                    throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n                }\n                else if (action.next) {\n                    if (action.next === '@push') {\n                        if (stack.depth >= this._lexer.maxStack) {\n                            throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\n                                stack.state + ',' + stack.parent.state + ',...]');\n                        }\n                        else {\n                            stack = stack.push(state);\n                        }\n                    }\n                    else if (action.next === '@pop') {\n                        if (stack.depth <= 1) {\n                            throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.pop();\n                        }\n                    }\n                    else if (action.next === '@popall') {\n                        stack = stack.popall();\n                    }\n                    else {\n                        let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n                        if (nextState[0] === '@') {\n                            nextState = nextState.substr(1); // peel off starting '@'\n                        }\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\n                            throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.push(nextState);\n                        }\n                    }\n                }\n                if (action.log && typeof (action.log) === 'string') {\n                    monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n                }\n            }\n            // check result\n            if (result === null) {\n                throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n            }\n            const computeNewStateForEmbeddedLanguage = (enteringEmbeddedLanguage) => {\n                // support language names, mime types, and language ids\n                const languageId = (this._languageService.getLanguageIdByLanguageName(enteringEmbeddedLanguage)\n                    || this._languageService.getLanguageIdByMimeType(enteringEmbeddedLanguage)\n                    || enteringEmbeddedLanguage);\n                const embeddedLanguageData = this._getNestedEmbeddedLanguageData(languageId);\n                if (pos < lineLength) {\n                    // there is content from the embedded language on this line\n                    const restOfLine = lineWithoutLF.substr(pos);\n                    return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedLanguageData), offsetDelta + pos, tokensCollector);\n                }\n                else {\n                    return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n                }\n            };\n            // is the result a group match?\n            if (Array.isArray(result)) {\n                if (groupMatching && groupMatching.groups.length > 0) {\n                    throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n                }\n                if (matches.length !== result.length + 1) {\n                    throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n                }\n                let totalLen = 0;\n                for (let i = 1; i < matches.length; i++) {\n                    totalLen += matches[i].length;\n                }\n                if (totalLen !== matched.length) {\n                    throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n                }\n                groupMatching = {\n                    rule: rule,\n                    matches: matches,\n                    groups: []\n                };\n                for (let i = 0; i < result.length; i++) {\n                    groupMatching.groups[i] = {\n                        action: result[i],\n                        matched: matches[i + 1]\n                    };\n                }\n                pos -= matched.length;\n                // call recursively to initiate first result match\n                continue;\n            }\n            else {\n                // regular result\n                // check for '@rematch'\n                if (result === '@rematch') {\n                    pos -= matched.length;\n                    matched = ''; // better set the next state too..\n                    matches = null;\n                    result = '';\n                    // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n                    // a state transition should occur.\n                    if (enteringEmbeddedLanguage !== null) {\n                        return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n                    }\n                }\n                // check progress\n                if (matched.length === 0) {\n                    if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n                        continue;\n                    }\n                    else {\n                        throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n                    }\n                }\n                // return the result (and check for brace matching)\n                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n                let tokenType = null;\n                if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n                    const rest = result.substr('@brackets'.length);\n                    const bracket = findBracket(this._lexer, matched);\n                    if (!bracket) {\n                        throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n                    }\n                    tokenType = monarchCommon.sanitize(bracket.token + rest);\n                }\n                else {\n                    const token = (result === '' ? '' : result + this._lexer.tokenPostfix);\n                    tokenType = monarchCommon.sanitize(token);\n                }\n                if (pos0 < lineWithoutLFLength) {\n                    tokensCollector.emit(pos0 + offsetDelta, tokenType);\n                }\n            }\n            if (enteringEmbeddedLanguage !== null) {\n                return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n            }\n        }\n        return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n    }\n    _getNestedEmbeddedLanguageData(languageId) {\n        if (!this._languageService.isRegisteredLanguageId(languageId)) {\n            return new EmbeddedLanguageData(languageId, NullState);\n        }\n        if (languageId !== this._languageId) {\n            // Fire language loading event\n            languages.TokenizationRegistry.getOrCreate(languageId);\n            this._embeddedLanguages[languageId] = true;\n        }\n        const tokenizationSupport = languages.TokenizationRegistry.get(languageId);\n        if (tokenizationSupport) {\n            return new EmbeddedLanguageData(languageId, tokenizationSupport.getInitialState());\n        }\n        return new EmbeddedLanguageData(languageId, NullState);\n    }\n}\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\nfunction findBracket(lexer, matched) {\n    if (!matched) {\n        return null;\n    }\n    matched = monarchCommon.fixCase(lexer, matched);\n    const brackets = lexer.brackets;\n    for (const bracket of brackets) {\n        if (bracket.open === matched) {\n            return { token: bracket.token, bracketType: 1 /* Open */ };\n        }\n        else if (bracket.close === matched) {\n            return { token: bracket.token, bracketType: -1 /* Close */ };\n        }\n    }\n    return null;\n}\n"]},"metadata":{},"sourceType":"module"}