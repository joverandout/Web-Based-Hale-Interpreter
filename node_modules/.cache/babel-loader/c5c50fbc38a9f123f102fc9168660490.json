{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorContext, CursorState, EditOperationResult } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewModel/viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n  constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n    super();\n    this._model = model;\n    this._knownModelVersionId = this._model.getVersionId();\n    this._viewModel = viewModel;\n    this._coordinatesConverter = coordinatesConverter;\n    this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n    this._cursors = new CursorCollection(this.context);\n    this._hasFocus = false;\n    this._isHandling = false;\n    this._isDoingComposition = false;\n    this._selectionsWhenCompositionStarted = null;\n    this._columnSelectData = null;\n    this._autoClosedActions = [];\n    this._prevEditOperationType = 0\n    /* Other */\n    ;\n  }\n\n  dispose() {\n    this._cursors.dispose();\n\n    this._autoClosedActions = dispose(this._autoClosedActions);\n    super.dispose();\n  }\n\n  updateConfiguration(cursorConfig) {\n    this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n\n    this._cursors.updateContext(this.context);\n  }\n\n  onLineMappingChanged(eventsCollector) {\n    if (this._knownModelVersionId !== this._model.getVersionId()) {\n      // There are model change events that I didn't yet receive.\n      //\n      // This can happen when editing the model, and the view model receives the change events first,\n      // and the view model emits line mapping changed events, all before the cursor gets a chance to\n      // recover from markers.\n      //\n      // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n      return;\n    } // Ensure valid state\n\n\n    this.setStates(eventsCollector, 'viewModel', 0\n    /* NotSet */\n    , this.getCursorStates());\n  }\n\n  setHasFocus(hasFocus) {\n    this._hasFocus = hasFocus;\n  }\n\n  _validateAutoClosedActions() {\n    if (this._autoClosedActions.length > 0) {\n      const selections = this._cursors.getSelections();\n\n      for (let i = 0; i < this._autoClosedActions.length; i++) {\n        const autoClosedAction = this._autoClosedActions[i];\n\n        if (!autoClosedAction.isValid(selections)) {\n          autoClosedAction.dispose();\n\n          this._autoClosedActions.splice(i, 1);\n\n          i--;\n        }\n      }\n    }\n  } // ------ some getters/setters\n\n\n  getPrimaryCursorState() {\n    return this._cursors.getPrimaryCursor();\n  }\n\n  getLastAddedCursorIndex() {\n    return this._cursors.getLastAddedCursorIndex();\n  }\n\n  getCursorStates() {\n    return this._cursors.getAll();\n  }\n\n  setStates(eventsCollector, source, reason, states) {\n    let reachedMaxCursorCount = false;\n\n    if (states !== null && states.length > CursorsController.MAX_CURSOR_COUNT) {\n      states = states.slice(0, CursorsController.MAX_CURSOR_COUNT);\n      reachedMaxCursorCount = true;\n    }\n\n    const oldState = CursorModelState.from(this._model, this);\n\n    this._cursors.setStates(states);\n\n    this._cursors.normalize();\n\n    this._columnSelectData = null;\n\n    this._validateAutoClosedActions();\n\n    return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n  }\n\n  setCursorColumnSelectData(columnSelectData) {\n    this._columnSelectData = columnSelectData;\n  }\n\n  revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n    const viewPositions = this._cursors.getViewPositions();\n\n    let revealViewRange = null;\n    let revealViewSelections = null;\n\n    if (viewPositions.length > 1) {\n      revealViewSelections = this._cursors.getViewSelections();\n    } else {\n      revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n    }\n\n    eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n  }\n\n  saveState() {\n    const result = [];\n\n    const selections = this._cursors.getSelections();\n\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      result.push({\n        inSelectionMode: !selection.isEmpty(),\n        selectionStart: {\n          lineNumber: selection.selectionStartLineNumber,\n          column: selection.selectionStartColumn\n        },\n        position: {\n          lineNumber: selection.positionLineNumber,\n          column: selection.positionColumn\n        }\n      });\n    }\n\n    return result;\n  }\n\n  restoreState(eventsCollector, states) {\n    const desiredSelections = [];\n\n    for (let i = 0, len = states.length; i < len; i++) {\n      const state = states[i];\n      let positionLineNumber = 1;\n      let positionColumn = 1; // Avoid missing properties on the literal\n\n      if (state.position && state.position.lineNumber) {\n        positionLineNumber = state.position.lineNumber;\n      }\n\n      if (state.position && state.position.column) {\n        positionColumn = state.position.column;\n      }\n\n      let selectionStartLineNumber = positionLineNumber;\n      let selectionStartColumn = positionColumn; // Avoid missing properties on the literal\n\n      if (state.selectionStart && state.selectionStart.lineNumber) {\n        selectionStartLineNumber = state.selectionStart.lineNumber;\n      }\n\n      if (state.selectionStart && state.selectionStart.column) {\n        selectionStartColumn = state.selectionStart.column;\n      }\n\n      desiredSelections.push({\n        selectionStartLineNumber: selectionStartLineNumber,\n        selectionStartColumn: selectionStartColumn,\n        positionLineNumber: positionLineNumber,\n        positionColumn: positionColumn\n      });\n    }\n\n    this.setStates(eventsCollector, 'restoreState', 0\n    /* NotSet */\n    , CursorState.fromModelSelections(desiredSelections));\n    this.revealPrimary(eventsCollector, 'restoreState', false, 0\n    /* Simple */\n    , true, 1\n    /* Immediate */\n    );\n  }\n\n  onModelContentChanged(eventsCollector, e) {\n    if (e instanceof ModelInjectedTextChangedEvent) {\n      // If injected texts change, the view positions of all cursors need to be updated.\n      if (this._isHandling) {\n        // The view positions will be updated when handling finishes\n        return;\n      } // setStates might remove markers, which could trigger a decoration change.\n      // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n      // and an endless recursion happens.\n      // _isHandling prevents that.\n\n\n      this._isHandling = true;\n\n      try {\n        this.setStates(eventsCollector, 'modelChange', 0\n        /* NotSet */\n        , this.getCursorStates());\n      } finally {\n        this._isHandling = false;\n      }\n    } else {\n      this._knownModelVersionId = e.versionId;\n\n      if (this._isHandling) {\n        return;\n      }\n\n      const hadFlushEvent = e.containsEvent(1\n      /* Flush */\n      );\n      this._prevEditOperationType = 0\n      /* Other */\n      ;\n\n      if (hadFlushEvent) {\n        // a model.setValue() was called\n        this._cursors.dispose();\n\n        this._cursors = new CursorCollection(this.context);\n\n        this._validateAutoClosedActions();\n\n        this._emitStateChangedIfNecessary(eventsCollector, 'model', 1\n        /* ContentFlush */\n        , null, false);\n      } else {\n        if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n          const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n\n          if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5\n          /* Undo */\n          : e.isRedoing ? 6\n          /* Redo */\n          : 2\n          /* RecoverFromMarkers */\n          , cursorState)) {\n            this.revealPrimary(eventsCollector, 'modelChange', false, 0\n            /* Simple */\n            , true, 0\n            /* Smooth */\n            );\n          }\n        } else {\n          const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n\n          this.setStates(eventsCollector, 'modelChange', 2\n          /* RecoverFromMarkers */\n          , CursorState.fromModelSelections(selectionsFromMarkers));\n        }\n      }\n    }\n  }\n\n  getSelection() {\n    return this._cursors.getPrimaryCursor().modelState.selection;\n  }\n\n  getTopMostViewPosition() {\n    return this._cursors.getTopMostViewPosition();\n  }\n\n  getBottomMostViewPosition() {\n    return this._cursors.getBottomMostViewPosition();\n  }\n\n  getCursorColumnSelectData() {\n    if (this._columnSelectData) {\n      return this._columnSelectData;\n    }\n\n    const primaryCursor = this._cursors.getPrimaryCursor();\n\n    const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n    const viewPosition = primaryCursor.viewState.position;\n    return {\n      isReal: false,\n      fromViewLineNumber: viewSelectionStart.lineNumber,\n      fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n      toViewLineNumber: viewPosition.lineNumber,\n      toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition)\n    };\n  }\n\n  getSelections() {\n    return this._cursors.getSelections();\n  }\n\n  setSelections(eventsCollector, source, selections, reason) {\n    this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n  }\n\n  getPrevEditOperationType() {\n    return this._prevEditOperationType;\n  }\n\n  setPrevEditOperationType(type) {\n    this._prevEditOperationType = type;\n  } // ------ auxiliary handling logic\n\n\n  _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n    const autoClosedCharactersDeltaDecorations = [];\n    const autoClosedEnclosingDeltaDecorations = [];\n\n    for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n      autoClosedCharactersDeltaDecorations.push({\n        range: autoClosedCharactersRanges[i],\n        options: {\n          description: 'auto-closed-character',\n          inlineClassName: 'auto-closed-character',\n          stickiness: 1\n          /* NeverGrowsWhenTypingAtEdges */\n\n        }\n      });\n      autoClosedEnclosingDeltaDecorations.push({\n        range: autoClosedEnclosingRanges[i],\n        options: {\n          description: 'auto-closed-enclosing',\n          stickiness: 1\n          /* NeverGrowsWhenTypingAtEdges */\n\n        }\n      });\n    }\n\n    const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n\n    const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n\n    this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n  }\n\n  _executeEditOperation(opResult) {\n    if (!opResult) {\n      // Nothing to execute\n      return;\n    }\n\n    if (opResult.shouldPushStackElementBefore) {\n      this._model.pushStackElement();\n    }\n\n    const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n\n    if (result) {\n      // The commands were applied correctly\n      this._interpretCommandResult(result); // Check for auto-closing closed characters\n\n\n      const autoClosedCharactersRanges = [];\n      const autoClosedEnclosingRanges = [];\n\n      for (let i = 0; i < opResult.commands.length; i++) {\n        const command = opResult.commands[i];\n\n        if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n          autoClosedCharactersRanges.push(command.closeCharacterRange);\n          autoClosedEnclosingRanges.push(command.enclosingRange);\n        }\n      }\n\n      if (autoClosedCharactersRanges.length > 0) {\n        this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n      }\n\n      this._prevEditOperationType = opResult.type;\n    }\n\n    if (opResult.shouldPushStackElementAfter) {\n      this._model.pushStackElement();\n    }\n  }\n\n  _interpretCommandResult(cursorState) {\n    if (!cursorState || cursorState.length === 0) {\n      cursorState = this._cursors.readSelectionFromMarkers();\n    }\n\n    this._columnSelectData = null;\n\n    this._cursors.setSelections(cursorState);\n\n    this._cursors.normalize();\n  } // -----------------------------------------------------------------------------------------------------------\n  // ----- emitting events\n\n\n  _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n    const newState = CursorModelState.from(this._model, this);\n\n    if (newState.equals(oldState)) {\n      return false;\n    }\n\n    const selections = this._cursors.getSelections();\n\n    const viewSelections = this._cursors.getViewSelections(); // Let the view get the event first.\n\n\n    eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections)); // Only after the view has been notified, let the rest of the world know...\n\n    if (!oldState || oldState.cursorState.length !== newState.cursorState.length || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n      const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n      const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n      eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n    }\n\n    return true;\n  } // -----------------------------------------------------------------------------------------------------------\n  // ----- handlers beyond this point\n\n\n  _findAutoClosingPairs(edits) {\n    if (!edits.length) {\n      return null;\n    }\n\n    const indices = [];\n\n    for (let i = 0, len = edits.length; i < len; i++) {\n      const edit = edits[i];\n\n      if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n        return null;\n      }\n\n      const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n\n      if (!m) {\n        return null;\n      }\n\n      const closeChar = m[1];\n      const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n\n      if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n        return null;\n      }\n\n      const openChar = autoClosingPairsCandidates[0].open;\n      const closeCharIndex = edit.text.length - m[2].length - 1;\n      const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n\n      if (openCharIndex === -1) {\n        return null;\n      }\n\n      indices.push([openCharIndex, closeCharIndex]);\n    }\n\n    return indices;\n  }\n\n  executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n    let autoClosingIndices = null;\n\n    if (source === 'snippet') {\n      autoClosingIndices = this._findAutoClosingPairs(edits);\n    }\n\n    if (autoClosingIndices) {\n      edits[0]._isTracked = true;\n    }\n\n    const autoClosedCharactersRanges = [];\n    const autoClosedEnclosingRanges = [];\n\n    const selections = this._model.pushEditOperations(this.getSelections(), edits, undoEdits => {\n      if (autoClosingIndices) {\n        for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n          const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n          const undoEdit = undoEdits[i];\n          const lineNumber = undoEdit.range.startLineNumber;\n          const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n          const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n          autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n          autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n        }\n      }\n\n      const selections = cursorStateComputer(undoEdits);\n\n      if (selections) {\n        // Don't recover the selection from markers because\n        // we know what it should be.\n        this._isHandling = true;\n      }\n\n      return selections;\n    });\n\n    if (selections) {\n      this._isHandling = false;\n      this.setSelections(eventsCollector, source, selections, 0\n      /* NotSet */\n      );\n    }\n\n    if (autoClosedCharactersRanges.length > 0) {\n      this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n    }\n  }\n\n  _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0\n  /* NotSet */\n  ) {\n    if (this.context.cursorConfig.readOnly) {\n      // we cannot edit when read only...\n      return;\n    }\n\n    const oldState = CursorModelState.from(this._model, this);\n\n    this._cursors.stopTrackingSelections();\n\n    this._isHandling = true;\n\n    try {\n      this._cursors.ensureValidState();\n\n      callback();\n    } catch (err) {\n      onUnexpectedError(err);\n    }\n\n    this._isHandling = false;\n\n    this._cursors.startTrackingSelections();\n\n    this._validateAutoClosedActions();\n\n    if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n      this.revealPrimary(eventsCollector, source, false, 0\n      /* Simple */\n      , true, 0\n      /* Smooth */\n      );\n    }\n  }\n\n  setIsDoingComposition(isDoingComposition) {\n    this._isDoingComposition = isDoingComposition;\n  }\n\n  getAutoClosedCharacters() {\n    return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n  }\n\n  startComposition(eventsCollector) {\n    this._selectionsWhenCompositionStarted = this.getSelections().slice(0);\n  }\n\n  endComposition(eventsCollector, source) {\n    this._executeEdit(() => {\n      if (source === 'keyboard') {\n        // composition finishes, let's check if we need to auto complete if necessary.\n        this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), this.getAutoClosedCharacters()));\n\n        this._selectionsWhenCompositionStarted = null;\n      }\n    }, eventsCollector, source);\n  }\n\n  type(eventsCollector, text, source) {\n    this._executeEdit(() => {\n      if (source === 'keyboard') {\n        // If this event is coming straight from the keyboard, look for electric characters and enter\n        const len = text.length;\n        let offset = 0;\n\n        while (offset < len) {\n          const charLength = strings.nextCharLength(text, offset);\n          const chr = text.substr(offset, charLength); // Here we must interpret each typed character individually\n\n          this._executeEditOperation(TypeOperations.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n\n          offset += charLength;\n        }\n      } else {\n        this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n      }\n    }, eventsCollector, source);\n  }\n\n  compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n    if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n      // this edit is a no-op\n      if (positionDelta !== 0) {\n        // but it still wants to move the cursor\n        const newSelections = this.getSelections().map(selection => {\n          const position = selection.getPosition();\n          return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n        });\n        this.setSelections(eventsCollector, source, newSelections, 0\n        /* NotSet */\n        );\n      }\n\n      return;\n    }\n\n    this._executeEdit(() => {\n      this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n    }, eventsCollector, source);\n  }\n\n  paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n    }, eventsCollector, source, 4\n    /* Paste */\n    );\n  }\n\n  cut(eventsCollector, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n    }, eventsCollector, source);\n  }\n\n  executeCommand(eventsCollector, command, source) {\n    this._executeEdit(() => {\n      this._cursors.killSecondaryCursors();\n\n      this._executeEditOperation(new EditOperationResult(0\n      /* Other */\n      , [command], {\n        shouldPushStackElementBefore: false,\n        shouldPushStackElementAfter: false\n      }));\n    }, eventsCollector, source);\n  }\n\n  executeCommands(eventsCollector, commands, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(new EditOperationResult(0\n      /* Other */\n      , commands, {\n        shouldPushStackElementBefore: false,\n        shouldPushStackElementAfter: false\n      }));\n    }, eventsCollector, source);\n  }\n\n}\nCursorsController.MAX_CURSOR_COUNT = 10000;\n/**\n * A snapshot of the cursor and the model state\n */\n\nclass CursorModelState {\n  constructor(modelVersionId, cursorState) {\n    this.modelVersionId = modelVersionId;\n    this.cursorState = cursorState;\n  }\n\n  static from(model, cursor) {\n    return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n  }\n\n  equals(other) {\n    if (!other) {\n      return false;\n    }\n\n    if (this.modelVersionId !== other.modelVersionId) {\n      return false;\n    }\n\n    if (this.cursorState.length !== other.cursorState.length) {\n      return false;\n    }\n\n    for (let i = 0, len = this.cursorState.length; i < len; i++) {\n      if (!this.cursorState[i].equals(other.cursorState[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nclass AutoClosedAction {\n  constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n    this._model = model;\n    this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n    this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n  }\n\n  static getAllAutoClosedCharacters(autoClosedActions) {\n    let autoClosedCharacters = [];\n\n    for (const autoClosedAction of autoClosedActions) {\n      autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n    }\n\n    return autoClosedCharacters;\n  }\n\n  dispose() {\n    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n    this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n  }\n\n  getAutoClosedCharactersRanges() {\n    const result = [];\n\n    for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n      const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n\n      if (decorationRange) {\n        result.push(decorationRange);\n      }\n    }\n\n    return result;\n  }\n\n  isValid(selections) {\n    const enclosingRanges = [];\n\n    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n      const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n\n      if (decorationRange) {\n        enclosingRanges.push(decorationRange);\n\n        if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n          // Stop tracking if the range becomes multiline...\n          return false;\n        }\n      }\n    }\n\n    enclosingRanges.sort(Range.compareRangesUsingStarts);\n    selections.sort(Range.compareRangesUsingStarts);\n\n    for (let i = 0; i < selections.length; i++) {\n      if (i >= enclosingRanges.length) {\n        return false;\n      }\n\n      if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nclass CommandExecutor {\n  static executeCommands(model, selectionsBefore, commands) {\n    const ctx = {\n      model: model,\n      selectionsBefore: selectionsBefore,\n      trackedRanges: [],\n      trackedRangesDirection: []\n    };\n\n    const result = this._innerExecuteCommands(ctx, commands);\n\n    for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n      ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0\n      /* AlwaysGrowsWhenTypingAtEdges */\n      );\n    }\n\n    return result;\n  }\n\n  static _innerExecuteCommands(ctx, commands) {\n    if (this._arrayIsEmpty(commands)) {\n      return null;\n    }\n\n    const commandsData = this._getEditOperations(ctx, commands);\n\n    if (commandsData.operations.length === 0) {\n      return null;\n    }\n\n    const rawOperations = commandsData.operations;\n\n    const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n\n    if (loserCursorsMap.hasOwnProperty('0')) {\n      // These commands are very messed up\n      console.warn('Ignoring commands');\n      return null;\n    } // Remove operations belonging to losing cursors\n\n\n    const filteredOperations = [];\n\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n        filteredOperations.push(rawOperations[i]);\n      }\n    } // TODO@Alex: find a better way to do this.\n    // give the hint that edit operations are tracked to the model\n\n\n    if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n      filteredOperations[0]._isTracked = true;\n    }\n\n    let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, inverseEditOperations => {\n      const groupedInverseEditOperations = [];\n\n      for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n        groupedInverseEditOperations[i] = [];\n      }\n\n      for (const op of inverseEditOperations) {\n        if (!op.identifier) {\n          // perhaps auto whitespace trim edits\n          continue;\n        }\n\n        groupedInverseEditOperations[op.identifier.major].push(op);\n      }\n\n      const minorBasedSorter = (a, b) => {\n        return a.identifier.minor - b.identifier.minor;\n      };\n\n      const cursorSelections = [];\n\n      for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n        if (groupedInverseEditOperations[i].length > 0) {\n          groupedInverseEditOperations[i].sort(minorBasedSorter);\n          cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n            getInverseEditOperations: () => {\n              return groupedInverseEditOperations[i];\n            },\n            getTrackedSelection: id => {\n              const idx = parseInt(id, 10);\n\n              const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n\n              if (ctx.trackedRangesDirection[idx] === 0\n              /* LTR */\n              ) {\n                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n              }\n\n              return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n            }\n          });\n        } else {\n          cursorSelections[i] = ctx.selectionsBefore[i];\n        }\n      }\n\n      return cursorSelections;\n    });\n\n    if (!selectionsAfter) {\n      selectionsAfter = ctx.selectionsBefore;\n    } // Extract losing cursors\n\n\n    const losingCursors = [];\n\n    for (let losingCursorIndex in loserCursorsMap) {\n      if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n        losingCursors.push(parseInt(losingCursorIndex, 10));\n      }\n    } // Sort losing cursors descending\n\n\n    losingCursors.sort((a, b) => {\n      return b - a;\n    }); // Remove losing cursors\n\n    for (const losingCursor of losingCursors) {\n      selectionsAfter.splice(losingCursor, 1);\n    }\n\n    return selectionsAfter;\n  }\n\n  static _arrayIsEmpty(commands) {\n    for (let i = 0, len = commands.length; i < len; i++) {\n      if (commands[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static _getEditOperations(ctx, commands) {\n    let operations = [];\n    let hadTrackedEditOperation = false;\n\n    for (let i = 0, len = commands.length; i < len; i++) {\n      const command = commands[i];\n\n      if (command) {\n        const r = this._getEditOperationsFromCommand(ctx, i, command);\n\n        operations = operations.concat(r.operations);\n        hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n      }\n    }\n\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  }\n\n  static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n    // This method acts as a transaction, if the command fails\n    // everything it has done is ignored\n    const operations = [];\n    let operationMinor = 0;\n\n    const addEditOperation = (range, text, forceMoveMarkers = false) => {\n      if (Range.isEmpty(range) && text === '') {\n        // This command wants to add a no-op => no thank you\n        return;\n      }\n\n      operations.push({\n        identifier: {\n          major: majorIdentifier,\n          minor: operationMinor++\n        },\n        range: range,\n        text: text,\n        forceMoveMarkers: forceMoveMarkers,\n        isAutoWhitespaceEdit: command.insertsAutoWhitespace\n      });\n    };\n\n    let hadTrackedEditOperation = false;\n\n    const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n      hadTrackedEditOperation = true;\n      addEditOperation(selection, text, forceMoveMarkers);\n    };\n\n    const trackSelection = (_selection, trackPreviousOnEmpty) => {\n      const selection = Selection.liftSelection(_selection);\n      let stickiness;\n\n      if (selection.isEmpty()) {\n        if (typeof trackPreviousOnEmpty === 'boolean') {\n          if (trackPreviousOnEmpty) {\n            stickiness = 2\n            /* GrowsOnlyWhenTypingBefore */\n            ;\n          } else {\n            stickiness = 3\n            /* GrowsOnlyWhenTypingAfter */\n            ;\n          }\n        } else {\n          // Try to lock it with surrounding text\n          const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n\n          if (selection.startColumn === maxLineColumn) {\n            stickiness = 2\n            /* GrowsOnlyWhenTypingBefore */\n            ;\n          } else {\n            stickiness = 3\n            /* GrowsOnlyWhenTypingAfter */\n            ;\n          }\n        }\n      } else {\n        stickiness = 1\n        /* NeverGrowsWhenTypingAtEdges */\n        ;\n      }\n\n      const l = ctx.trackedRanges.length;\n\n      const id = ctx.model._setTrackedRange(null, selection, stickiness);\n\n      ctx.trackedRanges[l] = id;\n      ctx.trackedRangesDirection[l] = selection.getDirection();\n      return l.toString();\n    };\n\n    const editOperationBuilder = {\n      addEditOperation: addEditOperation,\n      addTrackedEditOperation: addTrackedEditOperation,\n      trackSelection: trackSelection\n    };\n\n    try {\n      command.getEditOperations(ctx.model, editOperationBuilder);\n    } catch (e) {\n      // TODO@Alex use notification service if this should be user facing\n      // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n      onUnexpectedError(e);\n      return {\n        operations: [],\n        hadTrackedEditOperation: false\n      };\n    }\n\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  }\n\n  static _getLoserCursorMap(operations) {\n    // This is destructive on the array\n    operations = operations.slice(0); // Sort operations with last one first\n\n    operations.sort((a, b) => {\n      // Note the minus!\n      return -Range.compareRangesUsingEnds(a.range, b.range);\n    }); // Operations can not overlap!\n\n    const loserCursorsMap = {};\n\n    for (let i = 1; i < operations.length; i++) {\n      const previousOp = operations[i - 1];\n      const currentOp = operations[i];\n\n      if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n        let loserMajor;\n\n        if (previousOp.identifier.major > currentOp.identifier.major) {\n          // previousOp loses the battle\n          loserMajor = previousOp.identifier.major;\n        } else {\n          loserMajor = currentOp.identifier.major;\n        }\n\n        loserCursorsMap[loserMajor.toString()] = true;\n\n        for (let j = 0; j < operations.length; j++) {\n          if (operations[j].identifier.major === loserMajor) {\n            operations.splice(j, 1);\n\n            if (j < i) {\n              i--;\n            }\n\n            j--;\n          }\n        }\n\n        if (i > 0) {\n          i--;\n        }\n      }\n    }\n\n    return loserCursorsMap;\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js"],"names":["onUnexpectedError","strings","CursorCollection","CursorContext","CursorState","EditOperationResult","DeleteOperations","TypeOperations","TypeWithAutoClosingCommand","Range","Selection","ModelInjectedTextChangedEvent","ViewCursorStateChangedEvent","ViewRevealRangeRequestEvent","dispose","Disposable","CursorStateChangedEvent","CursorsController","constructor","model","viewModel","coordinatesConverter","cursorConfig","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","context","_cursors","_hasFocus","_isHandling","_isDoingComposition","_selectionsWhenCompositionStarted","_columnSelectData","_autoClosedActions","_prevEditOperationType","updateConfiguration","updateContext","onLineMappingChanged","eventsCollector","setStates","getCursorStates","setHasFocus","hasFocus","_validateAutoClosedActions","length","selections","getSelections","i","autoClosedAction","isValid","splice","getPrimaryCursorState","getPrimaryCursor","getLastAddedCursorIndex","getAll","source","reason","states","reachedMaxCursorCount","MAX_CURSOR_COUNT","slice","oldState","CursorModelState","from","normalize","_emitStateChangedIfNecessary","setCursorColumnSelectData","columnSelectData","revealPrimary","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","fromPositions","emitViewEvent","saveState","result","len","selection","push","inSelectionMode","isEmpty","selectionStart","lineNumber","selectionStartLineNumber","column","selectionStartColumn","position","positionLineNumber","positionColumn","restoreState","desiredSelections","state","fromModelSelections","onModelContentChanged","e","versionId","hadFlushEvent","containsEvent","resultingSelection","cursorState","isUndoing","isRedoing","selectionsFromMarkers","readSelectionFromMarkers","getSelection","modelState","getTopMostViewPosition","getBottomMostViewPosition","getCursorColumnSelectData","primaryCursor","viewSelectionStart","viewState","getStartPosition","viewPosition","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","setSelections","getPrevEditOperationType","setPrevEditOperationType","type","_pushAutoClosedAction","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","range","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","_executeEditOperation","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","enclosingRange","closeCharacterRange","shouldPushStackElementAfter","newState","equals","viewSelections","some","newCursorState","oldSelections","map","s","oldModelVersionId","modelVersionId","emitOutgoingEvent","_findAutoClosingPairs","edits","indices","edit","text","indexOf","m","match","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","get","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","executeEdits","cursorStateComputer","autoClosingIndices","_isTracked","pushEditOperations","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","startLineNumber","startColumn","_executeEdit","callback","cursorChangeReason","readOnly","stopTrackingSelections","ensureValidState","err","startTrackingSelections","setIsDoingComposition","isDoingComposition","getAutoClosedCharacters","getAllAutoClosedCharacters","startComposition","endComposition","compositionEndWithInterceptors","offset","charLength","nextCharLength","chr","substr","typeWithInterceptors","typeWithoutInterceptors","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","newSelections","getPosition","paste","pasteOnNewLine","multicursorText","cut","executeCommand","killSecondaryCursors","cursor","other","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","autoClosedActions","autoClosedCharacters","concat","getAutoClosedCharactersRanges","decorationRange","getDecorationRange","enclosingRanges","endLineNumber","sort","compareRangesUsingStarts","strictContainsRange","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_setTrackedRange","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","hasOwnProperty","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","a","b","minor","cursorSelections","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","_getTrackedRange","endColumn","losingCursors","losingCursorIndex","losingCursor","r","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","forceMoveMarkers","isAutoWhitespaceEdit","insertsAutoWhitespace","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getDirection","editOperationBuilder","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","isBefore","getEndPosition","loserMajor","j"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorContext, CursorState, EditOperationResult } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewModel/viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._isDoingComposition = false;\n        this._selectionsWhenCompositionStarted = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        if (states !== null && states.length > CursorsController.MAX_CURSOR_COUNT) {\n            states = states.slice(0, CursorsController.MAX_CURSOR_COUNT);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* Simple */, true, 1 /* Immediate */);\n    }\n    onModelContentChanged(eventsCollector, e) {\n        if (e instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* Flush */);\n            this._prevEditOperationType = 0 /* Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* Undo */ : e.isRedoing ? 6 /* Redo */ : 2 /* RecoverFromMarkers */, cursorState)) {\n                        this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* Simple */, true, 0 /* Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealPrimary(eventsCollector, source, false, 0 /* Simple */, true, 0 /* Smooth */);\n        }\n    }\n    setIsDoingComposition(isDoingComposition) {\n        this._isDoingComposition = isDoingComposition;\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._selectionsWhenCompositionStarted = this.getSelections().slice(0);\n    }\n    endComposition(eventsCollector, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), this.getAutoClosedCharacters()));\n                this._selectionsWhenCompositionStarted = null;\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\nCursorsController.MAX_CURSOR_COUNT = 10000;\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (let losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}