{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy, findLastMaxBy, findMinBy } from '../../../base/common/arrays.js';\nimport { CursorState } from './cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n  constructor(context) {\n    this.context = context;\n    this.cursors = [new Cursor(context)];\n    this.lastAddedCursorIndex = 0;\n  }\n\n  dispose() {\n    for (const cursor of this.cursors) {\n      cursor.dispose(this.context);\n    }\n  }\n\n  startTrackingSelections() {\n    for (const cursor of this.cursors) {\n      cursor.startTrackingSelection(this.context);\n    }\n  }\n\n  stopTrackingSelections() {\n    for (const cursor of this.cursors) {\n      cursor.stopTrackingSelection(this.context);\n    }\n  }\n\n  updateContext(context) {\n    this.context = context;\n  }\n\n  ensureValidState() {\n    for (const cursor of this.cursors) {\n      cursor.ensureValidState(this.context);\n    }\n  }\n\n  readSelectionFromMarkers() {\n    return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n  }\n\n  getAll() {\n    return this.cursors.map(c => c.asCursorState());\n  }\n\n  getViewPositions() {\n    return this.cursors.map(c => c.viewState.position);\n  }\n\n  getTopMostViewPosition() {\n    return findMinBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n  }\n\n  getBottomMostViewPosition() {\n    return findLastMaxBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n  }\n\n  getSelections() {\n    return this.cursors.map(c => c.modelState.selection);\n  }\n\n  getViewSelections() {\n    return this.cursors.map(c => c.viewState.selection);\n  }\n\n  setSelections(selections) {\n    this.setStates(CursorState.fromModelSelections(selections));\n  }\n\n  getPrimaryCursor() {\n    return this.cursors[0].asCursorState();\n  }\n\n  setStates(states) {\n    if (states === null) {\n      return;\n    }\n\n    this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n\n    this._setSecondaryStates(states.slice(1));\n  }\n  /**\n   * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n   */\n\n\n  _setSecondaryStates(secondaryStates) {\n    const secondaryCursorsLength = this.cursors.length - 1;\n    const secondaryStatesLength = secondaryStates.length;\n\n    if (secondaryCursorsLength < secondaryStatesLength) {\n      const createCnt = secondaryStatesLength - secondaryCursorsLength;\n\n      for (let i = 0; i < createCnt; i++) {\n        this._addSecondaryCursor();\n      }\n    } else if (secondaryCursorsLength > secondaryStatesLength) {\n      const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n\n      for (let i = 0; i < removeCnt; i++) {\n        this._removeSecondaryCursor(this.cursors.length - 2);\n      }\n    }\n\n    for (let i = 0; i < secondaryStatesLength; i++) {\n      this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n    }\n  }\n\n  killSecondaryCursors() {\n    this._setSecondaryStates([]);\n  }\n\n  _addSecondaryCursor() {\n    this.cursors.push(new Cursor(this.context));\n    this.lastAddedCursorIndex = this.cursors.length - 1;\n  }\n\n  getLastAddedCursorIndex() {\n    if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n      return 0;\n    }\n\n    return this.lastAddedCursorIndex;\n  }\n\n  _removeSecondaryCursor(removeIndex) {\n    if (this.lastAddedCursorIndex >= removeIndex + 1) {\n      this.lastAddedCursorIndex--;\n    }\n\n    this.cursors[removeIndex + 1].dispose(this.context);\n    this.cursors.splice(removeIndex + 1, 1);\n  }\n\n  normalize() {\n    if (this.cursors.length === 1) {\n      return;\n    }\n\n    const cursors = this.cursors.slice(0);\n    const sortedCursors = [];\n\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      sortedCursors.push({\n        index: i,\n        selection: cursors[i].modelState.selection\n      });\n    }\n\n    sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n\n    for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n      const current = sortedCursors[sortedCursorIndex];\n      const next = sortedCursors[sortedCursorIndex + 1];\n      const currentSelection = current.selection;\n      const nextSelection = next.selection;\n\n      if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n        continue;\n      }\n\n      let shouldMergeCursors;\n\n      if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n        // Merge touching cursors if one of them is collapsed\n        shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n      } else {\n        // Merge only overlapping cursors (i.e. allow touching ranges)\n        shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n      }\n\n      if (shouldMergeCursors) {\n        const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n        const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n        const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n        const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n        const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n        const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n\n        if (!looserSelection.equalsSelection(winnerSelection)) {\n          const resultingRange = looserSelection.plusRange(winnerSelection);\n          const looserSelectionIsLTR = looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn;\n          const winnerSelectionIsLTR = winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn; // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n\n          let resultingSelectionIsLTR;\n\n          if (looserIndex === this.lastAddedCursorIndex) {\n            resultingSelectionIsLTR = looserSelectionIsLTR;\n            this.lastAddedCursorIndex = winnerIndex;\n          } else {\n            // Winner takes it all\n            resultingSelectionIsLTR = winnerSelectionIsLTR;\n          }\n\n          let resultingSelection;\n\n          if (resultingSelectionIsLTR) {\n            resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n          } else {\n            resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n          }\n\n          sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n          const resultingState = CursorState.fromModelSelection(resultingSelection);\n          cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n        }\n\n        for (const sortedCursor of sortedCursors) {\n          if (sortedCursor.index > looserIndex) {\n            sortedCursor.index--;\n          }\n        }\n\n        cursors.splice(looserIndex, 1);\n        sortedCursors.splice(looserSortedCursorIndex, 1);\n\n        this._removeSecondaryCursor(looserIndex - 1);\n\n        sortedCursorIndex--;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js"],"names":["compareBy","findLastMaxBy","findMinBy","CursorState","Cursor","Position","Range","Selection","CursorCollection","constructor","context","cursors","lastAddedCursorIndex","dispose","cursor","startTrackingSelections","startTrackingSelection","stopTrackingSelections","stopTrackingSelection","updateContext","ensureValidState","readSelectionFromMarkers","map","c","getAll","asCursorState","getViewPositions","viewState","position","getTopMostViewPosition","compare","getBottomMostViewPosition","getSelections","modelState","selection","getViewSelections","setSelections","selections","setStates","fromModelSelections","getPrimaryCursor","states","setState","_setSecondaryStates","slice","secondaryStates","secondaryCursorsLength","length","secondaryStatesLength","createCnt","i","_addSecondaryCursor","removeCnt","_removeSecondaryCursor","killSecondaryCursors","push","getLastAddedCursorIndex","removeIndex","splice","normalize","sortedCursors","len","index","sort","s","compareRangesUsingStarts","sortedCursorIndex","current","next","currentSelection","nextSelection","cursorConfig","multiCursorMergeOverlapping","shouldMergeCursors","isEmpty","getStartPosition","isBeforeOrEqual","getEndPosition","isBefore","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","equalsSelection","resultingRange","plusRange","looserSelectionIsLTR","selectionStartLineNumber","startLineNumber","selectionStartColumn","startColumn","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingSelection","endLineNumber","endColumn","resultingState","fromModelSelection","sortedCursor"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy, findLastMaxBy, findMinBy } from '../../../base/common/arrays.js';\nimport { CursorState } from './cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findMinBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMaxBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}