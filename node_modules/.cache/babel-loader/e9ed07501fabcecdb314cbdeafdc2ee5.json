{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalMouseMoveMonitor, standardMouseMoveMerger } from '../../../../base/browser/globalMouseMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel/viewModel.js';\nimport { minimapSelection, scrollbarShadow, minimapBackground, minimapSliderBackground, minimapSliderHoverBackground, minimapSliderActiveBackground, minimapForegroundOpacity } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition } from '../../../common/model.js';\nimport { once } from '../../../../base/common/functional.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\n\nconst MOUSE_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\n\nclass MinimapOptions {\n  constructor(configuration, theme, tokensColorTracker) {\n    const options = configuration.options;\n    const pixelRatio = options.get(129\n    /* pixelRatio */\n    );\n    const layoutInfo = options.get(131\n    /* layoutInfo */\n    );\n    const minimapLayout = layoutInfo.minimap;\n    const fontInfo = options.get(44\n    /* fontInfo */\n    );\n    const minimapOpts = options.get(65\n    /* minimap */\n    );\n    this.renderMinimap = minimapLayout.renderMinimap;\n    this.size = minimapOpts.size;\n    this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n    this.scrollBeyondLastLine = options.get(94\n    /* scrollBeyondLastLine */\n    );\n    this.showSlider = minimapOpts.showSlider;\n    this.pixelRatio = pixelRatio;\n    this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this.lineHeight = options.get(59\n    /* lineHeight */\n    );\n    this.minimapLeft = minimapLayout.minimapLeft;\n    this.minimapWidth = minimapLayout.minimapWidth;\n    this.minimapHeight = layoutInfo.height;\n    this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n    this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n    this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n    this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n    this.isSampling = minimapLayout.minimapIsSampling;\n    this.editorHeight = layoutInfo.height;\n    this.fontScale = minimapLayout.minimapScale;\n    this.minimapLineHeight = minimapLayout.minimapLineHeight;\n    this.minimapCharWidth = 1\n    /* BASE_CHAR_WIDTH */\n    * this.fontScale;\n    this.charRenderer = once(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n    this.defaultBackgroundColor = tokensColorTracker.getColor(2\n    /* DefaultBackground */\n    );\n    this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n    this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n  }\n\n  static _getMinimapBackground(theme, defaultBackgroundColor) {\n    const themeColor = theme.getColor(minimapBackground);\n\n    if (themeColor) {\n      return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n    }\n\n    return defaultBackgroundColor;\n  }\n\n  static _getMinimapForegroundOpacity(theme) {\n    const themeColor = theme.getColor(minimapForegroundOpacity);\n\n    if (themeColor) {\n      return RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n    }\n\n    return 255;\n  }\n\n  equals(other) {\n    return this.renderMinimap === other.renderMinimap && this.size === other.size && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === other.scrollBeyondLastLine && this.showSlider === other.showSlider && this.pixelRatio === other.pixelRatio && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.lineHeight === other.lineHeight && this.minimapLeft === other.minimapLeft && this.minimapWidth === other.minimapWidth && this.minimapHeight === other.minimapHeight && this.canvasInnerWidth === other.canvasInnerWidth && this.canvasInnerHeight === other.canvasInnerHeight && this.canvasOuterWidth === other.canvasOuterWidth && this.canvasOuterHeight === other.canvasOuterHeight && this.isSampling === other.isSampling && this.editorHeight === other.editorHeight && this.fontScale === other.fontScale && this.minimapLineHeight === other.minimapLineHeight && this.minimapCharWidth === other.minimapCharWidth && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor) && this.foregroundAlpha === other.foregroundAlpha;\n  }\n\n}\n\nclass MinimapLayout {\n  constructor(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {\n    this.scrollTop = scrollTop;\n    this.scrollHeight = scrollHeight;\n    this.sliderNeeded = sliderNeeded;\n    this._computedSliderRatio = computedSliderRatio;\n    this.sliderTop = sliderTop;\n    this.sliderHeight = sliderHeight;\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n  }\n  /**\n   * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n   */\n\n\n  getDesiredScrollTopFromDelta(delta) {\n    return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n  }\n\n  getDesiredScrollTopFromTouchLocation(pageY) {\n    return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n  }\n\n  static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n    const pixelRatio = options.pixelRatio;\n    const minimapLineHeight = options.minimapLineHeight;\n    const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n    const lineHeight = options.lineHeight;\n\n    if (options.minimapHeightIsEditorHeight) {\n      const logicalScrollHeight = realLineCount * options.lineHeight + (options.scrollBeyondLastLine ? viewportHeight - options.lineHeight : 0);\n      const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n      const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight); // The slider can move from 0 to `maxMinimapSliderTop`\n      // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n\n      const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n      const sliderTop = scrollTop * computedSliderRatio;\n      const sliderNeeded = maxMinimapSliderTop > 0;\n      const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, 1, Math.min(lineCount, maxLinesFitting));\n    } // The visible line count in a viewport can change due to a number of reasons:\n    //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n    //    e.g. for a line height of 20, and a viewport height of 600\n    //          * scrollTop = 0  => visible lines are [1, 30]\n    //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n    //          * scrollTop = 20 => visible lines are [2, 31]\n    //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n    //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n    // We must first establish a desirable slider height.\n\n\n    let sliderHeight;\n\n    if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n      // case b) from above: there are whitespace gaps in the viewport.\n      // In this case, the height of the slider directly reflects the visible line count.\n      const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n      sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n    } else {\n      // The slider has a stable height\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n    }\n\n    let maxMinimapSliderTop;\n\n    if (options.scrollBeyondLastLine) {\n      // The minimap slider, when dragged all the way down, will contain the last line at its top\n      maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;\n    } else {\n      // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n      maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);\n    }\n\n    maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop); // The slider can move from 0 to `maxMinimapSliderTop`\n    // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n\n    const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n    const sliderTop = scrollTop * computedSliderRatio;\n    let extraLinesAtTheBottom = 0;\n\n    if (options.scrollBeyondLastLine) {\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      extraLinesAtTheBottom = expectedViewportLineCount - 1;\n    }\n\n    if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {\n      // All lines fit in the minimap\n      const startLineNumber = 1;\n      const endLineNumber = lineCount;\n      const sliderNeeded = maxMinimapSliderTop > 0;\n      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\n    } else {\n      let startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight)); // Avoid flickering caused by a partial viewport start line\n      // by being consistent w.r.t. the previous layout decision\n\n      if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n        if (previousLayout.scrollTop > scrollTop) {\n          // Scrolling up => never increase `startLineNumber`\n          startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n        }\n\n        if (previousLayout.scrollTop < scrollTop) {\n          // Scrolling down => never decrease `startLineNumber`\n          startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n        }\n      }\n\n      const endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);\n      const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n      const sliderTopAligned = (viewportStartLineNumber - startLineNumber + partialLine) * minimapLineHeight / pixelRatio;\n      return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, startLineNumber, endLineNumber);\n    }\n  }\n\n}\n\nclass MinimapLine {\n  constructor(dy) {\n    this.dy = dy;\n  }\n\n  onContentChanged() {\n    this.dy = -1;\n  }\n\n  onTokensChanged() {\n    this.dy = -1;\n  }\n\n}\n\nMinimapLine.INVALID = new MinimapLine(-1);\n\nclass RenderData {\n  constructor(renderedLayout, imageData, lines) {\n    this.renderedLayout = renderedLayout;\n    this._imageData = imageData;\n    this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n\n    this._renderedLines._set(renderedLayout.startLineNumber, lines);\n  }\n  /**\n   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n   */\n\n\n  linesEquals(layout) {\n    if (!this.scrollEquals(layout)) {\n      return false;\n    }\n\n    const tmp = this._renderedLines._get();\n\n    const lines = tmp.lines;\n\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].dy === -1) {\n        // This line is invalid\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Check if the current RenderData matches the new layout's scroll position\n   */\n\n\n  scrollEquals(layout) {\n    return this.renderedLayout.startLineNumber === layout.startLineNumber && this.renderedLayout.endLineNumber === layout.endLineNumber;\n  }\n\n  _get() {\n    const tmp = this._renderedLines._get();\n\n    return {\n      imageData: this._imageData,\n      rendLineNumberStart: tmp.rendLineNumberStart,\n      lines: tmp.lines\n    };\n  }\n\n  onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n    return this._renderedLines.onLinesChanged(changeFromLineNumber, changeToLineNumber);\n  }\n\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n  }\n\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n  }\n\n  onTokensChanged(ranges) {\n    return this._renderedLines.onTokensChanged(ranges);\n  }\n\n}\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\n\n\nclass MinimapBuffers {\n  constructor(ctx, WIDTH, HEIGHT, background) {\n    this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n    this._buffers = [ctx.createImageData(WIDTH, HEIGHT), ctx.createImageData(WIDTH, HEIGHT)];\n    this._lastUsedBuffer = 0;\n  }\n\n  getBuffer() {\n    // rotate buffers\n    this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n    const result = this._buffers[this._lastUsedBuffer]; // fill with background color\n\n    result.data.set(this._backgroundFillData);\n    return result;\n  }\n\n  static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n    const backgroundR = background.r;\n    const backgroundG = background.g;\n    const backgroundB = background.b;\n    const backgroundA = background.a;\n    const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n    let offset = 0;\n\n    for (let i = 0; i < HEIGHT; i++) {\n      for (let j = 0; j < WIDTH; j++) {\n        result[offset] = backgroundR;\n        result[offset + 1] = backgroundG;\n        result[offset + 2] = backgroundB;\n        result[offset + 3] = backgroundA;\n        offset += 4;\n      }\n    }\n\n    return result;\n  }\n\n}\n\nclass MinimapSamplingState {\n  constructor(samplingRatio, minimapLines) {\n    this.samplingRatio = samplingRatio;\n    this.minimapLines = minimapLines;\n  }\n\n  static compute(options, viewLineCount, oldSamplingState) {\n    if (options.renderMinimap === 0\n    /* None */\n    || !options.isSampling) {\n      return [null, []];\n    } // ratio is intentionally not part of the layout to avoid the layout changing all the time\n    // so we need to recompute it again...\n\n\n    const pixelRatio = options.pixelRatio;\n    const lineHeight = options.lineHeight;\n    const scrollBeyondLastLine = options.scrollBeyondLastLine;\n    const {\n      minimapLineCount\n    } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n      viewLineCount: viewLineCount,\n      scrollBeyondLastLine: scrollBeyondLastLine,\n      height: options.editorHeight,\n      lineHeight: lineHeight,\n      pixelRatio: pixelRatio\n    });\n    const ratio = viewLineCount / minimapLineCount;\n    const halfRatio = ratio / 2;\n\n    if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n      const result = [];\n      result[0] = 1;\n\n      if (minimapLineCount > 1) {\n        for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n          result[i] = Math.round(i * ratio + halfRatio);\n        }\n\n        result[minimapLineCount - 1] = viewLineCount;\n      }\n\n      return [new MinimapSamplingState(ratio, result), []];\n    }\n\n    const oldMinimapLines = oldSamplingState.minimapLines;\n    const oldLength = oldMinimapLines.length;\n    const result = [];\n    let oldIndex = 0;\n    let oldDeltaLineCount = 0;\n    let minViewLineNumber = 1;\n    const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n\n    let events = [];\n    let lastEvent = null;\n\n    for (let i = 0; i < minimapLineCount; i++) {\n      const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n      const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n\n      while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n        if (events.length < MAX_EVENT_COUNT) {\n          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\n          if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n            lastEvent.deleteToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'deleted',\n              _oldIndex: oldIndex,\n              deleteFromLineNumber: oldMinimapLineNumber,\n              deleteToLineNumber: oldMinimapLineNumber\n            };\n            events.push(lastEvent);\n          }\n\n          oldDeltaLineCount--;\n        }\n\n        oldIndex++;\n      }\n\n      let selectedViewLineNumber;\n\n      if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n        // reuse the old sampled line\n        selectedViewLineNumber = oldMinimapLines[oldIndex];\n        oldIndex++;\n      } else {\n        if (i === 0) {\n          selectedViewLineNumber = 1;\n        } else if (i + 1 === minimapLineCount) {\n          selectedViewLineNumber = viewLineCount;\n        } else {\n          selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n        }\n\n        if (events.length < MAX_EVENT_COUNT) {\n          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\n          if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n            lastEvent.insertToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'inserted',\n              _i: i,\n              insertFromLineNumber: oldMinimapLineNumber,\n              insertToLineNumber: oldMinimapLineNumber\n            };\n            events.push(lastEvent);\n          }\n\n          oldDeltaLineCount++;\n        }\n      }\n\n      result[i] = selectedViewLineNumber;\n      minViewLineNumber = selectedViewLineNumber;\n    }\n\n    if (events.length < MAX_EVENT_COUNT) {\n      while (oldIndex < oldLength) {\n        const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\n        if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n          lastEvent.deleteToLineNumber++;\n        } else {\n          lastEvent = {\n            type: 'deleted',\n            _oldIndex: oldIndex,\n            deleteFromLineNumber: oldMinimapLineNumber,\n            deleteToLineNumber: oldMinimapLineNumber\n          };\n          events.push(lastEvent);\n        }\n\n        oldDeltaLineCount--;\n        oldIndex++;\n      }\n    } else {\n      // too many events, just give up\n      events = [{\n        type: 'flush'\n      }];\n    }\n\n    return [new MinimapSamplingState(ratio, result), events];\n  }\n\n  modelLineToMinimapLine(lineNumber) {\n    return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n  }\n  /**\n   * Will return null if the model line ranges are not intersecting with a sampled model line.\n   */\n\n\n  modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n    let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n\n    while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n      fromLineIndex--;\n    }\n\n    let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n\n    while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n      toLineIndex++;\n    }\n\n    if (fromLineIndex === toLineIndex) {\n      const sampledLineNumber = this.minimapLines[fromLineIndex];\n\n      if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n        // This line is not part of the sampled lines ==> nothing to do\n        return null;\n      }\n    }\n\n    return [fromLineIndex + 1, toLineIndex + 1];\n  }\n  /**\n   * Will always return a range, even if it is not intersecting with a sampled model line.\n   */\n\n\n  decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n    let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n    let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n\n    if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n      if (minimapLineEnd === this.minimapLines.length) {\n        if (minimapLineStart > 1) {\n          minimapLineStart--;\n        }\n      } else {\n        minimapLineEnd++;\n      }\n    }\n\n    return [minimapLineStart, minimapLineEnd];\n  }\n\n  onLinesDeleted(e) {\n    // have the mapping be sticky\n    const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n    let changeStartIndex = this.minimapLines.length;\n    let changeEndIndex = 0;\n\n    for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n      if (this.minimapLines[i] < e.fromLineNumber) {\n        break;\n      }\n\n      if (this.minimapLines[i] <= e.toLineNumber) {\n        // this line got deleted => move to previous available\n        this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n        changeStartIndex = Math.min(changeStartIndex, i);\n        changeEndIndex = Math.max(changeEndIndex, i);\n      } else {\n        this.minimapLines[i] -= deletedLineCount;\n      }\n    }\n\n    return [changeStartIndex, changeEndIndex];\n  }\n\n  onLinesInserted(e) {\n    // have the mapping be sticky\n    const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n\n    for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n      if (this.minimapLines[i] < e.fromLineNumber) {\n        break;\n      }\n\n      this.minimapLines[i] += insertedLineCount;\n    }\n  }\n\n}\n\nexport class Minimap extends ViewPart {\n  constructor(context) {\n    super(context);\n    this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n    this._selections = [];\n    this._minimapSelections = null;\n    this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n    const [samplingState] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), null);\n    this._samplingState = samplingState;\n    this._shouldCheckSampling = false;\n    this._actual = new InnerMinimap(context.theme, this);\n  }\n\n  dispose() {\n    this._actual.dispose();\n\n    super.dispose();\n  }\n\n  getDomNode() {\n    return this._actual.getDomNode();\n  }\n\n  _onOptionsMaybeChanged() {\n    const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n\n    if (this.options.equals(opts)) {\n      return false;\n    }\n\n    this.options = opts;\n\n    this._recreateLineSampling();\n\n    this._actual.onDidChangeOptions();\n\n    return true;\n  } // ---- begin view event handlers\n\n\n  onConfigurationChanged(e) {\n    return this._onOptionsMaybeChanged();\n  }\n\n  onCursorStateChanged(e) {\n    this._selections = e.selections;\n    this._minimapSelections = null;\n    return this._actual.onSelectionChanged();\n  }\n\n  onDecorationsChanged(e) {\n    if (e.affectsMinimap) {\n      return this._actual.onDecorationsChanged();\n    }\n\n    return false;\n  }\n\n  onFlushed(e) {\n    if (this._samplingState) {\n      this._shouldCheckSampling = true;\n    }\n\n    return this._actual.onFlushed();\n  }\n\n  onLinesChanged(e) {\n    if (this._samplingState) {\n      const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);\n\n      if (minimapLineRange) {\n        return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1]);\n      } else {\n        return false;\n      }\n    } else {\n      return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n\n  onLinesDeleted(e) {\n    if (this._samplingState) {\n      const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n\n      if (changeStartIndex <= changeEndIndex) {\n        this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex + 1);\n      }\n\n      this._shouldCheckSampling = true;\n      return true;\n    } else {\n      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n\n  onLinesInserted(e) {\n    if (this._samplingState) {\n      this._samplingState.onLinesInserted(e);\n\n      this._shouldCheckSampling = true;\n      return true;\n    } else {\n      return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n\n  onScrollChanged(e) {\n    return this._actual.onScrollChanged();\n  }\n\n  onThemeChanged(e) {\n    this._context.model.invalidateMinimapColorCache();\n\n    this._actual.onThemeChanged();\n\n    this._onOptionsMaybeChanged();\n\n    return true;\n  }\n\n  onTokensChanged(e) {\n    if (this._samplingState) {\n      const ranges = [];\n\n      for (const range of e.ranges) {\n        const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n\n        if (minimapLineRange) {\n          ranges.push({\n            fromLineNumber: minimapLineRange[0],\n            toLineNumber: minimapLineRange[1]\n          });\n        }\n      }\n\n      if (ranges.length) {\n        return this._actual.onTokensChanged(ranges);\n      } else {\n        return false;\n      }\n    } else {\n      return this._actual.onTokensChanged(e.ranges);\n    }\n  }\n\n  onTokensColorsChanged(e) {\n    this._onOptionsMaybeChanged();\n\n    return this._actual.onTokensColorsChanged();\n  }\n\n  onZonesChanged(e) {\n    return this._actual.onZonesChanged();\n  } // --- end event handlers\n\n\n  prepareRender(ctx) {\n    if (this._shouldCheckSampling) {\n      this._shouldCheckSampling = false;\n\n      this._recreateLineSampling();\n    }\n  }\n\n  render(ctx) {\n    let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n    let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n\n    if (this._samplingState) {\n      viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n      viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n    }\n\n    const minimapCtx = {\n      viewportContainsWhitespaceGaps: ctx.viewportData.whitespaceViewportData.length > 0,\n      scrollWidth: ctx.scrollWidth,\n      scrollHeight: ctx.scrollHeight,\n      viewportStartLineNumber: viewportStartLineNumber,\n      viewportEndLineNumber: viewportEndLineNumber,\n      viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n      scrollTop: ctx.scrollTop,\n      scrollLeft: ctx.scrollLeft,\n      viewportWidth: ctx.viewportWidth,\n      viewportHeight: ctx.viewportHeight\n    };\n\n    this._actual.render(minimapCtx);\n  } //#region IMinimapModel\n\n\n  _recreateLineSampling() {\n    this._minimapSelections = null;\n    const wasSampling = Boolean(this._samplingState);\n    const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), this._samplingState);\n    this._samplingState = samplingState;\n\n    if (wasSampling && this._samplingState) {\n      // was sampling, is sampling\n      for (const event of events) {\n        switch (event.type) {\n          case 'deleted':\n            this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n\n            break;\n\n          case 'inserted':\n            this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n\n            break;\n\n          case 'flush':\n            this._actual.onFlushed();\n\n            break;\n        }\n      }\n    }\n  }\n\n  getLineCount() {\n    if (this._samplingState) {\n      return this._samplingState.minimapLines.length;\n    }\n\n    return this._context.model.getLineCount();\n  }\n\n  getRealLineCount() {\n    return this._context.model.getLineCount();\n  }\n\n  getLineContent(lineNumber) {\n    if (this._samplingState) {\n      return this._context.model.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n    }\n\n    return this._context.model.getLineContent(lineNumber);\n  }\n\n  getLineMaxColumn(lineNumber) {\n    if (this._samplingState) {\n      return this._context.model.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n    }\n\n    return this._context.model.getLineMaxColumn(lineNumber);\n  }\n\n  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n    if (this._samplingState) {\n      const result = [];\n\n      for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n        if (needed[lineIndex]) {\n          result[lineIndex] = this._context.model.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n        } else {\n          result[lineIndex] = null;\n        }\n      }\n\n      return result;\n    }\n\n    return this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n  }\n\n  getSelections() {\n    if (this._minimapSelections === null) {\n      if (this._samplingState) {\n        this._minimapSelections = [];\n\n        for (const selection of this._selections) {\n          const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n\n          this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n        }\n      } else {\n        this._minimapSelections = this._selections;\n      }\n    }\n\n    return this._minimapSelections;\n  }\n\n  getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n    let visibleRange;\n\n    if (this._samplingState) {\n      const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n      const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n      visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.model.getLineMaxColumn(modelEndLineNumber));\n    } else {\n      visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.model.getLineMaxColumn(endLineNumber));\n    }\n\n    const decorations = this._context.model.getDecorationsInViewport(visibleRange);\n\n    if (this._samplingState) {\n      const result = [];\n\n      for (const decoration of decorations) {\n        if (!decoration.options.minimap) {\n          continue;\n        }\n\n        const range = decoration.range;\n\n        const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n\n        const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n\n        result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n      }\n\n      return result;\n    }\n\n    return decorations;\n  }\n\n  getOptions() {\n    return this._context.model.getTextModelOptions();\n  }\n\n  revealLineNumber(lineNumber) {\n    if (this._samplingState) {\n      lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n    }\n\n    this._context.model.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1\n    /* Center */\n    , 0\n    /* Smooth */\n    );\n  }\n\n  setScrollTop(scrollTop) {\n    this._context.model.setScrollPosition({\n      scrollTop: scrollTop\n    }, 1\n    /* Immediate */\n    );\n  }\n\n}\n\nclass InnerMinimap extends Disposable {\n  constructor(theme, model) {\n    super();\n    this._renderDecorations = false;\n    this._gestureInProgress = false;\n    this._theme = theme;\n    this._model = model;\n    this._lastRenderData = null;\n    this._buffers = null;\n    this._selectionColor = this._theme.getColor(minimapSelection);\n    this._domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(this._domNode, 8\n    /* Minimap */\n    );\n\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n\n    this._domNode.setPosition('absolute');\n\n    this._domNode.setAttribute('role', 'presentation');\n\n    this._domNode.setAttribute('aria-hidden', 'true');\n\n    this._shadow = createFastDomNode(document.createElement('div'));\n\n    this._shadow.setClassName('minimap-shadow-hidden');\n\n    this._domNode.appendChild(this._shadow);\n\n    this._canvas = createFastDomNode(document.createElement('canvas'));\n\n    this._canvas.setPosition('absolute');\n\n    this._canvas.setLeft(0);\n\n    this._domNode.appendChild(this._canvas);\n\n    this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n\n    this._decorationsCanvas.setPosition('absolute');\n\n    this._decorationsCanvas.setClassName('minimap-decorations-layer');\n\n    this._decorationsCanvas.setLeft(0);\n\n    this._domNode.appendChild(this._decorationsCanvas);\n\n    this._slider = createFastDomNode(document.createElement('div'));\n\n    this._slider.setPosition('absolute');\n\n    this._slider.setClassName('minimap-slider');\n\n    this._slider.setLayerHinting(true);\n\n    this._slider.setContain('strict');\n\n    this._domNode.appendChild(this._slider);\n\n    this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n\n    this._sliderHorizontal.setPosition('absolute');\n\n    this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n\n    this._slider.appendChild(this._sliderHorizontal);\n\n    this._applyLayout();\n\n    this._mouseDownListener = dom.addStandardDisposableListener(this._domNode.domNode, 'mousedown', e => {\n      e.preventDefault();\n      const renderMinimap = this._model.options.renderMinimap;\n\n      if (renderMinimap === 0\n      /* None */\n      ) {\n        return;\n      }\n\n      if (!this._lastRenderData) {\n        return;\n      }\n\n      if (this._model.options.size !== 'proportional') {\n        if (e.leftButton && this._lastRenderData) {\n          // pretend the click occurred in the center of the slider\n          const position = dom.getDomNodePagePosition(this._slider.domNode);\n          const initialPosY = position.top + position.height / 2;\n\n          this._startSliderDragging(e.buttons, e.posx, initialPosY, e.posy, this._lastRenderData.renderedLayout);\n        }\n\n        return;\n      }\n\n      const minimapLineHeight = this._model.options.minimapLineHeight;\n      const internalOffsetY = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * e.browserEvent.offsetY;\n      const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n      let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber;\n      lineNumber = Math.min(lineNumber, this._model.getLineCount());\n\n      this._model.revealLineNumber(lineNumber);\n    });\n    this._sliderMouseMoveMonitor = new GlobalMouseMoveMonitor();\n    this._sliderMouseDownListener = dom.addStandardDisposableListener(this._slider.domNode, 'mousedown', e => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (e.leftButton && this._lastRenderData) {\n        this._startSliderDragging(e.buttons, e.posx, e.posy, e.posy, this._lastRenderData.renderedLayout);\n      }\n    });\n    this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n    this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, e => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (this._lastRenderData) {\n        this._slider.toggleClassName('active', true);\n\n        this._gestureInProgress = true;\n        this.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, e => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (this._lastRenderData && this._gestureInProgress) {\n        this.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      this._gestureInProgress = false;\n\n      this._slider.toggleClassName('active', false);\n    });\n  }\n\n  _startSliderDragging(initialButtons, initialPosX, initialPosY, posy, initialSliderState) {\n    this._slider.toggleClassName('active', true);\n\n    const handleMouseMove = (posy, posx) => {\n      const mouseOrthogonalDelta = Math.abs(posx - initialPosX);\n\n      if (platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {\n        // The mouse has wondered away from the scrollbar => reset dragging\n        this._model.setScrollTop(initialSliderState.scrollTop);\n\n        return;\n      }\n\n      const mouseDelta = posy - initialPosY;\n\n      this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(mouseDelta));\n    };\n\n    if (posy !== initialPosY) {\n      handleMouseMove(posy, initialPosX);\n    }\n\n    this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, initialButtons, standardMouseMoveMerger, mouseMoveData => handleMouseMove(mouseMoveData.posy, mouseMoveData.posx), () => {\n      this._slider.toggleClassName('active', false);\n    });\n  }\n\n  scrollDueToTouchEvent(touch) {\n    const startY = this._domNode.domNode.getBoundingClientRect().top;\n\n    const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n\n    this._model.setScrollTop(scrollTop);\n  }\n\n  dispose() {\n    this._mouseDownListener.dispose();\n\n    this._sliderMouseMoveMonitor.dispose();\n\n    this._sliderMouseDownListener.dispose();\n\n    this._gestureDisposable.dispose();\n\n    this._sliderTouchStartListener.dispose();\n\n    this._sliderTouchMoveListener.dispose();\n\n    this._sliderTouchEndListener.dispose();\n\n    super.dispose();\n  }\n\n  _getMinimapDomNodeClassName() {\n    if (this._model.options.showSlider === 'always') {\n      return 'minimap slider-always';\n    }\n\n    return 'minimap slider-mouseover';\n  }\n\n  getDomNode() {\n    return this._domNode;\n  }\n\n  _applyLayout() {\n    this._domNode.setLeft(this._model.options.minimapLeft);\n\n    this._domNode.setWidth(this._model.options.minimapWidth);\n\n    this._domNode.setHeight(this._model.options.minimapHeight);\n\n    this._shadow.setHeight(this._model.options.minimapHeight);\n\n    this._canvas.setWidth(this._model.options.canvasOuterWidth);\n\n    this._canvas.setHeight(this._model.options.canvasOuterHeight);\n\n    this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n    this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n\n    this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n\n    this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n\n    this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n    this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n\n    this._slider.setWidth(this._model.options.minimapWidth);\n  }\n\n  _getBuffer() {\n    if (!this._buffers) {\n      if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n        this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n      }\n    }\n\n    return this._buffers ? this._buffers.getBuffer() : null;\n  } // ---- begin view event handlers\n\n\n  onDidChangeOptions() {\n    this._lastRenderData = null;\n    this._buffers = null;\n\n    this._applyLayout();\n\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n  }\n\n  onSelectionChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n\n  onDecorationsChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n\n  onFlushed() {\n    this._lastRenderData = null;\n    return true;\n  }\n\n  onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeToLineNumber);\n    }\n\n    return false;\n  }\n\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    if (this._lastRenderData) {\n      this._lastRenderData.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    }\n\n    return true;\n  }\n\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    if (this._lastRenderData) {\n      this._lastRenderData.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    }\n\n    return true;\n  }\n\n  onScrollChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n\n  onThemeChanged() {\n    this._selectionColor = this._theme.getColor(minimapSelection);\n    this._renderDecorations = true;\n    return true;\n  }\n\n  onTokensChanged(ranges) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onTokensChanged(ranges);\n    }\n\n    return false;\n  }\n\n  onTokensColorsChanged() {\n    this._lastRenderData = null;\n    this._buffers = null;\n    return true;\n  }\n\n  onZonesChanged() {\n    this._lastRenderData = null;\n    return true;\n  } // --- end event handlers\n\n\n  render(renderingCtx) {\n    const renderMinimap = this._model.options.renderMinimap;\n\n    if (renderMinimap === 0\n    /* None */\n    ) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n\n      this._sliderHorizontal.setWidth(0);\n\n      this._sliderHorizontal.setHeight(0);\n\n      return;\n    }\n\n    if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n    } else {\n      this._shadow.setClassName('minimap-shadow-visible');\n    }\n\n    const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n\n    this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n\n    this._slider.setTop(layout.sliderTop);\n\n    this._slider.setHeight(layout.sliderHeight); // Compute horizontal slider coordinates\n\n\n    this._sliderHorizontal.setLeft(0);\n\n    this._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n\n    this._sliderHorizontal.setTop(0);\n\n    this._sliderHorizontal.setHeight(layout.sliderHeight);\n\n    this.renderDecorations(layout);\n    this._lastRenderData = this.renderLines(layout);\n  }\n\n  renderDecorations(layout) {\n    if (this._renderDecorations) {\n      this._renderDecorations = false;\n\n      const selections = this._model.getSelections();\n\n      selections.sort(Range.compareRangesUsingStarts);\n\n      const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n\n      decorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n      const {\n        canvasInnerWidth,\n        canvasInnerHeight\n      } = this._model.options;\n      const lineHeight = this._model.options.minimapLineHeight;\n      const characterWidth = this._model.options.minimapCharWidth;\n\n      const tabSize = this._model.getOptions().tabSize;\n\n      const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n\n      canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight); // We first need to render line highlights and then render decorations on top of those.\n      // But we need to pick a single color for each line, and use that as a line highlight.\n      // This needs to be the color of the decoration with the highest `zIndex`, but priority\n      // is given to the selection.\n\n      const highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, false);\n\n      this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, lineHeight);\n\n      this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, lineHeight);\n\n      const lineOffsetMap = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);\n\n      this._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n\n      this._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n    }\n  }\n\n  _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, lineHeight) {\n    if (!this._selectionColor || this._selectionColor.isTransparent()) {\n      return;\n    }\n\n    canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n    let y1 = 0;\n    let y2 = 0;\n\n    for (const selection of selections) {\n      const startLineNumber = Math.max(layout.startLineNumber, selection.startLineNumber);\n      const endLineNumber = Math.min(layout.endLineNumber, selection.endLineNumber);\n\n      if (startLineNumber > endLineNumber) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        highlightedLines.set(line, true);\n      }\n\n      const yy1 = (startLineNumber - layout.startLineNumber) * lineHeight;\n      const yy2 = (endLineNumber - layout.startLineNumber) * lineHeight + lineHeight;\n\n      if (y2 >= yy1) {\n        // merge into previous\n        y2 = yy2;\n      } else {\n        if (y2 > y1) {\n          // flush\n          canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n        }\n\n        y1 = yy1;\n        y2 = yy2;\n      }\n    }\n\n    if (y2 > y1) {\n      // flush\n      canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n    }\n  }\n\n  _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, lineHeight) {\n    const highlightColors = new Map(); // Loop backwards to hit first decorations with higher `zIndex`\n\n    for (let i = decorations.length - 1; i >= 0; i--) {\n      const decoration = decorations[i];\n      const minimapOptions = decoration.options.minimap;\n\n      if (!minimapOptions || minimapOptions.position !== MinimapPosition.Inline) {\n        continue;\n      }\n\n      const startLineNumber = Math.max(layout.startLineNumber, decoration.range.startLineNumber);\n      const endLineNumber = Math.min(layout.endLineNumber, decoration.range.endLineNumber);\n\n      if (startLineNumber > endLineNumber) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n\n      const decorationColor = minimapOptions.getColor(this._theme.value);\n\n      if (!decorationColor || decorationColor.isTransparent()) {\n        continue;\n      }\n\n      let highlightColor = highlightColors.get(decorationColor.toString());\n\n      if (!highlightColor) {\n        highlightColor = decorationColor.transparent(0.5).toString();\n        highlightColors.set(decorationColor.toString(), highlightColor);\n      }\n\n      canvasContext.fillStyle = highlightColor;\n\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        if (highlightedLines.has(line)) {\n          continue;\n        }\n\n        highlightedLines.set(line, true);\n        const y = (startLineNumber - layout.startLineNumber) * lineHeight;\n        canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, lineHeight);\n      }\n    }\n  }\n\n  _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n    if (!this._selectionColor || this._selectionColor.isTransparent()) {\n      return;\n    }\n\n    for (const selection of selections) {\n      const startLineNumber = Math.max(layout.startLineNumber, selection.startLineNumber);\n      const endLineNumber = Math.min(layout.endLineNumber, selection.endLineNumber);\n\n      if (startLineNumber > endLineNumber) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n      }\n    }\n  }\n\n  _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n    // Loop forwards to hit first decorations with lower `zIndex`\n    for (const decoration of decorations) {\n      const minimapOptions = decoration.options.minimap;\n\n      if (!minimapOptions) {\n        continue;\n      }\n\n      const startLineNumber = Math.max(layout.startLineNumber, decoration.range.startLineNumber);\n      const endLineNumber = Math.min(layout.endLineNumber, decoration.range.endLineNumber);\n\n      if (startLineNumber > endLineNumber) {\n        // entirely outside minimap's viewport\n        continue;\n      }\n\n      const decorationColor = minimapOptions.getColor(this._theme.value);\n\n      if (!decorationColor || decorationColor.isTransparent()) {\n        continue;\n      }\n\n      for (let line = startLineNumber; line <= endLineNumber; line++) {\n        switch (minimapOptions.position) {\n          case MinimapPosition.Inline:\n            this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n            continue;\n\n          case MinimapPosition.Gutter:\n            {\n              const y = (line - layout.startLineNumber) * lineHeight;\n              const x = 2;\n              this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, lineHeight);\n              continue;\n            }\n        }\n      }\n    }\n  }\n\n  renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, lineHeight, tabSize, charWidth, canvasInnerWidth) {\n    const y = (lineNumber - layout.startLineNumber) * lineHeight; // Skip rendering the line if it's vertically outside our viewport\n\n    if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n      return;\n    }\n\n    const {\n      startLineNumber,\n      endLineNumber\n    } = decorationRange;\n    const startColumn = startLineNumber === lineNumber ? decorationRange.startColumn : 1;\n    const endColumn = endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber);\n    const x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n    const x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n    this.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n  }\n\n  getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {\n    if (column === 1) {\n      return MINIMAP_GUTTER_WIDTH;\n    }\n\n    const minimumXOffset = (column - 1) * charWidth;\n\n    if (minimumXOffset >= canvasInnerWidth) {\n      // there is no need to look at actual characters,\n      // as this column is certainly after the minimap width\n      return canvasInnerWidth;\n    } // Cache line offset data so that it is only read once per line\n\n\n    let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n\n    if (!lineIndexToXOffset) {\n      const lineData = this._model.getLineContent(lineNumber);\n\n      lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n      let prevx = MINIMAP_GUTTER_WIDTH;\n\n      for (let i = 1; i < lineData.length + 1; i++) {\n        const charCode = lineData.charCodeAt(i - 1);\n        const dx = charCode === 9\n        /* Tab */\n        ? tabSize * charWidth : strings.isFullWidthCharacter(charCode) ? 2 * charWidth : charWidth;\n        const x = prevx + dx;\n\n        if (x >= canvasInnerWidth) {\n          // no need to keep on going, as we've hit the canvas width\n          lineIndexToXOffset[i] = canvasInnerWidth;\n          break;\n        }\n\n        lineIndexToXOffset[i] = x;\n        prevx = x;\n      }\n\n      lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n    }\n\n    if (column - 1 < lineIndexToXOffset.length) {\n      return lineIndexToXOffset[column - 1];\n    } // goes over the canvas width\n\n\n    return canvasInnerWidth;\n  }\n\n  renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n    canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n    canvasContext.fillRect(x, y, width, height);\n  }\n\n  renderLines(layout) {\n    const startLineNumber = layout.startLineNumber;\n    const endLineNumber = layout.endLineNumber;\n    const minimapLineHeight = this._model.options.minimapLineHeight; // Check if nothing changed w.r.t. lines from last frame\n\n    if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n      const _lastData = this._lastRenderData._get(); // Nice!! Nothing changed from last frame\n\n\n      return new RenderData(layout, _lastData.imageData, _lastData.lines);\n    } // Oh well!! We need to repaint some lines...\n\n\n    const imageData = this._getBuffer();\n\n    if (!imageData) {\n      // 0 width or 0 height canvas, nothing to do\n      return null;\n    } // Render untouched lines by using last rendered data.\n\n\n    const [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData); // Fetch rendering info from view model for rest of lines that need rendering.\n\n\n    const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n\n    const tabSize = this._model.getOptions().tabSize;\n\n    const defaultBackground = this._model.options.defaultBackgroundColor;\n    const background = this._model.options.backgroundColor;\n    const foregroundAlpha = this._model.options.foregroundAlpha;\n    const tokensColorTracker = this._model.tokensColorTracker;\n    const useLighterFont = tokensColorTracker.backgroundIsLight();\n    const renderMinimap = this._model.options.renderMinimap;\n\n    const charRenderer = this._model.options.charRenderer();\n\n    const fontScale = this._model.options.fontScale;\n    const minimapCharWidth = this._model.options.minimapCharWidth;\n    const baseCharHeight = renderMinimap === 1\n    /* Text */\n    ? 2\n    /* BASE_CHAR_HEIGHT */\n    : 2\n    /* BASE_CHAR_HEIGHT */\n    + 1;\n    const renderMinimapLineHeight = baseCharHeight * fontScale;\n    const innerLinePadding = minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0; // Render the rest of lines\n\n    const backgroundA = background.a / 255;\n    const renderBackground = new RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);\n    let dy = 0;\n    const renderedLines = [];\n\n    for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n      if (needed[lineIndex]) {\n        InnerMinimap._renderLine(imageData, renderBackground, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n      }\n\n      renderedLines[lineIndex] = new MinimapLine(dy);\n      dy += minimapLineHeight;\n    }\n\n    const dirtyY1 = _dirtyY1 === -1 ? 0 : _dirtyY1;\n    const dirtyY2 = _dirtyY2 === -1 ? imageData.height : _dirtyY2;\n    const dirtyHeight = dirtyY2 - dirtyY1; // Finally, paint to the canvas\n\n    const ctx = this._canvas.domNode.getContext('2d');\n\n    ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight); // Save rendered data for reuse on next frame if possible\n\n    return new RenderData(layout, imageData, renderedLines);\n  }\n\n  static _renderUntouchedLines(target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n    const needed = [];\n\n    if (!lastRenderData) {\n      for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n        needed[i] = true;\n      }\n\n      return [-1, -1, needed];\n    }\n\n    const _lastData = lastRenderData._get();\n\n    const lastTargetData = _lastData.imageData.data;\n    const lastStartLineNumber = _lastData.rendLineNumberStart;\n    const lastLines = _lastData.lines;\n    const lastLinesLength = lastLines.length;\n    const WIDTH = target.width;\n    const targetData = target.data;\n    const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n    let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n\n    let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n\n    let copySourceStart = -1;\n    let copySourceEnd = -1;\n    let copyDestStart = -1;\n    let copyDestEnd = -1;\n    let dest_dy = 0;\n\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineIndex = lineNumber - startLineNumber;\n      const lastLineIndex = lineNumber - lastStartLineNumber;\n      const source_dy = lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1;\n\n      if (source_dy === -1) {\n        needed[lineIndex] = true;\n        dest_dy += minimapLineHeight;\n        continue;\n      }\n\n      const sourceStart = source_dy * WIDTH * 4;\n      const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n      const destStart = dest_dy * WIDTH * 4;\n      const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n\n      if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n        // contiguous zone => extend copy request\n        copySourceEnd = sourceEnd;\n        copyDestEnd = destEnd;\n      } else {\n        if (copySourceStart !== -1) {\n          // flush existing copy request\n          targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n\n          if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n            dirtyPixel1 = copySourceEnd;\n          }\n\n          if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n            dirtyPixel2 = copySourceStart;\n          }\n        }\n\n        copySourceStart = sourceStart;\n        copySourceEnd = sourceEnd;\n        copyDestStart = destStart;\n        copyDestEnd = destEnd;\n      }\n\n      needed[lineIndex] = false;\n      dest_dy += minimapLineHeight;\n    }\n\n    if (copySourceStart !== -1) {\n      // flush existing copy request\n      targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n\n      if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n        dirtyPixel1 = copySourceEnd;\n      }\n\n      if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n        dirtyPixel2 = copySourceStart;\n      }\n    }\n\n    const dirtyY1 = dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4);\n    const dirtyY2 = dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4);\n    return [dirtyY1, dirtyY2, needed];\n  }\n\n  static _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n    const content = lineData.content;\n    const tokens = lineData.tokens;\n    const maxDx = target.width - charWidth;\n    const force1pxHeight = minimapLineHeight === 1;\n    let dx = MINIMAP_GUTTER_WIDTH;\n    let charIndex = 0;\n    let tabsCharDelta = 0;\n\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n      const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n      const tokenColorId = tokens.getForeground(tokenIndex);\n      const tokenColor = colorTracker.getColor(tokenColorId);\n\n      for (; charIndex < tokenEndIndex; charIndex++) {\n        if (dx > maxDx) {\n          // hit edge of minimap\n          return;\n        }\n\n        const charCode = content.charCodeAt(charIndex);\n\n        if (charCode === 9\n        /* Tab */\n        ) {\n          const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n          tabsCharDelta += insertSpacesCount - 1; // No need to render anything since tab is invisible\n\n          dx += insertSpacesCount * charWidth;\n        } else if (charCode === 32\n        /* Space */\n        ) {\n          // No need to render anything since space is invisible\n          dx += charWidth;\n        } else {\n          // Render twice for a full width character\n          const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n\n          for (let i = 0; i < count; i++) {\n            if (renderMinimap === 2\n            /* Blocks */\n            ) {\n              minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n            } else {\n              // RenderMinimap.Text\n              minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n            }\n\n            dx += charWidth;\n\n            if (dx > maxDx) {\n              // hit edge of minimap\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n\n}\n\nclass ContiguousLineMap {\n  constructor(startLineNumber, endLineNumber, defaultValue) {\n    this._startLineNumber = startLineNumber;\n    this._endLineNumber = endLineNumber;\n    this._defaultValue = defaultValue;\n    this._values = [];\n\n    for (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n      this._values[i] = defaultValue;\n    }\n  }\n\n  has(lineNumber) {\n    return this.get(lineNumber) !== this._defaultValue;\n  }\n\n  set(lineNumber, value) {\n    if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n      return;\n    }\n\n    this._values[lineNumber - this._startLineNumber] = value;\n  }\n\n  get(lineNumber) {\n    if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n      return this._defaultValue;\n    }\n\n    return this._values[lineNumber - this._startLineNumber];\n  }\n\n}\n\nregisterThemingParticipant((theme, collector) => {\n  const sliderBackground = theme.getColor(minimapSliderBackground);\n\n  if (sliderBackground) {\n    collector.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${sliderBackground}; }`);\n  }\n\n  const sliderHoverBackground = theme.getColor(minimapSliderHoverBackground);\n\n  if (sliderHoverBackground) {\n    collector.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${sliderHoverBackground}; }`);\n  }\n\n  const sliderActiveBackground = theme.getColor(minimapSliderActiveBackground);\n\n  if (sliderActiveBackground) {\n    collector.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${sliderActiveBackground}; }`);\n  }\n\n  const shadow = theme.getColor(scrollbarShadow);\n\n  if (shadow) {\n    collector.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${shadow} -6px 0 6px -6px inset; }`);\n  }\n});","map":{"version":3,"sources":["/home/joe/DISSY/flask_test_1/react-flask-app/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.js"],"names":["dom","createFastDomNode","GlobalMouseMoveMonitor","standardMouseMoveMerger","Disposable","platform","strings","RenderedLinesCollection","PartFingerprints","ViewPart","MINIMAP_GUTTER_WIDTH","EditorLayoutInfoComputer","Range","RGBA8","MinimapTokensColorTracker","ViewModelDecoration","minimapSelection","scrollbarShadow","minimapBackground","minimapSliderBackground","minimapSliderHoverBackground","minimapSliderActiveBackground","minimapForegroundOpacity","registerThemingParticipant","Selection","EventType","Gesture","MinimapCharRendererFactory","MinimapPosition","once","MOUSE_DRAG_RESET_DISTANCE","GUTTER_DECORATION_WIDTH","MinimapOptions","constructor","configuration","theme","tokensColorTracker","options","pixelRatio","get","layoutInfo","minimapLayout","minimap","fontInfo","minimapOpts","renderMinimap","size","minimapHeightIsEditorHeight","scrollBeyondLastLine","showSlider","typicalHalfwidthCharacterWidth","lineHeight","minimapLeft","minimapWidth","minimapHeight","height","canvasInnerWidth","minimapCanvasInnerWidth","canvasInnerHeight","minimapCanvasInnerHeight","canvasOuterWidth","minimapCanvasOuterWidth","canvasOuterHeight","minimapCanvasOuterHeight","isSampling","minimapIsSampling","editorHeight","fontScale","minimapScale","minimapLineHeight","minimapCharWidth","charRenderer","create","fontFamily","defaultBackgroundColor","getColor","backgroundColor","_getMinimapBackground","foregroundAlpha","_getMinimapForegroundOpacity","themeColor","rgba","r","g","b","Math","round","a","_clamp","equals","other","MinimapLayout","scrollTop","scrollHeight","sliderNeeded","computedSliderRatio","sliderTop","sliderHeight","startLineNumber","endLineNumber","_computedSliderRatio","getDesiredScrollTopFromDelta","delta","getDesiredScrollTopFromTouchLocation","pageY","viewportStartLineNumber","viewportEndLineNumber","viewportStartLineNumberVerticalOffset","viewportHeight","viewportContainsWhitespaceGaps","lineCount","realLineCount","previousLayout","minimapLinesFitting","floor","logicalScrollHeight","max","maxMinimapSliderTop","maxLinesFitting","min","viewportLineCount","expectedViewportLineCount","extraLinesAtTheBottom","partialLine","sliderTopAligned","MinimapLine","dy","onContentChanged","onTokensChanged","INVALID","RenderData","renderedLayout","imageData","lines","_imageData","_renderedLines","_set","linesEquals","layout","scrollEquals","tmp","_get","i","len","length","rendLineNumberStart","onLinesChanged","changeFromLineNumber","changeToLineNumber","onLinesDeleted","deleteFromLineNumber","deleteToLineNumber","onLinesInserted","insertFromLineNumber","insertToLineNumber","ranges","MinimapBuffers","ctx","WIDTH","HEIGHT","background","_backgroundFillData","_createBackgroundFillData","_buffers","createImageData","_lastUsedBuffer","getBuffer","result","data","set","backgroundR","backgroundG","backgroundB","backgroundA","Uint8ClampedArray","offset","j","MinimapSamplingState","samplingRatio","minimapLines","compute","viewLineCount","oldSamplingState","minimapLineCount","computeContainedMinimapLineCount","ratio","halfRatio","lastIndex","oldMinimapLines","oldLength","oldIndex","oldDeltaLineCount","minViewLineNumber","MAX_EVENT_COUNT","events","lastEvent","fromViewLineNumber","toViewLineNumber","oldMinimapLineNumber","type","_oldIndex","push","selectedViewLineNumber","_i","modelLineToMinimapLine","lineNumber","modelLineRangeToMinimapLineRange","fromLineNumber","toLineNumber","fromLineIndex","toLineIndex","sampledLineNumber","decorationLineRangeToMinimapLineRange","minimapLineStart","minimapLineEnd","e","deletedLineCount","changeStartIndex","changeEndIndex","insertedLineCount","Minimap","context","getInstance","_selections","_minimapSelections","_context","samplingState","model","getLineCount","_samplingState","_shouldCheckSampling","_actual","InnerMinimap","dispose","getDomNode","_onOptionsMaybeChanged","opts","_recreateLineSampling","onDidChangeOptions","onConfigurationChanged","onCursorStateChanged","selections","onSelectionChanged","onDecorationsChanged","affectsMinimap","onFlushed","minimapLineRange","onScrollChanged","onThemeChanged","invalidateMinimapColorCache","range","onTokensColorsChanged","onZonesChanged","prepareRender","render","visibleRange","minimapCtx","viewportData","whitespaceViewportData","scrollWidth","getVerticalOffsetForLineNumber","scrollLeft","viewportWidth","wasSampling","Boolean","event","getRealLineCount","getLineContent","getLineMaxColumn","getMinimapLinesRenderingData","needed","lineIndex","getViewLineData","getSelections","selection","startColumn","endColumn","getMinimapDecorationsInViewport","modelStartLineNumber","modelEndLineNumber","decorations","getDecorationsInViewport","decoration","minimapStartLineNumber","minimapEndLineNumber","getOptions","getTextModelOptions","revealLineNumber","revealRange","setScrollTop","setScrollPosition","_renderDecorations","_gestureInProgress","_theme","_model","_lastRenderData","_selectionColor","_domNode","document","createElement","write","setClassName","_getMinimapDomNodeClassName","setPosition","setAttribute","_shadow","appendChild","_canvas","setLeft","_decorationsCanvas","_slider","setLayerHinting","setContain","_sliderHorizontal","_applyLayout","_mouseDownListener","addStandardDisposableListener","domNode","preventDefault","leftButton","position","getDomNodePagePosition","initialPosY","top","_startSliderDragging","buttons","posx","posy","internalOffsetY","browserEvent","offsetY","_sliderMouseMoveMonitor","_sliderMouseDownListener","stopPropagation","_gestureDisposable","addTarget","_sliderTouchStartListener","addDisposableListener","Start","toggleClassName","scrollDueToTouchEvent","passive","_sliderTouchMoveListener","Change","_sliderTouchEndListener","End","initialButtons","initialPosX","initialSliderState","handleMouseMove","mouseOrthogonalDelta","abs","isWindows","mouseDelta","startMonitoring","mouseMoveData","touch","startY","getBoundingClientRect","setWidth","setHeight","width","_getBuffer","getContext","renderingCtx","setDisplay","setTop","renderDecorations","renderLines","sort","compareRangesUsingStarts","zIndex","characterWidth","tabSize","canvasContext","clearRect","highlightedLines","ContiguousLineMap","_renderSelectionLineHighlights","_renderDecorationsLineHighlights","lineOffsetMap","_renderSelectionsHighlights","_renderDecorationsHighlights","isTransparent","fillStyle","transparent","toString","y1","y2","line","yy1","yy2","fillRect","canvas","highlightColors","Map","minimapOptions","Inline","decorationColor","value","highlightColor","has","y","renderDecorationOnLine","Gutter","x","renderDecoration","decorationRange","charWidth","x1","getXOffsetForPosition","x2","column","minimumXOffset","lineIndexToXOffset","lineData","prevx","charCode","charCodeAt","dx","isFullWidthCharacter","_lastData","_dirtyY1","_dirtyY2","_renderUntouchedLines","lineInfo","defaultBackground","useLighterFont","backgroundIsLight","baseCharHeight","renderMinimapLineHeight","innerLinePadding","renderBackground","renderedLines","_renderLine","dirtyY1","dirtyY2","dirtyHeight","putImageData","target","lastRenderData","lastTargetData","lastStartLineNumber","lastLines","lastLinesLength","targetData","maxDestPixel","dirtyPixel1","dirtyPixel2","copySourceStart","copySourceEnd","copyDestStart","copyDestEnd","dest_dy","lastLineIndex","source_dy","sourceStart","sourceEnd","destStart","destEnd","subarray","backgroundAlpha","colorTracker","minimapCharRenderer","content","tokens","maxDx","force1pxHeight","charIndex","tabsCharDelta","tokenIndex","tokensLen","getCount","tokenEndIndex","getEndOffset","tokenColorId","getForeground","tokenColor","insertSpacesCount","count","blockRenderChar","renderChar","defaultValue","_startLineNumber","_endLineNumber","_defaultValue","_values","collector","sliderBackground","addRule","sliderHoverBackground","sliderActiveBackground","shadow"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalMouseMoveMonitor, standardMouseMoveMerger } from '../../../../base/browser/globalMouseMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel/viewModel.js';\nimport { minimapSelection, scrollbarShadow, minimapBackground, minimapSliderBackground, minimapSliderHoverBackground, minimapSliderActiveBackground, minimapForegroundOpacity } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition } from '../../../common/model.js';\nimport { once } from '../../../../base/common/functional.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst MOUSE_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\nclass MinimapOptions {\n    constructor(configuration, theme, tokensColorTracker) {\n        const options = configuration.options;\n        const pixelRatio = options.get(129 /* pixelRatio */);\n        const layoutInfo = options.get(131 /* layoutInfo */);\n        const minimapLayout = layoutInfo.minimap;\n        const fontInfo = options.get(44 /* fontInfo */);\n        const minimapOpts = options.get(65 /* minimap */);\n        this.renderMinimap = minimapLayout.renderMinimap;\n        this.size = minimapOpts.size;\n        this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n        this.scrollBeyondLastLine = options.get(94 /* scrollBeyondLastLine */);\n        this.showSlider = minimapOpts.showSlider;\n        this.pixelRatio = pixelRatio;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.lineHeight = options.get(59 /* lineHeight */);\n        this.minimapLeft = minimapLayout.minimapLeft;\n        this.minimapWidth = minimapLayout.minimapWidth;\n        this.minimapHeight = layoutInfo.height;\n        this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n        this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n        this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n        this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n        this.isSampling = minimapLayout.minimapIsSampling;\n        this.editorHeight = layoutInfo.height;\n        this.fontScale = minimapLayout.minimapScale;\n        this.minimapLineHeight = minimapLayout.minimapLineHeight;\n        this.minimapCharWidth = 1 /* BASE_CHAR_WIDTH */ * this.fontScale;\n        this.charRenderer = once(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n        this.defaultBackgroundColor = tokensColorTracker.getColor(2 /* DefaultBackground */);\n        this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n        this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n    }\n    static _getMinimapBackground(theme, defaultBackgroundColor) {\n        const themeColor = theme.getColor(minimapBackground);\n        if (themeColor) {\n            return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n        }\n        return defaultBackgroundColor;\n    }\n    static _getMinimapForegroundOpacity(theme) {\n        const themeColor = theme.getColor(minimapForegroundOpacity);\n        if (themeColor) {\n            return RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n        }\n        return 255;\n    }\n    equals(other) {\n        return (this.renderMinimap === other.renderMinimap\n            && this.size === other.size\n            && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight\n            && this.scrollBeyondLastLine === other.scrollBeyondLastLine\n            && this.showSlider === other.showSlider\n            && this.pixelRatio === other.pixelRatio\n            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\n            && this.lineHeight === other.lineHeight\n            && this.minimapLeft === other.minimapLeft\n            && this.minimapWidth === other.minimapWidth\n            && this.minimapHeight === other.minimapHeight\n            && this.canvasInnerWidth === other.canvasInnerWidth\n            && this.canvasInnerHeight === other.canvasInnerHeight\n            && this.canvasOuterWidth === other.canvasOuterWidth\n            && this.canvasOuterHeight === other.canvasOuterHeight\n            && this.isSampling === other.isSampling\n            && this.editorHeight === other.editorHeight\n            && this.fontScale === other.fontScale\n            && this.minimapLineHeight === other.minimapLineHeight\n            && this.minimapCharWidth === other.minimapCharWidth\n            && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor)\n            && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor)\n            && this.foregroundAlpha === other.foregroundAlpha);\n    }\n}\nclass MinimapLayout {\n    constructor(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {\n        this.scrollTop = scrollTop;\n        this.scrollHeight = scrollHeight;\n        this.sliderNeeded = sliderNeeded;\n        this._computedSliderRatio = computedSliderRatio;\n        this.sliderTop = sliderTop;\n        this.sliderHeight = sliderHeight;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n    getDesiredScrollTopFromDelta(delta) {\n        return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n    }\n    getDesiredScrollTopFromTouchLocation(pageY) {\n        return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n    }\n    static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n        const pixelRatio = options.pixelRatio;\n        const minimapLineHeight = options.minimapLineHeight;\n        const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n        const lineHeight = options.lineHeight;\n        if (options.minimapHeightIsEditorHeight) {\n            const logicalScrollHeight = (realLineCount * options.lineHeight\n                + (options.scrollBeyondLastLine ? viewportHeight - options.lineHeight : 0));\n            const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n            const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n            // The slider can move from 0 to `maxMinimapSliderTop`\n            // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n            const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n            const sliderTop = (scrollTop * computedSliderRatio);\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, 1, Math.min(lineCount, maxLinesFitting));\n        }\n        // The visible line count in a viewport can change due to a number of reasons:\n        //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n        //    e.g. for a line height of 20, and a viewport height of 600\n        //          * scrollTop = 0  => visible lines are [1, 30]\n        //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n        //          * scrollTop = 20 => visible lines are [2, 31]\n        //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n        //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n        // We must first establish a desirable slider height.\n        let sliderHeight;\n        if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n            // case b) from above: there are whitespace gaps in the viewport.\n            // In this case, the height of the slider directly reflects the visible line count.\n            const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n            sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        else {\n            // The slider has a stable height\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        let maxMinimapSliderTop;\n        if (options.scrollBeyondLastLine) {\n            // The minimap slider, when dragged all the way down, will contain the last line at its top\n            maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;\n        }\n        else {\n            // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n            maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);\n        }\n        maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n        // The slider can move from 0 to `maxMinimapSliderTop`\n        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n        const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n        const sliderTop = (scrollTop * computedSliderRatio);\n        let extraLinesAtTheBottom = 0;\n        if (options.scrollBeyondLastLine) {\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            extraLinesAtTheBottom = expectedViewportLineCount - 1;\n        }\n        if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {\n            // All lines fit in the minimap\n            const startLineNumber = 1;\n            const endLineNumber = lineCount;\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\n        }\n        else {\n            let startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n            // Avoid flickering caused by a partial viewport start line\n            // by being consistent w.r.t. the previous layout decision\n            if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n                if (previousLayout.scrollTop > scrollTop) {\n                    // Scrolling up => never increase `startLineNumber`\n                    startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n                }\n                if (previousLayout.scrollTop < scrollTop) {\n                    // Scrolling down => never decrease `startLineNumber`\n                    startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n                }\n            }\n            const endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);\n            const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n            const sliderTopAligned = (viewportStartLineNumber - startLineNumber + partialLine) * minimapLineHeight / pixelRatio;\n            return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, startLineNumber, endLineNumber);\n        }\n    }\n}\nclass MinimapLine {\n    constructor(dy) {\n        this.dy = dy;\n    }\n    onContentChanged() {\n        this.dy = -1;\n    }\n    onTokensChanged() {\n        this.dy = -1;\n    }\n}\nMinimapLine.INVALID = new MinimapLine(-1);\nclass RenderData {\n    constructor(renderedLayout, imageData, lines) {\n        this.renderedLayout = renderedLayout;\n        this._imageData = imageData;\n        this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n        this._renderedLines._set(renderedLayout.startLineNumber, lines);\n    }\n    /**\n     * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n     */\n    linesEquals(layout) {\n        if (!this.scrollEquals(layout)) {\n            return false;\n        }\n        const tmp = this._renderedLines._get();\n        const lines = tmp.lines;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].dy === -1) {\n                // This line is invalid\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Check if the current RenderData matches the new layout's scroll position\n     */\n    scrollEquals(layout) {\n        return this.renderedLayout.startLineNumber === layout.startLineNumber\n            && this.renderedLayout.endLineNumber === layout.endLineNumber;\n    }\n    _get() {\n        const tmp = this._renderedLines._get();\n        return {\n            imageData: this._imageData,\n            rendLineNumberStart: tmp.rendLineNumberStart,\n            lines: tmp.lines\n        };\n    }\n    onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n        return this._renderedLines.onLinesChanged(changeFromLineNumber, changeToLineNumber);\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    }\n    onTokensChanged(ranges) {\n        return this._renderedLines.onTokensChanged(ranges);\n    }\n}\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n    constructor(ctx, WIDTH, HEIGHT, background) {\n        this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n        this._buffers = [\n            ctx.createImageData(WIDTH, HEIGHT),\n            ctx.createImageData(WIDTH, HEIGHT)\n        ];\n        this._lastUsedBuffer = 0;\n    }\n    getBuffer() {\n        // rotate buffers\n        this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n        const result = this._buffers[this._lastUsedBuffer];\n        // fill with background color\n        result.data.set(this._backgroundFillData);\n        return result;\n    }\n    static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n        const backgroundR = background.r;\n        const backgroundG = background.g;\n        const backgroundB = background.b;\n        const backgroundA = background.a;\n        const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n        let offset = 0;\n        for (let i = 0; i < HEIGHT; i++) {\n            for (let j = 0; j < WIDTH; j++) {\n                result[offset] = backgroundR;\n                result[offset + 1] = backgroundG;\n                result[offset + 2] = backgroundB;\n                result[offset + 3] = backgroundA;\n                offset += 4;\n            }\n        }\n        return result;\n    }\n}\nclass MinimapSamplingState {\n    constructor(samplingRatio, minimapLines) {\n        this.samplingRatio = samplingRatio;\n        this.minimapLines = minimapLines;\n    }\n    static compute(options, viewLineCount, oldSamplingState) {\n        if (options.renderMinimap === 0 /* None */ || !options.isSampling) {\n            return [null, []];\n        }\n        // ratio is intentionally not part of the layout to avoid the layout changing all the time\n        // so we need to recompute it again...\n        const pixelRatio = options.pixelRatio;\n        const lineHeight = options.lineHeight;\n        const scrollBeyondLastLine = options.scrollBeyondLastLine;\n        const { minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n            viewLineCount: viewLineCount,\n            scrollBeyondLastLine: scrollBeyondLastLine,\n            height: options.editorHeight,\n            lineHeight: lineHeight,\n            pixelRatio: pixelRatio\n        });\n        const ratio = viewLineCount / minimapLineCount;\n        const halfRatio = ratio / 2;\n        if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n            const result = [];\n            result[0] = 1;\n            if (minimapLineCount > 1) {\n                for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n                    result[i] = Math.round(i * ratio + halfRatio);\n                }\n                result[minimapLineCount - 1] = viewLineCount;\n            }\n            return [new MinimapSamplingState(ratio, result), []];\n        }\n        const oldMinimapLines = oldSamplingState.minimapLines;\n        const oldLength = oldMinimapLines.length;\n        const result = [];\n        let oldIndex = 0;\n        let oldDeltaLineCount = 0;\n        let minViewLineNumber = 1;\n        const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n        let events = [];\n        let lastEvent = null;\n        for (let i = 0; i < minimapLineCount; i++) {\n            const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n            const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n            while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                        lastEvent.deleteToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount--;\n                }\n                oldIndex++;\n            }\n            let selectedViewLineNumber;\n            if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n                // reuse the old sampled line\n                selectedViewLineNumber = oldMinimapLines[oldIndex];\n                oldIndex++;\n            }\n            else {\n                if (i === 0) {\n                    selectedViewLineNumber = 1;\n                }\n                else if (i + 1 === minimapLineCount) {\n                    selectedViewLineNumber = viewLineCount;\n                }\n                else {\n                    selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n                }\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n                        lastEvent.insertToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'inserted', _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount++;\n                }\n            }\n            result[i] = selectedViewLineNumber;\n            minViewLineNumber = selectedViewLineNumber;\n        }\n        if (events.length < MAX_EVENT_COUNT) {\n            while (oldIndex < oldLength) {\n                const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                    lastEvent.deleteToLineNumber++;\n                }\n                else {\n                    lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                    events.push(lastEvent);\n                }\n                oldDeltaLineCount--;\n                oldIndex++;\n            }\n        }\n        else {\n            // too many events, just give up\n            events = [{ type: 'flush' }];\n        }\n        return [new MinimapSamplingState(ratio, result), events];\n    }\n    modelLineToMinimapLine(lineNumber) {\n        return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n    }\n    /**\n     * Will return null if the model line ranges are not intersecting with a sampled model line.\n     */\n    modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n        let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n        while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n            fromLineIndex--;\n        }\n        let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n        while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n            toLineIndex++;\n        }\n        if (fromLineIndex === toLineIndex) {\n            const sampledLineNumber = this.minimapLines[fromLineIndex];\n            if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n                // This line is not part of the sampled lines ==> nothing to do\n                return null;\n            }\n        }\n        return [fromLineIndex + 1, toLineIndex + 1];\n    }\n    /**\n     * Will always return a range, even if it is not intersecting with a sampled model line.\n     */\n    decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n        let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n        let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n        if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n            if (minimapLineEnd === this.minimapLines.length) {\n                if (minimapLineStart > 1) {\n                    minimapLineStart--;\n                }\n            }\n            else {\n                minimapLineEnd++;\n            }\n        }\n        return [minimapLineStart, minimapLineEnd];\n    }\n    onLinesDeleted(e) {\n        // have the mapping be sticky\n        const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        let changeStartIndex = this.minimapLines.length;\n        let changeEndIndex = 0;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            if (this.minimapLines[i] <= e.toLineNumber) {\n                // this line got deleted => move to previous available\n                this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n                changeStartIndex = Math.min(changeStartIndex, i);\n                changeEndIndex = Math.max(changeEndIndex, i);\n            }\n            else {\n                this.minimapLines[i] -= deletedLineCount;\n            }\n        }\n        return [changeStartIndex, changeEndIndex];\n    }\n    onLinesInserted(e) {\n        // have the mapping be sticky\n        const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            this.minimapLines[i] += insertedLineCount;\n        }\n    }\n}\nexport class Minimap extends ViewPart {\n    constructor(context) {\n        super(context);\n        this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n        this._selections = [];\n        this._minimapSelections = null;\n        this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        const [samplingState,] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), null);\n        this._samplingState = samplingState;\n        this._shouldCheckSampling = false;\n        this._actual = new InnerMinimap(context.theme, this);\n    }\n    dispose() {\n        this._actual.dispose();\n        super.dispose();\n    }\n    getDomNode() {\n        return this._actual.getDomNode();\n    }\n    _onOptionsMaybeChanged() {\n        const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        if (this.options.equals(opts)) {\n            return false;\n        }\n        this.options = opts;\n        this._recreateLineSampling();\n        this._actual.onDidChangeOptions();\n        return true;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        return this._onOptionsMaybeChanged();\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections;\n        this._minimapSelections = null;\n        return this._actual.onSelectionChanged();\n    }\n    onDecorationsChanged(e) {\n        if (e.affectsMinimap) {\n            return this._actual.onDecorationsChanged();\n        }\n        return false;\n    }\n    onFlushed(e) {\n        if (this._samplingState) {\n            this._shouldCheckSampling = true;\n        }\n        return this._actual.onFlushed();\n    }\n    onLinesChanged(e) {\n        if (this._samplingState) {\n            const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);\n            if (minimapLineRange) {\n                return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1]);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onLinesDeleted(e) {\n        if (this._samplingState) {\n            const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n            if (changeStartIndex <= changeEndIndex) {\n                this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex + 1);\n            }\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onLinesInserted(e) {\n        if (this._samplingState) {\n            this._samplingState.onLinesInserted(e);\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onScrollChanged(e) {\n        return this._actual.onScrollChanged();\n    }\n    onThemeChanged(e) {\n        this._context.model.invalidateMinimapColorCache();\n        this._actual.onThemeChanged();\n        this._onOptionsMaybeChanged();\n        return true;\n    }\n    onTokensChanged(e) {\n        if (this._samplingState) {\n            const ranges = [];\n            for (const range of e.ranges) {\n                const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n                if (minimapLineRange) {\n                    ranges.push({ fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1] });\n                }\n            }\n            if (ranges.length) {\n                return this._actual.onTokensChanged(ranges);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onTokensChanged(e.ranges);\n        }\n    }\n    onTokensColorsChanged(e) {\n        this._onOptionsMaybeChanged();\n        return this._actual.onTokensColorsChanged();\n    }\n    onZonesChanged(e) {\n        return this._actual.onZonesChanged();\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        if (this._shouldCheckSampling) {\n            this._shouldCheckSampling = false;\n            this._recreateLineSampling();\n        }\n    }\n    render(ctx) {\n        let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n        let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n        if (this._samplingState) {\n            viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n            viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n        }\n        const minimapCtx = {\n            viewportContainsWhitespaceGaps: (ctx.viewportData.whitespaceViewportData.length > 0),\n            scrollWidth: ctx.scrollWidth,\n            scrollHeight: ctx.scrollHeight,\n            viewportStartLineNumber: viewportStartLineNumber,\n            viewportEndLineNumber: viewportEndLineNumber,\n            viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n            scrollTop: ctx.scrollTop,\n            scrollLeft: ctx.scrollLeft,\n            viewportWidth: ctx.viewportWidth,\n            viewportHeight: ctx.viewportHeight,\n        };\n        this._actual.render(minimapCtx);\n    }\n    //#region IMinimapModel\n    _recreateLineSampling() {\n        this._minimapSelections = null;\n        const wasSampling = Boolean(this._samplingState);\n        const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), this._samplingState);\n        this._samplingState = samplingState;\n        if (wasSampling && this._samplingState) {\n            // was sampling, is sampling\n            for (const event of events) {\n                switch (event.type) {\n                    case 'deleted':\n                        this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n                        break;\n                    case 'inserted':\n                        this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n                        break;\n                    case 'flush':\n                        this._actual.onFlushed();\n                        break;\n                }\n            }\n        }\n    }\n    getLineCount() {\n        if (this._samplingState) {\n            return this._samplingState.minimapLines.length;\n        }\n        return this._context.model.getLineCount();\n    }\n    getRealLineCount() {\n        return this._context.model.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        if (this._samplingState) {\n            return this._context.model.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.model.getLineContent(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        if (this._samplingState) {\n            return this._context.model.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.model.getLineMaxColumn(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        if (this._samplingState) {\n            const result = [];\n            for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n                if (needed[lineIndex]) {\n                    result[lineIndex] = this._context.model.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n                }\n                else {\n                    result[lineIndex] = null;\n                }\n            }\n            return result;\n        }\n        return this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n    }\n    getSelections() {\n        if (this._minimapSelections === null) {\n            if (this._samplingState) {\n                this._minimapSelections = [];\n                for (const selection of this._selections) {\n                    const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n                    this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n                }\n            }\n            else {\n                this._minimapSelections = this._selections;\n            }\n        }\n        return this._minimapSelections;\n    }\n    getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n        let visibleRange;\n        if (this._samplingState) {\n            const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n            const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n            visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.model.getLineMaxColumn(modelEndLineNumber));\n        }\n        else {\n            visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.model.getLineMaxColumn(endLineNumber));\n        }\n        const decorations = this._context.model.getDecorationsInViewport(visibleRange);\n        if (this._samplingState) {\n            const result = [];\n            for (const decoration of decorations) {\n                if (!decoration.options.minimap) {\n                    continue;\n                }\n                const range = decoration.range;\n                const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n                const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n                result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n            }\n            return result;\n        }\n        return decorations;\n    }\n    getOptions() {\n        return this._context.model.getTextModelOptions();\n    }\n    revealLineNumber(lineNumber) {\n        if (this._samplingState) {\n            lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n        }\n        this._context.model.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* Center */, 0 /* Smooth */);\n    }\n    setScrollTop(scrollTop) {\n        this._context.model.setScrollPosition({\n            scrollTop: scrollTop\n        }, 1 /* Immediate */);\n    }\n}\nclass InnerMinimap extends Disposable {\n    constructor(theme, model) {\n        super();\n        this._renderDecorations = false;\n        this._gestureInProgress = false;\n        this._theme = theme;\n        this._model = model;\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._domNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this._domNode, 8 /* Minimap */);\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n        this._domNode.setPosition('absolute');\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._shadow = createFastDomNode(document.createElement('div'));\n        this._shadow.setClassName('minimap-shadow-hidden');\n        this._domNode.appendChild(this._shadow);\n        this._canvas = createFastDomNode(document.createElement('canvas'));\n        this._canvas.setPosition('absolute');\n        this._canvas.setLeft(0);\n        this._domNode.appendChild(this._canvas);\n        this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n        this._decorationsCanvas.setPosition('absolute');\n        this._decorationsCanvas.setClassName('minimap-decorations-layer');\n        this._decorationsCanvas.setLeft(0);\n        this._domNode.appendChild(this._decorationsCanvas);\n        this._slider = createFastDomNode(document.createElement('div'));\n        this._slider.setPosition('absolute');\n        this._slider.setClassName('minimap-slider');\n        this._slider.setLayerHinting(true);\n        this._slider.setContain('strict');\n        this._domNode.appendChild(this._slider);\n        this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n        this._sliderHorizontal.setPosition('absolute');\n        this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n        this._slider.appendChild(this._sliderHorizontal);\n        this._applyLayout();\n        this._mouseDownListener = dom.addStandardDisposableListener(this._domNode.domNode, 'mousedown', (e) => {\n            e.preventDefault();\n            const renderMinimap = this._model.options.renderMinimap;\n            if (renderMinimap === 0 /* None */) {\n                return;\n            }\n            if (!this._lastRenderData) {\n                return;\n            }\n            if (this._model.options.size !== 'proportional') {\n                if (e.leftButton && this._lastRenderData) {\n                    // pretend the click occurred in the center of the slider\n                    const position = dom.getDomNodePagePosition(this._slider.domNode);\n                    const initialPosY = position.top + position.height / 2;\n                    this._startSliderDragging(e.buttons, e.posx, initialPosY, e.posy, this._lastRenderData.renderedLayout);\n                }\n                return;\n            }\n            const minimapLineHeight = this._model.options.minimapLineHeight;\n            const internalOffsetY = (this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight) * e.browserEvent.offsetY;\n            const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n            let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber;\n            lineNumber = Math.min(lineNumber, this._model.getLineCount());\n            this._model.revealLineNumber(lineNumber);\n        });\n        this._sliderMouseMoveMonitor = new GlobalMouseMoveMonitor();\n        this._sliderMouseDownListener = dom.addStandardDisposableListener(this._slider.domNode, 'mousedown', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (e.leftButton && this._lastRenderData) {\n                this._startSliderDragging(e.buttons, e.posx, e.posy, e.posy, this._lastRenderData.renderedLayout);\n            }\n        });\n        this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n        this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData) {\n                this._slider.toggleClassName('active', true);\n                this._gestureInProgress = true;\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData && this._gestureInProgress) {\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            this._gestureInProgress = false;\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    _startSliderDragging(initialButtons, initialPosX, initialPosY, posy, initialSliderState) {\n        this._slider.toggleClassName('active', true);\n        const handleMouseMove = (posy, posx) => {\n            const mouseOrthogonalDelta = Math.abs(posx - initialPosX);\n            if (platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {\n                // The mouse has wondered away from the scrollbar => reset dragging\n                this._model.setScrollTop(initialSliderState.scrollTop);\n                return;\n            }\n            const mouseDelta = posy - initialPosY;\n            this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(mouseDelta));\n        };\n        if (posy !== initialPosY) {\n            handleMouseMove(posy, initialPosX);\n        }\n        this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, initialButtons, standardMouseMoveMerger, (mouseMoveData) => handleMouseMove(mouseMoveData.posy, mouseMoveData.posx), () => {\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    scrollDueToTouchEvent(touch) {\n        const startY = this._domNode.domNode.getBoundingClientRect().top;\n        const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n        this._model.setScrollTop(scrollTop);\n    }\n    dispose() {\n        this._mouseDownListener.dispose();\n        this._sliderMouseMoveMonitor.dispose();\n        this._sliderMouseDownListener.dispose();\n        this._gestureDisposable.dispose();\n        this._sliderTouchStartListener.dispose();\n        this._sliderTouchMoveListener.dispose();\n        this._sliderTouchEndListener.dispose();\n        super.dispose();\n    }\n    _getMinimapDomNodeClassName() {\n        if (this._model.options.showSlider === 'always') {\n            return 'minimap slider-always';\n        }\n        return 'minimap slider-mouseover';\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    _applyLayout() {\n        this._domNode.setLeft(this._model.options.minimapLeft);\n        this._domNode.setWidth(this._model.options.minimapWidth);\n        this._domNode.setHeight(this._model.options.minimapHeight);\n        this._shadow.setHeight(this._model.options.minimapHeight);\n        this._canvas.setWidth(this._model.options.canvasOuterWidth);\n        this._canvas.setHeight(this._model.options.canvasOuterHeight);\n        this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n        this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n        this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._slider.setWidth(this._model.options.minimapWidth);\n    }\n    _getBuffer() {\n        if (!this._buffers) {\n            if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n                this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n            }\n        }\n        return this._buffers ? this._buffers.getBuffer() : null;\n    }\n    // ---- begin view event handlers\n    onDidChangeOptions() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._applyLayout();\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    }\n    onSelectionChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onDecorationsChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onFlushed() {\n        this._lastRenderData = null;\n        return true;\n    }\n    onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeToLineNumber);\n        }\n        return false;\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        if (this._lastRenderData) {\n            this._lastRenderData.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n        }\n        return true;\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        if (this._lastRenderData) {\n            this._lastRenderData.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n        }\n        return true;\n    }\n    onScrollChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onThemeChanged() {\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._renderDecorations = true;\n        return true;\n    }\n    onTokensChanged(ranges) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onTokensChanged(ranges);\n        }\n        return false;\n    }\n    onTokensColorsChanged() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        return true;\n    }\n    onZonesChanged() {\n        this._lastRenderData = null;\n        return true;\n    }\n    // --- end event handlers\n    render(renderingCtx) {\n        const renderMinimap = this._model.options.renderMinimap;\n        if (renderMinimap === 0 /* None */) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n            this._sliderHorizontal.setWidth(0);\n            this._sliderHorizontal.setHeight(0);\n            return;\n        }\n        if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n        }\n        else {\n            this._shadow.setClassName('minimap-shadow-visible');\n        }\n        const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n        this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n        this._slider.setTop(layout.sliderTop);\n        this._slider.setHeight(layout.sliderHeight);\n        // Compute horizontal slider coordinates\n        this._sliderHorizontal.setLeft(0);\n        this._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n        this._sliderHorizontal.setTop(0);\n        this._sliderHorizontal.setHeight(layout.sliderHeight);\n        this.renderDecorations(layout);\n        this._lastRenderData = this.renderLines(layout);\n    }\n    renderDecorations(layout) {\n        if (this._renderDecorations) {\n            this._renderDecorations = false;\n            const selections = this._model.getSelections();\n            selections.sort(Range.compareRangesUsingStarts);\n            const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n            decorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n            const { canvasInnerWidth, canvasInnerHeight } = this._model.options;\n            const lineHeight = this._model.options.minimapLineHeight;\n            const characterWidth = this._model.options.minimapCharWidth;\n            const tabSize = this._model.getOptions().tabSize;\n            const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n            canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n            // We first need to render line highlights and then render decorations on top of those.\n            // But we need to pick a single color for each line, and use that as a line highlight.\n            // This needs to be the color of the decoration with the highest `zIndex`, but priority\n            // is given to the selection.\n            const highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, false);\n            this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, lineHeight);\n            this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, lineHeight);\n            const lineOffsetMap = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);\n            this._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n            this._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n        }\n    }\n    _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, lineHeight) {\n        if (!this._selectionColor || this._selectionColor.isTransparent()) {\n            return;\n        }\n        canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n        let y1 = 0;\n        let y2 = 0;\n        for (const selection of selections) {\n            const startLineNumber = Math.max(layout.startLineNumber, selection.startLineNumber);\n            const endLineNumber = Math.min(layout.endLineNumber, selection.endLineNumber);\n            if (startLineNumber > endLineNumber) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                highlightedLines.set(line, true);\n            }\n            const yy1 = (startLineNumber - layout.startLineNumber) * lineHeight;\n            const yy2 = (endLineNumber - layout.startLineNumber) * lineHeight + lineHeight;\n            if (y2 >= yy1) {\n                // merge into previous\n                y2 = yy2;\n            }\n            else {\n                if (y2 > y1) {\n                    // flush\n                    canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n                }\n                y1 = yy1;\n                y2 = yy2;\n            }\n        }\n        if (y2 > y1) {\n            // flush\n            canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n        }\n    }\n    _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, lineHeight) {\n        const highlightColors = new Map();\n        // Loop backwards to hit first decorations with higher `zIndex`\n        for (let i = decorations.length - 1; i >= 0; i--) {\n            const decoration = decorations[i];\n            const minimapOptions = decoration.options.minimap;\n            if (!minimapOptions || minimapOptions.position !== MinimapPosition.Inline) {\n                continue;\n            }\n            const startLineNumber = Math.max(layout.startLineNumber, decoration.range.startLineNumber);\n            const endLineNumber = Math.min(layout.endLineNumber, decoration.range.endLineNumber);\n            if (startLineNumber > endLineNumber) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const decorationColor = minimapOptions.getColor(this._theme.value);\n            if (!decorationColor || decorationColor.isTransparent()) {\n                continue;\n            }\n            let highlightColor = highlightColors.get(decorationColor.toString());\n            if (!highlightColor) {\n                highlightColor = decorationColor.transparent(0.5).toString();\n                highlightColors.set(decorationColor.toString(), highlightColor);\n            }\n            canvasContext.fillStyle = highlightColor;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                if (highlightedLines.has(line)) {\n                    continue;\n                }\n                highlightedLines.set(line, true);\n                const y = (startLineNumber - layout.startLineNumber) * lineHeight;\n                canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, lineHeight);\n            }\n        }\n    }\n    _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n        if (!this._selectionColor || this._selectionColor.isTransparent()) {\n            return;\n        }\n        for (const selection of selections) {\n            const startLineNumber = Math.max(layout.startLineNumber, selection.startLineNumber);\n            const endLineNumber = Math.min(layout.endLineNumber, selection.endLineNumber);\n            if (startLineNumber > endLineNumber) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n            }\n        }\n    }\n    _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n        // Loop forwards to hit first decorations with lower `zIndex`\n        for (const decoration of decorations) {\n            const minimapOptions = decoration.options.minimap;\n            if (!minimapOptions) {\n                continue;\n            }\n            const startLineNumber = Math.max(layout.startLineNumber, decoration.range.startLineNumber);\n            const endLineNumber = Math.min(layout.endLineNumber, decoration.range.endLineNumber);\n            if (startLineNumber > endLineNumber) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const decorationColor = minimapOptions.getColor(this._theme.value);\n            if (!decorationColor || decorationColor.isTransparent()) {\n                continue;\n            }\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                switch (minimapOptions.position) {\n                    case MinimapPosition.Inline:\n                        this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n                        continue;\n                    case MinimapPosition.Gutter: {\n                        const y = (line - layout.startLineNumber) * lineHeight;\n                        const x = 2;\n                        this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, lineHeight);\n                        continue;\n                    }\n                }\n            }\n        }\n    }\n    renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, lineHeight, tabSize, charWidth, canvasInnerWidth) {\n        const y = (lineNumber - layout.startLineNumber) * lineHeight;\n        // Skip rendering the line if it's vertically outside our viewport\n        if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n            return;\n        }\n        const { startLineNumber, endLineNumber } = decorationRange;\n        const startColumn = (startLineNumber === lineNumber ? decorationRange.startColumn : 1);\n        const endColumn = (endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber));\n        const x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n        const x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n        this.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n    }\n    getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {\n        if (column === 1) {\n            return MINIMAP_GUTTER_WIDTH;\n        }\n        const minimumXOffset = (column - 1) * charWidth;\n        if (minimumXOffset >= canvasInnerWidth) {\n            // there is no need to look at actual characters,\n            // as this column is certainly after the minimap width\n            return canvasInnerWidth;\n        }\n        // Cache line offset data so that it is only read once per line\n        let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n        if (!lineIndexToXOffset) {\n            const lineData = this._model.getLineContent(lineNumber);\n            lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n            let prevx = MINIMAP_GUTTER_WIDTH;\n            for (let i = 1; i < lineData.length + 1; i++) {\n                const charCode = lineData.charCodeAt(i - 1);\n                const dx = charCode === 9 /* Tab */\n                    ? tabSize * charWidth\n                    : strings.isFullWidthCharacter(charCode)\n                        ? 2 * charWidth\n                        : charWidth;\n                const x = prevx + dx;\n                if (x >= canvasInnerWidth) {\n                    // no need to keep on going, as we've hit the canvas width\n                    lineIndexToXOffset[i] = canvasInnerWidth;\n                    break;\n                }\n                lineIndexToXOffset[i] = x;\n                prevx = x;\n            }\n            lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n        }\n        if (column - 1 < lineIndexToXOffset.length) {\n            return lineIndexToXOffset[column - 1];\n        }\n        // goes over the canvas width\n        return canvasInnerWidth;\n    }\n    renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n        canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n        canvasContext.fillRect(x, y, width, height);\n    }\n    renderLines(layout) {\n        const startLineNumber = layout.startLineNumber;\n        const endLineNumber = layout.endLineNumber;\n        const minimapLineHeight = this._model.options.minimapLineHeight;\n        // Check if nothing changed w.r.t. lines from last frame\n        if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n            const _lastData = this._lastRenderData._get();\n            // Nice!! Nothing changed from last frame\n            return new RenderData(layout, _lastData.imageData, _lastData.lines);\n        }\n        // Oh well!! We need to repaint some lines...\n        const imageData = this._getBuffer();\n        if (!imageData) {\n            // 0 width or 0 height canvas, nothing to do\n            return null;\n        }\n        // Render untouched lines by using last rendered data.\n        const [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\n        // Fetch rendering info from view model for rest of lines that need rendering.\n        const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n        const tabSize = this._model.getOptions().tabSize;\n        const defaultBackground = this._model.options.defaultBackgroundColor;\n        const background = this._model.options.backgroundColor;\n        const foregroundAlpha = this._model.options.foregroundAlpha;\n        const tokensColorTracker = this._model.tokensColorTracker;\n        const useLighterFont = tokensColorTracker.backgroundIsLight();\n        const renderMinimap = this._model.options.renderMinimap;\n        const charRenderer = this._model.options.charRenderer();\n        const fontScale = this._model.options.fontScale;\n        const minimapCharWidth = this._model.options.minimapCharWidth;\n        const baseCharHeight = (renderMinimap === 1 /* Text */ ? 2 /* BASE_CHAR_HEIGHT */ : 2 /* BASE_CHAR_HEIGHT */ + 1);\n        const renderMinimapLineHeight = baseCharHeight * fontScale;\n        const innerLinePadding = (minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0);\n        // Render the rest of lines\n        const backgroundA = background.a / 255;\n        const renderBackground = new RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);\n        let dy = 0;\n        const renderedLines = [];\n        for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n            if (needed[lineIndex]) {\n                InnerMinimap._renderLine(imageData, renderBackground, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n            }\n            renderedLines[lineIndex] = new MinimapLine(dy);\n            dy += minimapLineHeight;\n        }\n        const dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);\n        const dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);\n        const dirtyHeight = dirtyY2 - dirtyY1;\n        // Finally, paint to the canvas\n        const ctx = this._canvas.domNode.getContext('2d');\n        ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n        // Save rendered data for reuse on next frame if possible\n        return new RenderData(layout, imageData, renderedLines);\n    }\n    static _renderUntouchedLines(target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n        const needed = [];\n        if (!lastRenderData) {\n            for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n                needed[i] = true;\n            }\n            return [-1, -1, needed];\n        }\n        const _lastData = lastRenderData._get();\n        const lastTargetData = _lastData.imageData.data;\n        const lastStartLineNumber = _lastData.rendLineNumberStart;\n        const lastLines = _lastData.lines;\n        const lastLinesLength = lastLines.length;\n        const WIDTH = target.width;\n        const targetData = target.data;\n        const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n        let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n        let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n        let copySourceStart = -1;\n        let copySourceEnd = -1;\n        let copyDestStart = -1;\n        let copyDestEnd = -1;\n        let dest_dy = 0;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - startLineNumber;\n            const lastLineIndex = lineNumber - lastStartLineNumber;\n            const source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);\n            if (source_dy === -1) {\n                needed[lineIndex] = true;\n                dest_dy += minimapLineHeight;\n                continue;\n            }\n            const sourceStart = source_dy * WIDTH * 4;\n            const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n            const destStart = dest_dy * WIDTH * 4;\n            const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n            if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n                // contiguous zone => extend copy request\n                copySourceEnd = sourceEnd;\n                copyDestEnd = destEnd;\n            }\n            else {\n                if (copySourceStart !== -1) {\n                    // flush existing copy request\n                    targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n                    if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                        dirtyPixel1 = copySourceEnd;\n                    }\n                    if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                        dirtyPixel2 = copySourceStart;\n                    }\n                }\n                copySourceStart = sourceStart;\n                copySourceEnd = sourceEnd;\n                copyDestStart = destStart;\n                copyDestEnd = destEnd;\n            }\n            needed[lineIndex] = false;\n            dest_dy += minimapLineHeight;\n        }\n        if (copySourceStart !== -1) {\n            // flush existing copy request\n            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                dirtyPixel1 = copySourceEnd;\n            }\n            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                dirtyPixel2 = copySourceStart;\n            }\n        }\n        const dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));\n        const dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));\n        return [dirtyY1, dirtyY2, needed];\n    }\n    static _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n        const content = lineData.content;\n        const tokens = lineData.tokens;\n        const maxDx = target.width - charWidth;\n        const force1pxHeight = (minimapLineHeight === 1);\n        let dx = MINIMAP_GUTTER_WIDTH;\n        let charIndex = 0;\n        let tabsCharDelta = 0;\n        for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n            const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n            const tokenColorId = tokens.getForeground(tokenIndex);\n            const tokenColor = colorTracker.getColor(tokenColorId);\n            for (; charIndex < tokenEndIndex; charIndex++) {\n                if (dx > maxDx) {\n                    // hit edge of minimap\n                    return;\n                }\n                const charCode = content.charCodeAt(charIndex);\n                if (charCode === 9 /* Tab */) {\n                    const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    // No need to render anything since tab is invisible\n                    dx += insertSpacesCount * charWidth;\n                }\n                else if (charCode === 32 /* Space */) {\n                    // No need to render anything since space is invisible\n                    dx += charWidth;\n                }\n                else {\n                    // Render twice for a full width character\n                    const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n                    for (let i = 0; i < count; i++) {\n                        if (renderMinimap === 2 /* Blocks */) {\n                            minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n                        }\n                        else { // RenderMinimap.Text\n                            minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n                        }\n                        dx += charWidth;\n                        if (dx > maxDx) {\n                            // hit edge of minimap\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nclass ContiguousLineMap {\n    constructor(startLineNumber, endLineNumber, defaultValue) {\n        this._startLineNumber = startLineNumber;\n        this._endLineNumber = endLineNumber;\n        this._defaultValue = defaultValue;\n        this._values = [];\n        for (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n            this._values[i] = defaultValue;\n        }\n    }\n    has(lineNumber) {\n        return (this.get(lineNumber) !== this._defaultValue);\n    }\n    set(lineNumber, value) {\n        if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n            return;\n        }\n        this._values[lineNumber - this._startLineNumber] = value;\n    }\n    get(lineNumber) {\n        if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n            return this._defaultValue;\n        }\n        return this._values[lineNumber - this._startLineNumber];\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const sliderBackground = theme.getColor(minimapSliderBackground);\n    if (sliderBackground) {\n        collector.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${sliderBackground}; }`);\n    }\n    const sliderHoverBackground = theme.getColor(minimapSliderHoverBackground);\n    if (sliderHoverBackground) {\n        collector.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${sliderHoverBackground}; }`);\n    }\n    const sliderActiveBackground = theme.getColor(minimapSliderActiveBackground);\n    if (sliderActiveBackground) {\n        collector.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${sliderActiveBackground}; }`);\n    }\n    const shadow = theme.getColor(scrollbarShadow);\n    if (shadow) {\n        collector.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${shadow} -6px 0 6px -6px inset; }`);\n    }\n});\n"]},"metadata":{},"sourceType":"module"}